(function () {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        r(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity),
            i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
            i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
            s
    }
    function r(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const s = n(i);
        fetch(i.href, s)
    }
}
)();
/**
* @vue/shared v3.5.6
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function qp(t) {
    const e = Object.create(null);
    for (const n of t.split(","))
        e[n] = 1;
    return n => n in e
}
const kt = {}
    , Pl = []
    , ii = () => { }
    , GI = () => !1
    , ld = t => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97)
    , My = t => t.startsWith("onUpdate:")
    , Kt = Object.assign
    , Ry = (t, e) => {
        const n = t.indexOf(e);
        n > -1 && t.splice(n, 1)
    }
    , JI = Object.prototype.hasOwnProperty
    , Ot = (t, e) => JI.call(t, e)
    , Re = Array.isArray
    , Nl = t => cu(t) === "[object Map]"
    , Va = t => cu(t) === "[object Set]"
    , Vw = t => cu(t) === "[object Date]"
    , ZI = t => cu(t) === "[object RegExp]"
    , We = t => typeof t == "function"
    , qt = t => typeof t == "string"
    , Zi = t => typeof t == "symbol"
    , jt = t => t !== null && typeof t == "object"
    , Py = t => (jt(t) || We(t)) && We(t.then) && We(t.catch)
    , ES = Object.prototype.toString
    , cu = t => ES.call(t)
    , YI = t => cu(t).slice(8, -1)
    , Gp = t => cu(t) === "[object Object]"
    , Ny = t => qt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t
    , Il = qp(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
    , Jp = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    }
    , XI = /-(\w)/g
    , Fn = Jp(t => t.replace(XI, (e, n) => n ? n.toUpperCase() : ""))
    , QI = /\B([A-Z])/g
    , kr = Jp(t => t.replace(QI, "-$1").toLowerCase())
    , Zp = Jp(t => t.charAt(0).toUpperCase() + t.slice(1))
    , ec = Jp(t => t ? `on${Zp(t)}` : "")
    , ur = (t, e) => !Object.is(t, e)
    , Ll = (t, ...e) => {
        for (let n = 0; n < t.length; n++)
            t[n](...e)
    }
    , TS = (t, e, n, r = !1) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            writable: r,
            value: n
        })
    }
    , Ch = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    }
    , Eh = t => {
        const e = qt(t) ? Number(t) : NaN;
        return isNaN(e) ? t : e
    }
    ;
let Ww;
const AS = () => Ww || (Ww = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {})
    , e4 = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol"
    , t4 = qp(e4);
function Vo(t) {
    if (Re(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n]
                , i = qt(r) ? s4(r) : Vo(r);
            if (i)
                for (const s in i)
                    e[s] = i[s]
        }
        return e
    } else if (qt(t) || jt(t))
        return t
}
const n4 = /;(?![^(]*\))/g
    , r4 = /:([^]+)/
    , i4 = /\/\*[^]*?\*\//g;
function s4(t) {
    const e = {};
    return t.replace(i4, "").split(n4).forEach(n => {
        if (n) {
            const r = n.split(r4);
            r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
    }
    ),
        e
}
function mt(t) {
    let e = "";
    if (qt(t))
        e = t;
    else if (Re(t))
        for (let n = 0; n < t.length; n++) {
            const r = mt(t[n]);
            r && (e += r + " ")
        }
    else if (jt(t))
        for (const n in t)
            t[n] && (e += n + " ");
    return e.trim()
}
function xi(t) {
    if (!t)
        return null;
    let { class: e, style: n } = t;
    return e && !qt(e) && (t.class = mt(e)),
        n && (t.style = Vo(n)),
        t
}
const o4 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
    , a4 = qp(o4);
function OS(t) {
    return !!t || t === ""
}
function l4(t, e) {
    if (t.length !== e.length)
        return !1;
    let n = !0;
    for (let r = 0; n && r < t.length; r++)
        n = Ao(t[r], e[r]);
    return n
}
function Ao(t, e) {
    if (t === e)
        return !0;
    let n = Vw(t)
        , r = Vw(e);
    if (n || r)
        return n && r ? t.getTime() === e.getTime() : !1;
    if (n = Zi(t),
        r = Zi(e),
        n || r)
        return t === e;
    if (n = Re(t),
        r = Re(e),
        n || r)
        return n && r ? l4(t, e) : !1;
    if (n = jt(t),
        r = jt(e),
        n || r) {
        if (!n || !r)
            return !1;
        const i = Object.keys(t).length
            , s = Object.keys(e).length;
        if (i !== s)
            return !1;
        for (const o in t) {
            const a = t.hasOwnProperty(o)
                , l = e.hasOwnProperty(o);
            if (a && !l || !a && l || !Ao(t[o], e[o]))
                return !1
        }
    }
    return String(t) === String(e)
}
function Yp(t, e) {
    return t.findIndex(n => Ao(n, e))
}
const MS = t => !!(t && t.__v_isRef === !0)
    , Vt = t => qt(t) ? t : t == null ? "" : Re(t) || jt(t) && (t.toString === ES || !We(t.toString)) ? MS(t) ? Vt(t.value) : JSON.stringify(t, RS, 2) : String(t)
    , RS = (t, e) => MS(e) ? RS(t, e.value) : Nl(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, i], s) => (n[Qg(r, s) + " =>"] = i,
            n), {})
    } : Va(e) ? {
        [`Set(${e.size})`]: [...e.values()].map(n => Qg(n))
    } : Zi(e) ? Qg(e) : jt(e) && !Re(e) && !Gp(e) ? String(e) : e
    , Qg = (t, e = "") => {
        var n;
        return Zi(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t
    }
    ;
/**
* @vue/reactivity v3.5.6
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let lr;
class PS {
    constructor(e = !1) {
        this.detached = e,
            this._active = !0,
            this.effects = [],
            this.cleanups = [],
            this._isPaused = !1,
            this.parent = lr,
            !e && lr && (this.index = (lr.scopes || (lr.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    pause() {
        if (this._active) {
            this._isPaused = !0;
            let e, n;
            if (this.scopes)
                for (e = 0,
                    n = this.scopes.length; e < n; e++)
                    this.scopes[e].pause();
            for (e = 0,
                n = this.effects.length; e < n; e++)
                this.effects[e].pause()
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            this._isPaused = !1;
            let e, n;
            if (this.scopes)
                for (e = 0,
                    n = this.scopes.length; e < n; e++)
                    this.scopes[e].resume();
            for (e = 0,
                n = this.effects.length; e < n; e++)
                this.effects[e].resume()
        }
    }
    run(e) {
        if (this._active) {
            const n = lr;
            try {
                return lr = this,
                    e()
            } finally {
                lr = n
            }
        }
    }
    on() {
        lr = this
    }
    off() {
        lr = this.parent
    }
    stop(e) {
        if (this._active) {
            let n, r;
            for (n = 0,
                r = this.effects.length; n < r; n++)
                this.effects[n].stop();
            for (n = 0,
                r = this.cleanups.length; n < r; n++)
                this.cleanups[n]();
            if (this.scopes)
                for (n = 0,
                    r = this.scopes.length; n < r; n++)
                    this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !e) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i,
                    i.index = this.index)
            }
            this.parent = void 0,
                this._active = !1
        }
    }
}
function Iy(t) {
    return new PS(t)
}
function ud() {
    return lr
}
function cd(t, e = !1) {
    lr && lr.cleanups.push(t)
}
let $t;
const e0 = new WeakSet;
class Th {
    constructor(e) {
        this.fn = e,
            this.deps = void 0,
            this.depsTail = void 0,
            this.flags = 5,
            this.next = void 0,
            this.cleanup = void 0,
            this.scheduler = void 0,
            lr && lr.active && lr.effects.push(this)
    }
    pause() {
        this.flags |= 64
    }
    resume() {
        this.flags & 64 && (this.flags &= -65,
            e0.has(this) && (e0.delete(this),
                this.trigger()))
    }
    notify() {
        this.flags & 2 && !(this.flags & 32) || this.flags & 8 || IS(this)
    }
    run() {
        if (!(this.flags & 1))
            return this.fn();
        this.flags |= 2,
            Uw(this),
            LS(this);
        const e = $t
            , n = ki;
        $t = this,
            ki = !0;
        try {
            return this.fn()
        } finally {
            DS(this),
                $t = e,
                ki = n,
                this.flags &= -3
        }
    }
    stop() {
        if (this.flags & 1) {
            for (let e = this.deps; e; e = e.nextDep)
                jy(e);
            this.deps = this.depsTail = void 0,
                Uw(this),
                this.onStop && this.onStop(),
                this.flags &= -2
        }
    }
    trigger() {
        this.flags & 64 ? e0.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
        J0(this) && this.run()
    }
    get dirty() {
        return J0(this)
    }
}
let NS = 0, tc;
function IS(t) {
    t.flags |= 8,
        t.next = tc,
        tc = t
}
function Ly() {
    NS++
}
function Dy() {
    if (--NS > 0)
        return;
    let t;
    for (; tc;) {
        let e = tc;
        for (tc = void 0; e;) {
            const n = e.next;
            if (e.next = void 0,
                e.flags &= -9,
                e.flags & 1)
                try {
                    e.trigger()
                } catch (r) {
                    t || (t = r)
                }
            e = n
        }
    }
    if (t)
        throw t
}
function LS(t) {
    for (let e = t.deps; e; e = e.nextDep)
        e.version = -1,
            e.prevActiveLink = e.dep.activeLink,
            e.dep.activeLink = e
}
function DS(t) {
    let e, n = t.depsTail, r = n;
    for (; r;) {
        const i = r.prevDep;
        r.version === -1 ? (r === n && (n = i),
            jy(r),
            u4(r)) : e = r,
            r.dep.activeLink = r.prevActiveLink,
            r.prevActiveLink = void 0,
            r = i
    }
    t.deps = e,
        t.depsTail = n
}
function J0(t) {
    for (let e = t.deps; e; e = e.nextDep)
        if (e.dep.version !== e.version || e.dep.computed && (jS(e.dep.computed) || e.dep.version !== e.version))
            return !0;
    return !!t._dirty
}
function jS(t) {
    if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17,
        t.globalVersion === xc))
        return;
    t.globalVersion = xc;
    const e = t.dep;
    if (t.flags |= 2,
        e.version > 0 && !t.isSSR && t.deps && !J0(t)) {
        t.flags &= -3;
        return
    }
    const n = $t
        , r = ki;
    $t = t,
        ki = !0;
    try {
        LS(t);
        const i = t.fn(t._value);
        (e.version === 0 || ur(i, t._value)) && (t._value = i,
            e.version++)
    } catch (i) {
        throw e.version++,
        i
    } finally {
        $t = n,
            ki = r,
            DS(t),
            t.flags &= -3
    }
}
function jy(t) {
    const { dep: e, prevSub: n, nextSub: r } = t;
    if (n && (n.nextSub = r,
        t.prevSub = void 0),
        r && (r.prevSub = n,
            t.nextSub = void 0),
        e.subs === t && (e.subs = n),
        !e.subs && e.computed) {
        e.computed.flags &= -5;
        for (let i = e.computed.deps; i; i = i.nextDep)
            jy(i)
    }
}
function u4(t) {
    const { prevDep: e, nextDep: n } = t;
    e && (e.nextDep = n,
        t.prevDep = void 0),
        n && (n.prevDep = e,
            t.nextDep = void 0)
}
function UX(t, e) {
    t.effect instanceof Th && (t = t.effect.fn);
    const n = new Th(t);
    e && Kt(n, e);
    try {
        n.run()
    } catch (i) {
        throw n.stop(),
        i
    }
    const r = n.run.bind(n);
    return r.effect = n,
        r
}
function KX(t) {
    t.effect.stop()
}
let ki = !0;
const BS = [];
function Wo() {
    BS.push(ki),
        ki = !1
}
function Uo() {
    const t = BS.pop();
    ki = t === void 0 ? !0 : t
}
function Uw(t) {
    const { cleanup: e } = t;
    if (t.cleanup = void 0,
        e) {
        const n = $t;
        $t = void 0;
        try {
            e()
        } finally {
            $t = n
        }
    }
}
let xc = 0
    , c4 = class {
        constructor(e, n) {
            this.sub = e,
                this.dep = n,
                this.version = n.version,
                this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
        }
    }
    ;
class Xp {
    constructor(e) {
        this.computed = e,
            this.version = 0,
            this.activeLink = void 0,
            this.subs = void 0
    }
    track(e) {
        if (!$t || !ki || $t === this.computed)
            return;
        let n = this.activeLink;
        if (n === void 0 || n.sub !== $t)
            n = this.activeLink = new c4($t, this),
                $t.deps ? (n.prevDep = $t.depsTail,
                    $t.depsTail.nextDep = n,
                    $t.depsTail = n) : $t.deps = $t.depsTail = n,
                $t.flags & 4 && $S(n);
        else if (n.version === -1 && (n.version = this.version,
            n.nextDep)) {
            const r = n.nextDep;
            r.prevDep = n.prevDep,
                n.prevDep && (n.prevDep.nextDep = r),
                n.prevDep = $t.depsTail,
                n.nextDep = void 0,
                $t.depsTail.nextDep = n,
                $t.depsTail = n,
                $t.deps === n && ($t.deps = r)
        }
        return n
    }
    trigger(e) {
        this.version++,
            xc++,
            this.notify(e)
    }
    notify(e) {
        Ly();
        try {
            for (let n = this.subs; n; n = n.prevSub)
                n.sub.notify() && n.sub.dep.notify()
        } finally {
            Dy()
        }
    }
}
function $S(t) {
    const e = t.dep.computed;
    if (e && !t.dep.subs) {
        e.flags |= 20;
        for (let r = e.deps; r; r = r.nextDep)
            $S(r)
    }
    const n = t.dep.subs;
    n !== t && (t.prevSub = n,
        n && (n.nextSub = t)),
        t.dep.subs = t
}
const Ah = new WeakMap
    , ga = Symbol("")
    , Z0 = Symbol("")
    , _c = Symbol("");
function Qn(t, e, n) {
    if (ki && $t) {
        let r = Ah.get(t);
        r || Ah.set(t, r = new Map);
        let i = r.get(n);
        i || r.set(n, i = new Xp),
            i.track()
    }
}
function Ns(t, e, n, r, i, s) {
    const o = Ah.get(t);
    if (!o) {
        xc++;
        return
    }
    const a = l => {
        l && l.trigger()
    }
        ;
    if (Ly(),
        e === "clear")
        o.forEach(a);
    else {
        const l = Re(t)
            , c = l && Ny(n);
        if (l && n === "length") {
            const d = Number(r);
            o.forEach((h, p) => {
                (p === "length" || p === _c || !Zi(p) && p >= d) && a(h)
            }
            )
        } else
            switch (n !== void 0 && a(o.get(n)),
            c && a(o.get(_c)),
            e) {
                case "add":
                    l ? c && a(o.get("length")) : (a(o.get(ga)),
                        Nl(t) && a(o.get(Z0)));
                    break;
                case "delete":
                    l || (a(o.get(ga)),
                        Nl(t) && a(o.get(Z0)));
                    break;
                case "set":
                    Nl(t) && a(o.get(ga));
                    break
            }
    }
    Dy()
}
function d4(t, e) {
    var n;
    return (n = Ah.get(t)) == null ? void 0 : n.get(e)
}
function cl(t) {
    const e = it(t);
    return e === t ? e : (Qn(e, "iterate", _c),
        si(t) ? e : e.map(Gn))
}
function Qp(t) {
    return Qn(t = it(t), "iterate", _c),
        t
}
const f4 = {
    __proto__: null,
    [Symbol.iterator]() {
        return t0(this, Symbol.iterator, Gn)
    },
    concat(...t) {
        return cl(this).concat(...t.map(e => Re(e) ? cl(e) : e))
    },
    entries() {
        return t0(this, "entries", t => (t[1] = Gn(t[1]),
            t))
    },
    every(t, e) {
        return bs(this, "every", t, e, void 0, arguments)
    },
    filter(t, e) {
        return bs(this, "filter", t, e, n => n.map(Gn), arguments)
    },
    find(t, e) {
        return bs(this, "find", t, e, Gn, arguments)
    },
    findIndex(t, e) {
        return bs(this, "findIndex", t, e, void 0, arguments)
    },
    findLast(t, e) {
        return bs(this, "findLast", t, e, Gn, arguments)
    },
    findLastIndex(t, e) {
        return bs(this, "findLastIndex", t, e, void 0, arguments)
    },
    forEach(t, e) {
        return bs(this, "forEach", t, e, void 0, arguments)
    },
    includes(...t) {
        return n0(this, "includes", t)
    },
    indexOf(...t) {
        return n0(this, "indexOf", t)
    },
    join(t) {
        return cl(this).join(t)
    },
    lastIndexOf(...t) {
        return n0(this, "lastIndexOf", t)
    },
    map(t, e) {
        return bs(this, "map", t, e, void 0, arguments)
    },
    pop() {
        return Lu(this, "pop")
    },
    push(...t) {
        return Lu(this, "push", t)
    },
    reduce(t, ...e) {
        return Kw(this, "reduce", t, e)
    },
    reduceRight(t, ...e) {
        return Kw(this, "reduceRight", t, e)
    },
    shift() {
        return Lu(this, "shift")
    },
    some(t, e) {
        return bs(this, "some", t, e, void 0, arguments)
    },
    splice(...t) {
        return Lu(this, "splice", t)
    },
    toReversed() {
        return cl(this).toReversed()
    },
    toSorted(t) {
        return cl(this).toSorted(t)
    },
    toSpliced(...t) {
        return cl(this).toSpliced(...t)
    },
    unshift(...t) {
        return Lu(this, "unshift", t)
    },
    values() {
        return t0(this, "values", Gn)
    }
};
function t0(t, e, n) {
    const r = Qp(t)
        , i = r[e]();
    return r !== t && !si(t) && (i._next = i.next,
        i.next = () => {
            const s = i._next();
            return s.value && (s.value = n(s.value)),
                s
        }
    ),
        i
}
const h4 = Array.prototype;
function bs(t, e, n, r, i, s) {
    const o = Qp(t)
        , a = o !== t && !si(t)
        , l = o[e];
    if (l !== h4[e]) {
        const h = l.apply(t, s);
        return a ? Gn(h) : h
    }
    let c = n;
    o !== t && (a ? c = function (h, p) {
        return n.call(this, Gn(h), p, t)
    }
        : n.length > 2 && (c = function (h, p) {
            return n.call(this, h, p, t)
        }
        ));
    const d = l.call(o, c, r);
    return a && i ? i(d) : d
}
function Kw(t, e, n, r) {
    const i = Qp(t);
    let s = n;
    return i !== t && (si(t) ? n.length > 3 && (s = function (o, a, l) {
        return n.call(this, o, a, l, t)
    }
    ) : s = function (o, a, l) {
        return n.call(this, o, Gn(a), l, t)
    }
    ),
        i[e](s, ...r)
}
function n0(t, e, n) {
    const r = it(t);
    Qn(r, "iterate", _c);
    const i = r[e](...n);
    return (i === -1 || i === !1) && $y(n[0]) ? (n[0] = it(n[0]),
        r[e](...n)) : i
}
function Lu(t, e, n = []) {
    Wo(),
        Ly();
    const r = it(t)[e].apply(t, n);
    return Dy(),
        Uo(),
        r
}
const p4 = qp("__proto__,__v_isRef,__isVue")
    , zS = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(Zi));
function m4(t) {
    Zi(t) || (t = String(t));
    const e = it(this);
    return Qn(e, "has", t),
        e.hasOwnProperty(t)
}
class FS {
    constructor(e = !1, n = !1) {
        this._isReadonly = e,
            this._isShallow = n
    }
    get(e, n, r) {
        const i = this._isReadonly
            , s = this._isShallow;
        if (n === "__v_isReactive")
            return !i;
        if (n === "__v_isReadonly")
            return i;
        if (n === "__v_isShallow")
            return s;
        if (n === "__v_raw")
            return r === (i ? s ? qS : KS : s ? US : WS).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0;
        const o = Re(e);
        if (!i) {
            let l;
            if (o && (l = f4[n]))
                return l;
            if (n === "hasOwnProperty")
                return m4
        }
        const a = Reflect.get(e, n, Yt(e) ? e : r);
        return (Zi(n) ? zS.has(n) : p4(n)) || (i || Qn(e, "get", n),
            s) ? a : Yt(a) ? o && Ny(n) ? a : a.value : jt(a) ? i ? du(a) : wn(a) : a
    }
}
class HS extends FS {
    constructor(e = !1) {
        super(!1, e)
    }
    set(e, n, r, i) {
        let s = e[n];
        if (!this._isShallow) {
            const l = Aa(s);
            if (!si(r) && !Aa(r) && (s = it(s),
                r = it(r)),
                !Re(e) && Yt(s) && !Yt(r))
                return l ? !1 : (s.value = r,
                    !0)
        }
        const o = Re(e) && Ny(n) ? Number(n) < e.length : Ot(e, n)
            , a = Reflect.set(e, n, r, Yt(e) ? e : i);
        return e === it(i) && (o ? ur(r, s) && Ns(e, "set", n, r) : Ns(e, "add", n, r)),
            a
    }
    deleteProperty(e, n) {
        const r = Ot(e, n);
        e[n];
        const i = Reflect.deleteProperty(e, n);
        return i && r && Ns(e, "delete", n, void 0),
            i
    }
    has(e, n) {
        const r = Reflect.has(e, n);
        return (!Zi(n) || !zS.has(n)) && Qn(e, "has", n),
            r
    }
    ownKeys(e) {
        return Qn(e, "iterate", Re(e) ? "length" : ga),
            Reflect.ownKeys(e)
    }
}
class VS extends FS {
    constructor(e = !1) {
        super(!0, e)
    }
    set(e, n) {
        return !0
    }
    deleteProperty(e, n) {
        return !0
    }
}
const g4 = new HS
    , y4 = new VS
    , v4 = new HS(!0)
    , b4 = new VS(!0)
    , By = t => t
    , em = t => Reflect.getPrototypeOf(t);
function wf(t, e, n = !1, r = !1) {
    t = t.__v_raw;
    const i = it(t)
        , s = it(e);
    n || (ur(e, s) && Qn(i, "get", e),
        Qn(i, "get", s));
    const { has: o } = em(i)
        , a = r ? By : n ? Fy : Gn;
    if (o.call(i, e))
        return a(t.get(e));
    if (o.call(i, s))
        return a(t.get(s));
    t !== i && t.get(e)
}
function xf(t, e = !1) {
    const n = this.__v_raw
        , r = it(n)
        , i = it(t);
    return e || (ur(t, i) && Qn(r, "has", t),
        Qn(r, "has", i)),
        t === i ? n.has(t) : n.has(t) || n.has(i)
}
function _f(t, e = !1) {
    return t = t.__v_raw,
        !e && Qn(it(t), "iterate", ga),
        Reflect.get(t, "size", t)
}
function qw(t, e = !1) {
    !e && !si(t) && !Aa(t) && (t = it(t));
    const n = it(this);
    return em(n).has.call(n, t) || (n.add(t),
        Ns(n, "add", t, t)),
        this
}
function Gw(t, e, n = !1) {
    !n && !si(e) && !Aa(e) && (e = it(e));
    const r = it(this)
        , { has: i, get: s } = em(r);
    let o = i.call(r, t);
    o || (t = it(t),
        o = i.call(r, t));
    const a = s.call(r, t);
    return r.set(t, e),
        o ? ur(e, a) && Ns(r, "set", t, e) : Ns(r, "add", t, e),
        this
}
function Jw(t) {
    const e = it(this)
        , { has: n, get: r } = em(e);
    let i = n.call(e, t);
    i || (t = it(t),
        i = n.call(e, t)),
        r && r.call(e, t);
    const s = e.delete(t);
    return i && Ns(e, "delete", t, void 0),
        s
}
function Zw() {
    const t = it(this)
        , e = t.size !== 0
        , n = t.clear();
    return e && Ns(t, "clear", void 0, void 0),
        n
}
function Sf(t, e) {
    return function (r, i) {
        const s = this
            , o = s.__v_raw
            , a = it(o)
            , l = e ? By : t ? Fy : Gn;
        return !t && Qn(a, "iterate", ga),
            o.forEach((c, d) => r.call(i, l(c), l(d), s))
    }
}
function kf(t, e, n) {
    return function (...r) {
        const i = this.__v_raw
            , s = it(i)
            , o = Nl(s)
            , a = t === "entries" || t === Symbol.iterator && o
            , l = t === "keys" && o
            , c = i[t](...r)
            , d = n ? By : e ? Fy : Gn;
        return !e && Qn(s, "iterate", l ? Z0 : ga),
        {
            next() {
                const { value: h, done: p } = c.next();
                return p ? {
                    value: h,
                    done: p
                } : {
                    value: a ? [d(h[0]), d(h[1])] : d(h),
                    done: p
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function Zs(t) {
    return function (...e) {
        return t === "delete" ? !1 : t === "clear" ? void 0 : this
    }
}
function w4() {
    const t = {
        get(s) {
            return wf(this, s)
        },
        get size() {
            return _f(this)
        },
        has: xf,
        add: qw,
        set: Gw,
        delete: Jw,
        clear: Zw,
        forEach: Sf(!1, !1)
    }
        , e = {
            get(s) {
                return wf(this, s, !1, !0)
            },
            get size() {
                return _f(this)
            },
            has: xf,
            add(s) {
                return qw.call(this, s, !0)
            },
            set(s, o) {
                return Gw.call(this, s, o, !0)
            },
            delete: Jw,
            clear: Zw,
            forEach: Sf(!1, !0)
        }
        , n = {
            get(s) {
                return wf(this, s, !0)
            },
            get size() {
                return _f(this, !0)
            },
            has(s) {
                return xf.call(this, s, !0)
            },
            add: Zs("add"),
            set: Zs("set"),
            delete: Zs("delete"),
            clear: Zs("clear"),
            forEach: Sf(!0, !1)
        }
        , r = {
            get(s) {
                return wf(this, s, !0, !0)
            },
            get size() {
                return _f(this, !0)
            },
            has(s) {
                return xf.call(this, s, !0)
            },
            add: Zs("add"),
            set: Zs("set"),
            delete: Zs("delete"),
            clear: Zs("clear"),
            forEach: Sf(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        t[s] = kf(s, !1, !1),
            n[s] = kf(s, !0, !1),
            e[s] = kf(s, !1, !0),
            r[s] = kf(s, !0, !0)
    }
    ),
        [t, n, e, r]
}
const [x4, _4, S4, k4] = w4();
function tm(t, e) {
    const n = e ? t ? k4 : S4 : t ? _4 : x4;
    return (r, i, s) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? r : Reflect.get(Ot(n, i) && i in r ? n : r, i, s)
}
const C4 = {
    get: tm(!1, !1)
}
    , E4 = {
        get: tm(!1, !0)
    }
    , T4 = {
        get: tm(!0, !1)
    }
    , A4 = {
        get: tm(!0, !0)
    }
    , WS = new WeakMap
    , US = new WeakMap
    , KS = new WeakMap
    , qS = new WeakMap;
function O4(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}
function M4(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : O4(YI(t))
}
function wn(t) {
    return Aa(t) ? t : nm(t, !1, g4, C4, WS)
}
function GS(t) {
    return nm(t, !1, v4, E4, US)
}
function du(t) {
    return nm(t, !0, y4, T4, KS)
}
function dl(t) {
    return nm(t, !0, b4, A4, qS)
}
function nm(t, e, n, r, i) {
    if (!jt(t) || t.__v_raw && !(e && t.__v_isReactive))
        return t;
    const s = i.get(t);
    if (s)
        return s;
    const o = M4(t);
    if (o === 0)
        return t;
    const a = new Proxy(t, o === 2 ? r : n);
    return i.set(t, a),
        a
}
function Ui(t) {
    return Aa(t) ? Ui(t.__v_raw) : !!(t && t.__v_isReactive)
}
function Aa(t) {
    return !!(t && t.__v_isReadonly)
}
function si(t) {
    return !!(t && t.__v_isShallow)
}
function $y(t) {
    return t ? !!t.__v_raw : !1
}
function it(t) {
    const e = t && t.__v_raw;
    return e ? it(e) : t
}
function zy(t) {
    return !Ot(t, "__v_skip") && Object.isExtensible(t) && TS(t, "__v_skip", !0),
        t
}
const Gn = t => jt(t) ? wn(t) : t
    , Fy = t => jt(t) ? du(t) : t;
function Yt(t) {
    return t ? t.__v_isRef === !0 : !1
}
function ce(t) {
    return JS(t, !1)
}
function Wa(t) {
    return JS(t, !0)
}
function JS(t, e) {
    return Yt(t) ? t : new R4(t, e)
}
class R4 {
    constructor(e, n) {
        this.dep = new Xp,
            this.__v_isRef = !0,
            this.__v_isShallow = !1,
            this._rawValue = n ? e : it(e),
            this._value = n ? e : Gn(e),
            this.__v_isShallow = n
    }
    get value() {
        return this.dep.track(),
            this._value
    }
    set value(e) {
        const n = this._rawValue
            , r = this.__v_isShallow || si(e) || Aa(e);
        e = r ? e : it(e),
            ur(e, n) && (this._rawValue = e,
                this._value = r ? e : Gn(e),
                this.dep.trigger())
    }
}
function Yw(t) {
    t.dep.trigger()
}
function ie(t) {
    return Yt(t) ? t.value : t
}
function GX(t) {
    return We(t) ? t() : ie(t)
}
const P4 = {
    get: (t, e, n) => e === "__v_raw" ? t : ie(Reflect.get(t, e, n)),
    set: (t, e, n, r) => {
        const i = t[e];
        return Yt(i) && !Yt(n) ? (i.value = n,
            !0) : Reflect.set(t, e, n, r)
    }
};
function ZS(t) {
    return Ui(t) ? t : new Proxy(t, P4)
}
class N4 {
    constructor(e) {
        this.__v_isRef = !0,
            this._value = void 0;
        const n = this.dep = new Xp
            , { get: r, set: i } = e(n.track.bind(n), n.trigger.bind(n));
        this._get = r,
            this._set = i
    }
    get value() {
        return this._value = this._get()
    }
    set value(e) {
        this._set(e)
    }
}
function YS(t) {
    return new N4(t)
}
function Hy(t) {
    const e = Re(t) ? new Array(t.length) : {};
    for (const n in t)
        e[n] = QS(t, n);
    return e
}
class I4 {
    constructor(e, n, r) {
        this._object = e,
            this._key = n,
            this._defaultValue = r,
            this.__v_isRef = !0,
            this._value = void 0
    }
    get value() {
        const e = this._object[this._key];
        return this._value = e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return d4(it(this._object), this._key)
    }
}
class L4 {
    constructor(e) {
        this._getter = e,
            this.__v_isRef = !0,
            this.__v_isReadonly = !0,
            this._value = void 0
    }
    get value() {
        return this._value = this._getter()
    }
}
function XS(t, e, n) {
    return Yt(t) ? t : We(t) ? new L4(t) : jt(t) && arguments.length > 1 ? QS(t, e, n) : ce(t)
}
function QS(t, e, n) {
    const r = t[e];
    return Yt(r) ? r : new I4(t, e, n)
}
class D4 {
    constructor(e, n, r) {
        this.fn = e,
            this.setter = n,
            this._value = void 0,
            this.dep = new Xp(this),
            this.__v_isRef = !0,
            this.deps = void 0,
            this.depsTail = void 0,
            this.flags = 16,
            this.globalVersion = xc - 1,
            this.effect = this,
            this.__v_isReadonly = !n,
            this.isSSR = r
    }
    notify() {
        if (this.flags |= 16,
            !(this.flags & 8) && $t !== this)
            return IS(this),
                !0
    }
    get value() {
        const e = this.dep.track();
        return jS(this),
            e && (e.version = this.dep.version),
            this._value
    }
    set value(e) {
        this.setter && this.setter(e)
    }
}
function j4(t, e, n = !1) {
    let r, i;
    return We(t) ? r = t : (r = t.get,
        i = t.set),
        new D4(r, i, n)
}
const JX = {
    GET: "get",
    HAS: "has",
    ITERATE: "iterate"
}
    , ZX = {
        SET: "set",
        ADD: "add",
        DELETE: "delete",
        CLEAR: "clear"
    }
    , Cf = {}
    , Oh = new WeakMap;
let ro;
function YX() {
    return ro
}
function B4(t, e = !1, n = ro) {
    if (n) {
        let r = Oh.get(n);
        r || Oh.set(n, r = []),
            r.push(t)
    }
}
function $4(t, e, n = kt) {
    const { immediate: r, deep: i, once: s, scheduler: o, augmentJob: a, call: l } = n
        , c = m => i ? m : si(m) || i === !1 || i === 0 ? Os(m, 1) : Os(m);
    let d, h, p, g, y = !1, x = !1;
    if (Yt(t) ? (h = () => t.value,
        y = si(t)) : Ui(t) ? (h = () => c(t),
            y = !0) : Re(t) ? (x = !0,
                y = t.some(m => Ui(m) || si(m)),
                h = () => t.map(m => {
                    if (Yt(m))
                        return m.value;
                    if (Ui(m))
                        return c(m);
                    if (We(m))
                        return l ? l(m, 2) : m()
                }
                )) : We(t) ? e ? h = l ? () => l(t, 2) : t : h = () => {
                    if (p) {
                        Wo();
                        try {
                            p()
                        } finally {
                            Uo()
                        }
                    }
                    const m = ro;
                    ro = d;
                    try {
                        return l ? l(t, 3, [g]) : t(g)
                    } finally {
                        ro = m
                    }
                }
        : h = ii,
        e && i) {
        const m = h
            , b = i === !0 ? 1 / 0 : i;
        h = () => Os(m(), b)
    }
    const S = ud()
        , k = () => {
            d.stop(),
                S && Ry(S.effects, d)
        }
        ;
    if (s && e) {
        const m = e;
        e = (...b) => {
            m(...b),
                k()
        }
    }
    let A = x ? new Array(t.length).fill(Cf) : Cf;
    const C = m => {
        if (!(!(d.flags & 1) || !d.dirty && !m))
            if (e) {
                const b = d.run();
                if (i || y || (x ? b.some((w, T) => ur(w, A[T])) : ur(b, A))) {
                    p && p();
                    const w = ro;
                    ro = d;
                    try {
                        const T = [b, A === Cf ? void 0 : x && A[0] === Cf ? [] : A, g];
                        l ? l(e, 3, T) : e(...T),
                            A = b
                    } finally {
                        ro = w
                    }
                }
            } else
                d.run()
    }
        ;
    return a && a(C),
        d = new Th(h),
        d.scheduler = o ? () => o(C, !1) : C,
        g = m => B4(m, !1, d),
        p = d.onStop = () => {
            const m = Oh.get(d);
            if (m) {
                if (l)
                    l(m, 4);
                else
                    for (const b of m)
                        b();
                Oh.delete(d)
            }
        }
        ,
        e ? r ? C(!0) : A = d.run() : o ? o(C.bind(null, !0), !0) : d.run(),
        k.pause = d.pause.bind(d),
        k.resume = d.resume.bind(d),
        k.stop = k,
        k
}
function Os(t, e = 1 / 0, n) {
    if (e <= 0 || !jt(t) || t.__v_skip || (n = n || new Set,
        n.has(t)))
        return t;
    if (n.add(t),
        e--,
        Yt(t))
        Os(t.value, e, n);
    else if (Re(t))
        for (let r = 0; r < t.length; r++)
            Os(t[r], e, n);
    else if (Va(t) || Nl(t))
        t.forEach(r => {
            Os(r, e, n)
        }
        );
    else if (Gp(t)) {
        for (const r in t)
            Os(t[r], e, n);
        for (const r of Object.getOwnPropertySymbols(t))
            Object.prototype.propertyIsEnumerable.call(t, r) && Os(t[r], e, n)
    }
    return t
}
/**
* @vue/runtime-core v3.5.6
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const ek = [];
function z4(t) {
    ek.push(t)
}
function F4() {
    ek.pop()
}
function XX(t, e) { }
const QX = {
    SETUP_FUNCTION: 0,
    0: "SETUP_FUNCTION",
    RENDER_FUNCTION: 1,
    1: "RENDER_FUNCTION",
    NATIVE_EVENT_HANDLER: 5,
    5: "NATIVE_EVENT_HANDLER",
    COMPONENT_EVENT_HANDLER: 6,
    6: "COMPONENT_EVENT_HANDLER",
    VNODE_HOOK: 7,
    7: "VNODE_HOOK",
    DIRECTIVE_HOOK: 8,
    8: "DIRECTIVE_HOOK",
    TRANSITION_HOOK: 9,
    9: "TRANSITION_HOOK",
    APP_ERROR_HANDLER: 10,
    10: "APP_ERROR_HANDLER",
    APP_WARN_HANDLER: 11,
    11: "APP_WARN_HANDLER",
    FUNCTION_REF: 12,
    12: "FUNCTION_REF",
    ASYNC_COMPONENT_LOADER: 13,
    13: "ASYNC_COMPONENT_LOADER",
    SCHEDULER: 14,
    14: "SCHEDULER",
    COMPONENT_UPDATE: 15,
    15: "COMPONENT_UPDATE",
    APP_UNMOUNT_CLEANUP: 16,
    16: "APP_UNMOUNT_CLEANUP"
}
    , H4 = {
        sp: "serverPrefetch hook",
        bc: "beforeCreate hook",
        c: "created hook",
        bm: "beforeMount hook",
        m: "mounted hook",
        bu: "beforeUpdate hook",
        u: "updated",
        bum: "beforeUnmount hook",
        um: "unmounted hook",
        a: "activated hook",
        da: "deactivated hook",
        ec: "errorCaptured hook",
        rtc: "renderTracked hook",
        rtg: "renderTriggered hook",
        0: "setup function",
        1: "render function",
        2: "watcher getter",
        3: "watcher callback",
        4: "watcher cleanup function",
        5: "native event handler",
        6: "component event handler",
        7: "vnode hook",
        8: "directive hook",
        9: "transition hook",
        10: "app errorHandler",
        11: "app warnHandler",
        12: "ref function",
        13: "async component loader",
        14: "scheduler flush",
        15: "component update",
        16: "app unmount cleanup function"
    };
function dd(t, e, n, r) {
    try {
        return r ? t(...r) : t()
    } catch (i) {
        fu(i, e, n)
    }
}
function Ti(t, e, n, r) {
    if (We(t)) {
        const i = dd(t, e, n, r);
        return i && Py(i) && i.catch(s => {
            fu(s, e, n)
        }
        ),
            i
    }
    if (Re(t)) {
        const i = [];
        for (let s = 0; s < t.length; s++)
            i.push(Ti(t[s], e, n, r));
        return i
    }
}
function fu(t, e, n, r = !0) {
    const i = e ? e.vnode : null
        , { errorHandler: s, throwUnhandledErrorInProduction: o } = e && e.appContext.config || kt;
    if (e) {
        let a = e.parent;
        const l = e.proxy
            , c = `https://vuejs.org/error-reference/#runtime-${n}`;
        for (; a;) {
            const d = a.ec;
            if (d) {
                for (let h = 0; h < d.length; h++)
                    if (d[h](t, l, c) === !1)
                        return
            }
            a = a.parent
        }
        if (s) {
            Wo(),
                dd(s, null, 10, [t, l, c]),
                Uo();
            return
        }
    }
    V4(t, n, i, r, o)
}
function V4(t, e, n, r = !0, i = !1) {
    if (i)
        throw t;
    console.error(t)
}
let Sc = !1
    , Y0 = !1;
const cr = [];
let ji = 0;
const Dl = [];
let io = null
    , bl = 0;
const tk = Promise.resolve();
let Vy = null;
function un(t) {
    const e = Vy || tk;
    return t ? e.then(this ? t.bind(this) : t) : e
}
function W4(t) {
    let e = Sc ? ji + 1 : 0
        , n = cr.length;
    for (; e < n;) {
        const r = e + n >>> 1
            , i = cr[r]
            , s = kc(i);
        s < t || s === t && i.flags & 2 ? e = r + 1 : n = r
    }
    return e
}
function Wy(t) {
    if (!(t.flags & 1)) {
        const e = kc(t)
            , n = cr[cr.length - 1];
        !n || !(t.flags & 2) && e >= kc(n) ? cr.push(t) : cr.splice(W4(e), 0, t),
            t.flags |= 1,
            nk()
    }
}
function nk() {
    !Sc && !Y0 && (Y0 = !0,
        Vy = tk.then(rk))
}
function X0(t) {
    Re(t) ? Dl.push(...t) : io && t.id === -1 ? io.splice(bl + 1, 0, t) : t.flags & 1 || (Dl.push(t),
        t.flags |= 1),
        nk()
}
function Xw(t, e, n = Sc ? ji + 1 : 0) {
    for (; n < cr.length; n++) {
        const r = cr[n];
        if (r && r.flags & 2) {
            if (t && r.id !== t.uid)
                continue;
            cr.splice(n, 1),
                n--,
                r.flags & 4 && (r.flags &= -2),
                r(),
                r.flags &= -2
        }
    }
}
function Mh(t) {
    if (Dl.length) {
        const e = [...new Set(Dl)].sort((n, r) => kc(n) - kc(r));
        if (Dl.length = 0,
            io) {
            io.push(...e);
            return
        }
        for (io = e,
            bl = 0; bl < io.length; bl++) {
            const n = io[bl];
            n.flags & 4 && (n.flags &= -2),
                n.flags & 8 || n(),
                n.flags &= -2
        }
        io = null,
            bl = 0
    }
}
const kc = t => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function rk(t) {
    Y0 = !1,
        Sc = !0;
    const e = ii;
    try {
        for (ji = 0; ji < cr.length; ji++) {
            const n = cr[ji];
            n && !(n.flags & 8) && (n.flags & 4 && (n.flags &= -2),
                dd(n, n.i, n.i ? 15 : 14),
                n.flags &= -2)
        }
    } finally {
        for (; ji < cr.length; ji++) {
            const n = cr[ji];
            n && (n.flags &= -2)
        }
        ji = 0,
            cr.length = 0,
            Mh(),
            Sc = !1,
            Vy = null,
            (cr.length || Dl.length) && rk()
    }
}
let wl, Ef = [];
function ik(t, e) {
    var n, r;
    wl = t,
        wl ? (wl.enabled = !0,
            Ef.forEach(({ event: i, args: s }) => wl.emit(i, ...s)),
            Ef = []) : typeof window < "u" && window.HTMLElement && !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(s => {
                ik(s, e)
            }
            ),
                setTimeout(() => {
                    wl || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null,
                        Ef = [])
                }
                    , 3e3)) : Ef = []
}
let bn = null
    , rm = null;
function Cc(t) {
    const e = bn;
    return bn = t,
        rm = t && t.type.__scopeId || null,
        e
}
function eQ(t) {
    rm = t
}
function tQ() {
    rm = null
}
const nQ = t => tt;
function tt(t, e = bn, n) {
    if (!e || t._n)
        return t;
    const r = (...i) => {
        r._d && dx(-1);
        const s = Cc(e);
        let o;
        try {
            o = t(...i)
        } finally {
            Cc(s),
                r._d && dx(1)
        }
        return o
    }
        ;
    return r._n = !0,
        r._c = !0,
        r._d = !0,
        r
}
function Rh(t, e) {
    if (bn === null)
        return t;
    const n = gd(bn)
        , r = t.dirs || (t.dirs = []);
    for (let i = 0; i < e.length; i++) {
        let [s, o, a, l = kt] = e[i];
        s && (We(s) && (s = {
            mounted: s,
            updated: s
        }),
            s.deep && Os(o),
            r.push({
                dir: s,
                instance: n,
                value: o,
                oldValue: void 0,
                arg: a,
                modifiers: l
            }))
    }
    return t
}
function Hi(t, e, n, r) {
    const i = t.dirs
        , s = e && e.dirs;
    for (let o = 0; o < i.length; o++) {
        const a = i[o];
        s && (a.oldValue = s[o].value);
        let l = a.dir[r];
        l && (Wo(),
            Ti(l, n, 8, [t.el, a, t, e]),
            Uo())
    }
}
const sk = Symbol("_vte")
    , ok = t => t.__isTeleport
    , nc = t => t && (t.disabled || t.disabled === "")
    , U4 = t => t && (t.defer || t.defer === "")
    , Qw = t => typeof SVGElement < "u" && t instanceof SVGElement
    , ex = t => typeof MathMLElement == "function" && t instanceof MathMLElement
    , Q0 = (t, e) => {
        const n = t && t.to;
        return qt(n) ? e ? e(n) : null : n
    }
    , K4 = {
        name: "Teleport",
        __isTeleport: !0,
        process(t, e, n, r, i, s, o, a, l, c) {
            const { mc: d, pc: h, pbc: p, o: { insert: g, querySelector: y, createText: x, createComment: S } } = c
                , k = nc(e.props);
            let { shapeFlag: A, children: C, dynamicChildren: m } = e;
            if (t == null) {
                const b = e.el = x("")
                    , w = e.anchor = x("");
                g(b, n, r),
                    g(w, n, r);
                const T = (M, E) => {
                    A & 16 && (i && i.isCE && (i.ce._teleportTarget = M),
                        d(C, M, E, i, s, o, a, l))
                }
                    , O = () => {
                        const M = e.target = Q0(e.props, y)
                            , E = ak(M, e, x, g);
                        M && (o !== "svg" && Qw(M) ? o = "svg" : o !== "mathml" && ex(M) && (o = "mathml"),
                            k || (T(M, E),
                                oh(e)))
                    }
                    ;
                k && (T(n, w),
                    oh(e)),
                    U4(e.props) ? kn(O, s) : O()
            } else {
                e.el = t.el,
                    e.targetStart = t.targetStart;
                const b = e.anchor = t.anchor
                    , w = e.target = t.target
                    , T = e.targetAnchor = t.targetAnchor
                    , O = nc(t.props)
                    , M = O ? n : w
                    , E = O ? b : T;
                if (o === "svg" || Qw(w) ? o = "svg" : (o === "mathml" || ex(w)) && (o = "mathml"),
                    m ? (p(t.dynamicChildren, m, M, i, s, o, a),
                        ev(t, e, !0)) : l || h(t, e, M, E, i, s, o, a, !1),
                    k)
                    O ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : Tf(e, n, b, c, 1);
                else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
                    const N = e.target = Q0(e.props, y);
                    N && Tf(e, N, null, c, 0)
                } else
                    O && Tf(e, w, T, c, 1);
                oh(e)
            }
        },
        remove(t, e, n, { um: r, o: { remove: i } }, s) {
            const { shapeFlag: o, children: a, anchor: l, targetStart: c, targetAnchor: d, target: h, props: p } = t;
            if (h && (i(c),
                i(d)),
                s && i(l),
                o & 16) {
                const g = s || !nc(p);
                for (let y = 0; y < a.length; y++) {
                    const x = a[y];
                    r(x, e, n, g, !!x.dynamicChildren)
                }
            }
        },
        move: Tf,
        hydrate: q4
    };
function Tf(t, e, n, { o: { insert: r }, m: i }, s = 2) {
    s === 0 && r(t.targetAnchor, e, n);
    const { el: o, anchor: a, shapeFlag: l, children: c, props: d } = t
        , h = s === 2;
    if (h && r(o, e, n),
        (!h || nc(d)) && l & 16)
        for (let p = 0; p < c.length; p++)
            i(c[p], e, n, 2);
    h && r(a, e, n)
}
function q4(t, e, n, r, i, s, { o: { nextSibling: o, parentNode: a, querySelector: l, insert: c, createText: d } }, h) {
    const p = e.target = Q0(e.props, l);
    if (p) {
        const g = p._lpa || p.firstChild;
        if (e.shapeFlag & 16)
            if (nc(e.props))
                e.anchor = h(o(t), e, a(t), n, r, i, s),
                    e.targetStart = g,
                    e.targetAnchor = g && o(g);
            else {
                e.anchor = o(t);
                let y = g;
                for (; y;) {
                    if (y && y.nodeType === 8) {
                        if (y.data === "teleport start anchor")
                            e.targetStart = y;
                        else if (y.data === "teleport anchor") {
                            e.targetAnchor = y,
                                p._lpa = e.targetAnchor && o(e.targetAnchor);
                            break
                        }
                    }
                    y = o(y)
                }
                e.targetAnchor || ak(p, e, d, c),
                    h(g && o(g), e, p, n, r, i, s)
            }
        oh(e)
    }
    return e.anchor && o(e.anchor)
}
const im = K4;
function oh(t) {
    const e = t.ctx;
    if (e && e.ut) {
        let n = t.targetStart;
        for (; n && n !== t.targetAnchor;)
            n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid),
                n = n.nextSibling;
        e.ut()
    }
}
function ak(t, e, n, r) {
    const i = e.targetStart = n("")
        , s = e.targetAnchor = n("");
    return i[sk] = s,
        t && (r(i, t),
            r(s, t)),
        s
}
const so = Symbol("_leaveCb")
    , Af = Symbol("_enterCb");
function lk() {
    const t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Nt(() => {
        t.isMounted = !0
    }
    ),
        Gy(() => {
            t.isUnmounting = !0
        }
        ),
        t
}
const Yr = [Function, Array]
    , uk = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: Yr,
        onEnter: Yr,
        onAfterEnter: Yr,
        onEnterCancelled: Yr,
        onBeforeLeave: Yr,
        onLeave: Yr,
        onAfterLeave: Yr,
        onLeaveCancelled: Yr,
        onBeforeAppear: Yr,
        onAppear: Yr,
        onAfterAppear: Yr,
        onAppearCancelled: Yr
    }
    , ck = t => {
        const e = t.subTree;
        return e.component ? ck(e.component) : e
    }
    , G4 = {
        name: "BaseTransition",
        props: uk,
        setup(t, { slots: e }) {
            const n = pn()
                , r = lk();
            return () => {
                const i = e.default && Uy(e.default(), !0);
                if (!i || !i.length)
                    return;
                const s = dk(i)
                    , o = it(t)
                    , { mode: a } = o;
                if (r.isLeaving)
                    return r0(s);
                const l = tx(s);
                if (!l)
                    return r0(s);
                let c = Ec(l, o, r, n, p => c = p);
                l.type !== cn && Oo(l, c);
                const d = n.subTree
                    , h = d && tx(d);
                if (h && h.type !== cn && !vi(l, h) && ck(n).type !== cn) {
                    const p = Ec(h, o, r, n);
                    if (Oo(h, p),
                        a === "out-in" && l.type !== cn)
                        return r.isLeaving = !0,
                            p.afterLeave = () => {
                                r.isLeaving = !1,
                                    n.job.flags & 8 || n.update(),
                                    delete p.afterLeave
                            }
                            ,
                            r0(s);
                    a === "in-out" && l.type !== cn && (p.delayLeave = (g, y, x) => {
                        const S = fk(r, h);
                        S[String(h.key)] = h,
                            g[so] = () => {
                                y(),
                                    g[so] = void 0,
                                    delete c.delayedLeave
                            }
                            ,
                            c.delayedLeave = x
                    }
                    )
                }
                return s
            }
        }
    };
function dk(t) {
    let e = t[0];
    if (t.length > 1) {
        for (const n of t)
            if (n.type !== cn) {
                e = n;
                break
            }
    }
    return e
}
const J4 = G4;
function fk(t, e) {
    const { leavingVNodes: n } = t;
    let r = n.get(e.type);
    return r || (r = Object.create(null),
        n.set(e.type, r)),
        r
}
function Ec(t, e, n, r, i) {
    const { appear: s, mode: o, persisted: a = !1, onBeforeEnter: l, onEnter: c, onAfterEnter: d, onEnterCancelled: h, onBeforeLeave: p, onLeave: g, onAfterLeave: y, onLeaveCancelled: x, onBeforeAppear: S, onAppear: k, onAfterAppear: A, onAppearCancelled: C } = e
        , m = String(t.key)
        , b = fk(n, t)
        , w = (M, E) => {
            M && Ti(M, r, 9, E)
        }
        , T = (M, E) => {
            const N = E[1];
            w(M, E),
                Re(M) ? M.every(j => j.length <= 1) && N() : M.length <= 1 && N()
        }
        , O = {
            mode: o,
            persisted: a,
            beforeEnter(M) {
                let E = l;
                if (!n.isMounted)
                    if (s)
                        E = S || l;
                    else
                        return;
                M[so] && M[so](!0);
                const N = b[m];
                N && vi(t, N) && N.el[so] && N.el[so](),
                    w(E, [M])
            },
            enter(M) {
                let E = c
                    , N = d
                    , j = h;
                if (!n.isMounted)
                    if (s)
                        E = k || c,
                            N = A || d,
                            j = C || h;
                    else
                        return;
                let z = !1;
                const V = M[Af] = W => {
                    z || (z = !0,
                        W ? w(j, [M]) : w(N, [M]),
                        O.delayedLeave && O.delayedLeave(),
                        M[Af] = void 0)
                }
                    ;
                E ? T(E, [M, V]) : V()
            },
            leave(M, E) {
                const N = String(t.key);
                if (M[Af] && M[Af](!0),
                    n.isUnmounting)
                    return E();
                w(p, [M]);
                let j = !1;
                const z = M[so] = V => {
                    j || (j = !0,
                        E(),
                        V ? w(x, [M]) : w(y, [M]),
                        M[so] = void 0,
                        b[N] === t && delete b[N])
                }
                    ;
                b[N] = t,
                    g ? T(g, [M, z]) : z()
            },
            clone(M) {
                const E = Ec(M, e, n, r, i);
                return i && i(E),
                    E
            }
        };
    return O
}
function r0(t) {
    if (fd(t))
        return t = ui(t),
            t.children = null,
            t
}
function tx(t) {
    if (!fd(t))
        return ok(t.type) && t.children ? dk(t.children) : t;
    const { shapeFlag: e, children: n } = t;
    if (n) {
        if (e & 16)
            return n[0];
        if (e & 32 && We(n.default))
            return n.default()
    }
}
function Oo(t, e) {
    t.shapeFlag & 6 && t.component ? (t.transition = e,
        Oo(t.component.subTree, e)) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent),
            t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
}
function Uy(t, e = !1, n) {
    let r = []
        , i = 0;
    for (let s = 0; s < t.length; s++) {
        let o = t[s];
        const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
        o.type === Rt ? (o.patchFlag & 128 && i++,
            r = r.concat(Uy(o.children, e, a))) : (e || o.type !== cn) && r.push(a != null ? ui(o, {
                key: a
            }) : o)
    }
    if (i > 1)
        for (let s = 0; s < r.length; s++)
            r[s].patchFlag = -2;
    return r
}
/*! #__NO_SIDE_EFFECTS__ */
function je(t, e) {
    return We(t) ? (() => Kt({
        name: t.name
    }, e, {
        setup: t
    }))() : t
}
function e1() {
    const t = pn();
    if (t)
        return (t.appContext.config.idPrefix || "v") + "-" + t.ids[0] + t.ids[1]++
}
function Ky(t) {
    t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0]
}
function rQ(t) {
    const e = pn()
        , n = Wa(null);
    if (e) {
        const i = e.refs === kt ? e.refs = {} : e.refs;
        Object.defineProperty(i, t, {
            enumerable: !0,
            get: () => n.value,
            set: s => n.value = s
        })
    }
    return n
}
function Ph(t, e, n, r, i = !1) {
    if (Re(t)) {
        t.forEach((y, x) => Ph(y, e && (Re(e) ? e[x] : e), n, r, i));
        return
    }
    if (_o(r) && !i)
        return;
    const s = r.shapeFlag & 4 ? gd(r.component) : r.el
        , o = i ? null : s
        , { i: a, r: l } = t
        , c = e && e.r
        , d = a.refs === kt ? a.refs = {} : a.refs
        , h = a.setupState
        , p = it(h)
        , g = h === kt ? () => !1 : y => Ot(p, y);
    if (c != null && c !== l && (qt(c) ? (d[c] = null,
        g(c) && (h[c] = null)) : Yt(c) && (c.value = null)),
        We(l))
        dd(l, a, 12, [o, d]);
    else {
        const y = qt(l)
            , x = Yt(l);
        if (y || x) {
            const S = () => {
                if (t.f) {
                    const k = y ? g(l) ? h[l] : d[l] : l.value;
                    i ? Re(k) && Ry(k, s) : Re(k) ? k.includes(s) || k.push(s) : y ? (d[l] = [s],
                        g(l) && (h[l] = d[l])) : (l.value = [s],
                            t.k && (d[t.k] = l.value))
                } else
                    y ? (d[l] = o,
                        g(l) && (h[l] = o)) : x && (l.value = o,
                            t.k && (d[t.k] = o))
            }
                ;
            o ? (S.id = -1,
                kn(S, n)) : S()
        }
    }
}
let nx = !1;
const fl = () => {
    nx || (console.error("Hydration completed but contains mismatches."),
        nx = !0)
}
    , Z4 = t => t.namespaceURI.includes("svg") && t.tagName !== "foreignObject"
    , Y4 = t => t.namespaceURI.includes("MathML")
    , Of = t => {
        if (t.nodeType === 1) {
            if (Z4(t))
                return "svg";
            if (Y4(t))
                return "mathml"
        }
    }
    , Al = t => t.nodeType === 8;
function X4(t) {
    const { mt: e, p: n, o: { patchProp: r, createText: i, nextSibling: s, parentNode: o, remove: a, insert: l, createComment: c } } = t
        , d = (C, m) => {
            if (!m.hasChildNodes()) {
                n(null, C, m),
                    Mh(),
                    m._vnode = C;
                return
            }
            h(m.firstChild, C, null, null, null),
                Mh(),
                m._vnode = C
        }
        , h = (C, m, b, w, T, O = !1) => {
            O = O || !!m.dynamicChildren;
            const M = Al(C) && C.data === "["
                , E = () => x(C, m, b, w, T, M)
                , { type: N, ref: j, shapeFlag: z, patchFlag: V } = m;
            let W = C.nodeType;
            m.el = C,
                V === -2 && (O = !1,
                    m.dynamicChildren = null);
            let P = null;
            switch (N) {
                case va:
                    W !== 3 ? m.children === "" ? (l(m.el = i(""), o(C), C),
                        P = C) : P = E() : (C.data !== m.children && (fl(),
                            C.data = m.children),
                            P = s(C));
                    break;
                case cn:
                    A(C) ? (P = s(C),
                        k(m.el = C.content.firstChild, C, b)) : W !== 8 || M ? P = E() : P = s(C);
                    break;
                case Bl:
                    if (M && (C = s(C),
                        W = C.nodeType),
                        W === 1 || W === 3) {
                        P = C;
                        const F = !m.children.length;
                        for (let K = 0; K < m.staticCount; K++)
                            F && (m.children += P.nodeType === 1 ? P.outerHTML : P.data),
                                K === m.staticCount - 1 && (m.anchor = P),
                                P = s(P);
                        return M ? s(P) : P
                    } else
                        E();
                    break;
                case Rt:
                    M ? P = y(C, m, b, w, T, O) : P = E();
                    break;
                default:
                    if (z & 1)
                        (W !== 1 || m.type.toLowerCase() !== C.tagName.toLowerCase()) && !A(C) ? P = E() : P = p(C, m, b, w, T, O);
                    else if (z & 6) {
                        m.slotScopeIds = T;
                        const F = o(C);
                        if (M ? P = S(C) : Al(C) && C.data === "teleport start" ? P = S(C, C.data, "teleport end") : P = s(C),
                            e(m, F, null, b, w, Of(F), O),
                            _o(m)) {
                            let K;
                            M ? (K = $e(Rt),
                                K.anchor = P ? P.previousSibling : F.lastChild) : K = C.nodeType === 3 ? Pa("") : $e("div"),
                                K.el = C,
                                m.component.subTree = K
                        }
                    } else
                        z & 64 ? W !== 8 ? P = E() : P = m.type.hydrate(C, m, b, w, T, O, t, g) : z & 128 && (P = m.type.hydrate(C, m, b, w, Of(o(C)), T, O, t, h))
            }
            return j != null && Ph(j, null, w, m),
                P
        }
        , p = (C, m, b, w, T, O) => {
            O = O || !!m.dynamicChildren;
            const { type: M, props: E, patchFlag: N, shapeFlag: j, dirs: z, transition: V } = m
                , W = M === "input" || M === "option";
            if (W || N !== -1) {
                z && Hi(m, null, b, "created");
                let P = !1;
                if (A(C)) {
                    P = Ok(w, V) && b && b.vnode.props && b.vnode.props.appear;
                    const K = C.content.firstChild;
                    P && V.beforeEnter(K),
                        k(K, C, b),
                        m.el = C = K
                }
                if (j & 16 && !(E && (E.innerHTML || E.textContent))) {
                    let K = g(C.firstChild, m, C, b, w, T, O);
                    for (; K;) {
                        Mf(C, 1) || fl();
                        const re = K;
                        K = K.nextSibling,
                            a(re)
                    }
                } else if (j & 8) {
                    let K = m.children;
                    K[0] === `
` && (C.tagName === "PRE" || C.tagName === "TEXTAREA") && (K = K.slice(1)),
                        C.textContent !== K && (Mf(C, 0) || fl(),
                            C.textContent = m.children)
                }
                if (E) {
                    if (W || !O || N & 48) {
                        const K = C.tagName.includes("-");
                        for (const re in E)
                            (W && (re.endsWith("value") || re === "indeterminate") || ld(re) && !Il(re) || re[0] === "." || K) && r(C, re, null, E[re], void 0, b)
                    } else if (E.onClick)
                        r(C, "onClick", null, E.onClick, void 0, b);
                    else if (N & 4 && Ui(E.style))
                        for (const K in E.style)
                            E.style[K]
                }
                let F;
                (F = E && E.onVnodeBeforeMount) && wr(F, b, m),
                    z && Hi(m, null, b, "beforeMount"),
                    ((F = E && E.onVnodeMounted) || z || P) && Dk(() => {
                        F && wr(F, b, m),
                            P && V.enter(C),
                            z && Hi(m, null, b, "mounted")
                    }
                        , w)
            }
            return C.nextSibling
        }
        , g = (C, m, b, w, T, O, M) => {
            M = M || !!m.dynamicChildren;
            const E = m.children
                , N = E.length;
            for (let j = 0; j < N; j++) {
                const z = M ? E[j] : E[j] = _r(E[j])
                    , V = z.type === va;
                C ? (V && !M && j + 1 < N && _r(E[j + 1]).type === va && (l(i(C.data.slice(z.children.length)), b, s(C)),
                    C.data = z.children),
                    C = h(C, z, w, T, O, M)) : V && !z.children ? l(z.el = i(""), b) : (Mf(b, 1) || fl(),
                        n(null, z, b, null, w, T, Of(b), O))
            }
            return C
        }
        , y = (C, m, b, w, T, O) => {
            const { slotScopeIds: M } = m;
            M && (T = T ? T.concat(M) : M);
            const E = o(C)
                , N = g(s(C), m, E, b, w, T, O);
            return N && Al(N) && N.data === "]" ? s(m.anchor = N) : (fl(),
                l(m.anchor = c("]"), E, N),
                N)
        }
        , x = (C, m, b, w, T, O) => {
            if (Mf(C.parentElement, 1) || fl(),
                m.el = null,
                O) {
                const N = S(C);
                for (; ;) {
                    const j = s(C);
                    if (j && j !== N)
                        a(j);
                    else
                        break
                }
            }
            const M = s(C)
                , E = o(C);
            return a(C),
                n(null, m, E, M, b, w, Of(E), T),
                M
        }
        , S = (C, m = "[", b = "]") => {
            let w = 0;
            for (; C;)
                if (C = s(C),
                    C && Al(C) && (C.data === m && w++,
                        C.data === b)) {
                    if (w === 0)
                        return s(C);
                    w--
                }
            return C
        }
        , k = (C, m, b) => {
            const w = m.parentNode;
            w && w.replaceChild(C, m);
            let T = b;
            for (; T;)
                T.vnode.el === m && (T.vnode.el = T.subTree.el = C),
                    T = T.parent
        }
        , A = C => C.nodeType === 1 && C.tagName === "TEMPLATE";
    return [d, h]
}
const rx = "data-allow-mismatch"
    , Q4 = {
        0: "text",
        1: "children",
        2: "class",
        3: "style",
        4: "attribute"
    };
function Mf(t, e) {
    if (e === 0 || e === 1)
        for (; t && !t.hasAttribute(rx);)
            t = t.parentElement;
    const n = t && t.getAttribute(rx);
    if (n == null)
        return !1;
    if (n === "")
        return !0;
    {
        const r = n.split(",");
        return e === 0 && r.includes("children") ? !0 : n.split(",").includes(Q4[e])
    }
}
const iQ = (t = 1e4) => e => {
    const n = requestIdleCallback(e, {
        timeout: t
    });
    return () => cancelIdleCallback(n)
}
    , sQ = t => (e, n) => {
        const r = new IntersectionObserver(i => {
            for (const s of i)
                if (s.isIntersecting) {
                    r.disconnect(),
                        e();
                    break
                }
        }
            , t);
        return n(i => r.observe(i)),
            () => r.disconnect()
    }
    , oQ = t => e => {
        if (t) {
            const n = matchMedia(t);
            if (n.matches)
                e();
            else
                return n.addEventListener("change", e, {
                    once: !0
                }),
                    () => n.removeEventListener("change", e)
        }
    }
    , aQ = (t = []) => (e, n) => {
        qt(t) && (t = [t]);
        let r = !1;
        const i = o => {
            r || (r = !0,
                s(),
                e(),
                o.target.dispatchEvent(new o.constructor(o.type, o)))
        }
            , s = () => {
                n(o => {
                    for (const a of t)
                        o.removeEventListener(a, i)
                }
                )
            }
            ;
        return n(o => {
            for (const a of t)
                o.addEventListener(a, i, {
                    once: !0
                })
        }
        ),
            s
    }
    ;
function e5(t, e) {
    if (Al(t) && t.data === "[") {
        let n = 1
            , r = t.nextSibling;
        for (; r;) {
            if (r.nodeType === 1)
                e(r);
            else if (Al(r))
                if (r.data === "]") {
                    if (--n === 0)
                        break
                } else
                    r.data === "[" && n++;
            r = r.nextSibling
        }
    } else
        e(t)
}
const _o = t => !!t.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
function lQ(t) {
    We(t) && (t = {
        loader: t
    });
    const { loader: e, loadingComponent: n, errorComponent: r, delay: i = 200, hydrate: s, timeout: o, suspensible: a = !0, onError: l } = t;
    let c = null, d, h = 0;
    const p = () => (h++,
        c = null,
        g())
        , g = () => {
            let y;
            return c || (y = c = e().catch(x => {
                if (x = x instanceof Error ? x : new Error(String(x)),
                    l)
                    return new Promise((S, k) => {
                        l(x, () => S(p()), () => k(x), h + 1)
                    }
                    );
                throw x
            }
            ).then(x => y !== c && c ? c : (x && (x.__esModule || x[Symbol.toStringTag] === "Module") && (x = x.default),
                d = x,
                x)))
        }
        ;
    return je({
        name: "AsyncComponentWrapper",
        __asyncLoader: g,
        __asyncHydrate(y, x, S) {
            const k = s ? () => {
                const A = s(S, C => e5(y, C));
                A && (x.bum || (x.bum = [])).push(A)
            }
                : S;
            d ? k() : g().then(() => !x.isUnmounted && k())
        },
        get __asyncResolved() {
            return d
        },
        setup() {
            const y = vn;
            if (Ky(y),
                d)
                return () => i0(d, y);
            const x = C => {
                c = null,
                    fu(C, y, 13, !r)
            }
                ;
            if (a && y.suspense || md)
                return g().then(C => () => i0(C, y)).catch(C => (x(C),
                    () => r ? $e(r, {
                        error: C
                    }) : null));
            const S = ce(!1)
                , k = ce()
                , A = ce(!!i);
            return i && setTimeout(() => {
                A.value = !1
            }
                , i),
                o != null && setTimeout(() => {
                    if (!S.value && !k.value) {
                        const C = new Error(`Async component timed out after ${o}ms.`);
                        x(C),
                            k.value = C
                    }
                }
                    , o),
                g().then(() => {
                    S.value = !0,
                        y.parent && fd(y.parent.vnode) && y.parent.update()
                }
                ).catch(C => {
                    x(C),
                        k.value = C
                }
                ),
                () => {
                    if (S.value && d)
                        return i0(d, y);
                    if (k.value && r)
                        return $e(r, {
                            error: k.value
                        });
                    if (n && !A.value)
                        return $e(n)
                }
        }
    })
}
function i0(t, e) {
    const { ref: n, props: r, children: i, ce: s } = e.vnode
        , o = $e(t, r, i);
    return o.ref = n,
        o.ce = s,
        delete e.vnode.ce,
        o
}
const fd = t => t.type.__isKeepAlive
    , t5 = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: {
            include: [String, RegExp, Array],
            exclude: [String, RegExp, Array],
            max: [String, Number]
        },
        setup(t, { slots: e }) {
            const n = pn()
                , r = n.ctx;
            if (!r.renderer)
                return () => {
                    const A = e.default && e.default();
                    return A && A.length === 1 ? A[0] : A
                }
                    ;
            const i = new Map
                , s = new Set;
            let o = null;
            const a = n.suspense
                , { renderer: { p: l, m: c, um: d, o: { createElement: h } } } = r
                , p = h("div");
            r.activate = (A, C, m, b, w) => {
                const T = A.component;
                c(A, C, m, 0, a),
                    l(T.vnode, A, C, m, T, a, b, A.slotScopeIds, w),
                    kn(() => {
                        T.isDeactivated = !1,
                            T.a && Ll(T.a);
                        const O = A.props && A.props.onVnodeMounted;
                        O && wr(O, T.parent, A)
                    }
                        , a)
            }
                ,
                r.deactivate = A => {
                    const C = A.component;
                    Ih(C.m),
                        Ih(C.a),
                        c(A, p, null, 1, a),
                        kn(() => {
                            C.da && Ll(C.da);
                            const m = A.props && A.props.onVnodeUnmounted;
                            m && wr(m, C.parent, A),
                                C.isDeactivated = !0
                        }
                            , a)
                }
                ;
            function g(A) {
                s0(A),
                    d(A, n, a, !0)
            }
            function y(A) {
                i.forEach((C, m) => {
                    const b = d1(C.type);
                    b && !A(b) && x(m)
                }
                )
            }
            function x(A) {
                const C = i.get(A);
                C && (!o || !vi(C, o)) ? g(C) : o && s0(o),
                    i.delete(A),
                    s.delete(A)
            }
            vt(() => [t.include, t.exclude], ([A, C]) => {
                A && y(m => Uu(A, m)),
                    C && y(m => !Uu(C, m))
            }
                , {
                    flush: "post",
                    deep: !0
                });
            let S = null;
            const k = () => {
                S != null && (Lh(n.subTree.type) ? kn(() => {
                    i.set(S, Rf(n.subTree))
                }
                    , n.subTree.suspense) : i.set(S, Rf(n.subTree)))
            }
                ;
            return Nt(k),
                qy(k),
                Gy(() => {
                    i.forEach(A => {
                        const { subTree: C, suspense: m } = n
                            , b = Rf(C);
                        if (A.type === b.type && A.key === b.key) {
                            s0(b);
                            const w = b.component.da;
                            w && kn(w, m);
                            return
                        }
                        g(A)
                    }
                    )
                }
                ),
                () => {
                    if (S = null,
                        !e.default)
                        return o = null;
                    const A = e.default()
                        , C = A[0];
                    if (A.length > 1)
                        return o = null,
                            A;
                    if (!Ra(C) || !(C.shapeFlag & 4) && !(C.shapeFlag & 128))
                        return o = null,
                            C;
                    let m = Rf(C);
                    if (m.type === cn)
                        return o = null,
                            m;
                    const b = m.type
                        , w = d1(_o(m) ? m.type.__asyncResolved || {} : b)
                        , { include: T, exclude: O, max: M } = t;
                    if (T && (!w || !Uu(T, w)) || O && w && Uu(O, w))
                        return m.shapeFlag &= -257,
                            o = m,
                            C;
                    const E = m.key == null ? b : m.key
                        , N = i.get(E);
                    return m.el && (m = ui(m),
                        C.shapeFlag & 128 && (C.ssContent = m)),
                        S = E,
                        N ? (m.el = N.el,
                            m.component = N.component,
                            m.transition && Oo(m, m.transition),
                            m.shapeFlag |= 512,
                            s.delete(E),
                            s.add(E)) : (s.add(E),
                                M && s.size > parseInt(M, 10) && x(s.values().next().value)),
                        m.shapeFlag |= 256,
                        o = m,
                        Lh(C.type) ? C : m
                }
        }
    }
    , uQ = t5;
function Uu(t, e) {
    return Re(t) ? t.some(n => Uu(n, e)) : qt(t) ? t.split(",").includes(e) : ZI(t) ? (t.lastIndex = 0,
        t.test(e)) : !1
}
function n5(t, e) {
    hk(t, "a", e)
}
function r5(t, e) {
    hk(t, "da", e)
}
function hk(t, e, n = vn) {
    const r = t.__wdc || (t.__wdc = () => {
        let i = n;
        for (; i;) {
            if (i.isDeactivated)
                return;
            i = i.parent
        }
        return t()
    }
    );
    if (sm(e, r, n),
        n) {
        let i = n.parent;
        for (; i && i.parent;)
            fd(i.parent.vnode) && i5(r, e, n, i),
                i = i.parent
    }
}
function i5(t, e, n, r) {
    const i = sm(e, t, r, !0);
    xn(() => {
        Ry(r[e], i)
    }
        , n)
}
function s0(t) {
    t.shapeFlag &= -257,
        t.shapeFlag &= -513
}
function Rf(t) {
    return t.shapeFlag & 128 ? t.ssContent : t
}
function sm(t, e, n = vn, r = !1) {
    if (n) {
        const i = n[t] || (n[t] = [])
            , s = e.__weh || (e.__weh = (...o) => {
                Wo();
                const a = Na(n)
                    , l = Ti(e, n, t, o);
                return a(),
                    Uo(),
                    l
            }
            );
        return r ? i.unshift(s) : i.push(s),
            s
    }
}
const $s = t => (e, n = vn) => {
    (!md || t === "sp") && sm(t, (...r) => e(...r), n)
}
    , pk = $s("bm")
    , Nt = $s("m")
    , s5 = $s("bu")
    , qy = $s("u")
    , Gy = $s("bum")
    , xn = $s("um")
    , o5 = $s("sp")
    , a5 = $s("rtg")
    , l5 = $s("rtc");
function u5(t, e = vn) {
    sm("ec", t, e)
}
const Jy = "components"
    , c5 = "directives";
function Cn(t, e) {
    return Zy(Jy, t, !0, e) || t
}
const mk = Symbol.for("v-ndc");
function d5(t) {
    return qt(t) ? Zy(Jy, t, !1) || t : t || mk
}
function cQ(t) {
    return Zy(c5, t)
}
function Zy(t, e, n = !0, r = !1) {
    const i = bn || vn;
    if (i) {
        const s = i.type;
        if (t === Jy) {
            const a = d1(s, !1);
            if (a && (a === e || a === Fn(e) || a === Zp(Fn(e))))
                return s
        }
        const o = ix(i[t] || s[t], e) || ix(i.appContext[t], e);
        return !o && r ? s : o
    }
}
function ix(t, e) {
    return t && (t[e] || t[Fn(e)] || t[Zp(Fn(e))])
}
function Oa(t, e, n, r) {
    let i;
    const s = n && n[r]
        , o = Re(t);
    if (o || qt(t)) {
        const a = o && Ui(t);
        let l = !1;
        a && (l = !si(t),
            t = Qp(t)),
            i = new Array(t.length);
        for (let c = 0, d = t.length; c < d; c++)
            i[c] = e(l ? Gn(t[c]) : t[c], c, void 0, s && s[c])
    } else if (typeof t == "number") {
        i = new Array(t);
        for (let a = 0; a < t; a++)
            i[a] = e(a + 1, a, void 0, s && s[a])
    } else if (jt(t))
        if (t[Symbol.iterator])
            i = Array.from(t, (a, l) => e(a, l, void 0, s && s[l]));
        else {
            const a = Object.keys(t);
            i = new Array(a.length);
            for (let l = 0, c = a.length; l < c; l++) {
                const d = a[l];
                i[l] = e(t[d], d, l, s && s[l])
            }
        }
    else
        i = [];
    return n && (n[r] = i),
        i
}
function o0(t, e) {
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (Re(r))
            for (let i = 0; i < r.length; i++)
                t[r[i].name] = r[i].fn;
        else
            r && (t[r.name] = r.key ? (...i) => {
                const s = r.fn(...i);
                return s && (s.key = r.key),
                    s
            }
                : r.fn)
    }
    return t
}
function Ue(t, e, n = {}, r, i) {
    if (bn.ce || bn.parent && _o(bn.parent) && bn.parent.ce)
        return e !== "default" && (n.name = e),
            oe(),
            gt(Rt, null, [$e("slot", n, r && r())], 64);
    let s = t[e];
    s && s._c && (s._d = !1),
        oe();
    const o = s && Yy(s(n))
        , a = gt(Rt, {
            key: (n.key || o && o.key || `_${e}`) + (!o && r ? "_fb" : "")
        }, o || (r ? r() : []), o && t._ === 1 ? 64 : -2);
    return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]),
        s && s._c && (s._d = !0),
        a
}
function Yy(t) {
    return t.some(e => Ra(e) ? !(e.type === cn || e.type === Rt && !Yy(e.children)) : !0) ? t : null
}
function f5(t, e) {
    const n = {};
    for (const r in t)
        n[e && /[A-Z]/.test(r) ? `on:${r}` : ec(r)] = t[r];
    return n
}
const t1 = t => t ? Fk(t) ? gd(t) : t1(t.parent) : null
    , rc = Kt(Object.create(null), {
        $: t => t,
        $el: t => t.vnode.el,
        $data: t => t.data,
        $props: t => t.props,
        $attrs: t => t.attrs,
        $slots: t => t.slots,
        $refs: t => t.refs,
        $parent: t => t1(t.parent),
        $root: t => t1(t.root),
        $host: t => t.ce,
        $emit: t => t.emit,
        $options: t => Xy(t),
        $forceUpdate: t => t.f || (t.f = () => {
            Wy(t.update)
        }
        ),
        $nextTick: t => t.n || (t.n = un.bind(t.proxy)),
        $watch: t => L5.bind(t)
    })
    , a0 = (t, e) => t !== kt && !t.__isScriptSetup && Ot(t, e)
    , n1 = {
        get({ _: t }, e) {
            if (e === "__v_skip")
                return !0;
            const { ctx: n, setupState: r, data: i, props: s, accessCache: o, type: a, appContext: l } = t;
            let c;
            if (e[0] !== "$") {
                const g = o[e];
                if (g !== void 0)
                    switch (g) {
                        case 1:
                            return r[e];
                        case 2:
                            return i[e];
                        case 4:
                            return n[e];
                        case 3:
                            return s[e]
                    }
                else {
                    if (a0(r, e))
                        return o[e] = 1,
                            r[e];
                    if (i !== kt && Ot(i, e))
                        return o[e] = 2,
                            i[e];
                    if ((c = t.propsOptions[0]) && Ot(c, e))
                        return o[e] = 3,
                            s[e];
                    if (n !== kt && Ot(n, e))
                        return o[e] = 4,
                            n[e];
                    r1 && (o[e] = 0)
                }
            }
            const d = rc[e];
            let h, p;
            if (d)
                return e === "$attrs" && Qn(t.attrs, "get", ""),
                    d(t);
            if ((h = a.__cssModules) && (h = h[e]))
                return h;
            if (n !== kt && Ot(n, e))
                return o[e] = 4,
                    n[e];
            if (p = l.config.globalProperties,
                Ot(p, e))
                return p[e]
        },
        set({ _: t }, e, n) {
            const { data: r, setupState: i, ctx: s } = t;
            return a0(i, e) ? (i[e] = n,
                !0) : r !== kt && Ot(r, e) ? (r[e] = n,
                    !0) : Ot(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (s[e] = n,
                        !0)
        },
        has({ _: { data: t, setupState: e, accessCache: n, ctx: r, appContext: i, propsOptions: s } }, o) {
            let a;
            return !!n[o] || t !== kt && Ot(t, o) || a0(e, o) || (a = s[0]) && Ot(a, o) || Ot(r, o) || Ot(rc, o) || Ot(i.config.globalProperties, o)
        },
        defineProperty(t, e, n) {
            return n.get != null ? t._.accessCache[e] = 0 : Ot(n, "value") && this.set(t, e, n.value, null),
                Reflect.defineProperty(t, e, n)
        }
    }
    , h5 = Kt({}, n1, {
        get(t, e) {
            if (e !== Symbol.unscopables)
                return n1.get(t, e, t)
        },
        has(t, e) {
            return e[0] !== "_" && !t4(e)
        }
    });
function dQ() {
    return null
}
function fQ() {
    return null
}
function hQ(t) { }
function pQ(t) { }
function mQ() {
    return null
}
function gQ() { }
function yQ(t, e) {
    return null
}
function om() {
    return gk().slots
}
function hd() {
    return gk().attrs
}
function gk() {
    const t = pn();
    return t.setupContext || (t.setupContext = Wk(t))
}
function Tc(t) {
    return Re(t) ? t.reduce((e, n) => (e[n] = null,
        e), {}) : t
}
function p5(t, e) {
    const n = Tc(t);
    for (const r in e) {
        if (r.startsWith("__skip"))
            continue;
        let i = n[r];
        i ? Re(i) || We(i) ? i = n[r] = {
            type: i,
            default: e[r]
        } : i.default = e[r] : i === null && (i = n[r] = {
            default: e[r]
        }),
            i && e[`__skip_${r}`] && (i.skipFactory = !0)
    }
    return n
}
function vQ(t, e) {
    return !t || !e ? t || e : Re(t) && Re(e) ? t.concat(e) : Kt({}, Tc(t), Tc(e))
}
function bQ(t, e) {
    const n = {};
    for (const r in t)
        e.includes(r) || Object.defineProperty(n, r, {
            enumerable: !0,
            get: () => t[r]
        });
    return n
}
function wQ(t) {
    const e = pn();
    let n = t();
    return l1(),
        Py(n) && (n = n.catch(r => {
            throw Na(e),
            r
        }
        )),
        [n, () => Na(e)]
}
let r1 = !0;
function m5(t) {
    const e = Xy(t)
        , n = t.proxy
        , r = t.ctx;
    r1 = !1,
        e.beforeCreate && sx(e.beforeCreate, t, "bc");
    const { data: i, computed: s, methods: o, watch: a, provide: l, inject: c, created: d, beforeMount: h, mounted: p, beforeUpdate: g, updated: y, activated: x, deactivated: S, beforeDestroy: k, beforeUnmount: A, destroyed: C, unmounted: m, render: b, renderTracked: w, renderTriggered: T, errorCaptured: O, serverPrefetch: M, expose: E, inheritAttrs: N, components: j, directives: z, filters: V } = e;
    if (c && g5(c, r, null),
        o)
        for (const F in o) {
            const K = o[F];
            We(K) && (r[F] = K.bind(n))
        }
    if (i) {
        const F = i.call(n, n);
        jt(F) && (t.data = wn(F))
    }
    if (r1 = !0,
        s)
        for (const F in s) {
            const K = s[F]
                , re = We(K) ? K.bind(n, n) : We(K.get) ? K.get.bind(n, n) : ii
                , Te = !We(K) && We(K.set) ? K.set.bind(n) : ii
                , ee = G({
                    get: re,
                    set: Te
                });
            Object.defineProperty(r, F, {
                enumerable: !0,
                configurable: !0,
                get: () => ee.value,
                set: Se => ee.value = Se
            })
        }
    if (a)
        for (const F in a)
            yk(a[F], r, n, F);
    if (l) {
        const F = We(l) ? l.call(n) : l;
        Reflect.ownKeys(F).forEach(K => {
            Hn(K, F[K])
        }
        )
    }
    d && sx(d, t, "c");
    function P(F, K) {
        Re(K) ? K.forEach(re => F(re.bind(n))) : K && F(K.bind(n))
    }
    if (P(pk, h),
        P(Nt, p),
        P(s5, g),
        P(qy, y),
        P(n5, x),
        P(r5, S),
        P(u5, O),
        P(l5, w),
        P(a5, T),
        P(Gy, A),
        P(xn, m),
        P(o5, M),
        Re(E))
        if (E.length) {
            const F = t.exposed || (t.exposed = {});
            E.forEach(K => {
                Object.defineProperty(F, K, {
                    get: () => n[K],
                    set: re => n[K] = re
                })
            }
            )
        } else
            t.exposed || (t.exposed = {});
    b && t.render === ii && (t.render = b),
        N != null && (t.inheritAttrs = N),
        j && (t.components = j),
        z && (t.directives = z),
        M && Ky(t)
}
function g5(t, e, n = ii) {
    Re(t) && (t = i1(t));
    for (const r in t) {
        const i = t[r];
        let s;
        jt(i) ? "default" in i ? s = Dt(i.from || r, i.default, !0) : s = Dt(i.from || r) : s = Dt(i),
            Yt(s) ? Object.defineProperty(e, r, {
                enumerable: !0,
                configurable: !0,
                get: () => s.value,
                set: o => s.value = o
            }) : e[r] = s
    }
}
function sx(t, e, n) {
    Ti(Re(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
}
function yk(t, e, n, r) {
    let i = r.includes(".") ? Pk(n, r) : () => n[r];
    if (qt(t)) {
        const s = e[t];
        We(s) && vt(i, s)
    } else if (We(t))
        vt(i, t.bind(n));
    else if (jt(t))
        if (Re(t))
            t.forEach(s => yk(s, e, n, r));
        else {
            const s = We(t.handler) ? t.handler.bind(n) : e[t.handler];
            We(s) && vt(i, s, t)
        }
}
function Xy(t) {
    const e = t.type
        , { mixins: n, extends: r } = e
        , { mixins: i, optionsCache: s, config: { optionMergeStrategies: o } } = t.appContext
        , a = s.get(e);
    let l;
    return a ? l = a : !i.length && !n && !r ? l = e : (l = {},
        i.length && i.forEach(c => Nh(l, c, o, !0)),
        Nh(l, e, o)),
        jt(e) && s.set(e, l),
        l
}
function Nh(t, e, n, r = !1) {
    const { mixins: i, extends: s } = e;
    s && Nh(t, s, n, !0),
        i && i.forEach(o => Nh(t, o, n, !0));
    for (const o in e)
        if (!(r && o === "expose")) {
            const a = y5[o] || n && n[o];
            t[o] = a ? a(t[o], e[o]) : e[o]
        }
    return t
}
const y5 = {
    data: ox,
    props: ax,
    emits: ax,
    methods: Ku,
    computed: Ku,
    beforeCreate: ar,
    created: ar,
    beforeMount: ar,
    mounted: ar,
    beforeUpdate: ar,
    updated: ar,
    beforeDestroy: ar,
    beforeUnmount: ar,
    destroyed: ar,
    unmounted: ar,
    activated: ar,
    deactivated: ar,
    errorCaptured: ar,
    serverPrefetch: ar,
    components: Ku,
    directives: Ku,
    watch: b5,
    provide: ox,
    inject: v5
};
function ox(t, e) {
    return e ? t ? function () {
        return Kt(We(t) ? t.call(this, this) : t, We(e) ? e.call(this, this) : e)
    }
        : e : t
}
function v5(t, e) {
    return Ku(i1(t), i1(e))
}
function i1(t) {
    if (Re(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++)
            e[t[n]] = t[n];
        return e
    }
    return t
}
function ar(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}
function Ku(t, e) {
    return t ? Kt(Object.create(null), t, e) : e
}
function ax(t, e) {
    return t ? Re(t) && Re(e) ? [...new Set([...t, ...e])] : Kt(Object.create(null), Tc(t), Tc(e ?? {})) : e
}
function b5(t, e) {
    if (!t)
        return e;
    if (!e)
        return t;
    const n = Kt(Object.create(null), t);
    for (const r in e)
        n[r] = ar(t[r], e[r]);
    return n
}
function vk() {
    return {
        app: null,
        config: {
            isNativeTag: GI,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let w5 = 0;
function x5(t, e) {
    return function (r, i = null) {
        We(r) || (r = Kt({}, r)),
            i != null && !jt(i) && (i = null);
        const s = vk()
            , o = new WeakSet
            , a = [];
        let l = !1;
        const c = s.app = {
            _uid: w5++,
            _component: r,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: eL,
            get config() {
                return s.config
            },
            set config(d) { },
            use(d, ...h) {
                return o.has(d) || (d && We(d.install) ? (o.add(d),
                    d.install(c, ...h)) : We(d) && (o.add(d),
                        d(c, ...h))),
                    c
            },
            mixin(d) {
                return s.mixins.includes(d) || s.mixins.push(d),
                    c
            },
            component(d, h) {
                return h ? (s.components[d] = h,
                    c) : s.components[d]
            },
            directive(d, h) {
                return h ? (s.directives[d] = h,
                    c) : s.directives[d]
            },
            mount(d, h, p) {
                if (!l) {
                    const g = c._ceVNode || $e(r, i);
                    return g.appContext = s,
                        p === !0 ? p = "svg" : p === !1 && (p = void 0),
                        h && e ? e(g, d) : t(g, d, p),
                        l = !0,
                        c._container = d,
                        d.__vue_app__ = c,
                        gd(g.component)
                }
            },
            onUnmount(d) {
                a.push(d)
            },
            unmount() {
                l && (Ti(a, c._instance, 16),
                    t(null, c._container),
                    delete c._container.__vue_app__)
            },
            provide(d, h) {
                return s.provides[d] = h,
                    c
            },
            runWithContext(d) {
                const h = ya;
                ya = c;
                try {
                    return d()
                } finally {
                    ya = h
                }
            }
        };
        return c
    }
}
let ya = null;
function Hn(t, e) {
    if (vn) {
        let n = vn.provides;
        const r = vn.parent && vn.parent.provides;
        r === n && (n = vn.provides = Object.create(r)),
            n[t] = e
    }
}
function Dt(t, e, n = !1) {
    const r = vn || bn;
    if (r || ya) {
        const i = ya ? ya._context.provides : r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
        if (i && t in i)
            return i[t];
        if (arguments.length > 1)
            return n && We(e) ? e.call(r && r.proxy) : e
    }
}
function _5() {
    return !!(vn || bn || ya)
}
const bk = {}
    , wk = () => Object.create(bk)
    , xk = t => Object.getPrototypeOf(t) === bk;
function S5(t, e, n, r = !1) {
    const i = {}
        , s = wk();
    t.propsDefaults = Object.create(null),
        _k(t, e, i, s);
    for (const o in t.propsOptions[0])
        o in i || (i[o] = void 0);
    n ? t.props = r ? i : GS(i) : t.type.props ? t.props = i : t.props = s,
        t.attrs = s
}
function k5(t, e, n, r) {
    const { props: i, attrs: s, vnode: { patchFlag: o } } = t
        , a = it(i)
        , [l] = t.propsOptions;
    let c = !1;
    if ((r || o > 0) && !(o & 16)) {
        if (o & 8) {
            const d = t.vnode.dynamicProps;
            for (let h = 0; h < d.length; h++) {
                let p = d[h];
                if (am(t.emitsOptions, p))
                    continue;
                const g = e[p];
                if (l)
                    if (Ot(s, p))
                        g !== s[p] && (s[p] = g,
                            c = !0);
                    else {
                        const y = Fn(p);
                        i[y] = s1(l, a, y, g, t, !1)
                    }
                else
                    g !== s[p] && (s[p] = g,
                        c = !0)
            }
        }
    } else {
        _k(t, e, i, s) && (c = !0);
        let d;
        for (const h in a)
            (!e || !Ot(e, h) && ((d = kr(h)) === h || !Ot(e, d))) && (l ? n && (n[h] !== void 0 || n[d] !== void 0) && (i[h] = s1(l, a, h, void 0, t, !0)) : delete i[h]);
        if (s !== a)
            for (const h in s)
                (!e || !Ot(e, h)) && (delete s[h],
                    c = !0)
    }
    c && Ns(t.attrs, "set", "")
}
function _k(t, e, n, r) {
    const [i, s] = t.propsOptions;
    let o = !1, a;
    if (e)
        for (let l in e) {
            if (Il(l))
                continue;
            const c = e[l];
            let d;
            i && Ot(i, d = Fn(l)) ? !s || !s.includes(d) ? n[d] = c : (a || (a = {}))[d] = c : am(t.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c,
                o = !0)
        }
    if (s) {
        const l = it(n)
            , c = a || kt;
        for (let d = 0; d < s.length; d++) {
            const h = s[d];
            n[h] = s1(i, l, h, c[h], t, !Ot(c, h))
        }
    }
    return o
}
function s1(t, e, n, r, i, s) {
    const o = t[n];
    if (o != null) {
        const a = Ot(o, "default");
        if (a && r === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && We(l)) {
                const { propsDefaults: c } = i;
                if (n in c)
                    r = c[n];
                else {
                    const d = Na(i);
                    r = c[n] = l.call(null, e),
                        d()
                }
            } else
                r = l;
            i.ce && i.ce._setProp(n, r)
        }
        o[0] && (s && !a ? r = !1 : o[1] && (r === "" || r === kr(n)) && (r = !0))
    }
    return r
}
const C5 = new WeakMap;
function Sk(t, e, n = !1) {
    const r = n ? C5 : e.propsCache
        , i = r.get(t);
    if (i)
        return i;
    const s = t.props
        , o = {}
        , a = [];
    let l = !1;
    if (!We(t)) {
        const d = h => {
            l = !0;
            const [p, g] = Sk(h, e, !0);
            Kt(o, p),
                g && a.push(...g)
        }
            ;
        !n && e.mixins.length && e.mixins.forEach(d),
            t.extends && d(t.extends),
            t.mixins && t.mixins.forEach(d)
    }
    if (!s && !l)
        return jt(t) && r.set(t, Pl),
            Pl;
    if (Re(s))
        for (let d = 0; d < s.length; d++) {
            const h = Fn(s[d]);
            lx(h) && (o[h] = kt)
        }
    else if (s)
        for (const d in s) {
            const h = Fn(d);
            if (lx(h)) {
                const p = s[d]
                    , g = o[h] = Re(p) || We(p) ? {
                        type: p
                    } : Kt({}, p)
                    , y = g.type;
                let x = !1
                    , S = !0;
                if (Re(y))
                    for (let k = 0; k < y.length; ++k) {
                        const A = y[k]
                            , C = We(A) && A.name;
                        if (C === "Boolean") {
                            x = !0;
                            break
                        } else
                            C === "String" && (S = !1)
                    }
                else
                    x = We(y) && y.name === "Boolean";
                g[0] = x,
                    g[1] = S,
                    (x || Ot(g, "default")) && a.push(h)
            }
        }
    const c = [o, a];
    return jt(t) && r.set(t, c),
        c
}
function lx(t) {
    return t[0] !== "$" && !Il(t)
}
const kk = t => t[0] === "_" || t === "$stable"
    , Qy = t => Re(t) ? t.map(_r) : [_r(t)]
    , E5 = (t, e, n) => {
        if (e._n)
            return e;
        const r = tt((...i) => Qy(e(...i)), n);
        return r._c = !1,
            r
    }
    , Ck = (t, e, n) => {
        const r = t._ctx;
        for (const i in t) {
            if (kk(i))
                continue;
            const s = t[i];
            if (We(s))
                e[i] = E5(i, s, r);
            else if (s != null) {
                const o = Qy(s);
                e[i] = () => o
            }
        }
    }
    , Ek = (t, e) => {
        const n = Qy(e);
        t.slots.default = () => n
    }
    , Tk = (t, e, n) => {
        for (const r in e)
            (n || r !== "_") && (t[r] = e[r])
    }
    , T5 = (t, e, n) => {
        const r = t.slots = wk();
        if (t.vnode.shapeFlag & 32) {
            const i = e._;
            i ? (Tk(r, e, n),
                n && TS(r, "_", i, !0)) : Ck(e, r)
        } else
            e && Ek(t, e)
    }
    , A5 = (t, e, n) => {
        const { vnode: r, slots: i } = t;
        let s = !0
            , o = kt;
        if (r.shapeFlag & 32) {
            const a = e._;
            a ? n && a === 1 ? s = !1 : Tk(i, e, n) : (s = !e.$stable,
                Ck(e, i)),
                o = e
        } else
            e && (Ek(t, e),
                o = {
                    default: 1
                });
        if (s)
            for (const a in i)
                !kk(a) && o[a] == null && delete i[a]
    }
    , kn = Dk;
function O5(t) {
    return Ak(t)
}
function M5(t) {
    return Ak(t, X4)
}
function Ak(t, e) {
    const n = AS();
    n.__VUE__ = !0;
    const { insert: r, remove: i, patchProp: s, createElement: o, createText: a, createComment: l, setText: c, setElementText: d, parentNode: h, nextSibling: p, setScopeId: g = ii, insertStaticContent: y } = t
        , x = (D, B, J, ae = null, X = null, de = null, be = void 0, pe = null, fe = !!B.dynamicChildren) => {
            if (D === B)
                return;
            D && !vi(D, B) && (ae = Y(D),
                Se(D, X, de, !0),
                D = null),
                B.patchFlag === -2 && (fe = !1,
                    B.dynamicChildren = null);
            const { type: ue, ref: Ne, shapeFlag: we } = B;
            switch (ue) {
                case va:
                    S(D, B, J, ae);
                    break;
                case cn:
                    k(D, B, J, ae);
                    break;
                case Bl:
                    D == null && A(B, J, ae, be);
                    break;
                case Rt:
                    j(D, B, J, ae, X, de, be, pe, fe);
                    break;
                default:
                    we & 1 ? b(D, B, J, ae, X, de, be, pe, fe) : we & 6 ? z(D, B, J, ae, X, de, be, pe, fe) : (we & 64 || we & 128) && ue.process(D, B, J, ae, X, de, be, pe, fe, Ee)
            }
            Ne != null && X && Ph(Ne, D && D.ref, de, B || D, !B)
        }
        , S = (D, B, J, ae) => {
            if (D == null)
                r(B.el = a(B.children), J, ae);
            else {
                const X = B.el = D.el;
                B.children !== D.children && c(X, B.children)
            }
        }
        , k = (D, B, J, ae) => {
            D == null ? r(B.el = l(B.children || ""), J, ae) : B.el = D.el
        }
        , A = (D, B, J, ae) => {
            [D.el, D.anchor] = y(D.children, B, J, ae, D.el, D.anchor)
        }
        , C = ({ el: D, anchor: B }, J, ae) => {
            let X;
            for (; D && D !== B;)
                X = p(D),
                    r(D, J, ae),
                    D = X;
            r(B, J, ae)
        }
        , m = ({ el: D, anchor: B }) => {
            let J;
            for (; D && D !== B;)
                J = p(D),
                    i(D),
                    D = J;
            i(B)
        }
        , b = (D, B, J, ae, X, de, be, pe, fe) => {
            B.type === "svg" ? be = "svg" : B.type === "math" && (be = "mathml"),
                D == null ? w(B, J, ae, X, de, be, pe, fe) : M(D, B, X, de, be, pe, fe)
        }
        , w = (D, B, J, ae, X, de, be, pe) => {
            let fe, ue;
            const { props: Ne, shapeFlag: we, transition: Oe, dirs: ze } = D;
            if (fe = D.el = o(D.type, de, Ne && Ne.is, Ne),
                we & 8 ? d(fe, D.children) : we & 16 && O(D.children, fe, null, ae, X, l0(D, de), be, pe),
                ze && Hi(D, null, ae, "created"),
                T(fe, D, D.scopeId, be, ae),
                Ne) {
                for (const bt in Ne)
                    bt !== "value" && !Il(bt) && s(fe, bt, null, Ne[bt], de, ae);
                "value" in Ne && s(fe, "value", null, Ne.value, de),
                    (ue = Ne.onVnodeBeforeMount) && wr(ue, ae, D)
            }
            ze && Hi(D, null, ae, "beforeMount");
            const nt = Ok(X, Oe);
            nt && Oe.beforeEnter(fe),
                r(fe, B, J),
                ((ue = Ne && Ne.onVnodeMounted) || nt || ze) && kn(() => {
                    ue && wr(ue, ae, D),
                        nt && Oe.enter(fe),
                        ze && Hi(D, null, ae, "mounted")
                }
                    , X)
        }
        , T = (D, B, J, ae, X) => {
            if (J && g(D, J),
                ae)
                for (let de = 0; de < ae.length; de++)
                    g(D, ae[de]);
            if (X) {
                let de = X.subTree;
                if (B === de || Lh(de.type) && (de.ssContent === B || de.ssFallback === B)) {
                    const be = X.vnode;
                    T(D, be, be.scopeId, be.slotScopeIds, X.parent)
                }
            }
        }
        , O = (D, B, J, ae, X, de, be, pe, fe = 0) => {
            for (let ue = fe; ue < D.length; ue++) {
                const Ne = D[ue] = pe ? oo(D[ue]) : _r(D[ue]);
                x(null, Ne, B, J, ae, X, de, be, pe)
            }
        }
        , M = (D, B, J, ae, X, de, be) => {
            const pe = B.el = D.el;
            let { patchFlag: fe, dynamicChildren: ue, dirs: Ne } = B;
            fe |= D.patchFlag & 16;
            const we = D.props || kt
                , Oe = B.props || kt;
            let ze;
            if (J && sa(J, !1),
                (ze = Oe.onVnodeBeforeUpdate) && wr(ze, J, B, D),
                Ne && Hi(B, D, J, "beforeUpdate"),
                J && sa(J, !0),
                (we.innerHTML && Oe.innerHTML == null || we.textContent && Oe.textContent == null) && d(pe, ""),
                ue ? E(D.dynamicChildren, ue, pe, J, ae, l0(B, X), de) : be || K(D, B, pe, null, J, ae, l0(B, X), de, !1),
                fe > 0) {
                if (fe & 16)
                    N(pe, we, Oe, J, X);
                else if (fe & 2 && we.class !== Oe.class && s(pe, "class", null, Oe.class, X),
                    fe & 4 && s(pe, "style", we.style, Oe.style, X),
                    fe & 8) {
                    const nt = B.dynamicProps;
                    for (let bt = 0; bt < nt.length; bt++) {
                        const Et = nt[bt]
                            , Mn = we[Et]
                            , dn = Oe[Et];
                        (dn !== Mn || Et === "value") && s(pe, Et, Mn, dn, X, J)
                    }
                }
                fe & 1 && D.children !== B.children && d(pe, B.children)
            } else
                !be && ue == null && N(pe, we, Oe, J, X);
            ((ze = Oe.onVnodeUpdated) || Ne) && kn(() => {
                ze && wr(ze, J, B, D),
                    Ne && Hi(B, D, J, "updated")
            }
                , ae)
        }
        , E = (D, B, J, ae, X, de, be) => {
            for (let pe = 0; pe < B.length; pe++) {
                const fe = D[pe]
                    , ue = B[pe]
                    , Ne = fe.el && (fe.type === Rt || !vi(fe, ue) || fe.shapeFlag & 70) ? h(fe.el) : J;
                x(fe, ue, Ne, null, ae, X, de, be, !0)
            }
        }
        , N = (D, B, J, ae, X) => {
            if (B !== J) {
                if (B !== kt)
                    for (const de in B)
                        !Il(de) && !(de in J) && s(D, de, B[de], null, X, ae);
                for (const de in J) {
                    if (Il(de))
                        continue;
                    const be = J[de]
                        , pe = B[de];
                    be !== pe && de !== "value" && s(D, de, pe, be, X, ae)
                }
                "value" in J && s(D, "value", B.value, J.value, X)
            }
        }
        , j = (D, B, J, ae, X, de, be, pe, fe) => {
            const ue = B.el = D ? D.el : a("")
                , Ne = B.anchor = D ? D.anchor : a("");
            let { patchFlag: we, dynamicChildren: Oe, slotScopeIds: ze } = B;
            ze && (pe = pe ? pe.concat(ze) : ze),
                D == null ? (r(ue, J, ae),
                    r(Ne, J, ae),
                    O(B.children || [], J, Ne, X, de, be, pe, fe)) : we > 0 && we & 64 && Oe && D.dynamicChildren ? (E(D.dynamicChildren, Oe, J, X, de, be, pe),
                        (B.key != null || X && B === X.subTree) && ev(D, B, !0)) : K(D, B, J, Ne, X, de, be, pe, fe)
        }
        , z = (D, B, J, ae, X, de, be, pe, fe) => {
            B.slotScopeIds = pe,
                D == null ? B.shapeFlag & 512 ? X.ctx.activate(B, J, ae, be, fe) : V(B, J, ae, X, de, be, fe) : W(D, B, fe)
        }
        , V = (D, B, J, ae, X, de, be) => {
            const pe = D.component = zk(D, ae, X);
            if (fd(D) && (pe.ctx.renderer = Ee),
                Hk(pe, !1, be),
                pe.asyncDep) {
                if (X && X.registerDep(pe, P, be),
                    !D.el) {
                    const fe = pe.subTree = $e(cn);
                    k(null, fe, B, J)
                }
            } else
                P(pe, D, B, J, X, de, be)
        }
        , W = (D, B, J) => {
            const ae = B.component = D.component;
            if (z5(D, B, J))
                if (ae.asyncDep && !ae.asyncResolved) {
                    F(ae, B, J);
                    return
                } else
                    ae.next = B,
                        ae.update();
            else
                B.el = D.el,
                    ae.vnode = B
        }
        , P = (D, B, J, ae, X, de, be) => {
            const pe = () => {
                if (D.isMounted) {
                    let { next: we, bu: Oe, u: ze, parent: nt, vnode: bt } = D;
                    {
                        const Rn = Mk(D);
                        if (Rn) {
                            we && (we.el = bt.el,
                                F(D, we, be)),
                                Rn.asyncDep.then(() => {
                                    D.isUnmounted || pe()
                                }
                                );
                            return
                        }
                    }
                    let Et = we, Mn;
                    sa(D, !1),
                        we ? (we.el = bt.el,
                            F(D, we, be)) : we = bt,
                        Oe && Ll(Oe),
                        (Mn = we.props && we.props.onVnodeBeforeUpdate) && wr(Mn, nt, we, bt),
                        sa(D, !0);
                    const dn = ah(D)
                        , rr = D.subTree;
                    D.subTree = dn,
                        x(rr, dn, h(rr.el), Y(rr), D, X, de),
                        we.el = dn.el,
                        Et === null && tv(D, dn.el),
                        ze && kn(ze, X),
                        (Mn = we.props && we.props.onVnodeUpdated) && kn(() => wr(Mn, nt, we, bt), X)
                } else {
                    let we;
                    const { el: Oe, props: ze } = B
                        , { bm: nt, m: bt, parent: Et, root: Mn, type: dn } = D
                        , rr = _o(B);
                    if (sa(D, !1),
                        nt && Ll(nt),
                        !rr && (we = ze && ze.onVnodeBeforeMount) && wr(we, Et, B),
                        sa(D, !0),
                        Oe && xt) {
                        const Rn = () => {
                            D.subTree = ah(D),
                                xt(Oe, D.subTree, D, X, null)
                        }
                            ;
                        rr && dn.__asyncHydrate ? dn.__asyncHydrate(Oe, D, Rn) : Rn()
                    } else {
                        Mn.ce && Mn.ce._injectChildStyle(dn);
                        const Rn = D.subTree = ah(D);
                        x(null, Rn, J, ae, D, X, de),
                            B.el = Rn.el
                    }
                    if (bt && kn(bt, X),
                        !rr && (we = ze && ze.onVnodeMounted)) {
                        const Rn = B;
                        kn(() => wr(we, Et, Rn), X)
                    }
                    (B.shapeFlag & 256 || Et && _o(Et.vnode) && Et.vnode.shapeFlag & 256) && D.a && kn(D.a, X),
                        D.isMounted = !0,
                        B = J = ae = null
                }
            }
                ;
            D.scope.on();
            const fe = D.effect = new Th(pe);
            D.scope.off();
            const ue = D.update = fe.run.bind(fe)
                , Ne = D.job = fe.runIfDirty.bind(fe);
            Ne.i = D,
                Ne.id = D.uid,
                fe.scheduler = () => Wy(Ne),
                sa(D, !0),
                ue()
        }
        , F = (D, B, J) => {
            B.component = D;
            const ae = D.vnode.props;
            D.vnode = B,
                D.next = null,
                k5(D, B.props, ae, J),
                A5(D, B.children, J),
                Wo(),
                Xw(D),
                Uo()
        }
        , K = (D, B, J, ae, X, de, be, pe, fe = !1) => {
            const ue = D && D.children
                , Ne = D ? D.shapeFlag : 0
                , we = B.children
                , { patchFlag: Oe, shapeFlag: ze } = B;
            if (Oe > 0) {
                if (Oe & 128) {
                    Te(ue, we, J, ae, X, de, be, pe, fe);
                    return
                } else if (Oe & 256) {
                    re(ue, we, J, ae, X, de, be, pe, fe);
                    return
                }
            }
            ze & 8 ? (Ne & 16 && Qe(ue, X, de),
                we !== ue && d(J, we)) : Ne & 16 ? ze & 16 ? Te(ue, we, J, ae, X, de, be, pe, fe) : Qe(ue, X, de, !0) : (Ne & 8 && d(J, ""),
                    ze & 16 && O(we, J, ae, X, de, be, pe, fe))
        }
        , re = (D, B, J, ae, X, de, be, pe, fe) => {
            D = D || Pl,
                B = B || Pl;
            const ue = D.length
                , Ne = B.length
                , we = Math.min(ue, Ne);
            let Oe;
            for (Oe = 0; Oe < we; Oe++) {
                const ze = B[Oe] = fe ? oo(B[Oe]) : _r(B[Oe]);
                x(D[Oe], ze, J, null, X, de, be, pe, fe)
            }
            ue > Ne ? Qe(D, X, de, !0, !1, we) : O(B, J, ae, X, de, be, pe, fe, we)
        }
        , Te = (D, B, J, ae, X, de, be, pe, fe) => {
            let ue = 0;
            const Ne = B.length;
            let we = D.length - 1
                , Oe = Ne - 1;
            for (; ue <= we && ue <= Oe;) {
                const ze = D[ue]
                    , nt = B[ue] = fe ? oo(B[ue]) : _r(B[ue]);
                if (vi(ze, nt))
                    x(ze, nt, J, null, X, de, be, pe, fe);
                else
                    break;
                ue++
            }
            for (; ue <= we && ue <= Oe;) {
                const ze = D[we]
                    , nt = B[Oe] = fe ? oo(B[Oe]) : _r(B[Oe]);
                if (vi(ze, nt))
                    x(ze, nt, J, null, X, de, be, pe, fe);
                else
                    break;
                we--,
                    Oe--
            }
            if (ue > we) {
                if (ue <= Oe) {
                    const ze = Oe + 1
                        , nt = ze < Ne ? B[ze].el : ae;
                    for (; ue <= Oe;)
                        x(null, B[ue] = fe ? oo(B[ue]) : _r(B[ue]), J, nt, X, de, be, pe, fe),
                            ue++
                }
            } else if (ue > Oe)
                for (; ue <= we;)
                    Se(D[ue], X, de, !0),
                        ue++;
            else {
                const ze = ue
                    , nt = ue
                    , bt = new Map;
                for (ue = nt; ue <= Oe; ue++) {
                    const Pn = B[ue] = fe ? oo(B[ue]) : _r(B[ue]);
                    Pn.key != null && bt.set(Pn.key, ue)
                }
                let Et, Mn = 0;
                const dn = Oe - nt + 1;
                let rr = !1
                    , Rn = 0;
                const us = new Array(dn);
                for (ue = 0; ue < dn; ue++)
                    us[ue] = 0;
                for (ue = ze; ue <= we; ue++) {
                    const Pn = D[ue];
                    if (Mn >= dn) {
                        Se(Pn, X, de, !0);
                        continue
                    }
                    let mr;
                    if (Pn.key != null)
                        mr = bt.get(Pn.key);
                    else
                        for (Et = nt; Et <= Oe; Et++)
                            if (us[Et - nt] === 0 && vi(Pn, B[Et])) {
                                mr = Et;
                                break
                            }
                    mr === void 0 ? Se(Pn, X, de, !0) : (us[mr - nt] = ue + 1,
                        mr >= Rn ? Rn = mr : rr = !0,
                        x(Pn, B[mr], J, null, X, de, be, pe, fe),
                        Mn++)
                }
                const Ja = rr ? R5(us) : Pl;
                for (Et = Ja.length - 1,
                    ue = dn - 1; ue >= 0; ue--) {
                    const Pn = nt + ue
                        , mr = B[Pn]
                        , Md = Pn + 1 < Ne ? B[Pn + 1].el : ae;
                    us[ue] === 0 ? x(null, mr, J, Md, X, de, be, pe, fe) : rr && (Et < 0 || ue !== Ja[Et] ? ee(mr, J, Md, 2) : Et--)
                }
            }
        }
        , ee = (D, B, J, ae, X = null) => {
            const { el: de, type: be, transition: pe, children: fe, shapeFlag: ue } = D;
            if (ue & 6) {
                ee(D.component.subTree, B, J, ae);
                return
            }
            if (ue & 128) {
                D.suspense.move(B, J, ae);
                return
            }
            if (ue & 64) {
                be.move(D, B, J, Ee);
                return
            }
            if (be === Rt) {
                r(de, B, J);
                for (let we = 0; we < fe.length; we++)
                    ee(fe[we], B, J, ae);
                r(D.anchor, B, J);
                return
            }
            if (be === Bl) {
                C(D, B, J);
                return
            }
            if (ae !== 2 && ue & 1 && pe)
                if (ae === 0)
                    pe.beforeEnter(de),
                        r(de, B, J),
                        kn(() => pe.enter(de), X);
                else {
                    const { leave: we, delayLeave: Oe, afterLeave: ze } = pe
                        , nt = () => r(de, B, J)
                        , bt = () => {
                            we(de, () => {
                                nt(),
                                    ze && ze()
                            }
                            )
                        }
                        ;
                    Oe ? Oe(de, nt, bt) : bt()
                }
            else
                r(de, B, J)
        }
        , Se = (D, B, J, ae = !1, X = !1) => {
            const { type: de, props: be, ref: pe, children: fe, dynamicChildren: ue, shapeFlag: Ne, patchFlag: we, dirs: Oe, cacheIndex: ze } = D;
            if (we === -2 && (X = !1),
                pe != null && Ph(pe, null, J, D, !0),
                ze != null && (B.renderCache[ze] = void 0),
                Ne & 256) {
                B.ctx.deactivate(D);
                return
            }
            const nt = Ne & 1 && Oe
                , bt = !_o(D);
            let Et;
            if (bt && (Et = be && be.onVnodeBeforeUnmount) && wr(Et, B, D),
                Ne & 6)
                Ye(D.component, J, ae);
            else {
                if (Ne & 128) {
                    D.suspense.unmount(J, ae);
                    return
                }
                nt && Hi(D, null, B, "beforeUnmount"),
                    Ne & 64 ? D.type.remove(D, B, J, Ee, ae) : ue && !ue.hasOnce && (de !== Rt || we > 0 && we & 64) ? Qe(ue, B, J, !1, !0) : (de === Rt && we & 384 || !X && Ne & 16) && Qe(fe, B, J),
                    ae && Ze(D)
            }
            (bt && (Et = be && be.onVnodeUnmounted) || nt) && kn(() => {
                Et && wr(Et, B, D),
                    nt && Hi(D, null, B, "unmounted")
            }
                , J)
        }
        , Ze = D => {
            const { type: B, el: J, anchor: ae, transition: X } = D;
            if (B === Rt) {
                Ke(J, ae);
                return
            }
            if (B === Bl) {
                m(D);
                return
            }
            const de = () => {
                i(J),
                    X && !X.persisted && X.afterLeave && X.afterLeave()
            }
                ;
            if (D.shapeFlag & 1 && X && !X.persisted) {
                const { leave: be, delayLeave: pe } = X
                    , fe = () => be(J, de);
                pe ? pe(D.el, de, fe) : fe()
            } else
                de()
        }
        , Ke = (D, B) => {
            let J;
            for (; D !== B;)
                J = p(D),
                    i(D),
                    D = J;
            i(B)
        }
        , Ye = (D, B, J) => {
            const { bum: ae, scope: X, job: de, subTree: be, um: pe, m: fe, a: ue } = D;
            Ih(fe),
                Ih(ue),
                ae && Ll(ae),
                X.stop(),
                de && (de.flags |= 8,
                    Se(be, D, B, J)),
                pe && kn(pe, B),
                kn(() => {
                    D.isUnmounted = !0
                }
                    , B),
                B && B.pendingBranch && !B.isUnmounted && D.asyncDep && !D.asyncResolved && D.suspenseId === B.pendingId && (B.deps--,
                    B.deps === 0 && B.resolve())
        }
        , Qe = (D, B, J, ae = !1, X = !1, de = 0) => {
            for (let be = de; be < D.length; be++)
                Se(D[be], B, J, ae, X)
        }
        , Y = D => {
            if (D.shapeFlag & 6)
                return Y(D.component.subTree);
            if (D.shapeFlag & 128)
                return D.suspense.next();
            const B = p(D.anchor || D.el)
                , J = B && B[sk];
            return J ? p(J) : B
        }
        ;
    let he = !1;
    const ge = (D, B, J) => {
        D == null ? B._vnode && Se(B._vnode, null, null, !0) : x(B._vnode || null, D, B, null, null, null, J),
            B._vnode = D,
            he || (he = !0,
                Xw(),
                Mh(),
                he = !1)
    }
        , Ee = {
            p: x,
            um: Se,
            m: ee,
            r: Ze,
            mt: V,
            mc: O,
            pc: K,
            pbc: E,
            n: Y,
            o: t
        };
    let st, xt;
    return e && ([st, xt] = e(Ee)),
    {
        render: ge,
        hydrate: st,
        createApp: x5(ge, st)
    }
}
function l0({ type: t, props: e }, n) {
    return n === "svg" && t === "foreignObject" || n === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n
}
function sa({ effect: t, job: e }, n) {
    n ? (t.flags |= 32,
        e.flags |= 4) : (t.flags &= -33,
            e.flags &= -5)
}
function Ok(t, e) {
    return (!t || t && !t.pendingBranch) && e && !e.persisted
}
function ev(t, e, n = !1) {
    const r = t.children
        , i = e.children;
    if (Re(r) && Re(i))
        for (let s = 0; s < r.length; s++) {
            const o = r[s];
            let a = i[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = oo(i[s]),
                a.el = o.el),
                !n && a.patchFlag !== -2 && ev(o, a)),
                a.type === va && (a.el = o.el)
        }
}
function R5(t) {
    const e = t.slice()
        , n = [0];
    let r, i, s, o, a;
    const l = t.length;
    for (r = 0; r < l; r++) {
        const c = t[r];
        if (c !== 0) {
            if (i = n[n.length - 1],
                t[i] < c) {
                e[r] = i,
                    n.push(r);
                continue
            }
            for (s = 0,
                o = n.length - 1; s < o;)
                a = s + o >> 1,
                    t[n[a]] < c ? s = a + 1 : o = a;
            c < t[n[s]] && (s > 0 && (e[r] = n[s - 1]),
                n[s] = r)
        }
    }
    for (s = n.length,
        o = n[s - 1]; s-- > 0;)
        n[s] = o,
            o = e[o];
    return n
}
function Mk(t) {
    const e = t.subTree.component;
    if (e)
        return e.asyncDep && !e.asyncResolved ? e : Mk(e)
}
function Ih(t) {
    if (t)
        for (let e = 0; e < t.length; e++)
            t[e].flags |= 8
}
const P5 = Symbol.for("v-scx")
    , N5 = () => Dt(P5);
function Ft(t, e) {
    return pd(t, null, e)
}
function Rk(t, e) {
    return pd(t, null, {
        flush: "post"
    })
}
function I5(t, e) {
    return pd(t, null, {
        flush: "sync"
    })
}
function vt(t, e, n) {
    return pd(t, e, n)
}
function pd(t, e, n = kt) {
    const { immediate: r, deep: i, flush: s, once: o } = n
        , a = Kt({}, n);
    let l;
    if (md)
        if (s === "sync") {
            const p = N5();
            l = p.__watcherHandles || (p.__watcherHandles = [])
        } else if (!e || r)
            a.once = !0;
        else {
            const p = () => { }
                ;
            return p.stop = ii,
                p.resume = ii,
                p.pause = ii,
                p
        }
    const c = vn;
    a.call = (p, g, y) => Ti(p, c, g, y);
    let d = !1;
    s === "post" ? a.scheduler = p => {
        kn(p, c && c.suspense)
    }
        : s !== "sync" && (d = !0,
            a.scheduler = (p, g) => {
                g ? p() : Wy(p)
            }
        ),
        a.augmentJob = p => {
            e && (p.flags |= 4),
                d && (p.flags |= 2,
                    c && (p.id = c.uid,
                        p.i = c))
        }
        ;
    const h = $4(t, e, a);
    return l && l.push(h),
        h
}
function L5(t, e, n) {
    const r = this.proxy
        , i = qt(t) ? t.includes(".") ? Pk(r, t) : () => r[t] : t.bind(r, r);
    let s;
    We(e) ? s = e : (s = e.handler,
        n = e);
    const o = Na(this)
        , a = pd(i, s.bind(r), n);
    return o(),
        a
}
function Pk(t, e) {
    const n = e.split(".");
    return () => {
        let r = t;
        for (let i = 0; i < n.length && r; i++)
            r = r[n[i]];
        return r
    }
}
function xQ(t, e, n = kt) {
    const r = pn()
        , i = Fn(e)
        , s = kr(e)
        , o = Nk(t, e)
        , a = YS((l, c) => {
            let d, h = kt, p;
            return I5(() => {
                const g = t[e];
                ur(d, g) && (d = g,
                    c())
            }
            ),
            {
                get() {
                    return l(),
                        n.get ? n.get(d) : d
                },
                set(g) {
                    const y = n.set ? n.set(g) : g;
                    if (!ur(y, d) && !(h !== kt && ur(g, h)))
                        return;
                    const x = r.vnode.props;
                    x && (e in x || i in x || s in x) && (`onUpdate:${e}` in x || `onUpdate:${i}` in x || `onUpdate:${s}` in x) || (d = g,
                        c()),
                        r.emit(`update:${e}`, y),
                        ur(g, y) && ur(g, h) && !ur(y, p) && c(),
                        h = g,
                        p = y
                }
            }
        }
        );
    return a[Symbol.iterator] = () => {
        let l = 0;
        return {
            next() {
                return l < 2 ? {
                    value: l++ ? o || kt : a,
                    done: !1
                } : {
                    done: !0
                }
            }
        }
    }
        ,
        a
}
const Nk = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${Fn(e)}Modifiers`] || t[`${kr(e)}Modifiers`];
function D5(t, e, ...n) {
    if (t.isUnmounted)
        return;
    const r = t.vnode.props || kt;
    let i = n;
    const s = e.startsWith("update:")
        , o = s && Nk(r, e.slice(7));
    o && (o.trim && (i = n.map(d => qt(d) ? d.trim() : d)),
        o.number && (i = n.map(Ch)));
    let a, l = r[a = ec(e)] || r[a = ec(Fn(e))];
    !l && s && (l = r[a = ec(kr(e))]),
        l && Ti(l, t, 6, i);
    const c = r[a + "Once"];
    if (c) {
        if (!t.emitted)
            t.emitted = {};
        else if (t.emitted[a])
            return;
        t.emitted[a] = !0,
            Ti(c, t, 6, i)
    }
}
function Ik(t, e, n = !1) {
    const r = e.emitsCache
        , i = r.get(t);
    if (i !== void 0)
        return i;
    const s = t.emits;
    let o = {}
        , a = !1;
    if (!We(t)) {
        const l = c => {
            const d = Ik(c, e, !0);
            d && (a = !0,
                Kt(o, d))
        }
            ;
        !n && e.mixins.length && e.mixins.forEach(l),
            t.extends && l(t.extends),
            t.mixins && t.mixins.forEach(l)
    }
    return !s && !a ? (jt(t) && r.set(t, null),
        null) : (Re(s) ? s.forEach(l => o[l] = null) : Kt(o, s),
            jt(t) && r.set(t, o),
            o)
}
function am(t, e) {
    return !t || !ld(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""),
        Ot(t, e[0].toLowerCase() + e.slice(1)) || Ot(t, kr(e)) || Ot(t, e))
}
function ah(t) {
    const { type: e, vnode: n, proxy: r, withProxy: i, propsOptions: [s], slots: o, attrs: a, emit: l, render: c, renderCache: d, props: h, data: p, setupState: g, ctx: y, inheritAttrs: x } = t
        , S = Cc(t);
    let k, A;
    try {
        if (n.shapeFlag & 4) {
            const m = i || r
                , b = m;
            k = _r(c.call(b, m, d, h, g, p, y)),
                A = a
        } else {
            const m = e;
            k = _r(m.length > 1 ? m(h, {
                attrs: a,
                slots: o,
                emit: l
            }) : m(h, null)),
                A = e.props ? a : B5(a)
        }
    } catch (m) {
        ic.length = 0,
            fu(m, t, 1),
            k = $e(cn)
    }
    let C = k;
    if (A && x !== !1) {
        const m = Object.keys(A)
            , { shapeFlag: b } = C;
        m.length && b & 7 && (s && m.some(My) && (A = $5(A, s)),
            C = ui(C, A, !1, !0))
    }
    return n.dirs && (C = ui(C, null, !1, !0),
        C.dirs = C.dirs ? C.dirs.concat(n.dirs) : n.dirs),
        n.transition && Oo(C, n.transition),
        k = C,
        Cc(S),
        k
}
function j5(t, e = !0) {
    let n;
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        if (Ra(i)) {
            if (i.type !== cn || i.children === "v-if") {
                if (n)
                    return;
                n = i
            }
        } else
            return
    }
    return n
}
const B5 = t => {
    let e;
    for (const n in t)
        (n === "class" || n === "style" || ld(n)) && ((e || (e = {}))[n] = t[n]);
    return e
}
    , $5 = (t, e) => {
        const n = {};
        for (const r in t)
            (!My(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
        return n
    }
    ;
function z5(t, e, n) {
    const { props: r, children: i, component: s } = t
        , { props: o, children: a, patchFlag: l } = e
        , c = s.emitsOptions;
    if (e.dirs || e.transition)
        return !0;
    if (n && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return r ? ux(r, o, c) : !!o;
        if (l & 8) {
            const d = e.dynamicProps;
            for (let h = 0; h < d.length; h++) {
                const p = d[h];
                if (o[p] !== r[p] && !am(c, p))
                    return !0
            }
        }
    } else
        return (i || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? o ? ux(r, o, c) : !0 : !!o;
    return !1
}
function ux(t, e, n) {
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length)
        return !0;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        if (e[s] !== t[s] && !am(n, s))
            return !0
    }
    return !1
}
function tv({ vnode: t, parent: e }, n) {
    for (; e;) {
        const r = e.subTree;
        if (r.suspense && r.suspense.activeBranch === t && (r.el = t.el),
            r === t)
            (t = e.vnode).el = n,
                e = e.parent;
        else
            break
    }
}
const Lh = t => t.__isSuspense;
let o1 = 0;
const F5 = {
    name: "Suspense",
    __isSuspense: !0,
    process(t, e, n, r, i, s, o, a, l, c) {
        if (t == null)
            H5(e, n, r, i, s, o, a, l, c);
        else {
            if (s && s.deps > 0 && !t.suspense.isInFallback) {
                e.suspense = t.suspense,
                    e.suspense.vnode = e,
                    e.el = t.el;
                return
            }
            V5(t, e, n, r, i, o, a, l, c)
        }
    },
    hydrate: W5,
    normalize: U5
}
    , _Q = F5;
function Ac(t, e) {
    const n = t.props && t.props[e];
    We(n) && n()
}
function H5(t, e, n, r, i, s, o, a, l) {
    const { p: c, o: { createElement: d } } = l
        , h = d("div")
        , p = t.suspense = Lk(t, i, r, e, h, n, s, o, a, l);
    c(null, p.pendingBranch = t.ssContent, h, null, r, p, s, o),
        p.deps > 0 ? (Ac(t, "onPending"),
            Ac(t, "onFallback"),
            c(null, t.ssFallback, e, n, r, null, s, o),
            jl(p, t.ssFallback)) : p.resolve(!1, !0)
}
function V5(t, e, n, r, i, s, o, a, { p: l, um: c, o: { createElement: d } }) {
    const h = e.suspense = t.suspense;
    h.vnode = e,
        e.el = t.el;
    const p = e.ssContent
        , g = e.ssFallback
        , { activeBranch: y, pendingBranch: x, isInFallback: S, isHydrating: k } = h;
    if (x)
        h.pendingBranch = p,
            vi(p, x) ? (l(x, p, h.hiddenContainer, null, i, h, s, o, a),
                h.deps <= 0 ? h.resolve() : S && (k || (l(y, g, n, r, i, null, s, o, a),
                    jl(h, g)))) : (h.pendingId = o1++,
                        k ? (h.isHydrating = !1,
                            h.activeBranch = x) : c(x, i, h),
                        h.deps = 0,
                        h.effects.length = 0,
                        h.hiddenContainer = d("div"),
                        S ? (l(null, p, h.hiddenContainer, null, i, h, s, o, a),
                            h.deps <= 0 ? h.resolve() : (l(y, g, n, r, i, null, s, o, a),
                                jl(h, g))) : y && vi(p, y) ? (l(y, p, n, r, i, h, s, o, a),
                                    h.resolve(!0)) : (l(null, p, h.hiddenContainer, null, i, h, s, o, a),
                                        h.deps <= 0 && h.resolve()));
    else if (y && vi(p, y))
        l(y, p, n, r, i, h, s, o, a),
            jl(h, p);
    else if (Ac(e, "onPending"),
        h.pendingBranch = p,
        p.shapeFlag & 512 ? h.pendingId = p.component.suspenseId : h.pendingId = o1++,
        l(null, p, h.hiddenContainer, null, i, h, s, o, a),
        h.deps <= 0)
        h.resolve();
    else {
        const { timeout: A, pendingId: C } = h;
        A > 0 ? setTimeout(() => {
            h.pendingId === C && h.fallback(g)
        }
            , A) : A === 0 && h.fallback(g)
    }
}
function Lk(t, e, n, r, i, s, o, a, l, c, d = !1) {
    const { p: h, m: p, um: g, n: y, o: { parentNode: x, remove: S } } = c;
    let k;
    const A = K5(t);
    A && e && e.pendingBranch && (k = e.pendingId,
        e.deps++);
    const C = t.props ? Eh(t.props.timeout) : void 0
        , m = s
        , b = {
            vnode: t,
            parent: e,
            parentComponent: n,
            namespace: o,
            container: r,
            hiddenContainer: i,
            deps: 0,
            pendingId: o1++,
            timeout: typeof C == "number" ? C : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: !d,
            isHydrating: d,
            isUnmounted: !1,
            effects: [],
            resolve(w = !1, T = !1) {
                const { vnode: O, activeBranch: M, pendingBranch: E, pendingId: N, effects: j, parentComponent: z, container: V } = b;
                let W = !1;
                b.isHydrating ? b.isHydrating = !1 : w || (W = M && E.transition && E.transition.mode === "out-in",
                    W && (M.transition.afterLeave = () => {
                        N === b.pendingId && (p(E, V, s === m ? y(M) : s, 0),
                            X0(j))
                    }
                    ),
                    M && (x(M.el) === V && (s = y(M)),
                        g(M, z, b, !0)),
                    W || p(E, V, s, 0)),
                    jl(b, E),
                    b.pendingBranch = null,
                    b.isInFallback = !1;
                let P = b.parent
                    , F = !1;
                for (; P;) {
                    if (P.pendingBranch) {
                        P.effects.push(...j),
                            F = !0;
                        break
                    }
                    P = P.parent
                }
                !F && !W && X0(j),
                    b.effects = [],
                    A && e && e.pendingBranch && k === e.pendingId && (e.deps--,
                        e.deps === 0 && !T && e.resolve()),
                    Ac(O, "onResolve")
            },
            fallback(w) {
                if (!b.pendingBranch)
                    return;
                const { vnode: T, activeBranch: O, parentComponent: M, container: E, namespace: N } = b;
                Ac(T, "onFallback");
                const j = y(O)
                    , z = () => {
                        b.isInFallback && (h(null, w, E, j, M, null, N, a, l),
                            jl(b, w))
                    }
                    , V = w.transition && w.transition.mode === "out-in";
                V && (O.transition.afterLeave = z),
                    b.isInFallback = !0,
                    g(O, M, null, !0),
                    V || z()
            },
            move(w, T, O) {
                b.activeBranch && p(b.activeBranch, w, T, O),
                    b.container = w
            },
            next() {
                return b.activeBranch && y(b.activeBranch)
            },
            registerDep(w, T, O) {
                const M = !!b.pendingBranch;
                M && b.deps++;
                const E = w.vnode.el;
                w.asyncDep.catch(N => {
                    fu(N, w, 0)
                }
                ).then(N => {
                    if (w.isUnmounted || b.isUnmounted || b.pendingId !== w.suspenseId)
                        return;
                    w.asyncResolved = !0;
                    const { vnode: j } = w;
                    u1(w, N, !1),
                        E && (j.el = E);
                    const z = !E && w.subTree.el;
                    T(w, j, x(E || w.subTree.el), E ? null : y(w.subTree), b, o, O),
                        z && S(z),
                        tv(w, j.el),
                        M && --b.deps === 0 && b.resolve()
                }
                )
            },
            unmount(w, T) {
                b.isUnmounted = !0,
                    b.activeBranch && g(b.activeBranch, n, w, T),
                    b.pendingBranch && g(b.pendingBranch, n, w, T)
            }
        };
    return b
}
function W5(t, e, n, r, i, s, o, a, l) {
    const c = e.suspense = Lk(e, r, n, t.parentNode, document.createElement("div"), null, i, s, o, a, !0)
        , d = l(t, c.pendingBranch = e.ssContent, n, c, s, o);
    return c.deps === 0 && c.resolve(!1, !0),
        d
}
function U5(t) {
    const { shapeFlag: e, children: n } = t
        , r = e & 32;
    t.ssContent = cx(r ? n.default : n),
        t.ssFallback = r ? cx(n.fallback) : $e(cn)
}
function cx(t) {
    let e;
    if (We(t)) {
        const n = Ma && t._c;
        n && (t._d = !1,
            oe()),
            t = t(),
            n && (t._d = !0,
                e = Jn,
                jk())
    }
    return Re(t) && (t = j5(t)),
        t = _r(t),
        e && !t.dynamicChildren && (t.dynamicChildren = e.filter(n => n !== t)),
        t
}
function Dk(t, e) {
    e && e.pendingBranch ? Re(t) ? e.effects.push(...t) : e.effects.push(t) : X0(t)
}
function jl(t, e) {
    t.activeBranch = e;
    const { vnode: n, parentComponent: r } = t;
    let i = e.el;
    for (; !i && e.component;)
        e = e.component.subTree,
            i = e.el;
    n.el = i,
        r && r.subTree === n && (r.vnode.el = i,
            tv(r, i))
}
function K5(t) {
    const e = t.props && t.props.suspensible;
    return e != null && e !== !1
}
const Rt = Symbol.for("v-fgt")
    , va = Symbol.for("v-txt")
    , cn = Symbol.for("v-cmt")
    , Bl = Symbol.for("v-stc")
    , ic = [];
let Jn = null;
function oe(t = !1) {
    ic.push(Jn = t ? null : [])
}
function jk() {
    ic.pop(),
        Jn = ic[ic.length - 1] || null
}
let Ma = 1;
function dx(t) {
    Ma += t,
        t < 0 && Jn && (Jn.hasOnce = !0)
}
function Bk(t) {
    return t.dynamicChildren = Ma > 0 ? Jn || Pl : null,
        jk(),
        Ma > 0 && Jn && Jn.push(t),
        t
}
function Ae(t, e, n, r, i, s) {
    return Bk(Xe(t, e, n, r, i, s, !0))
}
function gt(t, e, n, r, i) {
    return Bk($e(t, e, n, r, i, !0))
}
function Ra(t) {
    return t ? t.__v_isVNode === !0 : !1
}
function vi(t, e) {
    return t.type === e.type && t.key === e.key
}
function SQ(t) { }
const $k = ({ key: t }) => t ?? null
    , lh = ({ ref: t, ref_key: e, ref_for: n }) => (typeof t == "number" && (t = "" + t),
        t != null ? qt(t) || Yt(t) || We(t) ? {
            i: bn,
            r: t,
            k: e,
            f: !!n
        } : t : null);
function Xe(t, e = null, n = null, r = 0, i = null, s = t === Rt ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && $k(e),
        ref: e && lh(e),
        scopeId: rm,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: bn
    };
    return a ? (nv(l, n),
        s & 128 && t.normalize(l)) : n && (l.shapeFlag |= qt(n) ? 8 : 16),
        Ma > 0 && !o && Jn && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Jn.push(l),
        l
}
const $e = q5;
function q5(t, e = null, n = null, r = 0, i = null, s = !1) {
    if ((!t || t === mk) && (t = cn),
        Ra(t)) {
        const a = ui(t, e, !0);
        return n && nv(a, n),
            Ma > 0 && !s && Jn && (a.shapeFlag & 6 ? Jn[Jn.indexOf(t)] = a : Jn.push(a)),
            a.patchFlag = -2,
            a
    }
    if (X5(t) && (t = t.__vccOpts),
        e) {
        e = _i(e);
        let { class: a, style: l } = e;
        a && !qt(a) && (e.class = mt(a)),
            jt(l) && ($y(l) && !Re(l) && (l = Kt({}, l)),
                e.style = Vo(l))
    }
    const o = qt(t) ? 1 : Lh(t) ? 128 : ok(t) ? 64 : jt(t) ? 4 : We(t) ? 2 : 0;
    return Xe(t, e, n, r, i, o, s, !0)
}
function _i(t) {
    return t ? $y(t) || xk(t) ? Kt({}, t) : t : null
}
function ui(t, e, n = !1, r = !1) {
    const { props: i, ref: s, patchFlag: o, children: a, transition: l } = t
        , c = e ? Wt(i || {}, e) : i
        , d = {
            __v_isVNode: !0,
            __v_skip: !0,
            type: t.type,
            props: c,
            key: c && $k(c),
            ref: e && e.ref ? n && s ? Re(s) ? s.concat(lh(e)) : [s, lh(e)] : lh(e) : s,
            scopeId: t.scopeId,
            slotScopeIds: t.slotScopeIds,
            children: a,
            target: t.target,
            targetStart: t.targetStart,
            targetAnchor: t.targetAnchor,
            staticCount: t.staticCount,
            shapeFlag: t.shapeFlag,
            patchFlag: e && t.type !== Rt ? o === -1 ? 16 : o | 16 : o,
            dynamicProps: t.dynamicProps,
            dynamicChildren: t.dynamicChildren,
            appContext: t.appContext,
            dirs: t.dirs,
            transition: l,
            component: t.component,
            suspense: t.suspense,
            ssContent: t.ssContent && ui(t.ssContent),
            ssFallback: t.ssFallback && ui(t.ssFallback),
            el: t.el,
            anchor: t.anchor,
            ctx: t.ctx,
            ce: t.ce
        };
    return l && r && Oo(d, l.clone(d)),
        d
}
function Pa(t = " ", e = 0) {
    return $e(va, null, t, e)
}
function kQ(t, e) {
    const n = $e(Bl, null, t);
    return n.staticCount = e,
        n
}
function pt(t = "", e = !1) {
    return e ? (oe(),
        gt(cn, null, t)) : $e(cn, null, t)
}
function _r(t) {
    return t == null || typeof t == "boolean" ? $e(cn) : Re(t) ? $e(Rt, null, t.slice()) : typeof t == "object" ? oo(t) : $e(va, null, String(t))
}
function oo(t) {
    return t.el === null && t.patchFlag !== -1 || t.memo ? t : ui(t)
}
function nv(t, e) {
    let n = 0;
    const { shapeFlag: r } = t;
    if (e == null)
        e = null;
    else if (Re(e))
        n = 16;
    else if (typeof e == "object")
        if (r & 65) {
            const i = e.default;
            i && (i._c && (i._d = !1),
                nv(t, i()),
                i._c && (i._d = !0));
            return
        } else {
            n = 32;
            const i = e._;
            !i && !xk(e) ? e._ctx = bn : i === 3 && bn && (bn.slots._ === 1 ? e._ = 1 : (e._ = 2,
                t.patchFlag |= 1024))
        }
    else
        We(e) ? (e = {
            default: e,
            _ctx: bn
        },
            n = 32) : (e = String(e),
                r & 64 ? (n = 16,
                    e = [Pa(e)]) : n = 8);
    t.children = e,
        t.shapeFlag |= n
}
function Wt(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        for (const i in r)
            if (i === "class")
                e.class !== r.class && (e.class = mt([e.class, r.class]));
            else if (i === "style")
                e.style = Vo([e.style, r.style]);
            else if (ld(i)) {
                const s = e[i]
                    , o = r[i];
                o && s !== o && !(Re(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o)
            } else
                i !== "" && (e[i] = r[i])
    }
    return e
}
function wr(t, e, n, r = null) {
    Ti(t, e, 7, [n, r])
}
const G5 = vk();
let J5 = 0;
function zk(t, e, n) {
    const r = t.type
        , i = (e ? e.appContext : t.appContext) || G5
        , s = {
            uid: J5++,
            vnode: t,
            type: r,
            parent: e,
            appContext: i,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            job: null,
            scope: new PS(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(i.provides),
            ids: e ? e.ids : ["", 0, 0],
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: Sk(r, i),
            emitsOptions: Ik(r, i),
            emit: null,
            emitted: null,
            propsDefaults: kt,
            inheritAttrs: r.inheritAttrs,
            ctx: kt,
            data: kt,
            props: kt,
            attrs: kt,
            slots: kt,
            refs: kt,
            setupState: kt,
            setupContext: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return s.ctx = {
        _: s
    },
        s.root = e ? e.root : s,
        s.emit = D5.bind(null, s),
        t.ce && t.ce(s),
        s
}
let vn = null;
const pn = () => vn || bn;
let Dh, a1;
{
    const t = AS()
        , e = (n, r) => {
            let i;
            return (i = t[n]) || (i = t[n] = []),
                i.push(r),
                s => {
                    i.length > 1 ? i.forEach(o => o(s)) : i[0](s)
                }
        }
        ;
    Dh = e("__VUE_INSTANCE_SETTERS__", n => vn = n),
        a1 = e("__VUE_SSR_SETTERS__", n => md = n)
}
const Na = t => {
    const e = vn;
    return Dh(t),
        t.scope.on(),
        () => {
            t.scope.off(),
                Dh(e)
        }
}
    , l1 = () => {
        vn && vn.scope.off(),
            Dh(null)
    }
    ;
function Fk(t) {
    return t.vnode.shapeFlag & 4
}
let md = !1;
function Hk(t, e = !1, n = !1) {
    e && a1(e);
    const { props: r, children: i } = t.vnode
        , s = Fk(t);
    S5(t, r, s, e),
        T5(t, i, n);
    const o = s ? Z5(t, e) : void 0;
    return e && a1(!1),
        o
}
function Z5(t, e) {
    const n = t.type;
    t.accessCache = Object.create(null),
        t.proxy = new Proxy(t.ctx, n1);
    const { setup: r } = n;
    if (r) {
        const i = t.setupContext = r.length > 1 ? Wk(t) : null
            , s = Na(t);
        Wo();
        const o = dd(r, t, 0, [t.props, i]);
        if (Uo(),
            s(),
            Py(o)) {
            if (_o(t) || Ky(t),
                o.then(l1, l1),
                e)
                return o.then(a => {
                    u1(t, a, e)
                }
                ).catch(a => {
                    fu(a, t, 0)
                }
                );
            t.asyncDep = o
        } else
            u1(t, o, e)
    } else
        Vk(t, e)
}
function u1(t, e, n) {
    We(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : jt(e) && (t.setupState = ZS(e)),
        Vk(t, n)
}
let jh, c1;
function CQ(t) {
    jh = t,
        c1 = e => {
            e.render._rc && (e.withProxy = new Proxy(e.ctx, h5))
        }
}
const EQ = () => !jh;
function Vk(t, e, n) {
    const r = t.type;
    if (!t.render) {
        if (!e && jh && !r.render) {
            const i = r.template || Xy(t).template;
            if (i) {
                const { isCustomElement: s, compilerOptions: o } = t.appContext.config
                    , { delimiters: a, compilerOptions: l } = r
                    , c = Kt(Kt({
                        isCustomElement: s,
                        delimiters: a
                    }, o), l);
                r.render = jh(i, c)
            }
        }
        t.render = r.render || ii,
            c1 && c1(t)
    }
    {
        const i = Na(t);
        Wo();
        try {
            m5(t)
        } finally {
            Uo(),
                i()
        }
    }
}
const Y5 = {
    get(t, e) {
        return Qn(t, "get", ""),
            t[e]
    }
};
function Wk(t) {
    const e = n => {
        t.exposed = n || {}
    }
        ;
    return {
        attrs: new Proxy(t.attrs, Y5),
        slots: t.slots,
        emit: t.emit,
        expose: e
    }
}
function gd(t) {
    return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(ZS(zy(t.exposed)), {
        get(e, n) {
            if (n in e)
                return e[n];
            if (n in rc)
                return rc[n](t)
        },
        has(e, n) {
            return n in e || n in rc
        }
    })) : t.proxy
}
function d1(t, e = !0) {
    return We(t) ? t.displayName || t.name : t.name || e && t.__name
}
function X5(t) {
    return We(t) && "__vccOpts" in t
}
const G = (t, e) => j4(t, e, md);
function Mt(t, e, n) {
    const r = arguments.length;
    return r === 2 ? jt(e) && !Re(e) ? Ra(e) ? $e(t, null, [e]) : $e(t, e) : $e(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Ra(n) && (n = [n]),
        $e(t, e, n))
}
function TQ() { }
function AQ(t, e, n, r) {
    const i = n[r];
    if (i && Q5(i, t))
        return i;
    const s = e();
    return s.memo = t.slice(),
        s.cacheIndex = r,
        n[r] = s
}
function Q5(t, e) {
    const n = t.memo;
    if (n.length != e.length)
        return !1;
    for (let r = 0; r < n.length; r++)
        if (ur(n[r], e[r]))
            return !1;
    return Ma > 0 && Jn && Jn.push(t),
        !0
}
const eL = "3.5.6"
    , OQ = ii
    , MQ = H4
    , RQ = wl
    , PQ = ik
    , tL = {
        createComponentInstance: zk,
        setupComponent: Hk,
        renderComponentRoot: ah,
        setCurrentRenderingInstance: Cc,
        isVNode: Ra,
        normalizeVNode: _r,
        getComponentPublicInstance: gd,
        ensureValidVNode: Yy,
        pushWarningContext: z4,
        popWarningContext: F4
    }
    , NQ = tL
    , IQ = null
    , LQ = null
    , DQ = null;
/**
* @vue/runtime-dom v3.5.6
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let f1;
const fx = typeof window < "u" && window.trustedTypes;
if (fx)
    try {
        f1 = fx.createPolicy("vue", {
            createHTML: t => t
        })
    } catch { }
const Uk = f1 ? t => f1.createHTML(t) : t => t
    , nL = "http://www.w3.org/2000/svg"
    , rL = "http://www.w3.org/1998/Math/MathML"
    , Ts = typeof document < "u" ? document : null
    , hx = Ts && Ts.createElement("template")
    , iL = {
        insert: (t, e, n) => {
            e.insertBefore(t, n || null)
        }
        ,
        remove: t => {
            const e = t.parentNode;
            e && e.removeChild(t)
        }
        ,
        createElement: (t, e, n, r) => {
            const i = e === "svg" ? Ts.createElementNS(nL, t) : e === "mathml" ? Ts.createElementNS(rL, t) : n ? Ts.createElement(t, {
                is: n
            }) : Ts.createElement(t);
            return t === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple),
                i
        }
        ,
        createText: t => Ts.createTextNode(t),
        createComment: t => Ts.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        }
        ,
        setElementText: (t, e) => {
            t.textContent = e
        }
        ,
        parentNode: t => t.parentNode,
        nextSibling: t => t.nextSibling,
        querySelector: t => Ts.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        insertStaticContent(t, e, n, r, i, s) {
            const o = n ? n.previousSibling : e.lastChild;
            if (i && (i === s || i.nextSibling))
                for (; e.insertBefore(i.cloneNode(!0), n),
                    !(i === s || !(i = i.nextSibling));)
                    ;
            else {
                hx.innerHTML = Uk(r === "svg" ? `<svg>${t}</svg>` : r === "mathml" ? `<math>${t}</math>` : t);
                const a = hx.content;
                if (r === "svg" || r === "mathml") {
                    const l = a.firstChild;
                    for (; l.firstChild;)
                        a.appendChild(l.firstChild);
                    a.removeChild(l)
                }
                e.insertBefore(a, n)
            }
            return [o ? o.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
        }
    }
    , Ys = "transition"
    , Du = "animation"
    , Kl = Symbol("_vtc")
    , Kk = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    }
    , qk = Kt({}, uk, Kk)
    , sL = t => (t.displayName = "Transition",
        t.props = qk,
        t)
    , oL = sL((t, { slots: e }) => Mt(J4, Gk(t), e))
    , oa = (t, e = []) => {
        Re(t) ? t.forEach(n => n(...e)) : t && t(...e)
    }
    , px = t => t ? Re(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;
function Gk(t) {
    const e = {};
    for (const j in t)
        j in Kk || (e[j] = t[j]);
    if (t.css === !1)
        return e;
    const { name: n = "v", type: r, duration: i, enterFromClass: s = `${n}-enter-from`, enterActiveClass: o = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: l = s, appearActiveClass: c = o, appearToClass: d = a, leaveFromClass: h = `${n}-leave-from`, leaveActiveClass: p = `${n}-leave-active`, leaveToClass: g = `${n}-leave-to` } = t
        , y = aL(i)
        , x = y && y[0]
        , S = y && y[1]
        , { onBeforeEnter: k, onEnter: A, onEnterCancelled: C, onLeave: m, onLeaveCancelled: b, onBeforeAppear: w = k, onAppear: T = A, onAppearCancelled: O = C } = e
        , M = (j, z, V) => {
            eo(j, z ? d : a),
                eo(j, z ? c : o),
                V && V()
        }
        , E = (j, z) => {
            j._isLeaving = !1,
                eo(j, h),
                eo(j, g),
                eo(j, p),
                z && z()
        }
        , N = j => (z, V) => {
            const W = j ? T : A
                , P = () => M(z, j, V);
            oa(W, [z, P]),
                mx(() => {
                    eo(z, j ? l : s),
                        Ss(z, j ? d : a),
                        px(W) || gx(z, r, x, P)
                }
                )
        }
        ;
    return Kt(e, {
        onBeforeEnter(j) {
            oa(k, [j]),
                Ss(j, s),
                Ss(j, o)
        },
        onBeforeAppear(j) {
            oa(w, [j]),
                Ss(j, l),
                Ss(j, c)
        },
        onEnter: N(!1),
        onAppear: N(!0),
        onLeave(j, z) {
            j._isLeaving = !0;
            const V = () => E(j, z);
            Ss(j, h),
                Ss(j, p),
                Zk(),
                mx(() => {
                    j._isLeaving && (eo(j, h),
                        Ss(j, g),
                        px(m) || gx(j, r, S, V))
                }
                ),
                oa(m, [j, V])
        },
        onEnterCancelled(j) {
            M(j, !1),
                oa(C, [j])
        },
        onAppearCancelled(j) {
            M(j, !0),
                oa(O, [j])
        },
        onLeaveCancelled(j) {
            E(j),
                oa(b, [j])
        }
    })
}
function aL(t) {
    if (t == null)
        return null;
    if (jt(t))
        return [u0(t.enter), u0(t.leave)];
    {
        const e = u0(t);
        return [e, e]
    }
}
function u0(t) {
    return Eh(t)
}
function Ss(t, e) {
    e.split(/\s+/).forEach(n => n && t.classList.add(n)),
        (t[Kl] || (t[Kl] = new Set)).add(e)
}
function eo(t, e) {
    e.split(/\s+/).forEach(r => r && t.classList.remove(r));
    const n = t[Kl];
    n && (n.delete(e),
        n.size || (t[Kl] = void 0))
}
function mx(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    }
    )
}
let lL = 0;
function gx(t, e, n, r) {
    const i = t._endId = ++lL
        , s = () => {
            i === t._endId && r()
        }
        ;
    if (n)
        return setTimeout(s, n);
    const { type: o, timeout: a, propCount: l } = Jk(t, e);
    if (!o)
        return r();
    const c = o + "end";
    let d = 0;
    const h = () => {
        t.removeEventListener(c, p),
            s()
    }
        , p = g => {
            g.target === t && ++d >= l && h()
        }
        ;
    setTimeout(() => {
        d < l && h()
    }
        , a + 1),
        t.addEventListener(c, p)
}
function Jk(t, e) {
    const n = window.getComputedStyle(t)
        , r = y => (n[y] || "").split(", ")
        , i = r(`${Ys}Delay`)
        , s = r(`${Ys}Duration`)
        , o = yx(i, s)
        , a = r(`${Du}Delay`)
        , l = r(`${Du}Duration`)
        , c = yx(a, l);
    let d = null
        , h = 0
        , p = 0;
    e === Ys ? o > 0 && (d = Ys,
        h = o,
        p = s.length) : e === Du ? c > 0 && (d = Du,
            h = c,
            p = l.length) : (h = Math.max(o, c),
                d = h > 0 ? o > c ? Ys : Du : null,
                p = d ? d === Ys ? s.length : l.length : 0);
    const g = d === Ys && /\b(transform|all)(,|$)/.test(r(`${Ys}Property`).toString());
    return {
        type: d,
        timeout: h,
        propCount: p,
        hasTransform: g
    }
}
function yx(t, e) {
    for (; t.length < e.length;)
        t = t.concat(t);
    return Math.max(...e.map((n, r) => vx(n) + vx(t[r])))
}
function vx(t) {
    return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3
}
function Zk() {
    return document.body.offsetHeight
}
function uL(t, e, n) {
    const r = t[Kl];
    r && (e = (e ? [e, ...r] : [...r]).join(" ")),
        e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
}
const Bh = Symbol("_vod")
    , Yk = Symbol("_vsh")
    , Oc = {
        beforeMount(t, { value: e }, { transition: n }) {
            t[Bh] = t.style.display === "none" ? "" : t.style.display,
                n && e ? n.beforeEnter(t) : ju(t, e)
        },
        mounted(t, { value: e }, { transition: n }) {
            n && e && n.enter(t)
        },
        updated(t, { value: e, oldValue: n }, { transition: r }) {
            !e != !n && (r ? e ? (r.beforeEnter(t),
                ju(t, !0),
                r.enter(t)) : r.leave(t, () => {
                    ju(t, !1)
                }
                ) : ju(t, e))
        },
        beforeUnmount(t, { value: e }) {
            ju(t, e)
        }
    };
function ju(t, e) {
    t.style.display = e ? t[Bh] : "none",
        t[Yk] = !e
}
function cL() {
    Oc.getSSRProps = ({ value: t }) => {
        if (!t)
            return {
                style: {
                    display: "none"
                }
            }
    }
}
const Xk = Symbol("");
function jQ(t) {
    const e = pn();
    if (!e)
        return;
    const n = e.ut = (i = t(e.proxy)) => {
        Array.from(document.querySelectorAll(`[data-v-owner="${e.uid}"]`)).forEach(s => $h(s, i))
    }
        , r = () => {
            const i = t(e.proxy);
            e.ce ? $h(e.ce, i) : h1(e.subTree, i),
                n(i)
        }
        ;
    pk(() => {
        Rk(r)
    }
    ),
        Nt(() => {
            const i = new MutationObserver(r);
            i.observe(e.subTree.el.parentNode, {
                childList: !0
            }),
                xn(() => i.disconnect())
        }
        )
}
function h1(t, e) {
    if (t.shapeFlag & 128) {
        const n = t.suspense;
        t = n.activeBranch,
            n.pendingBranch && !n.isHydrating && n.effects.push(() => {
                h1(n.activeBranch, e)
            }
            )
    }
    for (; t.component;)
        t = t.component.subTree;
    if (t.shapeFlag & 1 && t.el)
        $h(t.el, e);
    else if (t.type === Rt)
        t.children.forEach(n => h1(n, e));
    else if (t.type === Bl) {
        let { el: n, anchor: r } = t;
        for (; n && ($h(n, e),
            n !== r);)
            n = n.nextSibling
    }
}
function $h(t, e) {
    if (t.nodeType === 1) {
        const n = t.style;
        let r = "";
        for (const i in e)
            n.setProperty(`--${i}`, e[i]),
                r += `--${i}: ${e[i]};`;
        n[Xk] = r
    }
}
const dL = /(^|;)\s*display\s*:/;
function fL(t, e, n) {
    const r = t.style
        , i = qt(n);
    let s = !1;
    if (n && !i) {
        if (e)
            if (qt(e))
                for (const o of e.split(";")) {
                    const a = o.slice(0, o.indexOf(":")).trim();
                    n[a] == null && uh(r, a, "")
                }
            else
                for (const o in e)
                    n[o] == null && uh(r, o, "");
        for (const o in n)
            o === "display" && (s = !0),
                uh(r, o, n[o])
    } else if (i) {
        if (e !== n) {
            const o = r[Xk];
            o && (n += ";" + o),
                r.cssText = n,
                s = dL.test(n)
        }
    } else
        e && t.removeAttribute("style");
    Bh in t && (t[Bh] = s ? r.display : "",
        t[Yk] && (r.display = "none"))
}
const bx = /\s*!important$/;
function uh(t, e, n) {
    if (Re(n))
        n.forEach(r => uh(t, e, r));
    else if (n == null && (n = ""),
        e.startsWith("--"))
        t.setProperty(e, n);
    else {
        const r = hL(t, e);
        bx.test(n) ? t.setProperty(kr(r), n.replace(bx, ""), "important") : t[r] = n
    }
}
const wx = ["Webkit", "Moz", "ms"]
    , c0 = {};
function hL(t, e) {
    const n = c0[e];
    if (n)
        return n;
    let r = Fn(e);
    if (r !== "filter" && r in t)
        return c0[e] = r;
    r = Zp(r);
    for (let i = 0; i < wx.length; i++) {
        const s = wx[i] + r;
        if (s in t)
            return c0[e] = s
    }
    return e
}
const xx = "http://www.w3.org/1999/xlink";
function _x(t, e, n, r, i, s = a4(e)) {
    r && e.startsWith("xlink:") ? n == null ? t.removeAttributeNS(xx, e.slice(6, e.length)) : t.setAttributeNS(xx, e, n) : n == null || s && !OS(n) ? t.removeAttribute(e) : t.setAttribute(e, s ? "" : Zi(n) ? String(n) : n)
}
function pL(t, e, n, r) {
    if (e === "innerHTML" || e === "textContent") {
        n != null && (t[e] = e === "innerHTML" ? Uk(n) : n);
        return
    }
    const i = t.tagName;
    if (e === "value" && i !== "PROGRESS" && !i.includes("-")) {
        const o = i === "OPTION" ? t.getAttribute("value") || "" : t.value
            , a = n == null ? t.type === "checkbox" ? "on" : "" : String(n);
        (o !== a || !("_value" in t)) && (t.value = a),
            n == null && t.removeAttribute(e),
            t._value = n;
        return
    }
    let s = !1;
    if (n === "" || n == null) {
        const o = typeof t[e];
        o === "boolean" ? n = OS(n) : n == null && o === "string" ? (n = "",
            s = !0) : o === "number" && (n = 0,
                s = !0)
    }
    try {
        t[e] = n
    } catch { }
    s && t.removeAttribute(e)
}
function Ms(t, e, n, r) {
    t.addEventListener(e, n, r)
}
function mL(t, e, n, r) {
    t.removeEventListener(e, n, r)
}
const Sx = Symbol("_vei");
function gL(t, e, n, r, i = null) {
    const s = t[Sx] || (t[Sx] = {})
        , o = s[e];
    if (r && o)
        o.value = r;
    else {
        const [a, l] = yL(e);
        if (r) {
            const c = s[e] = wL(r, i);
            Ms(t, a, c, l)
        } else
            o && (mL(t, a, o, l),
                s[e] = void 0)
    }
}
const kx = /(?:Once|Passive|Capture)$/;
function yL(t) {
    let e;
    if (kx.test(t)) {
        e = {};
        let r;
        for (; r = t.match(kx);)
            t = t.slice(0, t.length - r[0].length),
                e[r[0].toLowerCase()] = !0
    }
    return [t[2] === ":" ? t.slice(3) : kr(t.slice(2)), e]
}
let d0 = 0;
const vL = Promise.resolve()
    , bL = () => d0 || (vL.then(() => d0 = 0),
        d0 = Date.now());
function wL(t, e) {
    const n = r => {
        if (!r._vts)
            r._vts = Date.now();
        else if (r._vts <= n.attached)
            return;
        Ti(xL(r, n.value), e, 5, [r])
    }
        ;
    return n.value = t,
        n.attached = bL(),
        n
}
function xL(t, e) {
    if (Re(e)) {
        const n = t.stopImmediatePropagation;
        return t.stopImmediatePropagation = () => {
            n.call(t),
                t._stopped = !0
        }
            ,
            e.map(r => i => !i._stopped && r && r(i))
    } else
        return e
}
const Cx = t => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123
    , _L = (t, e, n, r, i, s) => {
        const o = i === "svg";
        e === "class" ? uL(t, r, o) : e === "style" ? fL(t, n, r) : ld(e) ? My(e) || gL(t, e, n, r, s) : (e[0] === "." ? (e = e.slice(1),
            !0) : e[0] === "^" ? (e = e.slice(1),
                !1) : SL(t, e, r, o)) ? (pL(t, e, r),
                    !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && _x(t, e, r, o, s, e !== "value")) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r),
                        _x(t, e, r, o))
    }
    ;
function SL(t, e, n, r) {
    if (r)
        return !!(e === "innerHTML" || e === "textContent" || e in t && Cx(e) && We(n));
    if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA")
        return !1;
    if (e === "width" || e === "height") {
        const i = t.tagName;
        if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
            return !1
    }
    return Cx(e) && qt(n) ? !1 : !!(e in t || t._isVueCE && (/[A-Z]/.test(e) || !qt(n)))
}
const Ex = {};
/*! #__NO_SIDE_EFFECTS__ */
function kL(t, e, n) {
    const r = je(t, e);
    Gp(r) && Kt(r, e);
    class i extends rv {
        constructor(o) {
            super(r, o, n)
        }
    }
    return i.def = r,
        i
}
/*! #__NO_SIDE_EFFECTS__ */
const BQ = (t, e) => kL(t, e, HL)
    , CL = typeof HTMLElement < "u" ? HTMLElement : class {
    }
    ;
class rv extends CL {
    constructor(e, n = {}, r = g1) {
        super(),
            this._def = e,
            this._props = n,
            this._createApp = r,
            this._isVueCE = !0,
            this._instance = null,
            this._app = null,
            this._nonce = this._def.nonce,
            this._connected = !1,
            this._resolved = !1,
            this._numberProps = null,
            this._styleChildren = new WeakSet,
            this._ob = null,
            this.shadowRoot && r !== g1 ? this._root = this.shadowRoot : e.shadowRoot !== !1 ? (this.attachShadow({
                mode: "open"
            }),
                this._root = this.shadowRoot) : this._root = this,
            this._def.__asyncLoader || this._resolveProps(this._def)
    }
    connectedCallback() {
        if (!this.isConnected)
            return;
        this.shadowRoot || this._parseSlots(),
            this._connected = !0;
        let e = this;
        for (; e = e && (e.parentNode || e.host);)
            if (e instanceof rv) {
                this._parent = e;
                break
            }
        this._instance || (this._resolved ? (this._setParent(),
            this._update()) : e && e._pendingResolve ? this._pendingResolve = e._pendingResolve.then(() => {
                this._pendingResolve = void 0,
                    this._resolveDef()
            }
            ) : this._resolveDef())
    }
    _setParent(e = this._parent) {
        e && (this._instance.parent = e._instance,
            this._instance.provides = e._instance.provides)
    }
    disconnectedCallback() {
        this._connected = !1,
            un(() => {
                this._connected || (this._ob && (this._ob.disconnect(),
                    this._ob = null),
                    this._app && this._app.unmount(),
                    this._instance && (this._instance.ce = void 0),
                    this._app = this._instance = null)
            }
            )
    }
    _resolveDef() {
        if (this._pendingResolve)
            return;
        for (let r = 0; r < this.attributes.length; r++)
            this._setAttr(this.attributes[r].name);
        this._ob = new MutationObserver(r => {
            for (const i of r)
                this._setAttr(i.attributeName)
        }
        ),
            this._ob.observe(this, {
                attributes: !0
            });
        const e = (r, i = !1) => {
            this._resolved = !0,
                this._pendingResolve = void 0;
            const { props: s, styles: o } = r;
            let a;
            if (s && !Re(s))
                for (const l in s) {
                    const c = s[l];
                    (c === Number || c && c.type === Number) && (l in this._props && (this._props[l] = Eh(this._props[l])),
                        (a || (a = Object.create(null)))[Fn(l)] = !0)
                }
            this._numberProps = a,
                i && this._resolveProps(r),
                this.shadowRoot && this._applyStyles(o),
                this._mount(r)
        }
            , n = this._def.__asyncLoader;
        n ? this._pendingResolve = n().then(r => e(this._def = r, !0)) : e(this._def)
    }
    _mount(e) {
        this._app = this._createApp(e),
            e.configureApp && e.configureApp(this._app),
            this._app._ceVNode = this._createVNode(),
            this._app.mount(this._root);
        const n = this._instance && this._instance.exposed;
        if (n)
            for (const r in n)
                Ot(this, r) || Object.defineProperty(this, r, {
                    get: () => ie(n[r])
                })
    }
    _resolveProps(e) {
        const { props: n } = e
            , r = Re(n) ? n : Object.keys(n || {});
        for (const i of Object.keys(this))
            i[0] !== "_" && r.includes(i) && this._setProp(i, this[i]);
        for (const i of r.map(Fn))
            Object.defineProperty(this, i, {
                get() {
                    return this._getProp(i)
                },
                set(s) {
                    this._setProp(i, s, !0, !0)
                }
            })
    }
    _setAttr(e) {
        if (e.startsWith("data-v-"))
            return;
        const n = this.hasAttribute(e);
        let r = n ? this.getAttribute(e) : Ex;
        const i = Fn(e);
        n && this._numberProps && this._numberProps[i] && (r = Eh(r)),
            this._setProp(i, r, !1, !0)
    }
    _getProp(e) {
        return this._props[e]
    }
    _setProp(e, n, r = !0, i = !1) {
        n !== this._props[e] && (n === Ex ? delete this._props[e] : (this._props[e] = n,
            e === "key" && this._app && (this._app._ceVNode.key = n)),
            i && this._instance && this._update(),
            r && (n === !0 ? this.setAttribute(kr(e), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(kr(e), n + "") : n || this.removeAttribute(kr(e))))
    }
    _update() {
        FL(this._createVNode(), this._root)
    }
    _createVNode() {
        const e = {};
        this.shadowRoot || (e.onVnodeMounted = e.onVnodeUpdated = this._renderSlots.bind(this));
        const n = $e(this._def, Kt(e, this._props));
        return this._instance || (n.ce = r => {
            this._instance = r,
                r.ce = this,
                r.isCE = !0;
            const i = (s, o) => {
                this.dispatchEvent(new CustomEvent(s, Gp(o[0]) ? Kt({
                    detail: o
                }, o[0]) : {
                    detail: o
                }))
            }
                ;
            r.emit = (s, ...o) => {
                i(s, o),
                    kr(s) !== s && i(kr(s), o)
            }
                ,
                this._setParent()
        }
        ),
            n
    }
    _applyStyles(e, n) {
        if (!e)
            return;
        if (n) {
            if (n === this._def || this._styleChildren.has(n))
                return;
            this._styleChildren.add(n)
        }
        const r = this._nonce;
        for (let i = e.length - 1; i >= 0; i--) {
            const s = document.createElement("style");
            r && s.setAttribute("nonce", r),
                s.textContent = e[i],
                this.shadowRoot.prepend(s)
        }
    }
    _parseSlots() {
        const e = this._slots = {};
        let n;
        for (; n = this.firstChild;) {
            const r = n.nodeType === 1 && n.getAttribute("slot") || "default";
            (e[r] || (e[r] = [])).push(n),
                this.removeChild(n)
        }
    }
    _renderSlots() {
        const e = (this._teleportTarget || this).querySelectorAll("slot")
            , n = this._instance.type.__scopeId;
        for (let r = 0; r < e.length; r++) {
            const i = e[r]
                , s = i.getAttribute("name") || "default"
                , o = this._slots[s]
                , a = i.parentNode;
            if (o)
                for (const l of o) {
                    if (n && l.nodeType === 1) {
                        const c = n + "-s"
                            , d = document.createTreeWalker(l, 1);
                        l.setAttribute(c, "");
                        let h;
                        for (; h = d.nextNode();)
                            h.setAttribute(c, "")
                    }
                    a.insertBefore(l, i)
                }
            else
                for (; i.firstChild;)
                    a.insertBefore(i.firstChild, i);
            a.removeChild(i)
        }
    }
    _injectChildStyle(e) {
        this._applyStyles(e.styles, e)
    }
    _removeChildStyle(e) { }
}
function EL(t) {
    const e = pn()
        , n = e && e.ce;
    return n || null
}
function $Q() {
    const t = EL();
    return t && t.shadowRoot
}
function zQ(t = "$style") {
    {
        const e = pn();
        if (!e)
            return kt;
        const n = e.type.__cssModules;
        if (!n)
            return kt;
        const r = n[t];
        return r || kt
    }
}
const Qk = new WeakMap
    , eC = new WeakMap
    , zh = Symbol("_moveCb")
    , Tx = Symbol("_enterCb")
    , TL = t => (delete t.props.mode,
        t)
    , AL = TL({
        name: "TransitionGroup",
        props: Kt({}, qk, {
            tag: String,
            moveClass: String
        }),
        setup(t, { slots: e }) {
            const n = pn()
                , r = lk();
            let i, s;
            return qy(() => {
                if (!i.length)
                    return;
                const o = t.moveClass || `${t.name || "v"}-move`;
                if (!NL(i[0].el, n.vnode.el, o))
                    return;
                i.forEach(ML),
                    i.forEach(RL);
                const a = i.filter(PL);
                Zk(),
                    a.forEach(l => {
                        const c = l.el
                            , d = c.style;
                        Ss(c, o),
                            d.transform = d.webkitTransform = d.transitionDuration = "";
                        const h = c[zh] = p => {
                            p && p.target !== c || (!p || /transform$/.test(p.propertyName)) && (c.removeEventListener("transitionend", h),
                                c[zh] = null,
                                eo(c, o))
                        }
                            ;
                        c.addEventListener("transitionend", h)
                    }
                    )
            }
            ),
                () => {
                    const o = it(t)
                        , a = Gk(o);
                    let l = o.tag || Rt;
                    if (i = [],
                        s)
                        for (let c = 0; c < s.length; c++) {
                            const d = s[c];
                            d.el && d.el instanceof Element && (i.push(d),
                                Oo(d, Ec(d, a, r, n)),
                                Qk.set(d, d.el.getBoundingClientRect()))
                        }
                    s = e.default ? Uy(e.default()) : [];
                    for (let c = 0; c < s.length; c++) {
                        const d = s[c];
                        d.key != null && Oo(d, Ec(d, a, r, n))
                    }
                    return $e(l, null, s)
                }
        }
    })
    , OL = AL;
function ML(t) {
    const e = t.el;
    e[zh] && e[zh](),
        e[Tx] && e[Tx]()
}
function RL(t) {
    eC.set(t, t.el.getBoundingClientRect())
}
function PL(t) {
    const e = Qk.get(t)
        , n = eC.get(t)
        , r = e.left - n.left
        , i = e.top - n.top;
    if (r || i) {
        const s = t.el.style;
        return s.transform = s.webkitTransform = `translate(${r}px,${i}px)`,
            s.transitionDuration = "0s",
            t
    }
}
function NL(t, e, n) {
    const r = t.cloneNode()
        , i = t[Kl];
    i && i.forEach(a => {
        a.split(/\s+/).forEach(l => l && r.classList.remove(l))
    }
    ),
        n.split(/\s+/).forEach(a => a && r.classList.add(a)),
        r.style.display = "none";
    const s = e.nodeType === 1 ? e : e.parentNode;
    s.appendChild(r);
    const { hasTransform: o } = Jk(r);
    return s.removeChild(r),
        o
}
const Mo = t => {
    const e = t.props["onUpdate:modelValue"] || !1;
    return Re(e) ? n => Ll(e, n) : e
}
    ;
function IL(t) {
    t.target.composing = !0
}
function Ax(t) {
    const e = t.target;
    e.composing && (e.composing = !1,
        e.dispatchEvent(new Event("input")))
}
const oi = Symbol("_assign")
    , p1 = {
        created(t, { modifiers: { lazy: e, trim: n, number: r } }, i) {
            t[oi] = Mo(i);
            const s = r || i.props && i.props.type === "number";
            Ms(t, e ? "change" : "input", o => {
                if (o.target.composing)
                    return;
                let a = t.value;
                n && (a = a.trim()),
                    s && (a = Ch(a)),
                    t[oi](a)
            }
            ),
                n && Ms(t, "change", () => {
                    t.value = t.value.trim()
                }
                ),
                e || (Ms(t, "compositionstart", IL),
                    Ms(t, "compositionend", Ax),
                    Ms(t, "change", Ax))
        },
        mounted(t, { value: e }) {
            t.value = e ?? ""
        },
        beforeUpdate(t, { value: e, oldValue: n, modifiers: { lazy: r, trim: i, number: s } }, o) {
            if (t[oi] = Mo(o),
                t.composing)
                return;
            const a = (s || t.type === "number") && !/^0\d/.test(t.value) ? Ch(t.value) : t.value
                , l = e ?? "";
            a !== l && (document.activeElement === t && t.type !== "range" && (r && e === n || i && t.value.trim() === l) || (t.value = l))
        }
    }
    , tC = {
        deep: !0,
        created(t, e, n) {
            t[oi] = Mo(n),
                Ms(t, "change", () => {
                    const r = t._modelValue
                        , i = ql(t)
                        , s = t.checked
                        , o = t[oi];
                    if (Re(r)) {
                        const a = Yp(r, i)
                            , l = a !== -1;
                        if (s && !l)
                            o(r.concat(i));
                        else if (!s && l) {
                            const c = [...r];
                            c.splice(a, 1),
                                o(c)
                        }
                    } else if (Va(r)) {
                        const a = new Set(r);
                        s ? a.add(i) : a.delete(i),
                            o(a)
                    } else
                        o(rC(t, s))
                }
                )
        },
        mounted: Ox,
        beforeUpdate(t, e, n) {
            t[oi] = Mo(n),
                Ox(t, e, n)
        }
    };
function Ox(t, { value: e, oldValue: n }, r) {
    t._modelValue = e;
    let i;
    Re(e) ? i = Yp(e, r.props.value) > -1 : Va(e) ? i = e.has(r.props.value) : i = Ao(e, rC(t, !0)),
        t.checked !== i && (t.checked = i)
}
const nC = {
    created(t, { value: e }, n) {
        t.checked = Ao(e, n.props.value),
            t[oi] = Mo(n),
            Ms(t, "change", () => {
                t[oi](ql(t))
            }
            )
    },
    beforeUpdate(t, { value: e, oldValue: n }, r) {
        t[oi] = Mo(r),
            e !== n && (t.checked = Ao(e, r.props.value))
    }
}
    , LL = {
        deep: !0,
        created(t, { value: e, modifiers: { number: n } }, r) {
            const i = Va(e);
            Ms(t, "change", () => {
                const s = Array.prototype.filter.call(t.options, o => o.selected).map(o => n ? Ch(ql(o)) : ql(o));
                t[oi](t.multiple ? i ? new Set(s) : s : s[0]),
                    t._assigning = !0,
                    un(() => {
                        t._assigning = !1
                    }
                    )
            }
            ),
                t[oi] = Mo(r)
        },
        mounted(t, { value: e, modifiers: { number: n } }) {
            Mx(t, e)
        },
        beforeUpdate(t, e, n) {
            t[oi] = Mo(n)
        },
        updated(t, { value: e, modifiers: { number: n } }) {
            t._assigning || Mx(t, e)
        }
    };
function Mx(t, e, n) {
    const r = t.multiple
        , i = Re(e);
    if (!(r && !i && !Va(e))) {
        for (let s = 0, o = t.options.length; s < o; s++) {
            const a = t.options[s]
                , l = ql(a);
            if (r)
                if (i) {
                    const c = typeof l;
                    c === "string" || c === "number" ? a.selected = e.some(d => String(d) === String(l)) : a.selected = Yp(e, l) > -1
                } else
                    a.selected = e.has(l);
            else if (Ao(ql(a), e)) {
                t.selectedIndex !== s && (t.selectedIndex = s);
                return
            }
        }
        !r && t.selectedIndex !== -1 && (t.selectedIndex = -1)
    }
}
function ql(t) {
    return "_value" in t ? t._value : t.value
}
function rC(t, e) {
    const n = e ? "_trueValue" : "_falseValue";
    return n in t ? t[n] : e
}
const DL = {
    created(t, e, n) {
        Pf(t, e, n, null, "created")
    },
    mounted(t, e, n) {
        Pf(t, e, n, null, "mounted")
    },
    beforeUpdate(t, e, n, r) {
        Pf(t, e, n, r, "beforeUpdate")
    },
    updated(t, e, n, r) {
        Pf(t, e, n, r, "updated")
    }
};
function iC(t, e) {
    switch (t) {
        case "SELECT":
            return LL;
        case "TEXTAREA":
            return p1;
        default:
            switch (e) {
                case "checkbox":
                    return tC;
                case "radio":
                    return nC;
                default:
                    return p1
            }
    }
}
function Pf(t, e, n, r, i) {
    const o = iC(t.tagName, n.props && n.props.type)[i];
    o && o(t, e, n, r)
}
function jL() {
    p1.getSSRProps = ({ value: t }) => ({
        value: t
    }),
        nC.getSSRProps = ({ value: t }, e) => {
            if (e.props && Ao(e.props.value, t))
                return {
                    checked: !0
                }
        }
        ,
        tC.getSSRProps = ({ value: t }, e) => {
            if (Re(t)) {
                if (e.props && Yp(t, e.props.value) > -1)
                    return {
                        checked: !0
                    }
            } else if (Va(t)) {
                if (e.props && t.has(e.props.value))
                    return {
                        checked: !0
                    }
            } else if (t)
                return {
                    checked: !0
                }
        }
        ,
        DL.getSSRProps = (t, e) => {
            if (typeof e.type != "string")
                return;
            const n = iC(e.type.toUpperCase(), e.props && e.props.type);
            if (n.getSSRProps)
                return n.getSSRProps(t, e)
        }
}
const BL = ["ctrl", "shift", "alt", "meta"]
    , $L = {
        stop: t => t.stopPropagation(),
        prevent: t => t.preventDefault(),
        self: t => t.target !== t.currentTarget,
        ctrl: t => !t.ctrlKey,
        shift: t => !t.shiftKey,
        alt: t => !t.altKey,
        meta: t => !t.metaKey,
        left: t => "button" in t && t.button !== 0,
        middle: t => "button" in t && t.button !== 1,
        right: t => "button" in t && t.button !== 2,
        exact: (t, e) => BL.some(n => t[`${n}Key`] && !e.includes(n))
    }
    , m1 = (t, e) => {
        const n = t._withMods || (t._withMods = {})
            , r = e.join(".");
        return n[r] || (n[r] = (i, ...s) => {
            for (let o = 0; o < e.length; o++) {
                const a = $L[e[o]];
                if (a && a(i, e))
                    return
            }
            return t(i, ...s)
        }
        )
    }
    , zL = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    }
    , FQ = (t, e) => {
        const n = t._withKeys || (t._withKeys = {})
            , r = e.join(".");
        return n[r] || (n[r] = i => {
            if (!("key" in i))
                return;
            const s = kr(i.key);
            if (e.some(o => o === s || zL[o] === s))
                return t(i)
        }
        )
    }
    , sC = Kt({
        patchProp: _L
    }, iL);
let sc, Rx = !1;
function oC() {
    return sc || (sc = O5(sC))
}
function aC() {
    return sc = Rx ? sc : M5(sC),
        Rx = !0,
        sc
}
const FL = (...t) => {
    oC().render(...t)
}
    , HQ = (...t) => {
        aC().hydrate(...t)
    }
    , g1 = (...t) => {
        const e = oC().createApp(...t)
            , { mount: n } = e;
        return e.mount = r => {
            const i = uC(r);
            if (!i)
                return;
            const s = e._component;
            !We(s) && !s.render && !s.template && (s.template = i.innerHTML),
                i.nodeType === 1 && (i.textContent = "");
            const o = n(i, !1, lC(i));
            return i instanceof Element && (i.removeAttribute("v-cloak"),
                i.setAttribute("data-v-app", "")),
                o
        }
            ,
            e
    }
    , HL = (...t) => {
        const e = aC().createApp(...t)
            , { mount: n } = e;
        return e.mount = r => {
            const i = uC(r);
            if (i)
                return n(i, !0, lC(i))
        }
            ,
            e
    }
    ;
function lC(t) {
    if (t instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && t instanceof MathMLElement)
        return "mathml"
}
function uC(t) {
    return qt(t) ? document.querySelector(t) : t
}
let Px = !1;
const VQ = () => {
    Px || (Px = !0,
        jL(),
        cL())
}
    ;
var VL = !1;
/*!
 * pinia v2.2.2
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
let cC;
const lm = t => cC = t
    , dC = Symbol();
function y1(t) {
    return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function"
}
var oc;
(function (t) {
    t.direct = "direct",
        t.patchObject = "patch object",
        t.patchFunction = "patch function"
}
)(oc || (oc = {}));
function WL() {
    const t = Iy(!0)
        , e = t.run(() => ce({}));
    let n = []
        , r = [];
    const i = zy({
        install(s) {
            lm(i),
                i._a = s,
                s.provide(dC, i),
                s.config.globalProperties.$pinia = i,
                r.forEach(o => n.push(o)),
                r = []
        },
        use(s) {
            return !this._a && !VL ? r.push(s) : n.push(s),
                this
        },
        _p: n,
        _a: null,
        _e: t,
        _s: new Map,
        state: e
    });
    return i
}
const fC = () => { }
    ;
function Nx(t, e, n, r = fC) {
    t.push(e);
    const i = () => {
        const s = t.indexOf(e);
        s > -1 && (t.splice(s, 1),
            r())
    }
        ;
    return !n && ud() && cd(i),
        i
}
function hl(t, ...e) {
    t.slice().forEach(n => {
        n(...e)
    }
    )
}
const UL = t => t()
    , Ix = Symbol()
    , f0 = Symbol();
function v1(t, e) {
    t instanceof Map && e instanceof Map ? e.forEach((n, r) => t.set(r, n)) : t instanceof Set && e instanceof Set && e.forEach(t.add, t);
    for (const n in e) {
        if (!e.hasOwnProperty(n))
            continue;
        const r = e[n]
            , i = t[n];
        y1(i) && y1(r) && t.hasOwnProperty(n) && !Yt(r) && !Ui(r) ? t[n] = v1(i, r) : t[n] = r
    }
    return t
}
const KL = Symbol();
function qL(t) {
    return !y1(t) || !t.hasOwnProperty(KL)
}
const { assign: to } = Object;
function GL(t) {
    return !!(Yt(t) && t.effect)
}
function JL(t, e, n, r) {
    const { state: i, actions: s, getters: o } = e
        , a = n.state.value[t];
    let l;
    function c() {
        a || (n.state.value[t] = i ? i() : {});
        const d = Hy(n.state.value[t]);
        return to(d, s, Object.keys(o || {}).reduce((h, p) => (h[p] = zy(G(() => {
            lm(n);
            const g = n._s.get(t);
            return o[p].call(g, g)
        }
        )),
            h), {}))
    }
    return l = hC(t, c, e, n, r, !0),
        l
}
function hC(t, e, n = {}, r, i, s) {
    let o;
    const a = to({
        actions: {}
    }, n)
        , l = {
            deep: !0
        };
    let c, d, h = [], p = [], g;
    const y = r.state.value[t];
    !s && !y && (r.state.value[t] = {}),
        ce({});
    let x;
    function S(O) {
        let M;
        c = d = !1,
            typeof O == "function" ? (O(r.state.value[t]),
                M = {
                    type: oc.patchFunction,
                    storeId: t,
                    events: g
                }) : (v1(r.state.value[t], O),
                    M = {
                        type: oc.patchObject,
                        payload: O,
                        storeId: t,
                        events: g
                    });
        const E = x = Symbol();
        un().then(() => {
            x === E && (c = !0)
        }
        ),
            d = !0,
            hl(h, M, r.state.value[t])
    }
    const k = s ? function () {
        const { state: M } = n
            , E = M ? M() : {};
        this.$patch(N => {
            to(N, E)
        }
        )
    }
        : fC;
    function A() {
        o.stop(),
            h = [],
            p = [],
            r._s.delete(t)
    }
    const C = (O, M = "") => {
        if (Ix in O)
            return O[f0] = M,
                O;
        const E = function () {
            lm(r);
            const N = Array.from(arguments)
                , j = []
                , z = [];
            function V(F) {
                j.push(F)
            }
            function W(F) {
                z.push(F)
            }
            hl(p, {
                args: N,
                name: E[f0],
                store: b,
                after: V,
                onError: W
            });
            let P;
            try {
                P = O.apply(this && this.$id === t ? this : b, N)
            } catch (F) {
                throw hl(z, F),
                F
            }
            return P instanceof Promise ? P.then(F => (hl(j, F),
                F)).catch(F => (hl(z, F),
                    Promise.reject(F))) : (hl(j, P),
                        P)
        };
        return E[Ix] = !0,
            E[f0] = M,
            E
    }
        , m = {
            _p: r,
            $id: t,
            $onAction: Nx.bind(null, p),
            $patch: S,
            $reset: k,
            $subscribe(O, M = {}) {
                const E = Nx(h, O, M.detached, () => N())
                    , N = o.run(() => vt(() => r.state.value[t], j => {
                        (M.flush === "sync" ? d : c) && O({
                            storeId: t,
                            type: oc.direct,
                            events: g
                        }, j)
                    }
                        , to({}, l, M)));
                return E
            },
            $dispose: A
        }
        , b = wn(m);
    r._s.set(t, b);
    const T = (r._a && r._a.runWithContext || UL)(() => r._e.run(() => (o = Iy()).run(() => e({
        action: C
    }))));
    for (const O in T) {
        const M = T[O];
        if (Yt(M) && !GL(M) || Ui(M))
            s || (y && qL(M) && (Yt(M) ? M.value = y[O] : v1(M, y[O])),
                r.state.value[t][O] = M);
        else if (typeof M == "function") {
            const E = C(M, O);
            T[O] = E,
                a.actions[O] = M
        }
    }
    return to(b, T),
        to(it(b), T),
        Object.defineProperty(b, "$state", {
            get: () => r.state.value[t],
            set: O => {
                S(M => {
                    to(M, O)
                }
                )
            }
        }),
        r._p.forEach(O => {
            to(b, o.run(() => O({
                store: b,
                app: r._a,
                pinia: r,
                options: a
            })))
        }
        ),
        y && s && n.hydrate && n.hydrate(b.$state, y),
        c = !0,
        d = !0,
        b
}
function um(t, e, n) {
    let r, i;
    const s = typeof e == "function";
    typeof t == "string" ? (r = t,
        i = s ? n : e) : (i = t,
            r = t.id);
    function o(a, l) {
        const c = _5();
        return a = a || (c ? Dt(dC, null) : null),
            a && lm(a),
            a = cC,
            a._s.has(r) || (s ? hC(r, e, i, a) : JL(r, i, a)),
            a._s.get(r)
    }
    return o.$id = r,
        o
}
function WQ(t) {
    {
        t = it(t);
        const e = {};
        for (const n in t) {
            const r = t[n];
            (Yt(r) || Ui(r)) && (e[n] = XS(t, n))
        }
        return e
    }
}
const Ua = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r, i] of e)
        n[r] = i;
    return n
}
    ;
function pl(t, e, n) {
    let r = n.initialDeps ?? [], i;
    return () => {
        var s, o, a, l;
        let c;
        n.key && ((s = n.debug) != null && s.call(n)) && (c = Date.now());
        const d = t();
        if (!(d.length !== r.length || d.some((g, y) => r[y] !== g)))
            return i;
        r = d;
        let p;
        if (n.key && ((o = n.debug) != null && o.call(n)) && (p = Date.now()),
            i = e(...d),
            n.key && ((a = n.debug) != null && a.call(n))) {
            const g = Math.round((Date.now() - c) * 100) / 100
                , y = Math.round((Date.now() - p) * 100) / 100
                , x = y / 16
                , S = (k, A) => {
                    for (k = String(k); k.length < A;)
                        k = " " + k;
                    return k
                }
                ;
            console.info(`%c ${S(y, 5)} /${S(g, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * x, 120))}deg 100% 31%);`, n?.key)
        }
        return (l = n?.onChange) == null || l.call(n, i),
            i
    }
}
function h0(t, e) {
    if (t === void 0)
        throw new Error(`Unexpected undefined${e ? `: ${e}` : ""}`);
    return t
}
const ZL = (t, e) => Math.abs(t - e) < 1
    , YL = (t, e, n) => {
        let r;
        return function (...i) {
            t.clearTimeout(r),
                r = t.setTimeout(() => e.apply(this, i), n)
        }
    }
    , XL = t => t
    , QL = t => {
        const e = Math.max(t.startIndex - t.overscan, 0)
            , n = Math.min(t.endIndex + t.overscan, t.count - 1)
            , r = [];
        for (let i = e; i <= n; i++)
            r.push(i);
        return r
    }
    , eD = (t, e) => {
        const n = t.scrollElement;
        if (!n)
            return;
        const r = t.targetWindow;
        if (!r)
            return;
        const i = o => {
            const { width: a, height: l } = o;
            e({
                width: Math.round(a),
                height: Math.round(l)
            })
        }
            ;
        if (i(n.getBoundingClientRect()),
            !r.ResizeObserver)
            return () => { }
                ;
        const s = new r.ResizeObserver(o => {
            const a = o[0];
            if (a?.borderBoxSize) {
                const l = a.borderBoxSize[0];
                if (l) {
                    i({
                        width: l.inlineSize,
                        height: l.blockSize
                    });
                    return
                }
            }
            i(n.getBoundingClientRect())
        }
        );
        return s.observe(n, {
            box: "border-box"
        }),
            () => {
                s.unobserve(n)
            }
    }
    , Lx = {
        passive: !0
    }
    , tD = typeof window > "u" ? !0 : "onscrollend" in window
    , nD = (t, e) => {
        const n = t.scrollElement;
        if (!n)
            return;
        const r = t.targetWindow;
        if (!r)
            return;
        let i = 0;
        const s = tD ? () => { }
            : YL(r, () => {
                e(i, !1)
            }
                , t.options.isScrollingResetDelay)
            , o = c => () => {
                const { horizontal: d, isRtl: h } = t.options;
                i = d ? n.scrollLeft * (h && -1 || 1) : n.scrollTop,
                    s(),
                    e(i, c)
            }
            , a = o(!0)
            , l = o(!1);
        return l(),
            n.addEventListener("scroll", a, Lx),
            n.addEventListener("scrollend", l, Lx),
            () => {
                n.removeEventListener("scroll", a),
                    n.removeEventListener("scrollend", l)
            }
    }
    , rD = (t, e, n) => {
        if (e?.borderBoxSize) {
            const r = e.borderBoxSize[0];
            if (r)
                return Math.round(r[n.options.horizontal ? "inlineSize" : "blockSize"])
        }
        return Math.round(t.getBoundingClientRect()[n.options.horizontal ? "width" : "height"])
    }
    , iD = (t, { adjustments: e = 0, behavior: n }, r) => {
        var i, s;
        const o = t + e;
        (s = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null || s.call(i, {
            [r.options.horizontal ? "left" : "top"]: o,
            behavior: n
        })
    }
    ;
class sD {
    constructor(e) {
        this.unsubs = [],
            this.scrollElement = null,
            this.targetWindow = null,
            this.isScrolling = !1,
            this.scrollToIndexTimeoutId = null,
            this.measurementsCache = [],
            this.itemSizeCache = new Map,
            this.pendingMeasuredCacheIndexes = [],
            this.scrollRect = null,
            this.scrollOffset = null,
            this.scrollDirection = null,
            this.scrollAdjustments = 0,
            this.elementsCache = new Map,
            this.observer = (() => {
                let n = null;
                const r = () => n || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : n = new this.targetWindow.ResizeObserver(i => {
                    i.forEach(s => {
                        this._measureElement(s.target, s)
                    }
                    )
                }
                ));
                return {
                    disconnect: () => {
                        var i;
                        (i = r()) == null || i.disconnect(),
                            n = null
                    }
                    ,
                    observe: i => {
                        var s;
                        return (s = r()) == null ? void 0 : s.observe(i, {
                            box: "border-box"
                        })
                    }
                    ,
                    unobserve: i => {
                        var s;
                        return (s = r()) == null ? void 0 : s.unobserve(i)
                    }
                }
            }
            )(),
            this.range = null,
            this.setOptions = n => {
                Object.entries(n).forEach(([r, i]) => {
                    typeof i > "u" && delete n[r]
                }
                ),
                    this.options = {
                        debug: !1,
                        initialOffset: 0,
                        overscan: 1,
                        paddingStart: 0,
                        paddingEnd: 0,
                        scrollPaddingStart: 0,
                        scrollPaddingEnd: 0,
                        horizontal: !1,
                        getItemKey: XL,
                        rangeExtractor: QL,
                        onChange: () => { }
                        ,
                        measureElement: rD,
                        initialRect: {
                            width: 0,
                            height: 0
                        },
                        scrollMargin: 0,
                        gap: 0,
                        indexAttribute: "data-index",
                        initialMeasurementsCache: [],
                        lanes: 1,
                        isScrollingResetDelay: 150,
                        enabled: !0,
                        isRtl: !1,
                        ...n
                    }
            }
            ,
            this.notify = n => {
                var r, i;
                (i = (r = this.options).onChange) == null || i.call(r, this, n)
            }
            ,
            this.maybeNotify = pl(() => (this.calculateRange(),
                [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]), n => {
                    this.notify(n)
                }
                , {
                    key: !1,
                    debug: () => this.options.debug,
                    initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]
                }),
            this.cleanup = () => {
                this.unsubs.filter(Boolean).forEach(n => n()),
                    this.unsubs = [],
                    this.observer.disconnect(),
                    this.scrollElement = null,
                    this.targetWindow = null
            }
            ,
            this._didMount = () => () => {
                this.cleanup()
            }
            ,
            this._willUpdate = () => {
                var n;
                const r = this.options.enabled ? this.options.getScrollElement() : null;
                if (this.scrollElement !== r) {
                    if (this.cleanup(),
                        !r) {
                        this.maybeNotify();
                        return
                    }
                    this.scrollElement = r,
                        this.scrollElement && "ownerDocument" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((n = this.scrollElement) == null ? void 0 : n.window) ?? null,
                        this.elementsCache.forEach(i => {
                            this.observer.observe(i)
                        }
                        ),
                        this._scrollToOffset(this.getScrollOffset(), {
                            adjustments: void 0,
                            behavior: void 0
                        }),
                        this.unsubs.push(this.options.observeElementRect(this, i => {
                            this.scrollRect = i,
                                this.maybeNotify()
                        }
                        )),
                        this.unsubs.push(this.options.observeElementOffset(this, (i, s) => {
                            this.scrollAdjustments = 0,
                                this.scrollDirection = s ? this.getScrollOffset() < i ? "forward" : "backward" : null,
                                this.scrollOffset = i,
                                this.isScrolling = s,
                                this.maybeNotify()
                        }
                        ))
                }
            }
            ,
            this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect,
                this.scrollRect[this.options.horizontal ? "width" : "height"]) : (this.scrollRect = null,
                    0),
            this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == "function" ? this.options.initialOffset() : this.options.initialOffset),
                this.scrollOffset) : (this.scrollOffset = null,
                    0),
            this.getFurthestMeasurement = (n, r) => {
                const i = new Map
                    , s = new Map;
                for (let o = r - 1; o >= 0; o--) {
                    const a = n[o];
                    if (i.has(a.lane))
                        continue;
                    const l = s.get(a.lane);
                    if (l == null || a.end > l.end ? s.set(a.lane, a) : a.end < l.end && i.set(a.lane, !0),
                        i.size === this.options.lanes)
                        break
                }
                return s.size === this.options.lanes ? Array.from(s.values()).sort((o, a) => o.end === a.end ? o.index - a.index : o.end - a.end)[0] : void 0
            }
            ,
            this.getMeasurementOptions = pl(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey, this.options.enabled], (n, r, i, s, o) => (this.pendingMeasuredCacheIndexes = [],
            {
                count: n,
                paddingStart: r,
                scrollMargin: i,
                getItemKey: s,
                enabled: o
            }), {
                key: !1
            }),
            this.getMeasurements = pl(() => [this.getMeasurementOptions(), this.itemSizeCache], ({ count: n, paddingStart: r, scrollMargin: i, getItemKey: s, enabled: o }, a) => {
                if (!o)
                    return this.measurementsCache = [],
                        this.itemSizeCache.clear(),
                        [];
                this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache,
                    this.measurementsCache.forEach(d => {
                        this.itemSizeCache.set(d.key, d.size)
                    }
                    ));
                const l = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
                this.pendingMeasuredCacheIndexes = [];
                const c = this.measurementsCache.slice(0, l);
                for (let d = l; d < n; d++) {
                    const h = s(d)
                        , p = this.options.lanes === 1 ? c[d - 1] : this.getFurthestMeasurement(c, d)
                        , g = p ? p.end + this.options.gap : r + i
                        , y = a.get(h)
                        , x = typeof y == "number" ? y : this.options.estimateSize(d)
                        , S = g + x
                        , k = p ? p.lane : d % this.options.lanes;
                    c[d] = {
                        index: d,
                        start: g,
                        size: x,
                        end: S,
                        key: h,
                        lane: k
                    }
                }
                return this.measurementsCache = c,
                    c
            }
                , {
                    key: !1,
                    debug: () => this.options.debug
                }),
            this.calculateRange = pl(() => [this.getMeasurements(), this.getSize(), this.getScrollOffset()], (n, r, i) => this.range = n.length > 0 && r > 0 ? oD({
                measurements: n,
                outerSize: r,
                scrollOffset: i
            }) : null, {
                key: !1,
                debug: () => this.options.debug
            }),
            this.getIndexes = pl(() => [this.options.rangeExtractor, this.calculateRange(), this.options.overscan, this.options.count], (n, r, i, s) => r === null ? [] : n({
                startIndex: r.startIndex,
                endIndex: r.endIndex,
                overscan: i,
                count: s
            }), {
                key: !1,
                debug: () => this.options.debug
            }),
            this.indexFromElement = n => {
                const r = this.options.indexAttribute
                    , i = n.getAttribute(r);
                return i ? parseInt(i, 10) : (console.warn(`Missing attribute name '${r}={index}' on measured element.`),
                    -1)
            }
            ,
            this._measureElement = (n, r) => {
                const i = this.indexFromElement(n)
                    , s = this.measurementsCache[i];
                if (!s)
                    return;
                const o = s.key
                    , a = this.elementsCache.get(o);
                a !== n && (a && this.observer.unobserve(a),
                    this.observer.observe(n),
                    this.elementsCache.set(o, n)),
                    n.isConnected && this.resizeItem(i, this.options.measureElement(n, r, this))
            }
            ,
            this.resizeItem = (n, r) => {
                const i = this.measurementsCache[n];
                if (!i)
                    return;
                const s = this.itemSizeCache.get(i.key) ?? i.size
                    , o = r - s;
                o !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(i, o, this) : i.start < this.getScrollOffset() + this.scrollAdjustments) && this._scrollToOffset(this.getScrollOffset(), {
                    adjustments: this.scrollAdjustments += o,
                    behavior: void 0
                }),
                    this.pendingMeasuredCacheIndexes.push(i.index),
                    this.itemSizeCache = new Map(this.itemSizeCache.set(i.key, r)),
                    this.notify(!1))
            }
            ,
            this.measureElement = n => {
                if (!n) {
                    this.elementsCache.forEach((r, i) => {
                        r.isConnected || (this.observer.unobserve(r),
                            this.elementsCache.delete(i))
                    }
                    );
                    return
                }
                this._measureElement(n, void 0)
            }
            ,
            this.getVirtualItems = pl(() => [this.getIndexes(), this.getMeasurements()], (n, r) => {
                const i = [];
                for (let s = 0, o = n.length; s < o; s++) {
                    const a = n[s]
                        , l = r[a];
                    i.push(l)
                }
                return i
            }
                , {
                    key: !1,
                    debug: () => this.options.debug
                }),
            this.getVirtualItemForOffset = n => {
                const r = this.getMeasurements();
                if (r.length !== 0)
                    return h0(r[pC(0, r.length - 1, i => h0(r[i]).start, n)])
            }
            ,
            this.getOffsetForAlignment = (n, r) => {
                const i = this.getSize()
                    , s = this.getScrollOffset();
                r === "auto" && (n <= s ? r = "start" : n >= s + i ? r = "end" : r = "start"),
                    r === "start" ? n = n : r === "end" ? n = n - i : r === "center" && (n = n - i / 2);
                const o = this.options.horizontal ? "scrollWidth" : "scrollHeight"
                    , l = (this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[o] : this.scrollElement[o] : 0) - i;
                return Math.max(Math.min(l, n), 0)
            }
            ,
            this.getOffsetForIndex = (n, r = "auto") => {
                n = Math.max(0, Math.min(n, this.options.count - 1));
                const i = this.measurementsCache[n];
                if (!i)
                    return;
                const s = this.getSize()
                    , o = this.getScrollOffset();
                if (r === "auto")
                    if (i.end >= o + s - this.options.scrollPaddingEnd)
                        r = "end";
                    else if (i.start <= o + this.options.scrollPaddingStart)
                        r = "start";
                    else
                        return [o, r];
                const a = r === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart;
                return [this.getOffsetForAlignment(a, r), r]
            }
            ,
            this.isDynamicMode = () => this.elementsCache.size > 0,
            this.cancelScrollToIndex = () => {
                this.scrollToIndexTimeoutId !== null && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId),
                    this.scrollToIndexTimeoutId = null)
            }
            ,
            this.scrollToOffset = (n, { align: r = "start", behavior: i } = {}) => {
                this.cancelScrollToIndex(),
                    i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."),
                    this._scrollToOffset(this.getOffsetForAlignment(n, r), {
                        adjustments: void 0,
                        behavior: i
                    })
            }
            ,
            this.scrollToIndex = (n, { align: r = "auto", behavior: i } = {}) => {
                n = Math.max(0, Math.min(n, this.options.count - 1)),
                    this.cancelScrollToIndex(),
                    i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
                const s = this.getOffsetForIndex(n, r);
                if (!s)
                    return;
                const [o, a] = s;
                this._scrollToOffset(o, {
                    adjustments: void 0,
                    behavior: i
                }),
                    i !== "smooth" && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
                        if (this.scrollToIndexTimeoutId = null,
                            this.elementsCache.has(this.options.getItemKey(n))) {
                            const [c] = h0(this.getOffsetForIndex(n, a));
                            ZL(c, this.getScrollOffset()) || this.scrollToIndex(n, {
                                align: a,
                                behavior: i
                            })
                        } else
                            this.scrollToIndex(n, {
                                align: a,
                                behavior: i
                            })
                    }
                    ))
            }
            ,
            this.scrollBy = (n, { behavior: r } = {}) => {
                this.cancelScrollToIndex(),
                    r === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."),
                    this._scrollToOffset(this.getScrollOffset() + n, {
                        adjustments: void 0,
                        behavior: r
                    })
            }
            ,
            this.getTotalSize = () => {
                var n;
                const r = this.getMeasurements();
                let i;
                return r.length === 0 ? i = this.options.paddingStart : i = this.options.lanes === 1 ? ((n = r[r.length - 1]) == null ? void 0 : n.end) ?? 0 : Math.max(...r.slice(-this.options.lanes).map(s => s.end)),
                    Math.max(i - this.options.scrollMargin + this.options.paddingEnd, 0)
            }
            ,
            this._scrollToOffset = (n, { adjustments: r, behavior: i }) => {
                this.options.scrollToFn(n, {
                    behavior: i,
                    adjustments: r
                }, this)
            }
            ,
            this.measure = () => {
                this.itemSizeCache = new Map,
                    this.notify(!1)
            }
            ,
            this.setOptions(e)
    }
}
const pC = (t, e, n, r) => {
    for (; t <= e;) {
        const i = (t + e) / 2 | 0
            , s = n(i);
        if (s < r)
            t = i + 1;
        else if (s > r)
            e = i - 1;
        else
            return i
    }
    return t > 0 ? t - 1 : 0
}
    ;
function oD({ measurements: t, outerSize: e, scrollOffset: n }) {
    const r = t.length - 1
        , s = pC(0, r, a => t[a].start, n);
    let o = s;
    for (; o < r && t[o].end < n + e;)
        o++;
    return {
        startIndex: s,
        endIndex: o
    }
}
function aD(t) {
    const e = new sD(ie(t))
        , n = Wa(e)
        , r = e._didMount();
    return vt(() => ie(t).getScrollElement(), i => {
        i && e._willUpdate()
    }
        , {
            immediate: !0
        }),
        vt(() => ie(t), i => {
            e.setOptions({
                ...i,
                onChange: (s, o) => {
                    var a;
                    Yw(n),
                        (a = i.onChange) == null || a.call(i, s, o)
                }
            }),
                e._willUpdate(),
                Yw(n)
        }
            , {
                immediate: !0
            }),
        cd(r),
        n
}
function lD(t) {
    return aD(G(() => ({
        observeElementRect: eD,
        observeElementOffset: nD,
        scrollToFn: iD,
        ...ie(t)
    })))
}
function uD(t, e, n) {
    let r = ce(n?.value)
        , i = G(() => t.value !== void 0);
    return [G(() => i.value ? t.value : r.value), function (s) {
        return i.value || (r.value = s),
            e?.(s)
    }
    ]
}
function iv(t) {
    typeof queueMicrotask == "function" ? queueMicrotask(t) : Promise.resolve().then(t).catch(e => setTimeout(() => {
        throw e
    }
    ))
}
function Ro() {
    let t = []
        , e = {
            addEventListener(n, r, i, s) {
                return n.addEventListener(r, i, s),
                    e.add(() => n.removeEventListener(r, i, s))
            },
            requestAnimationFrame(...n) {
                let r = requestAnimationFrame(...n);
                e.add(() => cancelAnimationFrame(r))
            },
            nextFrame(...n) {
                e.requestAnimationFrame(() => {
                    e.requestAnimationFrame(...n)
                }
                )
            },
            setTimeout(...n) {
                let r = setTimeout(...n);
                e.add(() => clearTimeout(r))
            },
            microTask(...n) {
                let r = {
                    current: !0
                };
                return iv(() => {
                    r.current && n[0]()
                }
                ),
                    e.add(() => {
                        r.current = !1
                    }
                    )
            },
            style(n, r, i) {
                let s = n.style.getPropertyValue(r);
                return Object.assign(n.style, {
                    [r]: i
                }),
                    this.add(() => {
                        Object.assign(n.style, {
                            [r]: s
                        })
                    }
                    )
            },
            group(n) {
                let r = Ro();
                return n(r),
                    this.add(() => r.dispose())
            },
            add(n) {
                return t.push(n),
                    () => {
                        let r = t.indexOf(n);
                        if (r >= 0)
                            for (let i of t.splice(r, 1))
                                i()
                    }
            },
            dispose() {
                for (let n of t.splice(0))
                    n()
            }
        };
    return e
}
function cD() {
    let t = Ro();
    return xn(() => t.dispose()),
        t
}
function dD() {
    let t = cD();
    return e => {
        t.dispose(),
            t.nextFrame(e)
    }
}
var Dx;
let fD = Symbol("headlessui.useid")
    , hD = 0;
const ss = (Dx = e1) != null ? Dx : function () {
    return Dt(fD, () => `${++hD}`)()
}
    ;
function Ge(t) {
    var e;
    if (t == null || t.value == null)
        return null;
    let n = (e = t.value.$el) != null ? e : t.value;
    return n instanceof Node ? n : null
}
function Zn(t, e, ...n) {
    if (t in e) {
        let i = e[t];
        return typeof i == "function" ? i(...n) : i
    }
    let r = new Error(`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map(i => `"${i}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Zn),
    r
}
var pD = Object.defineProperty
    , mD = (t, e, n) => e in t ? pD(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n
    , jx = (t, e, n) => (mD(t, typeof e != "symbol" ? e + "" : e, n),
        n);
let gD = class {
    constructor() {
        jx(this, "current", this.detect()),
            jx(this, "currentId", 0)
    }
    set(e) {
        this.current !== e && (this.currentId = 0,
            this.current = e)
    }
    reset() {
        this.set(this.detect())
    }
    nextId() {
        return ++this.currentId
    }
    get isServer() {
        return this.current === "server"
    }
    get isClient() {
        return this.current === "client"
    }
    detect() {
        return typeof window > "u" || typeof document > "u" ? "server" : "client"
    }
}
    , yd = new gD;
function zs(t) {
    if (yd.isServer)
        return null;
    if (t instanceof Node)
        return t.ownerDocument;
    if (t != null && t.hasOwnProperty("value")) {
        let e = Ge(t);
        if (e)
            return e.ownerDocument
    }
    return document
}
let b1 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(t => `${t}:not([tabindex='-1'])`).join(",");
var fo = (t => (t[t.First = 1] = "First",
    t[t.Previous = 2] = "Previous",
    t[t.Next = 4] = "Next",
    t[t.Last = 8] = "Last",
    t[t.WrapAround = 16] = "WrapAround",
    t[t.NoScroll = 32] = "NoScroll",
    t))(fo || {})
    , mC = (t => (t[t.Error = 0] = "Error",
        t[t.Overflow = 1] = "Overflow",
        t[t.Success = 2] = "Success",
        t[t.Underflow = 3] = "Underflow",
        t))(mC || {})
    , yD = (t => (t[t.Previous = -1] = "Previous",
        t[t.Next = 1] = "Next",
        t))(yD || {});
function gC(t = document.body) {
    return t == null ? [] : Array.from(t.querySelectorAll(b1)).sort((e, n) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (n.tabIndex || Number.MAX_SAFE_INTEGER)))
}
var yC = (t => (t[t.Strict = 0] = "Strict",
    t[t.Loose = 1] = "Loose",
    t))(yC || {});
function vC(t, e = 0) {
    var n;
    return t === ((n = zs(t)) == null ? void 0 : n.body) ? !1 : Zn(e, {
        0() {
            return t.matches(b1)
        },
        1() {
            let r = t;
            for (; r !== null;) {
                if (r.matches(b1))
                    return !0;
                r = r.parentElement
            }
            return !1
        }
    })
}
function KQ(t) {
    let e = zs(t);
    un(() => {
        e && !vC(e.activeElement, 0) && So(t)
    }
    )
}
var vD = (t => (t[t.Keyboard = 0] = "Keyboard",
    t[t.Mouse = 1] = "Mouse",
    t))(vD || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", t => {
    t.metaKey || t.altKey || t.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
}
    , !0),
    document.addEventListener("click", t => {
        t.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : t.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "")
    }
        , !0));
function So(t) {
    t?.focus({
        preventScroll: !0
    })
}
let bD = ["textarea", "input"].join(",");
function wD(t) {
    var e, n;
    return (n = (e = t?.matches) == null ? void 0 : e.call(t, bD)) != null ? n : !1
}
function bC(t, e = n => n) {
    return t.slice().sort((n, r) => {
        let i = e(n)
            , s = e(r);
        if (i === null || s === null)
            return 0;
        let o = i.compareDocumentPosition(s);
        return o & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
    }
    )
}
function qQ(t, e) {
    return ac(gC(), e, {
        relativeTo: t
    })
}
function ac(t, e, { sorted: n = !0, relativeTo: r = null, skipElements: i = [] } = {}) {
    var s;
    let o = (s = Array.isArray(t) ? t.length > 0 ? t[0].ownerDocument : document : t?.ownerDocument) != null ? s : document
        , a = Array.isArray(t) ? n ? bC(t) : t : gC(t);
    i.length > 0 && a.length > 1 && (a = a.filter(y => !i.includes(y))),
        r = r ?? o.activeElement;
    let l = (() => {
        if (e & 5)
            return 1;
        if (e & 10)
            return -1;
        throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
    }
    )(), c = (() => {
        if (e & 1)
            return 0;
        if (e & 2)
            return Math.max(0, a.indexOf(r)) - 1;
        if (e & 4)
            return Math.max(0, a.indexOf(r)) + 1;
        if (e & 8)
            return a.length - 1;
        throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
    }
    )(), d = e & 32 ? {
        preventScroll: !0
    } : {}, h = 0, p = a.length, g;
    do {
        if (h >= p || h + p <= 0)
            return 0;
        let y = c + h;
        if (e & 16)
            y = (y + p) % p;
        else {
            if (y < 0)
                return 3;
            if (y >= p)
                return 1
        }
        g = a[y],
            g?.focus(d),
            h += l
    } while (g !== o.activeElement);
    return e & 6 && wD(g) && g.select(),
        2
}
function wC() {
    return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0
}
function xD() {
    return /Android/gi.test(window.navigator.userAgent)
}
function xC() {
    return wC() || xD()
}
function Nf(t, e, n) {
    yd.isServer || Ft(r => {
        document.addEventListener(t, e, n),
            r(() => document.removeEventListener(t, e, n))
    }
    )
}
function _C(t, e, n) {
    yd.isServer || Ft(r => {
        window.addEventListener(t, e, n),
            r(() => window.removeEventListener(t, e, n))
    }
    )
}
function SC(t, e, n = G(() => !0)) {
    function r(s, o) {
        if (!n.value || s.defaultPrevented)
            return;
        let a = o(s);
        if (a === null || !a.getRootNode().contains(a))
            return;
        let l = function c(d) {
            return typeof d == "function" ? c(d()) : Array.isArray(d) || d instanceof Set ? d : [d]
        }(t);
        for (let c of l) {
            if (c === null)
                continue;
            let d = c instanceof HTMLElement ? c : Ge(c);
            if (d != null && d.contains(a) || s.composed && s.composedPath().includes(d))
                return
        }
        return !vC(a, yC.Loose) && a.tabIndex !== -1 && s.preventDefault(),
            e(s, a)
    }
    let i = ce(null);
    Nf("pointerdown", s => {
        var o, a;
        n.value && (i.value = ((a = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : a[0]) || s.target)
    }
        , !0),
        Nf("mousedown", s => {
            var o, a;
            n.value && (i.value = ((a = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : a[0]) || s.target)
        }
            , !0),
        Nf("click", s => {
            xC() || i.value && (r(s, () => i.value),
                i.value = null)
        }
            , !0),
        Nf("touchend", s => r(s, () => s.target instanceof HTMLElement ? s.target : null), !0),
        _C("blur", s => r(s, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0)
}
function Bx(t, e) {
    if (t)
        return t;
    let n = e ?? "button";
    if (typeof n == "string" && n.toLowerCase() === "button")
        return "button"
}
function _D(t, e) {
    let n = ce(Bx(t.value.type, t.value.as));
    return Nt(() => {
        n.value = Bx(t.value.type, t.value.as)
    }
    ),
        Ft(() => {
            var r;
            n.value || Ge(e) && Ge(e) instanceof HTMLButtonElement && !((r = Ge(e)) != null && r.hasAttribute("type")) && (n.value = "button")
        }
        ),
        n
}
function $x(t) {
    return [t.screenX, t.screenY]
}
function SD() {
    let t = ce([-1, -1]);
    return {
        wasMoved(e) {
            let n = $x(e);
            return t.value[0] === n[0] && t.value[1] === n[1] ? !1 : (t.value = n,
                !0)
        },
        update(e) {
            t.value = $x(e)
        }
    }
}
function kD({ container: t, accept: e, walk: n, enabled: r }) {
    Ft(() => {
        let i = t.value;
        if (!i || r !== void 0 && !r.value)
            return;
        let s = zs(t);
        if (!s)
            return;
        let o = Object.assign(l => e(l), {
            acceptNode: e
        })
            , a = s.createTreeWalker(i, NodeFilter.SHOW_ELEMENT, o, !1);
        for (; a.nextNode();)
            n(a.currentNode)
    }
    )
}
var Po = (t => (t[t.None = 0] = "None",
    t[t.RenderStrategy = 1] = "RenderStrategy",
    t[t.Static = 2] = "Static",
    t))(Po || {})
    , yo = (t => (t[t.Unmount = 0] = "Unmount",
        t[t.Hidden = 1] = "Hidden",
        t))(yo || {});
function Wn({ visible: t = !0, features: e = 0, ourProps: n, theirProps: r, ...i }) {
    var s;
    let o = CC(r, n)
        , a = Object.assign(i, {
            props: o
        });
    if (t || e & 2 && o.static)
        return p0(a);
    if (e & 1) {
        let l = (s = o.unmount) == null || s ? 0 : 1;
        return Zn(l, {
            0() {
                return null
            },
            1() {
                return p0({
                    ...i,
                    props: {
                        ...o,
                        hidden: !0,
                        style: {
                            display: "none"
                        }
                    }
                })
            }
        })
    }
    return p0(a)
}
function p0({ props: t, attrs: e, slots: n, slot: r, name: i }) {
    var s, o;
    let { as: a, ...l } = vd(t, ["unmount", "static"])
        , c = (s = n.default) == null ? void 0 : s.call(n, r)
        , d = {};
    if (r) {
        let h = !1
            , p = [];
        for (let [g, y] of Object.entries(r))
            typeof y == "boolean" && (h = !0),
                y === !0 && p.push(g);
        h && (d["data-headlessui-state"] = p.join(" "))
    }
    if (a === "template") {
        if (c = kC(c ?? []),
            Object.keys(l).length > 0 || Object.keys(e).length > 0) {
            let [h, ...p] = c ?? [];
            if (!ED(h) || p.length > 0)
                throw new Error(['Passing props on "template"!', "", `The current component <${i} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l).concat(Object.keys(e)).map(x => x.trim()).filter((x, S, k) => k.indexOf(x) === S).sort((x, S) => x.localeCompare(S)).map(x => `  - ${x}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(x => `  - ${x}`).join(`
`)].join(`
`));
            let g = CC((o = h.props) != null ? o : {}, l, d)
                , y = ui(h, g, !0);
            for (let x in g)
                x.startsWith("on") && (y.props || (y.props = {}),
                    y.props[x] = g[x]);
            return y
        }
        return Array.isArray(c) && c.length === 1 ? c[0] : c
    }
    return Mt(a, Object.assign({}, l, d), {
        default: () => c
    })
}
function kC(t) {
    return t.flatMap(e => e.type === Rt ? kC(e.children) : [e])
}
function CC(...t) {
    if (t.length === 0)
        return {};
    if (t.length === 1)
        return t[0];
    let e = {}
        , n = {};
    for (let r of t)
        for (let i in r)
            i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []),
                n[i].push(r[i])) : e[i] = r[i];
    if (e.disabled || e["aria-disabled"])
        return Object.assign(e, Object.fromEntries(Object.keys(n).map(r => [r, void 0])));
    for (let r in n)
        Object.assign(e, {
            [r](i, ...s) {
                let o = n[r];
                for (let a of o) {
                    if (i instanceof Event && i.defaultPrevented)
                        return;
                    a(i, ...s)
                }
            }
        });
    return e
}
function CD(t) {
    let e = Object.assign({}, t);
    for (let n in e)
        e[n] === void 0 && delete e[n];
    return e
}
function vd(t, e = []) {
    let n = Object.assign({}, t);
    for (let r of e)
        r in n && delete n[r];
    return n
}
function ED(t) {
    return t == null ? !1 : typeof t.type == "string" || typeof t.type == "object" || typeof t.type == "function"
}
var Mc = (t => (t[t.None = 1] = "None",
    t[t.Focusable = 2] = "Focusable",
    t[t.Hidden = 4] = "Hidden",
    t))(Mc || {});
let Fh = je({
    name: "Hidden",
    props: {
        as: {
            type: [Object, String],
            default: "div"
        },
        features: {
            type: Number,
            default: 1
        }
    },
    setup(t, { slots: e, attrs: n }) {
        return () => {
            var r;
            let { features: i, ...s } = t
                , o = {
                    "aria-hidden": (i & 2) === 2 ? !0 : (r = s["aria-hidden"]) != null ? r : void 0,
                    hidden: (i & 4) === 4 ? !0 : void 0,
                    style: {
                        position: "fixed",
                        top: 1,
                        left: 1,
                        width: 1,
                        height: 0,
                        padding: 0,
                        margin: -1,
                        overflow: "hidden",
                        clip: "rect(0, 0, 0, 0)",
                        whiteSpace: "nowrap",
                        borderWidth: "0",
                        ...(i & 4) === 4 && (i & 2) !== 2 && {
                            display: "none"
                        }
                    }
                };
            return Wn({
                ourProps: o,
                theirProps: s,
                slot: {},
                attrs: n,
                slots: e,
                name: "Hidden"
            })
        }
    }
})
    , EC = Symbol("Context");
var jn = (t => (t[t.Open = 1] = "Open",
    t[t.Closed = 2] = "Closed",
    t[t.Closing = 4] = "Closing",
    t[t.Opening = 8] = "Opening",
    t))(jn || {});
function TD() {
    return cm() !== null
}
function cm() {
    return Dt(EC, null)
}
function TC(t) {
    Hn(EC, t)
}
var xr = (t => (t.Space = " ",
    t.Enter = "Enter",
    t.Escape = "Escape",
    t.Backspace = "Backspace",
    t.Delete = "Delete",
    t.ArrowLeft = "ArrowLeft",
    t.ArrowUp = "ArrowUp",
    t.ArrowRight = "ArrowRight",
    t.ArrowDown = "ArrowDown",
    t.Home = "Home",
    t.End = "End",
    t.PageUp = "PageUp",
    t.PageDown = "PageDown",
    t.Tab = "Tab",
    t))(xr || {})
    , AC = (t => (t[t.Left = 0] = "Left",
        t[t.Right = 2] = "Right",
        t))(AC || {});
function AD(t) {
    function e() {
        document.readyState !== "loading" && (t(),
            document.removeEventListener("DOMContentLoaded", e))
    }
    typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", e),
        e())
}
let Rs = [];
AD(() => {
    function t(e) {
        e.target instanceof HTMLElement && e.target !== document.body && Rs[0] !== e.target && (Rs.unshift(e.target),
            Rs = Rs.filter(n => n != null && n.isConnected),
            Rs.splice(10))
    }
    window.addEventListener("click", t, {
        capture: !0
    }),
        window.addEventListener("mousedown", t, {
            capture: !0
        }),
        window.addEventListener("focus", t, {
            capture: !0
        }),
        document.body.addEventListener("click", t, {
            capture: !0
        }),
        document.body.addEventListener("mousedown", t, {
            capture: !0
        }),
        document.body.addEventListener("focus", t, {
            capture: !0
        })
}
);
function OD(t) {
    throw new Error("Unexpected object: " + t)
}
var Dn = (t => (t[t.First = 0] = "First",
    t[t.Previous = 1] = "Previous",
    t[t.Next = 2] = "Next",
    t[t.Last = 3] = "Last",
    t[t.Specific = 4] = "Specific",
    t[t.Nothing = 5] = "Nothing",
    t))(Dn || {});
function zx(t, e) {
    let n = e.resolveItems();
    if (n.length <= 0)
        return null;
    let r = e.resolveActiveIndex()
        , i = r ?? -1;
    switch (t.focus) {
        case 0:
            {
                for (let s = 0; s < n.length; ++s)
                    if (!e.resolveDisabled(n[s], s, n))
                        return s;
                return r
            }
        case 1:
            {
                i === -1 && (i = n.length);
                for (let s = i - 1; s >= 0; --s)
                    if (!e.resolveDisabled(n[s], s, n))
                        return s;
                return r
            }
        case 2:
            {
                for (let s = i + 1; s < n.length; ++s)
                    if (!e.resolveDisabled(n[s], s, n))
                        return s;
                return r
            }
        case 3:
            {
                for (let s = n.length - 1; s >= 0; --s)
                    if (!e.resolveDisabled(n[s], s, n))
                        return s;
                return r
            }
        case 4:
            {
                for (let s = 0; s < n.length; ++s)
                    if (e.resolveId(n[s], s, n) === t.id)
                        return s;
                return r
            }
        case 5:
            return null;
        default:
            OD(t)
    }
}
function OC(t = {}, e = null, n = []) {
    for (let [r, i] of Object.entries(t))
        RC(n, MC(e, r), i);
    return n
}
function MC(t, e) {
    return t ? t + "[" + e + "]" : e
}
function RC(t, e, n) {
    if (Array.isArray(n))
        for (let [r, i] of n.entries())
            RC(t, MC(e, r.toString()), i);
    else
        n instanceof Date ? t.push([e, n.toISOString()]) : typeof n == "boolean" ? t.push([e, n ? "1" : "0"]) : typeof n == "string" ? t.push([e, n]) : typeof n == "number" ? t.push([e, `${n}`]) : n == null ? t.push([e, ""]) : OC(n, e, t)
}
function GQ(t) {
    var e, n;
    let r = (e = t?.form) != null ? e : t.closest("form");
    if (r) {
        for (let i of r.elements)
            if (i !== t && (i.tagName === "INPUT" && i.type === "submit" || i.tagName === "BUTTON" && i.type === "submit" || i.nodeName === "INPUT" && i.type === "image")) {
                i.click();
                return
            }
        (n = r.requestSubmit) == null || n.call(r)
    }
}
function MD(t, e) {
    return t === e
}
var RD = (t => (t[t.Open = 0] = "Open",
    t[t.Closed = 1] = "Closed",
    t))(RD || {})
    , PD = (t => (t[t.Single = 0] = "Single",
        t[t.Multi = 1] = "Multi",
        t))(PD || {})
    , ND = (t => (t[t.Pointer = 0] = "Pointer",
        t[t.Focus = 1] = "Focus",
        t[t.Other = 2] = "Other",
        t))(ND || {});
let PC = Symbol("ComboboxContext");
function hu(t) {
    let e = Dt(PC, null);
    if (e === null) {
        let n = new Error(`<${t} /> is missing a parent <Combobox /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(n, hu),
        n
    }
    return e
}
let NC = Symbol("VirtualContext")
    , ID = je({
        name: "VirtualProvider",
        setup(t, { slots: e }) {
            let n = hu("VirtualProvider")
                , r = G(() => {
                    let a = Ge(n.optionsRef);
                    if (!a)
                        return {
                            start: 0,
                            end: 0
                        };
                    let l = window.getComputedStyle(a);
                    return {
                        start: parseFloat(l.paddingBlockStart || l.paddingTop),
                        end: parseFloat(l.paddingBlockEnd || l.paddingBottom)
                    }
                }
                )
                , i = lD(G(() => ({
                    scrollPaddingStart: r.value.start,
                    scrollPaddingEnd: r.value.end,
                    count: n.virtual.value.options.length,
                    estimateSize() {
                        return 40
                    },
                    getScrollElement() {
                        return Ge(n.optionsRef)
                    },
                    overscan: 12
                })))
                , s = G(() => {
                    var a;
                    return (a = n.virtual.value) == null ? void 0 : a.options
                }
                )
                , o = ce(0);
            return vt([s], () => {
                o.value += 1
            }
            ),
                Hn(NC, n.virtual.value ? i : null),
                () => [Mt("div", {
                    style: {
                        position: "relative",
                        width: "100%",
                        height: `${i.value.getTotalSize()}px`
                    },
                    ref: a => {
                        if (a) {
                            if (typeof process < "u" && {}.JEST_WORKER_ID !== void 0 || n.activationTrigger.value === 0)
                                return;
                            n.activeOptionIndex.value !== null && n.virtual.value.options.length > n.activeOptionIndex.value && i.value.scrollToIndex(n.activeOptionIndex.value)
                        }
                    }
                }, i.value.getVirtualItems().map(a => ui(e.default({
                    option: n.virtual.value.options[a.index],
                    open: n.comboboxState.value === 0
                })[0], {
                    key: `${o.value}-${a.index}`,
                    "data-index": a.index,
                    "aria-setsize": n.virtual.value.options.length,
                    "aria-posinset": a.index + 1,
                    style: {
                        position: "absolute",
                        top: 0,
                        left: 0,
                        transform: `translateY(${a.start}px)`,
                        overflowAnchor: "none"
                    }
                })))]
        }
    })
    , LD = je({
        name: "Combobox",
        emits: {
            "update:modelValue": t => !0
        },
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            disabled: {
                type: [Boolean],
                default: !1
            },
            by: {
                type: [String, Function],
                nullable: !0,
                default: null
            },
            modelValue: {
                type: [Object, String, Number, Boolean],
                default: void 0
            },
            defaultValue: {
                type: [Object, String, Number, Boolean],
                default: void 0
            },
            form: {
                type: String,
                optional: !0
            },
            name: {
                type: String,
                optional: !0
            },
            nullable: {
                type: Boolean,
                default: !1
            },
            multiple: {
                type: [Boolean],
                default: !1
            },
            immediate: {
                type: [Boolean],
                default: !1
            },
            virtual: {
                type: Object,
                default: null
            }
        },
        inheritAttrs: !1,
        setup(t, { slots: e, attrs: n, emit: r }) {
            let i = ce(1)
                , s = ce(null)
                , o = ce(null)
                , a = ce(null)
                , l = ce(null)
                , c = ce({
                    static: !1,
                    hold: !1
                })
                , d = ce([])
                , h = ce(null)
                , p = ce(2)
                , g = ce(!1);
            function y(E = N => N) {
                let N = h.value !== null ? d.value[h.value] : null
                    , j = E(d.value.slice())
                    , z = j.length > 0 && j[0].dataRef.order.value !== null ? j.sort((W, P) => W.dataRef.order.value - P.dataRef.order.value) : bC(j, W => Ge(W.dataRef.domRef))
                    , V = N ? z.indexOf(N) : null;
                return V === -1 && (V = null),
                {
                    options: z,
                    activeOptionIndex: V
                }
            }
            let x = G(() => t.multiple ? 1 : 0)
                , S = G(() => t.nullable)
                , [k, A] = uD(G(() => t.modelValue), E => r("update:modelValue", E), G(() => t.defaultValue))
                , C = G(() => k.value === void 0 ? Zn(x.value, {
                    1: [],
                    0: void 0
                }) : k.value)
                , m = null
                , b = null;
            function w(E) {
                return Zn(x.value, {
                    0() {
                        return A?.(E)
                    },
                    1: () => {
                        let N = it(O.value.value).slice()
                            , j = it(E)
                            , z = N.findIndex(V => O.compare(j, it(V)));
                        return z === -1 ? N.push(j) : N.splice(z, 1),
                            A?.(N)
                    }
                })
            }
            let T = G(() => { }
            );
            vt([T], ([E], [N]) => {
                if (O.virtual.value && E && N && h.value !== null) {
                    let j = E.indexOf(N[h.value]);
                    j !== -1 ? h.value = j : h.value = null
                }
            }
            );
            let O = {
                comboboxState: i,
                value: C,
                mode: x,
                compare(E, N) {
                    if (typeof t.by == "string") {
                        let j = t.by;
                        return E?.[j] === N?.[j]
                    }
                    return t.by === null ? MD(E, N) : t.by(E, N)
                },
                calculateIndex(E) {
                    return O.virtual.value ? t.by === null ? O.virtual.value.options.indexOf(E) : O.virtual.value.options.findIndex(N => O.compare(N, E)) : d.value.findIndex(N => O.compare(N.dataRef.value, E))
                },
                defaultValue: G(() => t.defaultValue),
                nullable: S,
                immediate: G(() => !1),
                virtual: G(() => null),
                inputRef: o,
                labelRef: s,
                buttonRef: a,
                optionsRef: l,
                disabled: G(() => t.disabled),
                options: d,
                change(E) {
                    A(E)
                },
                activeOptionIndex: G(() => {
                    if (g.value && h.value === null && (O.virtual.value ? O.virtual.value.options.length > 0 : d.value.length > 0)) {
                        if (O.virtual.value) {
                            let N = O.virtual.value.options.findIndex(j => {
                                var z;
                                return !((z = O.virtual.value) != null && z.disabled(j))
                            }
                            );
                            if (N !== -1)
                                return N
                        }
                        let E = d.value.findIndex(N => !N.dataRef.disabled);
                        if (E !== -1)
                            return E
                    }
                    return h.value
                }
                ),
                activationTrigger: p,
                optionsPropsRef: c,
                closeCombobox() {
                    g.value = !1,
                        !t.disabled && i.value !== 1 && (i.value = 1,
                            h.value = null)
                },
                openCombobox() {
                    if (g.value = !0,
                        !t.disabled && i.value !== 0) {
                        if (O.value.value) {
                            let E = O.calculateIndex(O.value.value);
                            E !== -1 && (h.value = E)
                        }
                        i.value = 0
                    }
                },
                setActivationTrigger(E) {
                    p.value = E
                },
                goToOption(E, N, j) {
                    g.value = !1,
                        m !== null && cancelAnimationFrame(m),
                        m = requestAnimationFrame(() => {
                            if (t.disabled || l.value && !c.value.static && i.value === 1)
                                return;
                            if (O.virtual.value) {
                                h.value = E === Dn.Specific ? N : zx({
                                    focus: E
                                }, {
                                    resolveItems: () => O.virtual.value.options,
                                    resolveActiveIndex: () => {
                                        var W, P;
                                        return (P = (W = O.activeOptionIndex.value) != null ? W : O.virtual.value.options.findIndex(F => {
                                            var K;
                                            return !((K = O.virtual.value) != null && K.disabled(F))
                                        }
                                        )) != null ? P : null
                                    }
                                    ,
                                    resolveDisabled: W => O.virtual.value.disabled(W),
                                    resolveId() {
                                        throw new Error("Function not implemented.")
                                    }
                                }),
                                    p.value = j ?? 2;
                                return
                            }
                            let z = y();
                            if (z.activeOptionIndex === null) {
                                let W = z.options.findIndex(P => !P.dataRef.disabled);
                                W !== -1 && (z.activeOptionIndex = W)
                            }
                            let V = E === Dn.Specific ? N : zx({
                                focus: E
                            }, {
                                resolveItems: () => z.options,
                                resolveActiveIndex: () => z.activeOptionIndex,
                                resolveId: W => W.id,
                                resolveDisabled: W => W.dataRef.disabled
                            });
                            h.value = V,
                                p.value = j ?? 2,
                                d.value = z.options
                        }
                        )
                },
                selectOption(E) {
                    let N = d.value.find(z => z.id === E);
                    if (!N)
                        return;
                    let { dataRef: j } = N;
                    w(j.value)
                },
                selectActiveOption() {
                    if (O.activeOptionIndex.value !== null) {
                        if (O.virtual.value)
                            w(O.virtual.value.options[O.activeOptionIndex.value]);
                        else {
                            let { dataRef: E } = d.value[O.activeOptionIndex.value];
                            w(E.value)
                        }
                        O.goToOption(Dn.Specific, O.activeOptionIndex.value)
                    }
                },
                registerOption(E, N) {
                    let j = wn({
                        id: E,
                        dataRef: N
                    });
                    if (O.virtual.value) {
                        d.value.push(j);
                        return
                    }
                    b && cancelAnimationFrame(b);
                    let z = y(V => (V.push(j),
                        V));
                    h.value === null && O.isSelected(N.value.value) && (z.activeOptionIndex = z.options.indexOf(j)),
                        d.value = z.options,
                        h.value = z.activeOptionIndex,
                        p.value = 2,
                        z.options.some(V => !Ge(V.dataRef.domRef)) && (b = requestAnimationFrame(() => {
                            let V = y();
                            d.value = V.options,
                                h.value = V.activeOptionIndex
                        }
                        ))
                },
                unregisterOption(E, N) {
                    if (m !== null && cancelAnimationFrame(m),
                        N && (g.value = !0),
                        O.virtual.value) {
                        d.value = d.value.filter(z => z.id !== E);
                        return
                    }
                    let j = y(z => {
                        let V = z.findIndex(W => W.id === E);
                        return V !== -1 && z.splice(V, 1),
                            z
                    }
                    );
                    d.value = j.options,
                        h.value = j.activeOptionIndex,
                        p.value = 2
                },
                isSelected(E) {
                    return Zn(x.value, {
                        0: () => O.compare(it(O.value.value), it(E)),
                        1: () => it(O.value.value).some(N => O.compare(it(N), it(E)))
                    })
                },
                isActive(E) {
                    return h.value === O.calculateIndex(E)
                }
            };
            SC([o, a, l], () => O.closeCombobox(), G(() => i.value === 0)),
                Hn(PC, O),
                TC(G(() => Zn(i.value, {
                    0: jn.Open,
                    1: jn.Closed
                })));
            let M = G(() => {
                var E;
                return (E = Ge(o)) == null ? void 0 : E.closest("form")
            }
            );
            return Nt(() => {
                vt([M], () => {
                    if (!M.value || t.defaultValue === void 0)
                        return;
                    function E() {
                        O.change(t.defaultValue)
                    }
                    return M.value.addEventListener("reset", E),
                        () => {
                            var N;
                            (N = M.value) == null || N.removeEventListener("reset", E)
                        }
                }
                    , {
                        immediate: !0
                    })
            }
            ),
                () => {
                    var E, N, j;
                    let { name: z, disabled: V, form: W, ...P } = t
                        , F = {
                            open: i.value === 0,
                            disabled: V,
                            activeIndex: O.activeOptionIndex.value,
                            activeOption: O.activeOptionIndex.value === null ? null : O.virtual.value ? O.virtual.value.options[(E = O.activeOptionIndex.value) != null ? E : 0] : (j = (N = O.options.value[O.activeOptionIndex.value]) == null ? void 0 : N.dataRef.value) != null ? j : null,
                            value: C.value
                        };
                    return Mt(Rt, [...z != null && C.value != null ? OC({
                        [z]: C.value
                    }).map(([K, re]) => Mt(Fh, CD({
                        features: Mc.Hidden,
                        key: K,
                        as: "input",
                        type: "hidden",
                        hidden: !0,
                        readOnly: !0,
                        form: W,
                        disabled: V,
                        name: K,
                        value: re
                    }))) : [], Wn({
                        theirProps: {
                            ...n,
                            ...vd(P, ["by", "defaultValue", "immediate", "modelValue", "multiple", "nullable", "onUpdate:modelValue", "virtual"])
                        },
                        ourProps: {},
                        slot: F,
                        slots: e,
                        attrs: n,
                        name: "Combobox"
                    })])
                }
        }
    })
    , DD = je({
        name: "ComboboxButton",
        props: {
            as: {
                type: [Object, String],
                default: "button"
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(t, { attrs: e, slots: n, expose: r }) {
            var i;
            let s = (i = t.id) != null ? i : `headlessui-combobox-button-${ss()}`
                , o = hu("ComboboxButton");
            r({
                el: o.buttonRef,
                $el: o.buttonRef
            });
            function a(d) {
                o.disabled.value || (o.comboboxState.value === 0 ? o.closeCombobox() : (d.preventDefault(),
                    o.openCombobox()),
                    un(() => {
                        var h;
                        return (h = Ge(o.inputRef)) == null ? void 0 : h.focus({
                            preventScroll: !0
                        })
                    }
                    ))
            }
            function l(d) {
                switch (d.key) {
                    case xr.ArrowDown:
                        d.preventDefault(),
                            d.stopPropagation(),
                            o.comboboxState.value === 1 && o.openCombobox(),
                            un(() => {
                                var h;
                                return (h = o.inputRef.value) == null ? void 0 : h.focus({
                                    preventScroll: !0
                                })
                            }
                            );
                        return;
                    case xr.ArrowUp:
                        d.preventDefault(),
                            d.stopPropagation(),
                            o.comboboxState.value === 1 && (o.openCombobox(),
                                un(() => {
                                    o.value.value || o.goToOption(Dn.Last)
                                }
                                )),
                            un(() => {
                                var h;
                                return (h = o.inputRef.value) == null ? void 0 : h.focus({
                                    preventScroll: !0
                                })
                            }
                            );
                        return;
                    case xr.Escape:
                        if (o.comboboxState.value !== 0)
                            return;
                        d.preventDefault(),
                            o.optionsRef.value && !o.optionsPropsRef.value.static && d.stopPropagation(),
                            o.closeCombobox(),
                            un(() => {
                                var h;
                                return (h = o.inputRef.value) == null ? void 0 : h.focus({
                                    preventScroll: !0
                                })
                            }
                            );
                        return
                }
            }
            let c = _D(G(() => ({
                as: t.as,
                type: e.type
            })), o.buttonRef);
            return () => {
                var d, h;
                let p = {
                    open: o.comboboxState.value === 0,
                    disabled: o.disabled.value,
                    value: o.value.value
                }
                    , { ...g } = t
                    , y = {
                        ref: o.buttonRef,
                        id: s,
                        type: c.value,
                        tabindex: "-1",
                        "aria-haspopup": "listbox",
                        "aria-controls": (d = Ge(o.optionsRef)) == null ? void 0 : d.id,
                        "aria-expanded": o.comboboxState.value === 0,
                        "aria-labelledby": o.labelRef.value ? [(h = Ge(o.labelRef)) == null ? void 0 : h.id, s].join(" ") : void 0,
                        disabled: o.disabled.value === !0 ? !0 : void 0,
                        onKeydown: l,
                        onClick: a
                    };
                return Wn({
                    ourProps: y,
                    theirProps: g,
                    slot: p,
                    attrs: e,
                    slots: n,
                    name: "ComboboxButton"
                })
            }
        }
    })
    , jD = je({
        name: "ComboboxInput",
        props: {
            as: {
                type: [Object, String],
                default: "input"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            },
            displayValue: {
                type: Function
            },
            defaultValue: {
                type: String,
                default: void 0
            },
            id: {
                type: String,
                default: null
            }
        },
        emits: {
            change: t => !0
        },
        setup(t, { emit: e, attrs: n, slots: r, expose: i }) {
            var s;
            let o = (s = t.id) != null ? s : `headlessui-combobox-input-${ss()}`
                , a = hu("ComboboxInput")
                , l = G(() => zs(Ge(a.inputRef)))
                , c = {
                    value: !1
                };
            i({
                el: a.inputRef,
                $el: a.inputRef
            });
            function d() {
                a.change(null);
                let b = Ge(a.optionsRef);
                b && (b.scrollTop = 0),
                    a.goToOption(Dn.Nothing)
            }
            let h = G(() => {
                var b;
                let w = a.value.value;
                return Ge(a.inputRef) ? typeof t.displayValue < "u" && w !== void 0 ? (b = t.displayValue(w)) != null ? b : "" : typeof w == "string" ? w : "" : ""
            }
            );
            Nt(() => {
                vt([h, a.comboboxState, l], ([b, w], [T, O]) => {
                    if (c.value)
                        return;
                    let M = Ge(a.inputRef);
                    M && ((O === 0 && w === 1 || b !== T) && (M.value = b),
                        requestAnimationFrame(() => {
                            var E;
                            if (c.value || !M || ((E = l.value) == null ? void 0 : E.activeElement) !== M)
                                return;
                            let { selectionStart: N, selectionEnd: j } = M;
                            Math.abs((j ?? 0) - (N ?? 0)) === 0 && N === 0 && M.setSelectionRange(M.value.length, M.value.length)
                        }
                        ))
                }
                    , {
                        immediate: !0
                    }),
                    vt([a.comboboxState], ([b], [w]) => {
                        if (b === 0 && w === 1) {
                            if (c.value)
                                return;
                            let T = Ge(a.inputRef);
                            if (!T)
                                return;
                            let O = T.value
                                , { selectionStart: M, selectionEnd: E, selectionDirection: N } = T;
                            T.value = "",
                                T.value = O,
                                N !== null ? T.setSelectionRange(M, E, N) : T.setSelectionRange(M, E)
                        }
                    }
                    )
            }
            );
            let p = ce(!1);
            function g() {
                p.value = !0
            }
            function y() {
                Ro().nextFrame(() => {
                    p.value = !1
                }
                )
            }
            let x = dD();
            function S(b) {
                switch (c.value = !0,
                x(() => {
                    c.value = !1
                }
                ),
                b.key) {
                    case xr.Enter:
                        if (c.value = !1,
                            a.comboboxState.value !== 0 || p.value)
                            return;
                        if (b.preventDefault(),
                            b.stopPropagation(),
                            a.activeOptionIndex.value === null) {
                            a.closeCombobox();
                            return
                        }
                        a.selectActiveOption(),
                            a.mode.value === 0 && a.closeCombobox();
                        break;
                    case xr.ArrowDown:
                        return c.value = !1,
                            b.preventDefault(),
                            b.stopPropagation(),
                            Zn(a.comboboxState.value, {
                                0: () => a.goToOption(Dn.Next),
                                1: () => a.openCombobox()
                            });
                    case xr.ArrowUp:
                        return c.value = !1,
                            b.preventDefault(),
                            b.stopPropagation(),
                            Zn(a.comboboxState.value, {
                                0: () => a.goToOption(Dn.Previous),
                                1: () => {
                                    a.openCombobox(),
                                        un(() => {
                                            a.value.value || a.goToOption(Dn.Last)
                                        }
                                        )
                                }
                            });
                    case xr.Home:
                        if (b.shiftKey)
                            break;
                        return c.value = !1,
                            b.preventDefault(),
                            b.stopPropagation(),
                            a.goToOption(Dn.First);
                    case xr.PageUp:
                        return c.value = !1,
                            b.preventDefault(),
                            b.stopPropagation(),
                            a.goToOption(Dn.First);
                    case xr.End:
                        if (b.shiftKey)
                            break;
                        return c.value = !1,
                            b.preventDefault(),
                            b.stopPropagation(),
                            a.goToOption(Dn.Last);
                    case xr.PageDown:
                        return c.value = !1,
                            b.preventDefault(),
                            b.stopPropagation(),
                            a.goToOption(Dn.Last);
                    case xr.Escape:
                        if (c.value = !1,
                            a.comboboxState.value !== 0)
                            return;
                        b.preventDefault(),
                            a.optionsRef.value && !a.optionsPropsRef.value.static && b.stopPropagation(),
                            a.nullable.value && a.mode.value === 0 && a.value.value === null && d(),
                            a.closeCombobox();
                        break;
                    case xr.Tab:
                        if (c.value = !1,
                            a.comboboxState.value !== 0)
                            return;
                        a.mode.value === 0 && a.activationTrigger.value !== 1 && a.selectActiveOption(),
                            a.closeCombobox();
                        break
                }
            }
            function k(b) {
                e("change", b),
                    a.nullable.value && a.mode.value === 0 && b.target.value === "" && d(),
                    a.openCombobox()
            }
            function A(b) {
                var w, T, O;
                let M = (w = b.relatedTarget) != null ? w : Rs.find(E => E !== b.currentTarget);
                if (c.value = !1,
                    !((T = Ge(a.optionsRef)) != null && T.contains(M)) && !((O = Ge(a.buttonRef)) != null && O.contains(M)) && a.comboboxState.value === 0)
                    return b.preventDefault(),
                        a.mode.value === 0 && (a.nullable.value && a.value.value === null ? d() : a.activationTrigger.value !== 1 && a.selectActiveOption()),
                        a.closeCombobox()
            }
            function C(b) {
                var w, T, O;
                let M = (w = b.relatedTarget) != null ? w : Rs.find(E => E !== b.currentTarget);
                (T = Ge(a.buttonRef)) != null && T.contains(M) || (O = Ge(a.optionsRef)) != null && O.contains(M) || a.disabled.value || a.immediate.value && a.comboboxState.value !== 0 && (a.openCombobox(),
                    Ro().nextFrame(() => {
                        a.setActivationTrigger(1)
                    }
                    ))
            }
            let m = G(() => {
                var b, w, T, O;
                return (O = (T = (w = t.defaultValue) != null ? w : a.defaultValue.value !== void 0 ? (b = t.displayValue) == null ? void 0 : b.call(t, a.defaultValue.value) : null) != null ? T : a.defaultValue.value) != null ? O : ""
            }
            );
            return () => {
                var b, w, T, O, M, E, N;
                let j = {
                    open: a.comboboxState.value === 0
                }
                    , { displayValue: z, onChange: V, ...W } = t
                    , P = {
                        "aria-controls": (b = a.optionsRef.value) == null ? void 0 : b.id,
                        "aria-expanded": a.comboboxState.value === 0,
                        "aria-activedescendant": a.activeOptionIndex.value === null ? void 0 : a.virtual.value ? (w = a.options.value.find(F => !a.virtual.value.disabled(F.dataRef.value) && a.compare(F.dataRef.value, a.virtual.value.options[a.activeOptionIndex.value]))) == null ? void 0 : w.id : (T = a.options.value[a.activeOptionIndex.value]) == null ? void 0 : T.id,
                        "aria-labelledby": (E = (O = Ge(a.labelRef)) == null ? void 0 : O.id) != null ? E : (M = Ge(a.buttonRef)) == null ? void 0 : M.id,
                        "aria-autocomplete": "list",
                        id: o,
                        onCompositionstart: g,
                        onCompositionend: y,
                        onKeydown: S,
                        onInput: k,
                        onFocus: C,
                        onBlur: A,
                        role: "combobox",
                        type: (N = n.type) != null ? N : "text",
                        tabIndex: 0,
                        ref: a.inputRef,
                        defaultValue: m.value,
                        disabled: a.disabled.value === !0 ? !0 : void 0
                    };
                return Wn({
                    ourProps: P,
                    theirProps: W,
                    slot: j,
                    attrs: n,
                    slots: r,
                    features: Po.RenderStrategy | Po.Static,
                    name: "ComboboxInput"
                })
            }
        }
    })
    , BD = je({
        name: "ComboboxOptions",
        props: {
            as: {
                type: [Object, String],
                default: "ul"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            },
            hold: {
                type: [Boolean],
                default: !1
            }
        },
        setup(t, { attrs: e, slots: n, expose: r }) {
            let i = hu("ComboboxOptions")
                , s = `headlessui-combobox-options-${ss()}`;
            r({
                el: i.optionsRef,
                $el: i.optionsRef
            }),
                Ft(() => {
                    i.optionsPropsRef.value.static = t.static
                }
                ),
                Ft(() => {
                    i.optionsPropsRef.value.hold = t.hold
                }
                );
            let o = cm()
                , a = G(() => o !== null ? (o.value & jn.Open) === jn.Open : i.comboboxState.value === 0);
            kD({
                container: G(() => Ge(i.optionsRef)),
                enabled: G(() => i.comboboxState.value === 0),
                accept(c) {
                    return c.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : c.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT
                },
                walk(c) {
                    c.setAttribute("role", "none")
                }
            });
            function l(c) {
                c.preventDefault()
            }
            return () => {
                var c, d, h;
                let p = {
                    open: i.comboboxState.value === 0
                }
                    , g = {
                        "aria-labelledby": (h = (c = Ge(i.labelRef)) == null ? void 0 : c.id) != null ? h : (d = Ge(i.buttonRef)) == null ? void 0 : d.id,
                        id: s,
                        ref: i.optionsRef,
                        role: "listbox",
                        "aria-multiselectable": i.mode.value === 1 ? !0 : void 0,
                        onMousedown: l
                    }
                    , y = vd(t, ["hold"]);
                return Wn({
                    ourProps: g,
                    theirProps: y,
                    slot: p,
                    attrs: e,
                    slots: i.virtual.value && i.comboboxState.value === 0 ? {
                        ...n,
                        default: () => [Mt(ID, {}, n.default)]
                    } : n,
                    features: Po.RenderStrategy | Po.Static,
                    visible: a.value,
                    name: "ComboboxOptions"
                })
            }
        }
    })
    , $D = je({
        name: "ComboboxOption",
        props: {
            as: {
                type: [Object, String],
                default: "li"
            },
            value: {
                type: [Object, String, Number, Boolean]
            },
            disabled: {
                type: Boolean,
                default: !1
            },
            order: {
                type: [Number],
                default: null
            }
        },
        setup(t, { slots: e, attrs: n, expose: r }) {
            let i = hu("ComboboxOption")
                , s = `headlessui-combobox-option-${ss()}`
                , o = ce(null)
                , a = G(() => t.disabled);
            r({
                el: o,
                $el: o
            });
            let l = G(() => {
                var A;
                return i.virtual.value ? i.activeOptionIndex.value === i.calculateIndex(t.value) : i.activeOptionIndex.value === null ? !1 : ((A = i.options.value[i.activeOptionIndex.value]) == null ? void 0 : A.id) === s
            }
            )
                , c = G(() => i.isSelected(t.value))
                , d = Dt(NC, null)
                , h = G(() => ({
                    disabled: t.disabled,
                    value: t.value,
                    domRef: o,
                    order: G(() => t.order)
                }));
            Nt(() => i.registerOption(s, h)),
                xn(() => i.unregisterOption(s, l.value)),
                Ft(() => {
                    let A = Ge(o);
                    A && d?.value.measureElement(A)
                }
                ),
                Ft(() => {
                    i.comboboxState.value === 0 && l.value && (i.virtual.value || i.activationTrigger.value !== 0 && un(() => {
                        var A, C;
                        return (C = (A = Ge(o)) == null ? void 0 : A.scrollIntoView) == null ? void 0 : C.call(A, {
                            block: "nearest"
                        })
                    }
                    ))
                }
                );
            function p(A) {
                A.preventDefault(),
                    A.button === AC.Left && (a.value || (i.selectOption(s),
                        xC() || requestAnimationFrame(() => {
                            var C;
                            return (C = Ge(i.inputRef)) == null ? void 0 : C.focus({
                                preventScroll: !0
                            })
                        }
                        ),
                        i.mode.value === 0 && i.closeCombobox()))
            }
            function g() {
                var A;
                if (t.disabled || (A = i.virtual.value) != null && A.disabled(t.value))
                    return i.goToOption(Dn.Nothing);
                let C = i.calculateIndex(t.value);
                i.goToOption(Dn.Specific, C)
            }
            let y = SD();
            function x(A) {
                y.update(A)
            }
            function S(A) {
                var C;
                if (!y.wasMoved(A) || t.disabled || (C = i.virtual.value) != null && C.disabled(t.value) || l.value)
                    return;
                let m = i.calculateIndex(t.value);
                i.goToOption(Dn.Specific, m, 0)
            }
            function k(A) {
                var C;
                y.wasMoved(A) && (t.disabled || (C = i.virtual.value) != null && C.disabled(t.value) || l.value && (i.optionsPropsRef.value.hold || i.goToOption(Dn.Nothing)))
            }
            return () => {
                let { disabled: A } = t
                    , C = {
                        active: l.value,
                        selected: c.value,
                        disabled: A
                    }
                    , m = {
                        id: s,
                        ref: o,
                        role: "option",
                        tabIndex: A === !0 ? void 0 : -1,
                        "aria-disabled": A === !0 ? !0 : void 0,
                        "aria-selected": c.value,
                        disabled: void 0,
                        onMousedown: p,
                        onFocus: g,
                        onPointerenter: x,
                        onMouseenter: x,
                        onPointermove: S,
                        onMousemove: S,
                        onPointerleave: k,
                        onMouseleave: k
                    }
                    , b = vd(t, ["order", "value"]);
                return Wn({
                    ourProps: m,
                    theirProps: b,
                    slot: C,
                    attrs: n,
                    slots: e,
                    name: "ComboboxOption"
                })
            }
        }
    });
function IC(t, e, n, r) {
    yd.isServer || Ft(i => {
        t = t ?? window,
            t.addEventListener(e, n, r),
            i(() => t.removeEventListener(e, n, r))
    }
    )
}
var qu = (t => (t[t.Forwards = 0] = "Forwards",
    t[t.Backwards = 1] = "Backwards",
    t))(qu || {});
function zD() {
    let t = ce(0);
    return _C("keydown", e => {
        e.key === "Tab" && (t.value = e.shiftKey ? 1 : 0)
    }
    ),
        t
}
function LC(t) {
    if (!t)
        return new Set;
    if (typeof t == "function")
        return new Set(t());
    let e = new Set;
    for (let n of t.value) {
        let r = Ge(n);
        r instanceof HTMLElement && e.add(r)
    }
    return e
}
var DC = (t => (t[t.None = 1] = "None",
    t[t.InitialFocus = 2] = "InitialFocus",
    t[t.TabLock = 4] = "TabLock",
    t[t.FocusLock = 8] = "FocusLock",
    t[t.RestoreFocus = 16] = "RestoreFocus",
    t[t.All = 30] = "All",
    t))(DC || {});
let Bu = Object.assign(je({
    name: "FocusTrap",
    props: {
        as: {
            type: [Object, String],
            default: "div"
        },
        initialFocus: {
            type: Object,
            default: null
        },
        features: {
            type: Number,
            default: 30
        },
        containers: {
            type: [Object, Function],
            default: ce(new Set)
        }
    },
    inheritAttrs: !1,
    setup(t, { attrs: e, slots: n, expose: r }) {
        let i = ce(null);
        r({
            el: i,
            $el: i
        });
        let s = G(() => zs(i))
            , o = ce(!1);
        Nt(() => o.value = !0),
            xn(() => o.value = !1),
            HD({
                ownerDocument: s
            }, G(() => o.value && !!(t.features & 16)));
        let a = VD({
            ownerDocument: s,
            container: i,
            initialFocus: G(() => t.initialFocus)
        }, G(() => o.value && !!(t.features & 2)));
        WD({
            ownerDocument: s,
            container: i,
            containers: t.containers,
            previousActiveElement: a
        }, G(() => o.value && !!(t.features & 8)));
        let l = zD();
        function c(g) {
            let y = Ge(i);
            y && (x => x())(() => {
                Zn(l.value, {
                    [qu.Forwards]: () => {
                        ac(y, fo.First, {
                            skipElements: [g.relatedTarget]
                        })
                    }
                    ,
                    [qu.Backwards]: () => {
                        ac(y, fo.Last, {
                            skipElements: [g.relatedTarget]
                        })
                    }
                })
            }
            )
        }
        let d = ce(!1);
        function h(g) {
            g.key === "Tab" && (d.value = !0,
                requestAnimationFrame(() => {
                    d.value = !1
                }
                ))
        }
        function p(g) {
            if (!o.value)
                return;
            let y = LC(t.containers);
            Ge(i) instanceof HTMLElement && y.add(Ge(i));
            let x = g.relatedTarget;
            x instanceof HTMLElement && x.dataset.headlessuiFocusGuard !== "true" && (jC(y, x) || (d.value ? ac(Ge(i), Zn(l.value, {
                [qu.Forwards]: () => fo.Next,
                [qu.Backwards]: () => fo.Previous
            }) | fo.WrapAround, {
                relativeTo: g.target
            }) : g.target instanceof HTMLElement && So(g.target)))
        }
        return () => {
            let g = {}
                , y = {
                    ref: i,
                    onKeydown: h,
                    onFocusout: p
                }
                , { features: x, initialFocus: S, containers: k, ...A } = t;
            return Mt(Rt, [!!(x & 4) && Mt(Fh, {
                as: "button",
                type: "button",
                "data-headlessui-focus-guard": !0,
                onFocus: c,
                features: Mc.Focusable
            }), Wn({
                ourProps: y,
                theirProps: {
                    ...e,
                    ...A
                },
                slot: g,
                attrs: e,
                slots: n,
                name: "FocusTrap"
            }), !!(x & 4) && Mt(Fh, {
                as: "button",
                type: "button",
                "data-headlessui-focus-guard": !0,
                onFocus: c,
                features: Mc.Focusable
            })])
        }
    }
}), {
    features: DC
});
function FD(t) {
    let e = ce(Rs.slice());
    return vt([t], ([n], [r]) => {
        r === !0 && n === !1 ? iv(() => {
            e.value.splice(0)
        }
        ) : r === !1 && n === !0 && (e.value = Rs.slice())
    }
        , {
            flush: "post"
        }),
        () => {
            var n;
            return (n = e.value.find(r => r != null && r.isConnected)) != null ? n : null
        }
}
function HD({ ownerDocument: t }, e) {
    let n = FD(e);
    Nt(() => {
        Ft(() => {
            var r, i;
            e.value || ((r = t.value) == null ? void 0 : r.activeElement) === ((i = t.value) == null ? void 0 : i.body) && So(n())
        }
            , {
                flush: "post"
            })
    }
    ),
        xn(() => {
            e.value && So(n())
        }
        )
}
function VD({ ownerDocument: t, container: e, initialFocus: n }, r) {
    let i = ce(null)
        , s = ce(!1);
    return Nt(() => s.value = !0),
        xn(() => s.value = !1),
        Nt(() => {
            vt([e, n, r], (o, a) => {
                if (o.every((c, d) => a?.[d] === c) || !r.value)
                    return;
                let l = Ge(e);
                l && iv(() => {
                    var c, d;
                    if (!s.value)
                        return;
                    let h = Ge(n)
                        , p = (c = t.value) == null ? void 0 : c.activeElement;
                    if (h) {
                        if (h === p) {
                            i.value = p;
                            return
                        }
                    } else if (l.contains(p)) {
                        i.value = p;
                        return
                    }
                    h ? So(h) : ac(l, fo.First | fo.NoScroll) === mC.Error && console.warn("There are no focusable elements inside the <FocusTrap />"),
                        i.value = (d = t.value) == null ? void 0 : d.activeElement
                }
                )
            }
                , {
                    immediate: !0,
                    flush: "post"
                })
        }
        ),
        i
}
function WD({ ownerDocument: t, container: e, containers: n, previousActiveElement: r }, i) {
    var s;
    IC((s = t.value) == null ? void 0 : s.defaultView, "focus", o => {
        if (!i.value)
            return;
        let a = LC(n);
        Ge(e) instanceof HTMLElement && a.add(Ge(e));
        let l = r.value;
        if (!l)
            return;
        let c = o.target;
        c && c instanceof HTMLElement ? jC(a, c) ? (r.value = c,
            So(c)) : (o.preventDefault(),
                o.stopPropagation(),
                So(l)) : So(r.value)
    }
        , !0)
}
function jC(t, e) {
    for (let n of t)
        if (n.contains(e))
            return !0;
    return !1
}
function UD(t) {
    let e = Wa(t.getSnapshot());
    return xn(t.subscribe(() => {
        e.value = t.getSnapshot()
    }
    )),
        e
}
function KD(t, e) {
    let n = t()
        , r = new Set;
    return {
        getSnapshot() {
            return n
        },
        subscribe(i) {
            return r.add(i),
                () => r.delete(i)
        },
        dispatch(i, ...s) {
            let o = e[i].call(n, ...s);
            o && (n = o,
                r.forEach(a => a()))
        }
    }
}
function qD() {
    let t;
    return {
        before({ doc: e }) {
            var n;
            let r = e.documentElement;
            t = ((n = e.defaultView) != null ? n : window).innerWidth - r.clientWidth
        },
        after({ doc: e, d: n }) {
            let r = e.documentElement
                , i = r.clientWidth - r.offsetWidth
                , s = t - i;
            n.style(r, "paddingRight", `${s}px`)
        }
    }
}
function GD() {
    return wC() ? {
        before({ doc: t, d: e, meta: n }) {
            function r(i) {
                return n.containers.flatMap(s => s()).some(s => s.contains(i))
            }
            e.microTask(() => {
                var i;
                if (window.getComputedStyle(t.documentElement).scrollBehavior !== "auto") {
                    let a = Ro();
                    a.style(t.documentElement, "scrollBehavior", "auto"),
                        e.add(() => e.microTask(() => a.dispose()))
                }
                let s = (i = window.scrollY) != null ? i : window.pageYOffset
                    , o = null;
                e.addEventListener(t, "click", a => {
                    if (a.target instanceof HTMLElement)
                        try {
                            let l = a.target.closest("a");
                            if (!l)
                                return;
                            let { hash: c } = new URL(l.href)
                                , d = t.querySelector(c);
                            d && !r(d) && (o = d)
                        } catch { }
                }
                    , !0),
                    e.addEventListener(t, "touchstart", a => {
                        if (a.target instanceof HTMLElement)
                            if (r(a.target)) {
                                let l = a.target;
                                for (; l.parentElement && r(l.parentElement);)
                                    l = l.parentElement;
                                e.style(l, "overscrollBehavior", "contain")
                            } else
                                e.style(a.target, "touchAction", "none")
                    }
                    ),
                    e.addEventListener(t, "touchmove", a => {
                        if (a.target instanceof HTMLElement) {
                            if (a.target.tagName === "INPUT")
                                return;
                            if (r(a.target)) {
                                let l = a.target;
                                for (; l.parentElement && l.dataset.headlessuiPortal !== "" && !(l.scrollHeight > l.clientHeight || l.scrollWidth > l.clientWidth);)
                                    l = l.parentElement;
                                l.dataset.headlessuiPortal === "" && a.preventDefault()
                            } else
                                a.preventDefault()
                        }
                    }
                        , {
                            passive: !1
                        }),
                    e.add(() => {
                        var a;
                        let l = (a = window.scrollY) != null ? a : window.pageYOffset;
                        s !== l && window.scrollTo(0, s),
                            o && o.isConnected && (o.scrollIntoView({
                                block: "nearest"
                            }),
                                o = null)
                    }
                    )
            }
            )
        }
    } : {}
}
function JD() {
    return {
        before({ doc: t, d: e }) {
            e.style(t.documentElement, "overflow", "hidden")
        }
    }
}
function ZD(t) {
    let e = {};
    for (let n of t)
        Object.assign(e, n(e));
    return e
}
let fa = KD(() => new Map, {
    PUSH(t, e) {
        var n;
        let r = (n = this.get(t)) != null ? n : {
            doc: t,
            count: 0,
            d: Ro(),
            meta: new Set
        };
        return r.count++,
            r.meta.add(e),
            this.set(t, r),
            this
    },
    POP(t, e) {
        let n = this.get(t);
        return n && (n.count--,
            n.meta.delete(e)),
            this
    },
    SCROLL_PREVENT({ doc: t, d: e, meta: n }) {
        let r = {
            doc: t,
            d: e,
            meta: ZD(n)
        }
            , i = [GD(), qD(), JD()];
        i.forEach(({ before: s }) => s?.(r)),
            i.forEach(({ after: s }) => s?.(r))
    },
    SCROLL_ALLOW({ d: t }) {
        t.dispose()
    },
    TEARDOWN({ doc: t }) {
        this.delete(t)
    }
});
fa.subscribe(() => {
    let t = fa.getSnapshot()
        , e = new Map;
    for (let [n] of t)
        e.set(n, n.documentElement.style.overflow);
    for (let n of t.values()) {
        let r = e.get(n.doc) === "hidden"
            , i = n.count !== 0;
        (i && !r || !i && r) && fa.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n),
            n.count === 0 && fa.dispatch("TEARDOWN", n)
    }
}
);
function YD(t, e, n) {
    let r = UD(fa)
        , i = G(() => {
            let s = t.value ? r.value.get(t.value) : void 0;
            return s ? s.count > 0 : !1
        }
        );
    return vt([t, e], ([s, o], [a], l) => {
        if (!s || !o)
            return;
        fa.dispatch("PUSH", s, n);
        let c = !1;
        l(() => {
            c || (fa.dispatch("POP", a ?? s, n),
                c = !0)
        }
        )
    }
        , {
            immediate: !0
        }),
        i
}
let m0 = new Map
    , $u = new Map;
function Fx(t, e = ce(!0)) {
    Ft(n => {
        var r;
        if (!e.value)
            return;
        let i = Ge(t);
        if (!i)
            return;
        n(function () {
            var o;
            if (!i)
                return;
            let a = (o = $u.get(i)) != null ? o : 1;
            if (a === 1 ? $u.delete(i) : $u.set(i, a - 1),
                a !== 1)
                return;
            let l = m0.get(i);
            l && (l["aria-hidden"] === null ? i.removeAttribute("aria-hidden") : i.setAttribute("aria-hidden", l["aria-hidden"]),
                i.inert = l.inert,
                m0.delete(i))
        });
        let s = (r = $u.get(i)) != null ? r : 0;
        $u.set(i, s + 1),
            s === 0 && (m0.set(i, {
                "aria-hidden": i.getAttribute("aria-hidden"),
                inert: i.inert
            }),
                i.setAttribute("aria-hidden", "true"),
                i.inert = !0)
    }
    )
}
function XD({ defaultContainers: t = [], portals: e, mainTreeNodeRef: n } = {}) {
    let r = ce(null)
        , i = zs(r);
    function s() {
        var o, a, l;
        let c = [];
        for (let d of t)
            d !== null && (d instanceof HTMLElement ? c.push(d) : "value" in d && d.value instanceof HTMLElement && c.push(d.value));
        if (e != null && e.value)
            for (let d of e.value)
                c.push(d);
        for (let d of (o = i?.querySelectorAll("html > *, body > *")) != null ? o : [])
            d !== document.body && d !== document.head && d instanceof HTMLElement && d.id !== "headlessui-portal-root" && (d.contains(Ge(r)) || d.contains((l = (a = Ge(r)) == null ? void 0 : a.getRootNode()) == null ? void 0 : l.host) || c.some(h => d.contains(h)) || c.push(d));
        return c
    }
    return {
        resolveContainers: s,
        contains(o) {
            return s().some(a => a.contains(o))
        },
        mainTreeNodeRef: r,
        MainTreeNode() {
            return n != null ? null : Mt(Fh, {
                features: Mc.Hidden,
                ref: r
            })
        }
    }
}
let BC = Symbol("ForcePortalRootContext");
function QD() {
    return Dt(BC, !1)
}
let Hx = je({
    name: "ForcePortalRoot",
    props: {
        as: {
            type: [Object, String],
            default: "template"
        },
        force: {
            type: Boolean,
            default: !1
        }
    },
    setup(t, { slots: e, attrs: n }) {
        return Hn(BC, t.force),
            () => {
                let { force: r, ...i } = t;
                return Wn({
                    theirProps: i,
                    ourProps: {},
                    slot: {},
                    slots: e,
                    attrs: n,
                    name: "ForcePortalRoot"
                })
            }
    }
})
    , $C = Symbol("StackContext");
var w1 = (t => (t[t.Add = 0] = "Add",
    t[t.Remove = 1] = "Remove",
    t))(w1 || {});
function ej() {
    return Dt($C, () => { }
    )
}
function tj({ type: t, enabled: e, element: n, onUpdate: r }) {
    let i = ej();
    function s(...o) {
        r?.(...o),
            i(...o)
    }
    Nt(() => {
        vt(e, (o, a) => {
            o ? s(0, t, n) : a === !0 && s(1, t, n)
        }
            , {
                immediate: !0,
                flush: "sync"
            })
    }
    ),
        xn(() => {
            e.value && s(1, t, n)
        }
        ),
        Hn($C, s)
}
let zC = Symbol("DescriptionContext");
function nj() {
    let t = Dt(zC, null);
    if (t === null)
        throw new Error("Missing parent");
    return t
}
function rj({ slot: t = ce({}), name: e = "Description", props: n = {} } = {}) {
    let r = ce([]);
    function i(s) {
        return r.value.push(s),
            () => {
                let o = r.value.indexOf(s);
                o !== -1 && r.value.splice(o, 1)
            }
    }
    return Hn(zC, {
        register: i,
        slot: t,
        name: e,
        props: n
    }),
        G(() => r.value.length > 0 ? r.value.join(" ") : void 0)
}
let JQ = je({
    name: "Description",
    props: {
        as: {
            type: [Object, String],
            default: "p"
        },
        id: {
            type: String,
            default: null
        }
    },
    setup(t, { attrs: e, slots: n }) {
        var r;
        let i = (r = t.id) != null ? r : `headlessui-description-${ss()}`
            , s = nj();
        return Nt(() => xn(s.register(i))),
            () => {
                let { name: o = "Description", slot: a = ce({}), props: l = {} } = s
                    , { ...c } = t
                    , d = {
                        ...Object.entries(l).reduce((h, [p, g]) => Object.assign(h, {
                            [p]: ie(g)
                        }), {}),
                        id: i
                    };
                return Wn({
                    ourProps: d,
                    theirProps: c,
                    slot: a.value,
                    attrs: e,
                    slots: n,
                    name: o
                })
            }
    }
});
function ij(t) {
    let e = zs(t);
    if (!e) {
        if (t === null)
            return null;
        throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${t}`)
    }
    let n = e.getElementById("headlessui-portal-root");
    if (n)
        return n;
    let r = e.createElement("div");
    return r.setAttribute("id", "headlessui-portal-root"),
        e.body.appendChild(r)
}
const x1 = new WeakMap;
function sj(t) {
    var e;
    return (e = x1.get(t)) != null ? e : 0
}
function Vx(t, e) {
    let n = e(sj(t));
    return n <= 0 ? x1.delete(t) : x1.set(t, n),
        n
}
let oj = je({
    name: "Portal",
    props: {
        as: {
            type: [Object, String],
            default: "div"
        }
    },
    setup(t, { slots: e, attrs: n }) {
        let r = ce(null)
            , i = G(() => zs(r))
            , s = QD()
            , o = Dt(FC, null)
            , a = ce(s === !0 || o == null ? ij(r.value) : o.resolveTarget());
        a.value && Vx(a.value, p => p + 1);
        let l = ce(!1);
        Nt(() => {
            l.value = !0
        }
        ),
            Ft(() => {
                s || o != null && (a.value = o.resolveTarget())
            }
            );
        let c = Dt(_1, null)
            , d = !1
            , h = pn();
        return vt(r, () => {
            if (d || !c)
                return;
            let p = Ge(r);
            p && (xn(c.register(p), h),
                d = !0)
        }
        ),
            xn(() => {
                var p, g;
                let y = (p = i.value) == null ? void 0 : p.getElementById("headlessui-portal-root");
                !y || a.value !== y || Vx(a.value, x => x - 1) || a.value.children.length > 0 || (g = a.value.parentElement) == null || g.removeChild(a.value)
            }
            ),
            () => {
                if (!l.value || a.value === null)
                    return null;
                let p = {
                    ref: r,
                    "data-headlessui-portal": ""
                };
                return Mt(im, {
                    to: a.value
                }, Wn({
                    ourProps: p,
                    theirProps: t,
                    slot: {},
                    attrs: n,
                    slots: e,
                    name: "Portal"
                }))
            }
    }
})
    , _1 = Symbol("PortalParentContext");
function aj() {
    let t = Dt(_1, null)
        , e = ce([]);
    function n(s) {
        return e.value.push(s),
            t && t.register(s),
            () => r(s)
    }
    function r(s) {
        let o = e.value.indexOf(s);
        o !== -1 && e.value.splice(o, 1),
            t && t.unregister(s)
    }
    let i = {
        register: n,
        unregister: r,
        portals: e
    };
    return [e, je({
        name: "PortalWrapper",
        setup(s, { slots: o }) {
            return Hn(_1, i),
                () => {
                    var a;
                    return (a = o.default) == null ? void 0 : a.call(o)
                }
        }
    })]
}
let FC = Symbol("PortalGroupContext")
    , lj = je({
        name: "PortalGroup",
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            target: {
                type: Object,
                default: null
            }
        },
        setup(t, { attrs: e, slots: n }) {
            let r = wn({
                resolveTarget() {
                    return t.target
                }
            });
            return Hn(FC, r),
                () => {
                    let { target: i, ...s } = t;
                    return Wn({
                        theirProps: s,
                        ourProps: {},
                        slot: {},
                        attrs: e,
                        slots: n,
                        name: "PortalGroup"
                    })
                }
        }
    });
var uj = (t => (t[t.Open = 0] = "Open",
    t[t.Closed = 1] = "Closed",
    t))(uj || {});
let S1 = Symbol("DialogContext");
function dm(t) {
    let e = Dt(S1, null);
    if (e === null) {
        let n = new Error(`<${t} /> is missing a parent <Dialog /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(n, dm),
        n
    }
    return e
}
let If = "DC8F892D-2EBD-447C-A4C8-A03058436FF4"
    , cj = je({
        name: "Dialog",
        inheritAttrs: !1,
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            },
            open: {
                type: [Boolean, String],
                default: If
            },
            initialFocus: {
                type: Object,
                default: null
            },
            id: {
                type: String,
                default: null
            },
            role: {
                type: String,
                default: "dialog"
            }
        },
        emits: {
            close: t => !0
        },
        setup(t, { emit: e, attrs: n, slots: r, expose: i }) {
            var s, o;
            let a = (s = t.id) != null ? s : `headlessui-dialog-${ss()}`
                , l = ce(!1);
            Nt(() => {
                l.value = !0
            }
            );
            let c = !1
                , d = G(() => t.role === "dialog" || t.role === "alertdialog" ? t.role : (c || (c = !0,
                    console.warn(`Invalid role [${d}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)),
                    "dialog"))
                , h = ce(0)
                , p = cm()
                , g = G(() => t.open === If && p !== null ? (p.value & jn.Open) === jn.Open : t.open)
                , y = ce(null)
                , x = G(() => zs(y));
            if (i({
                el: y,
                $el: y
            }),
                !(t.open !== If || p !== null))
                throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
            if (typeof g.value != "boolean")
                throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${g.value === If ? void 0 : t.open}`);
            let S = G(() => l.value && g.value ? 0 : 1)
                , k = G(() => S.value === 0)
                , A = G(() => h.value > 1)
                , C = Dt(S1, null) !== null
                , [m, b] = aj()
                , { resolveContainers: w, mainTreeNodeRef: T, MainTreeNode: O } = XD({
                    portals: m,
                    defaultContainers: [G(() => {
                        var ee;
                        return (ee = F.panelRef.value) != null ? ee : y.value
                    }
                    )]
                })
                , M = G(() => A.value ? "parent" : "leaf")
                , E = G(() => p !== null ? (p.value & jn.Closing) === jn.Closing : !1)
                , N = G(() => C || E.value ? !1 : k.value)
                , j = G(() => {
                    var ee, Se, Ze;
                    return (Ze = Array.from((Se = (ee = x.value) == null ? void 0 : ee.querySelectorAll("body > *")) != null ? Se : []).find(Ke => Ke.id === "headlessui-portal-root" ? !1 : Ke.contains(Ge(T)) && Ke instanceof HTMLElement)) != null ? Ze : null
                }
                );
            Fx(j, N);
            let z = G(() => A.value ? !0 : k.value)
                , V = G(() => {
                    var ee, Se, Ze;
                    return (Ze = Array.from((Se = (ee = x.value) == null ? void 0 : ee.querySelectorAll("[data-headlessui-portal]")) != null ? Se : []).find(Ke => Ke.contains(Ge(T)) && Ke instanceof HTMLElement)) != null ? Ze : null
                }
                );
            Fx(V, z),
                tj({
                    type: "Dialog",
                    enabled: G(() => S.value === 0),
                    element: y,
                    onUpdate: (ee, Se) => {
                        if (Se === "Dialog")
                            return Zn(ee, {
                                [w1.Add]: () => h.value += 1,
                                [w1.Remove]: () => h.value -= 1
                            })
                    }
                });
            let W = rj({
                name: "DialogDescription",
                slot: G(() => ({
                    open: g.value
                }))
            })
                , P = ce(null)
                , F = {
                    titleId: P,
                    panelRef: ce(null),
                    dialogState: S,
                    setTitleId(ee) {
                        P.value !== ee && (P.value = ee)
                    },
                    close() {
                        e("close", !1)
                    }
                };
            Hn(S1, F);
            let K = G(() => !(!k.value || A.value));
            SC(w, (ee, Se) => {
                ee.preventDefault(),
                    F.close(),
                    un(() => Se?.focus())
            }
                , K);
            let re = G(() => !(A.value || S.value !== 0));
            IC((o = x.value) == null ? void 0 : o.defaultView, "keydown", ee => {
                re.value && (ee.defaultPrevented || ee.key === xr.Escape && (ee.preventDefault(),
                    ee.stopPropagation(),
                    F.close()))
            }
            );
            let Te = G(() => !(E.value || S.value !== 0 || C));
            return YD(x, Te, ee => {
                var Se;
                return {
                    containers: [...(Se = ee.containers) != null ? Se : [], w]
                }
            }
            ),
                Ft(ee => {
                    if (S.value !== 0)
                        return;
                    let Se = Ge(y);
                    if (!Se)
                        return;
                    let Ze = new ResizeObserver(Ke => {
                        for (let Ye of Ke) {
                            let Qe = Ye.target.getBoundingClientRect();
                            Qe.x === 0 && Qe.y === 0 && Qe.width === 0 && Qe.height === 0 && F.close()
                        }
                    }
                    );
                    Ze.observe(Se),
                        ee(() => Ze.disconnect())
                }
                ),
                () => {
                    let { open: ee, initialFocus: Se, ...Ze } = t
                        , Ke = {
                            ...n,
                            ref: y,
                            id: a,
                            role: d.value,
                            "aria-modal": S.value === 0 ? !0 : void 0,
                            "aria-labelledby": P.value,
                            "aria-describedby": W.value
                        }
                        , Ye = {
                            open: S.value === 0
                        };
                    return Mt(Hx, {
                        force: !0
                    }, () => [Mt(oj, () => Mt(lj, {
                        target: y.value
                    }, () => Mt(Hx, {
                        force: !1
                    }, () => Mt(Bu, {
                        initialFocus: Se,
                        containers: w,
                        features: k.value ? Zn(M.value, {
                            parent: Bu.features.RestoreFocus,
                            leaf: Bu.features.All & ~Bu.features.FocusLock
                        }) : Bu.features.None
                    }, () => Mt(b, {}, () => Wn({
                        ourProps: Ke,
                        theirProps: {
                            ...Ze,
                            ...n
                        },
                        slot: Ye,
                        attrs: n,
                        slots: r,
                        visible: S.value === 0,
                        features: Po.RenderStrategy | Po.Static,
                        name: "Dialog"
                    })))))), Mt(O)])
                }
        }
    })
    , ZQ = je({
        name: "DialogOverlay",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(t, { attrs: e, slots: n }) {
            var r;
            let i = (r = t.id) != null ? r : `headlessui-dialog-overlay-${ss()}`
                , s = dm("DialogOverlay");
            function o(a) {
                a.target === a.currentTarget && (a.preventDefault(),
                    a.stopPropagation(),
                    s.close())
            }
            return () => {
                let { ...a } = t;
                return Wn({
                    ourProps: {
                        id: i,
                        "aria-hidden": !0,
                        onClick: o
                    },
                    theirProps: a,
                    slot: {
                        open: s.dialogState.value === 0
                    },
                    attrs: e,
                    slots: n,
                    name: "DialogOverlay"
                })
            }
        }
    })
    , dj = je({
        name: "DialogPanel",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(t, { attrs: e, slots: n, expose: r }) {
            var i;
            let s = (i = t.id) != null ? i : `headlessui-dialog-panel-${ss()}`
                , o = dm("DialogPanel");
            r({
                el: o.panelRef,
                $el: o.panelRef
            });
            function a(l) {
                l.stopPropagation()
            }
            return () => {
                let { ...l } = t
                    , c = {
                        id: s,
                        ref: o.panelRef,
                        onClick: a
                    };
                return Wn({
                    ourProps: c,
                    theirProps: l,
                    slot: {
                        open: o.dialogState.value === 0
                    },
                    attrs: e,
                    slots: n,
                    name: "DialogPanel"
                })
            }
        }
    })
    , fj = je({
        name: "DialogTitle",
        props: {
            as: {
                type: [Object, String],
                default: "h2"
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(t, { attrs: e, slots: n }) {
            var r;
            let i = (r = t.id) != null ? r : `headlessui-dialog-title-${ss()}`
                , s = dm("DialogTitle");
            return Nt(() => {
                s.setTitleId(i),
                    xn(() => s.setTitleId(null))
            }
            ),
                () => {
                    let { ...o } = t;
                    return Wn({
                        ourProps: {
                            id: i
                        },
                        theirProps: o,
                        slot: {
                            open: s.dialogState.value === 0
                        },
                        attrs: e,
                        slots: n,
                        name: "DialogTitle"
                    })
                }
        }
    });
function hj(t) {
    let e = {
        called: !1
    };
    return (...n) => {
        if (!e.called)
            return e.called = !0,
                t(...n)
    }
}
function g0(t, ...e) {
    t && e.length > 0 && t.classList.add(...e)
}
function Lf(t, ...e) {
    t && e.length > 0 && t.classList.remove(...e)
}
var k1 = (t => (t.Finished = "finished",
    t.Cancelled = "cancelled",
    t))(k1 || {});
function pj(t, e) {
    let n = Ro();
    if (!t)
        return n.dispose;
    let { transitionDuration: r, transitionDelay: i } = getComputedStyle(t)
        , [s, o] = [r, i].map(a => {
            let [l = 0] = a.split(",").filter(Boolean).map(c => c.includes("ms") ? parseFloat(c) : parseFloat(c) * 1e3).sort((c, d) => d - c);
            return l
        }
        );
    return s !== 0 ? n.setTimeout(() => e("finished"), s + o) : e("finished"),
        n.add(() => e("cancelled")),
        n.dispose
}
function Wx(t, e, n, r, i, s) {
    let o = Ro()
        , a = s !== void 0 ? hj(s) : () => { }
        ;
    return Lf(t, ...i),
        g0(t, ...e, ...n),
        o.nextFrame(() => {
            Lf(t, ...n),
                g0(t, ...r),
                o.add(pj(t, l => (Lf(t, ...r, ...e),
                    g0(t, ...i),
                    a(l))))
        }
        ),
        o.add(() => Lf(t, ...e, ...n, ...r, ...i)),
        o.add(() => a("cancelled")),
        o.dispose
}
function aa(t = "") {
    return t.split(/\s+/).filter(e => e.length > 1)
}
let sv = Symbol("TransitionContext");
var mj = (t => (t.Visible = "visible",
    t.Hidden = "hidden",
    t))(mj || {});
function gj() {
    return Dt(sv, null) !== null
}
function yj() {
    let t = Dt(sv, null);
    if (t === null)
        throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
    return t
}
function vj() {
    let t = Dt(ov, null);
    if (t === null)
        throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
    return t
}
let ov = Symbol("NestingContext");
function fm(t) {
    return "children" in t ? fm(t.children) : t.value.filter(({ state: e }) => e === "visible").length > 0
}
function HC(t) {
    let e = ce([])
        , n = ce(!1);
    Nt(() => n.value = !0),
        xn(() => n.value = !1);
    function r(s, o = yo.Hidden) {
        let a = e.value.findIndex(({ id: l }) => l === s);
        a !== -1 && (Zn(o, {
            [yo.Unmount]() {
                e.value.splice(a, 1)
            },
            [yo.Hidden]() {
                e.value[a].state = "hidden"
            }
        }),
            !fm(e) && n.value && t?.())
    }
    function i(s) {
        let o = e.value.find(({ id: a }) => a === s);
        return o ? o.state !== "visible" && (o.state = "visible") : e.value.push({
            id: s,
            state: "visible"
        }),
            () => r(s, yo.Unmount)
    }
    return {
        children: e,
        register: i,
        unregister: r
    }
}
let VC = Po.RenderStrategy
    , WC = je({
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            show: {
                type: [Boolean],
                default: null
            },
            unmount: {
                type: [Boolean],
                default: !0
            },
            appear: {
                type: [Boolean],
                default: !1
            },
            enter: {
                type: [String],
                default: ""
            },
            enterFrom: {
                type: [String],
                default: ""
            },
            enterTo: {
                type: [String],
                default: ""
            },
            entered: {
                type: [String],
                default: ""
            },
            leave: {
                type: [String],
                default: ""
            },
            leaveFrom: {
                type: [String],
                default: ""
            },
            leaveTo: {
                type: [String],
                default: ""
            }
        },
        emits: {
            beforeEnter: () => !0,
            afterEnter: () => !0,
            beforeLeave: () => !0,
            afterLeave: () => !0
        },
        setup(t, { emit: e, attrs: n, slots: r, expose: i }) {
            let s = ce(0);
            function o() {
                s.value |= jn.Opening,
                    e("beforeEnter")
            }
            function a() {
                s.value &= ~jn.Opening,
                    e("afterEnter")
            }
            function l() {
                s.value |= jn.Closing,
                    e("beforeLeave")
            }
            function c() {
                s.value &= ~jn.Closing,
                    e("afterLeave")
            }
            if (!gj() && TD())
                return () => Mt(UC, {
                    ...t,
                    onBeforeEnter: o,
                    onAfterEnter: a,
                    onBeforeLeave: l,
                    onAfterLeave: c
                }, r);
            let d = ce(null)
                , h = G(() => t.unmount ? yo.Unmount : yo.Hidden);
            i({
                el: d,
                $el: d
            });
            let { show: p, appear: g } = yj()
                , { register: y, unregister: x } = vj()
                , S = ce(p.value ? "visible" : "hidden")
                , k = {
                    value: !0
                }
                , A = ss()
                , C = {
                    value: !1
                }
                , m = HC(() => {
                    !C.value && S.value !== "hidden" && (S.value = "hidden",
                        x(A),
                        c())
                }
                );
            Nt(() => {
                let z = y(A);
                xn(z)
            }
            ),
                Ft(() => {
                    if (h.value === yo.Hidden && A) {
                        if (p.value && S.value !== "visible") {
                            S.value = "visible";
                            return
                        }
                        Zn(S.value, {
                            hidden: () => x(A),
                            visible: () => y(A)
                        })
                    }
                }
                );
            let b = aa(t.enter)
                , w = aa(t.enterFrom)
                , T = aa(t.enterTo)
                , O = aa(t.entered)
                , M = aa(t.leave)
                , E = aa(t.leaveFrom)
                , N = aa(t.leaveTo);
            Nt(() => {
                Ft(() => {
                    if (S.value === "visible") {
                        let z = Ge(d);
                        if (z instanceof Comment && z.data === "")
                            throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?")
                    }
                }
                )
            }
            );
            function j(z) {
                let V = k.value && !g.value
                    , W = Ge(d);
                !W || !(W instanceof HTMLElement) || V || (C.value = !0,
                    p.value && o(),
                    p.value || l(),
                    z(p.value ? Wx(W, b, w, T, O, P => {
                        C.value = !1,
                            P === k1.Finished && a()
                    }
                    ) : Wx(W, M, E, N, O, P => {
                        C.value = !1,
                            P === k1.Finished && (fm(m) || (S.value = "hidden",
                                x(A),
                                c()))
                    }
                    )))
            }
            return Nt(() => {
                vt([p], (z, V, W) => {
                    j(W),
                        k.value = !1
                }
                    , {
                        immediate: !0
                    })
            }
            ),
                Hn(ov, m),
                TC(G(() => Zn(S.value, {
                    visible: jn.Open,
                    hidden: jn.Closed
                }) | s.value)),
                () => {
                    let { appear: z, show: V, enter: W, enterFrom: P, enterTo: F, entered: K, leave: re, leaveFrom: Te, leaveTo: ee, ...Se } = t
                        , Ze = {
                            ref: d
                        }
                        , Ke = {
                            ...Se,
                            ...g.value && p.value && yd.isServer ? {
                                class: mt([n.class, Se.class, ...b, ...w])
                            } : {}
                        };
                    return Wn({
                        theirProps: Ke,
                        ourProps: Ze,
                        slot: {},
                        slots: r,
                        attrs: n,
                        features: VC,
                        visible: S.value === "visible",
                        name: "TransitionChild"
                    })
                }
        }
    })
    , bj = WC
    , UC = je({
        inheritAttrs: !1,
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            show: {
                type: [Boolean],
                default: null
            },
            unmount: {
                type: [Boolean],
                default: !0
            },
            appear: {
                type: [Boolean],
                default: !1
            },
            enter: {
                type: [String],
                default: ""
            },
            enterFrom: {
                type: [String],
                default: ""
            },
            enterTo: {
                type: [String],
                default: ""
            },
            entered: {
                type: [String],
                default: ""
            },
            leave: {
                type: [String],
                default: ""
            },
            leaveFrom: {
                type: [String],
                default: ""
            },
            leaveTo: {
                type: [String],
                default: ""
            }
        },
        emits: {
            beforeEnter: () => !0,
            afterEnter: () => !0,
            beforeLeave: () => !0,
            afterLeave: () => !0
        },
        setup(t, { emit: e, attrs: n, slots: r }) {
            let i = cm()
                , s = G(() => t.show === null && i !== null ? (i.value & jn.Open) === jn.Open : t.show);
            Ft(() => {
                if (![!0, !1].includes(s.value))
                    throw new Error('A <Transition /> is used but it is missing a `:show="true | false"` prop.')
            }
            );
            let o = ce(s.value ? "visible" : "hidden")
                , a = HC(() => {
                    o.value = "hidden"
                }
                )
                , l = ce(!0)
                , c = {
                    show: s,
                    appear: G(() => t.appear || !l.value)
                };
            return Nt(() => {
                Ft(() => {
                    l.value = !1,
                        s.value ? o.value = "visible" : fm(a) || (o.value = "hidden")
                }
                )
            }
            ),
                Hn(ov, a),
                Hn(sv, c),
                () => {
                    let d = vd(t, ["show", "appear", "unmount", "onBeforeEnter", "onBeforeLeave", "onAfterEnter", "onAfterLeave"])
                        , h = {
                            unmount: t.unmount
                        };
                    return Wn({
                        ourProps: {
                            ...h,
                            as: "template"
                        },
                        theirProps: {},
                        slot: {},
                        slots: {
                            ...r,
                            default: () => [Mt(bj, {
                                onBeforeEnter: () => e("beforeEnter"),
                                onAfterEnter: () => e("afterEnter"),
                                onBeforeLeave: () => e("beforeLeave"),
                                onAfterLeave: () => e("afterLeave"),
                                ...n,
                                ...h,
                                ...d
                            }, r.default)]
                        },
                        attrs: {},
                        features: VC,
                        visible: o.value === "visible",
                        name: "Transition"
                    })
                }
        }
    });
var Cr = "top"
    , ci = "bottom"
    , di = "right"
    , Er = "left"
    , av = "auto"
    , bd = [Cr, ci, di, Er]
    , Gl = "start"
    , Rc = "end"
    , wj = "clippingParents"
    , KC = "viewport"
    , zu = "popper"
    , xj = "reference"
    , Ux = bd.reduce(function (t, e) {
        return t.concat([e + "-" + Gl, e + "-" + Rc])
    }, [])
    , qC = [].concat(bd, [av]).reduce(function (t, e) {
        return t.concat([e, e + "-" + Gl, e + "-" + Rc])
    }, [])
    , _j = "beforeRead"
    , Sj = "read"
    , kj = "afterRead"
    , Cj = "beforeMain"
    , Ej = "main"
    , Tj = "afterMain"
    , Aj = "beforeWrite"
    , Oj = "write"
    , Mj = "afterWrite"
    , Rj = [_j, Sj, kj, Cj, Ej, Tj, Aj, Oj, Mj];
function Yi(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}
function zr(t) {
    if (t == null)
        return window;
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}
function Ia(t) {
    var e = zr(t).Element;
    return t instanceof e || t instanceof Element
}
function ai(t) {
    var e = zr(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement
}
function lv(t) {
    if (typeof ShadowRoot > "u")
        return !1;
    var e = zr(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot
}
function Pj(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function (n) {
        var r = e.styles[n] || {}
            , i = e.attributes[n] || {}
            , s = e.elements[n];
        !ai(s) || !Yi(s) || (Object.assign(s.style, r),
            Object.keys(i).forEach(function (o) {
                var a = i[o];
                a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a)
            }))
    })
}
function Nj(t) {
    var e = t.state
        , n = {
            popper: {
                position: e.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
    return Object.assign(e.elements.popper.style, n.popper),
        e.styles = n,
        e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function () {
            Object.keys(e.elements).forEach(function (r) {
                var i = e.elements[r]
                    , s = e.attributes[r] || {}
                    , o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r])
                    , a = o.reduce(function (l, c) {
                        return l[c] = "",
                            l
                    }, {});
                !ai(i) || !Yi(i) || (Object.assign(i.style, a),
                    Object.keys(s).forEach(function (l) {
                        i.removeAttribute(l)
                    }))
            })
        }
}
const Ij = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: Pj,
    effect: Nj,
    requires: ["computeStyles"]
};
function Ki(t) {
    return t.split("-")[0]
}
var ba = Math.max
    , Hh = Math.min
    , Jl = Math.round;
function C1() {
    var t = navigator.userAgentData;
    return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function (e) {
        return e.brand + "/" + e.version
    }).join(" ") : navigator.userAgent
}
function GC() {
    return !/^((?!chrome|android).)*safari/i.test(C1())
}
function Zl(t, e, n) {
    e === void 0 && (e = !1),
        n === void 0 && (n = !1);
    var r = t.getBoundingClientRect()
        , i = 1
        , s = 1;
    e && ai(t) && (i = t.offsetWidth > 0 && Jl(r.width) / t.offsetWidth || 1,
        s = t.offsetHeight > 0 && Jl(r.height) / t.offsetHeight || 1);
    var o = Ia(t) ? zr(t) : window
        , a = o.visualViewport
        , l = !GC() && n
        , c = (r.left + (l && a ? a.offsetLeft : 0)) / i
        , d = (r.top + (l && a ? a.offsetTop : 0)) / s
        , h = r.width / i
        , p = r.height / s;
    return {
        width: h,
        height: p,
        top: d,
        right: c + h,
        bottom: d + p,
        left: c,
        x: c,
        y: d
    }
}
function uv(t) {
    var e = Zl(t)
        , n = t.offsetWidth
        , r = t.offsetHeight;
    return Math.abs(e.width - n) <= 1 && (n = e.width),
        Math.abs(e.height - r) <= 1 && (r = e.height),
    {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: n,
        height: r
    }
}
function JC(t, e) {
    var n = e.getRootNode && e.getRootNode();
    if (t.contains(e))
        return !0;
    if (n && lv(n)) {
        var r = e;
        do {
            if (r && t.isSameNode(r))
                return !0;
            r = r.parentNode || r.host
        } while (r)
    }
    return !1
}
function Ls(t) {
    return zr(t).getComputedStyle(t)
}
function Lj(t) {
    return ["table", "td", "th"].indexOf(Yi(t)) >= 0
}
function Ko(t) {
    return ((Ia(t) ? t.ownerDocument : t.document) || window.document).documentElement
}
function hm(t) {
    return Yi(t) === "html" ? t : t.assignedSlot || t.parentNode || (lv(t) ? t.host : null) || Ko(t)
}
function Kx(t) {
    return !ai(t) || Ls(t).position === "fixed" ? null : t.offsetParent
}
function Dj(t) {
    var e = /firefox/i.test(C1())
        , n = /Trident/i.test(C1());
    if (n && ai(t)) {
        var r = Ls(t);
        if (r.position === "fixed")
            return null
    }
    var i = hm(t);
    for (lv(i) && (i = i.host); ai(i) && ["html", "body"].indexOf(Yi(i)) < 0;) {
        var s = Ls(i);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
            return i;
        i = i.parentNode
    }
    return null
}
function wd(t) {
    for (var e = zr(t), n = Kx(t); n && Lj(n) && Ls(n).position === "static";)
        n = Kx(n);
    return n && (Yi(n) === "html" || Yi(n) === "body" && Ls(n).position === "static") ? e : n || Dj(t) || e
}
function cv(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}
function lc(t, e, n) {
    return ba(t, Hh(e, n))
}
function jj(t, e, n) {
    var r = lc(t, e, n);
    return r > n ? n : r
}
function ZC() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function YC(t) {
    return Object.assign({}, ZC(), t)
}
function XC(t, e) {
    return e.reduce(function (n, r) {
        return n[r] = t,
            n
    }, {})
}
var Bj = function (e, n) {
    return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
        placement: n.placement
    })) : e,
        YC(typeof e != "number" ? e : XC(e, bd))
};
function $j(t) {
    var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = Ki(n.placement), l = cv(a), c = [Er, di].indexOf(a) >= 0, d = c ? "height" : "width";
    if (!(!s || !o)) {
        var h = Bj(i.padding, n)
            , p = uv(s)
            , g = l === "y" ? Cr : Er
            , y = l === "y" ? ci : di
            , x = n.rects.reference[d] + n.rects.reference[l] - o[l] - n.rects.popper[d]
            , S = o[l] - n.rects.reference[l]
            , k = wd(s)
            , A = k ? l === "y" ? k.clientHeight || 0 : k.clientWidth || 0 : 0
            , C = x / 2 - S / 2
            , m = h[g]
            , b = A - p[d] - h[y]
            , w = A / 2 - p[d] / 2 + C
            , T = lc(m, w, b)
            , O = l;
        n.modifiersData[r] = (e = {},
            e[O] = T,
            e.centerOffset = T - w,
            e)
    }
}
function zj(t) {
    var e = t.state
        , n = t.options
        , r = n.element
        , i = r === void 0 ? "[data-popper-arrow]" : r;
    i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i),
        !i) || JC(e.elements.popper, i) && (e.elements.arrow = i))
}
const Fj = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: $j,
    effect: zj,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function Yl(t) {
    return t.split("-")[1]
}
var Hj = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function Vj(t, e) {
    var n = t.x
        , r = t.y
        , i = e.devicePixelRatio || 1;
    return {
        x: Jl(n * i) / i || 0,
        y: Jl(r * i) / i || 0
    }
}
function qx(t) {
    var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, d = t.roundOffsets, h = t.isFixed, p = o.x, g = p === void 0 ? 0 : p, y = o.y, x = y === void 0 ? 0 : y, S = typeof d == "function" ? d({
        x: g,
        y: x
    }) : {
        x: g,
        y: x
    };
    g = S.x,
        x = S.y;
    var k = o.hasOwnProperty("x")
        , A = o.hasOwnProperty("y")
        , C = Er
        , m = Cr
        , b = window;
    if (c) {
        var w = wd(n)
            , T = "clientHeight"
            , O = "clientWidth";
        if (w === zr(n) && (w = Ko(n),
            Ls(w).position !== "static" && a === "absolute" && (T = "scrollHeight",
                O = "scrollWidth")),
            w = w,
            i === Cr || (i === Er || i === di) && s === Rc) {
            m = ci;
            var M = h && w === b && b.visualViewport ? b.visualViewport.height : w[T];
            x -= M - r.height,
                x *= l ? 1 : -1
        }
        if (i === Er || (i === Cr || i === ci) && s === Rc) {
            C = di;
            var E = h && w === b && b.visualViewport ? b.visualViewport.width : w[O];
            g -= E - r.width,
                g *= l ? 1 : -1
        }
    }
    var N = Object.assign({
        position: a
    }, c && Hj)
        , j = d === !0 ? Vj({
            x: g,
            y: x
        }, zr(n)) : {
            x: g,
            y: x
        };
    if (g = j.x,
        x = j.y,
        l) {
        var z;
        return Object.assign({}, N, (z = {},
            z[m] = A ? "0" : "",
            z[C] = k ? "0" : "",
            z.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + x + "px)" : "translate3d(" + g + "px, " + x + "px, 0)",
            z))
    }
    return Object.assign({}, N, (e = {},
        e[m] = A ? x + "px" : "",
        e[C] = k ? g + "px" : "",
        e.transform = "",
        e))
}
function Wj(t) {
    var e = t.state
        , n = t.options
        , r = n.gpuAcceleration
        , i = r === void 0 ? !0 : r
        , s = n.adaptive
        , o = s === void 0 ? !0 : s
        , a = n.roundOffsets
        , l = a === void 0 ? !0 : a
        , c = {
            placement: Ki(e.placement),
            variation: Yl(e.placement),
            popper: e.elements.popper,
            popperRect: e.rects.popper,
            gpuAcceleration: i,
            isFixed: e.options.strategy === "fixed"
        };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, qx(Object.assign({}, c, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))),
        e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, qx(Object.assign({}, c, {
            offsets: e.modifiersData.arrow,
            position: "absolute",
            adaptive: !1,
            roundOffsets: l
        })))),
        e.attributes.popper = Object.assign({}, e.attributes.popper, {
            "data-popper-placement": e.placement
        })
}
const Uj = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: Wj,
    data: {}
};
var Df = {
    passive: !0
};
function Kj(t) {
    var e = t.state
        , n = t.instance
        , r = t.options
        , i = r.scroll
        , s = i === void 0 ? !0 : i
        , o = r.resize
        , a = o === void 0 ? !0 : o
        , l = zr(e.elements.popper)
        , c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return s && c.forEach(function (d) {
        d.addEventListener("scroll", n.update, Df)
    }),
        a && l.addEventListener("resize", n.update, Df),
        function () {
            s && c.forEach(function (d) {
                d.removeEventListener("scroll", n.update, Df)
            }),
                a && l.removeEventListener("resize", n.update, Df)
        }
}
const qj = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () { },
    effect: Kj,
    data: {}
};
var Gj = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function ch(t) {
    return t.replace(/left|right|bottom|top/g, function (e) {
        return Gj[e]
    })
}
var Jj = {
    start: "end",
    end: "start"
};
function Gx(t) {
    return t.replace(/start|end/g, function (e) {
        return Jj[e]
    })
}
function dv(t) {
    var e = zr(t)
        , n = e.pageXOffset
        , r = e.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}
function fv(t) {
    return Zl(Ko(t)).left + dv(t).scrollLeft
}
function Zj(t, e) {
    var n = zr(t)
        , r = Ko(t)
        , i = n.visualViewport
        , s = r.clientWidth
        , o = r.clientHeight
        , a = 0
        , l = 0;
    if (i) {
        s = i.width,
            o = i.height;
        var c = GC();
        (c || !c && e === "fixed") && (a = i.offsetLeft,
            l = i.offsetTop)
    }
    return {
        width: s,
        height: o,
        x: a + fv(t),
        y: l
    }
}
function Yj(t) {
    var e, n = Ko(t), r = dv(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = ba(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = ba(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + fv(t), l = -r.scrollTop;
    return Ls(i || n).direction === "rtl" && (a += ba(n.clientWidth, i ? i.clientWidth : 0) - s),
    {
        width: s,
        height: o,
        x: a,
        y: l
    }
}
function hv(t) {
    var e = Ls(t)
        , n = e.overflow
        , r = e.overflowX
        , i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r)
}
function QC(t) {
    return ["html", "body", "#document"].indexOf(Yi(t)) >= 0 ? t.ownerDocument.body : ai(t) && hv(t) ? t : QC(hm(t))
}
function uc(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = QC(t)
        , i = r === ((n = t.ownerDocument) == null ? void 0 : n.body)
        , s = zr(r)
        , o = i ? [s].concat(s.visualViewport || [], hv(r) ? r : []) : r
        , a = e.concat(o);
    return i ? a : a.concat(uc(hm(o)))
}
function E1(t) {
    return Object.assign({}, t, {
        left: t.x,
        top: t.y,
        right: t.x + t.width,
        bottom: t.y + t.height
    })
}
function Xj(t, e) {
    var n = Zl(t, !1, e === "fixed");
    return n.top = n.top + t.clientTop,
        n.left = n.left + t.clientLeft,
        n.bottom = n.top + t.clientHeight,
        n.right = n.left + t.clientWidth,
        n.width = t.clientWidth,
        n.height = t.clientHeight,
        n.x = n.left,
        n.y = n.top,
        n
}
function Jx(t, e, n) {
    return e === KC ? E1(Zj(t, n)) : Ia(e) ? Xj(e, n) : E1(Yj(Ko(t)))
}
function Qj(t) {
    var e = uc(hm(t))
        , n = ["absolute", "fixed"].indexOf(Ls(t).position) >= 0
        , r = n && ai(t) ? wd(t) : t;
    return Ia(r) ? e.filter(function (i) {
        return Ia(i) && JC(i, r) && Yi(i) !== "body"
    }) : []
}
function eB(t, e, n, r) {
    var i = e === "clippingParents" ? Qj(t) : [].concat(e)
        , s = [].concat(i, [n])
        , o = s[0]
        , a = s.reduce(function (l, c) {
            var d = Jx(t, c, r);
            return l.top = ba(d.top, l.top),
                l.right = Hh(d.right, l.right),
                l.bottom = Hh(d.bottom, l.bottom),
                l.left = ba(d.left, l.left),
                l
        }, Jx(t, o, r));
    return a.width = a.right - a.left,
        a.height = a.bottom - a.top,
        a.x = a.left,
        a.y = a.top,
        a
}
function eE(t) {
    var e = t.reference, n = t.element, r = t.placement, i = r ? Ki(r) : null, s = r ? Yl(r) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
    switch (i) {
        case Cr:
            l = {
                x: o,
                y: e.y - n.height
            };
            break;
        case ci:
            l = {
                x: o,
                y: e.y + e.height
            };
            break;
        case di:
            l = {
                x: e.x + e.width,
                y: a
            };
            break;
        case Er:
            l = {
                x: e.x - n.width,
                y: a
            };
            break;
        default:
            l = {
                x: e.x,
                y: e.y
            }
    }
    var c = i ? cv(i) : null;
    if (c != null) {
        var d = c === "y" ? "height" : "width";
        switch (s) {
            case Gl:
                l[c] = l[c] - (e[d] / 2 - n[d] / 2);
                break;
            case Rc:
                l[c] = l[c] + (e[d] / 2 - n[d] / 2);
                break
        }
    }
    return l
}
function Pc(t, e) {
    e === void 0 && (e = {});
    var n = e
        , r = n.placement
        , i = r === void 0 ? t.placement : r
        , s = n.strategy
        , o = s === void 0 ? t.strategy : s
        , a = n.boundary
        , l = a === void 0 ? wj : a
        , c = n.rootBoundary
        , d = c === void 0 ? KC : c
        , h = n.elementContext
        , p = h === void 0 ? zu : h
        , g = n.altBoundary
        , y = g === void 0 ? !1 : g
        , x = n.padding
        , S = x === void 0 ? 0 : x
        , k = YC(typeof S != "number" ? S : XC(S, bd))
        , A = p === zu ? xj : zu
        , C = t.rects.popper
        , m = t.elements[y ? A : p]
        , b = eB(Ia(m) ? m : m.contextElement || Ko(t.elements.popper), l, d, o)
        , w = Zl(t.elements.reference)
        , T = eE({
            reference: w,
            element: C,
            strategy: "absolute",
            placement: i
        })
        , O = E1(Object.assign({}, C, T))
        , M = p === zu ? O : w
        , E = {
            top: b.top - M.top + k.top,
            bottom: M.bottom - b.bottom + k.bottom,
            left: b.left - M.left + k.left,
            right: M.right - b.right + k.right
        }
        , N = t.modifiersData.offset;
    if (p === zu && N) {
        var j = N[i];
        Object.keys(E).forEach(function (z) {
            var V = [di, ci].indexOf(z) >= 0 ? 1 : -1
                , W = [Cr, ci].indexOf(z) >= 0 ? "y" : "x";
            E[z] += j[W] * V
        })
    }
    return E
}
function tB(t, e) {
    e === void 0 && (e = {});
    var n = e
        , r = n.placement
        , i = n.boundary
        , s = n.rootBoundary
        , o = n.padding
        , a = n.flipVariations
        , l = n.allowedAutoPlacements
        , c = l === void 0 ? qC : l
        , d = Yl(r)
        , h = d ? a ? Ux : Ux.filter(function (y) {
            return Yl(y) === d
        }) : bd
        , p = h.filter(function (y) {
            return c.indexOf(y) >= 0
        });
    p.length === 0 && (p = h);
    var g = p.reduce(function (y, x) {
        return y[x] = Pc(t, {
            placement: x,
            boundary: i,
            rootBoundary: s,
            padding: o
        })[Ki(x)],
            y
    }, {});
    return Object.keys(g).sort(function (y, x) {
        return g[y] - g[x]
    })
}
function nB(t) {
    if (Ki(t) === av)
        return [];
    var e = ch(t);
    return [Gx(t), e, Gx(e)]
}
function rB(t) {
    var e = t.state
        , n = t.options
        , r = t.name;
    if (!e.modifiersData[r]._skip) {
        for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, c = n.padding, d = n.boundary, h = n.rootBoundary, p = n.altBoundary, g = n.flipVariations, y = g === void 0 ? !0 : g, x = n.allowedAutoPlacements, S = e.options.placement, k = Ki(S), A = k === S, C = l || (A || !y ? [ch(S)] : nB(S)), m = [S].concat(C).reduce(function (Ke, Ye) {
            return Ke.concat(Ki(Ye) === av ? tB(e, {
                placement: Ye,
                boundary: d,
                rootBoundary: h,
                padding: c,
                flipVariations: y,
                allowedAutoPlacements: x
            }) : Ye)
        }, []), b = e.rects.reference, w = e.rects.popper, T = new Map, O = !0, M = m[0], E = 0; E < m.length; E++) {
            var N = m[E]
                , j = Ki(N)
                , z = Yl(N) === Gl
                , V = [Cr, ci].indexOf(j) >= 0
                , W = V ? "width" : "height"
                , P = Pc(e, {
                    placement: N,
                    boundary: d,
                    rootBoundary: h,
                    altBoundary: p,
                    padding: c
                })
                , F = V ? z ? di : Er : z ? ci : Cr;
            b[W] > w[W] && (F = ch(F));
            var K = ch(F)
                , re = [];
            if (s && re.push(P[j] <= 0),
                a && re.push(P[F] <= 0, P[K] <= 0),
                re.every(function (Ke) {
                    return Ke
                })) {
                M = N,
                    O = !1;
                break
            }
            T.set(N, re)
        }
        if (O)
            for (var Te = y ? 3 : 1, ee = function (Ye) {
                var Qe = m.find(function (Y) {
                    var he = T.get(Y);
                    if (he)
                        return he.slice(0, Ye).every(function (ge) {
                            return ge
                        })
                });
                if (Qe)
                    return M = Qe,
                        "break"
            }, Se = Te; Se > 0; Se--) {
                var Ze = ee(Se);
                if (Ze === "break")
                    break
            }
        e.placement !== M && (e.modifiersData[r]._skip = !0,
            e.placement = M,
            e.reset = !0)
    }
}
const iB = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: rB,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function Zx(t, e, n) {
    return n === void 0 && (n = {
        x: 0,
        y: 0
    }),
    {
        top: t.top - e.height - n.y,
        right: t.right - e.width + n.x,
        bottom: t.bottom - e.height + n.y,
        left: t.left - e.width - n.x
    }
}
function Yx(t) {
    return [Cr, di, ci, Er].some(function (e) {
        return t[e] >= 0
    })
}
function sB(t) {
    var e = t.state
        , n = t.name
        , r = e.rects.reference
        , i = e.rects.popper
        , s = e.modifiersData.preventOverflow
        , o = Pc(e, {
            elementContext: "reference"
        })
        , a = Pc(e, {
            altBoundary: !0
        })
        , l = Zx(o, r)
        , c = Zx(a, i, s)
        , d = Yx(l)
        , h = Yx(c);
    e.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: d,
        hasPopperEscaped: h
    },
        e.attributes.popper = Object.assign({}, e.attributes.popper, {
            "data-popper-reference-hidden": d,
            "data-popper-escaped": h
        })
}
const oB = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: sB
};
function aB(t, e, n) {
    var r = Ki(t)
        , i = [Er, Cr].indexOf(r) >= 0 ? -1 : 1
        , s = typeof n == "function" ? n(Object.assign({}, e, {
            placement: t
        })) : n
        , o = s[0]
        , a = s[1];
    return o = o || 0,
        a = (a || 0) * i,
        [Er, di].indexOf(r) >= 0 ? {
            x: a,
            y: o
        } : {
            x: o,
            y: a
        }
}
function lB(t) {
    var e = t.state
        , n = t.options
        , r = t.name
        , i = n.offset
        , s = i === void 0 ? [0, 0] : i
        , o = qC.reduce(function (d, h) {
            return d[h] = aB(h, e.rects, s),
                d
        }, {})
        , a = o[e.placement]
        , l = a.x
        , c = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l,
        e.modifiersData.popperOffsets.y += c),
        e.modifiersData[r] = o
}
const uB = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: lB
};
function cB(t) {
    var e = t.state
        , n = t.name;
    e.modifiersData[n] = eE({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
    })
}
const dB = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: cB,
    data: {}
};
function fB(t) {
    return t === "x" ? "y" : "x"
}
function hB(t) {
    var e = t.state
        , n = t.options
        , r = t.name
        , i = n.mainAxis
        , s = i === void 0 ? !0 : i
        , o = n.altAxis
        , a = o === void 0 ? !1 : o
        , l = n.boundary
        , c = n.rootBoundary
        , d = n.altBoundary
        , h = n.padding
        , p = n.tether
        , g = p === void 0 ? !0 : p
        , y = n.tetherOffset
        , x = y === void 0 ? 0 : y
        , S = Pc(e, {
            boundary: l,
            rootBoundary: c,
            padding: h,
            altBoundary: d
        })
        , k = Ki(e.placement)
        , A = Yl(e.placement)
        , C = !A
        , m = cv(k)
        , b = fB(m)
        , w = e.modifiersData.popperOffsets
        , T = e.rects.reference
        , O = e.rects.popper
        , M = typeof x == "function" ? x(Object.assign({}, e.rects, {
            placement: e.placement
        })) : x
        , E = typeof M == "number" ? {
            mainAxis: M,
            altAxis: M
        } : Object.assign({
            mainAxis: 0,
            altAxis: 0
        }, M)
        , N = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null
        , j = {
            x: 0,
            y: 0
        };
    if (w) {
        if (s) {
            var z, V = m === "y" ? Cr : Er, W = m === "y" ? ci : di, P = m === "y" ? "height" : "width", F = w[m], K = F + S[V], re = F - S[W], Te = g ? -O[P] / 2 : 0, ee = A === Gl ? T[P] : O[P], Se = A === Gl ? -O[P] : -T[P], Ze = e.elements.arrow, Ke = g && Ze ? uv(Ze) : {
                width: 0,
                height: 0
            }, Ye = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : ZC(), Qe = Ye[V], Y = Ye[W], he = lc(0, T[P], Ke[P]), ge = C ? T[P] / 2 - Te - he - Qe - E.mainAxis : ee - he - Qe - E.mainAxis, Ee = C ? -T[P] / 2 + Te + he + Y + E.mainAxis : Se + he + Y + E.mainAxis, st = e.elements.arrow && wd(e.elements.arrow), xt = st ? m === "y" ? st.clientTop || 0 : st.clientLeft || 0 : 0, D = (z = N?.[m]) != null ? z : 0, B = F + ge - D - xt, J = F + Ee - D, ae = lc(g ? Hh(K, B) : K, F, g ? ba(re, J) : re);
            w[m] = ae,
                j[m] = ae - F
        }
        if (a) {
            var X, de = m === "x" ? Cr : Er, be = m === "x" ? ci : di, pe = w[b], fe = b === "y" ? "height" : "width", ue = pe + S[de], Ne = pe - S[be], we = [Cr, Er].indexOf(k) !== -1, Oe = (X = N?.[b]) != null ? X : 0, ze = we ? ue : pe - T[fe] - O[fe] - Oe + E.altAxis, nt = we ? pe + T[fe] + O[fe] - Oe - E.altAxis : Ne, bt = g && we ? jj(ze, pe, nt) : lc(g ? ze : ue, pe, g ? nt : Ne);
            w[b] = bt,
                j[b] = bt - pe
        }
        e.modifiersData[r] = j
    }
}
const pB = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: hB,
    requiresIfExists: ["offset"]
};
function mB(t) {
    return {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    }
}
function gB(t) {
    return t === zr(t) || !ai(t) ? dv(t) : mB(t)
}
function yB(t) {
    var e = t.getBoundingClientRect()
        , n = Jl(e.width) / t.offsetWidth || 1
        , r = Jl(e.height) / t.offsetHeight || 1;
    return n !== 1 || r !== 1
}
function vB(t, e, n) {
    n === void 0 && (n = !1);
    var r = ai(e)
        , i = ai(e) && yB(e)
        , s = Ko(e)
        , o = Zl(t, i, n)
        , a = {
            scrollLeft: 0,
            scrollTop: 0
        }
        , l = {
            x: 0,
            y: 0
        };
    return (r || !r && !n) && ((Yi(e) !== "body" || hv(s)) && (a = gB(e)),
        ai(e) ? (l = Zl(e, !0),
            l.x += e.clientLeft,
            l.y += e.clientTop) : s && (l.x = fv(s))),
    {
        x: o.left + a.scrollLeft - l.x,
        y: o.top + a.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}
function bB(t) {
    var e = new Map
        , n = new Set
        , r = [];
    t.forEach(function (s) {
        e.set(s.name, s)
    });
    function i(s) {
        n.add(s.name);
        var o = [].concat(s.requires || [], s.requiresIfExists || []);
        o.forEach(function (a) {
            if (!n.has(a)) {
                var l = e.get(a);
                l && i(l)
            }
        }),
            r.push(s)
    }
    return t.forEach(function (s) {
        n.has(s.name) || i(s)
    }),
        r
}
function wB(t) {
    var e = bB(t);
    return Rj.reduce(function (n, r) {
        return n.concat(e.filter(function (i) {
            return i.phase === r
        }))
    }, [])
}
function xB(t) {
    var e;
    return function () {
        return e || (e = new Promise(function (n) {
            Promise.resolve().then(function () {
                e = void 0,
                    n(t())
            })
        }
        )),
            e
    }
}
function _B(t) {
    var e = t.reduce(function (n, r) {
        var i = n[r.name];
        return n[r.name] = i ? Object.assign({}, i, r, {
            options: Object.assign({}, i.options, r.options),
            data: Object.assign({}, i.data, r.data)
        }) : r,
            n
    }, {});
    return Object.keys(e).map(function (n) {
        return e[n]
    })
}
var Xx = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function Qx() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
        e[n] = arguments[n];
    return !e.some(function (r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}
function SB(t) {
    t === void 0 && (t = {});
    var e = t
        , n = e.defaultModifiers
        , r = n === void 0 ? [] : n
        , i = e.defaultOptions
        , s = i === void 0 ? Xx : i;
    return function (a, l, c) {
        c === void 0 && (c = s);
        var d = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, Xx, s),
            modifiersData: {},
            elements: {
                reference: a,
                popper: l
            },
            attributes: {},
            styles: {}
        }
            , h = []
            , p = !1
            , g = {
                state: d,
                setOptions: function (k) {
                    var A = typeof k == "function" ? k(d.options) : k;
                    x(),
                        d.options = Object.assign({}, s, d.options, A),
                        d.scrollParents = {
                            reference: Ia(a) ? uc(a) : a.contextElement ? uc(a.contextElement) : [],
                            popper: uc(l)
                        };
                    var C = wB(_B([].concat(r, d.options.modifiers)));
                    return d.orderedModifiers = C.filter(function (m) {
                        return m.enabled
                    }),
                        y(),
                        g.update()
                },
                forceUpdate: function () {
                    if (!p) {
                        var k = d.elements
                            , A = k.reference
                            , C = k.popper;
                        if (Qx(A, C)) {
                            d.rects = {
                                reference: vB(A, wd(C), d.options.strategy === "fixed"),
                                popper: uv(C)
                            },
                                d.reset = !1,
                                d.placement = d.options.placement,
                                d.orderedModifiers.forEach(function (E) {
                                    return d.modifiersData[E.name] = Object.assign({}, E.data)
                                });
                            for (var m = 0; m < d.orderedModifiers.length; m++) {
                                if (d.reset === !0) {
                                    d.reset = !1,
                                        m = -1;
                                    continue
                                }
                                var b = d.orderedModifiers[m]
                                    , w = b.fn
                                    , T = b.options
                                    , O = T === void 0 ? {} : T
                                    , M = b.name;
                                typeof w == "function" && (d = w({
                                    state: d,
                                    options: O,
                                    name: M,
                                    instance: g
                                }) || d)
                            }
                        }
                    }
                },
                update: xB(function () {
                    return new Promise(function (S) {
                        g.forceUpdate(),
                            S(d)
                    }
                    )
                }),
                destroy: function () {
                    x(),
                        p = !0
                }
            };
        if (!Qx(a, l))
            return g;
        g.setOptions(c).then(function (S) {
            !p && c.onFirstUpdate && c.onFirstUpdate(S)
        });
        function y() {
            d.orderedModifiers.forEach(function (S) {
                var k = S.name
                    , A = S.options
                    , C = A === void 0 ? {} : A
                    , m = S.effect;
                if (typeof m == "function") {
                    var b = m({
                        state: d,
                        name: k,
                        instance: g,
                        options: C
                    })
                        , w = function () { };
                    h.push(b || w)
                }
            })
        }
        function x() {
            h.forEach(function (S) {
                return S()
            }),
                h = []
        }
        return g
    }
}
var kB = [qj, dB, Uj, Ij, uB, iB, pB, Fj, oB]
    , CB = SB({
        defaultModifiers: kB
    });
const EB = {
    name: "Popover",
    inheritAttrs: !1,
    props: {
        show: {
            default: void 0
        },
        trigger: {
            type: String,
            default: "click"
        },
        hoverDelay: {
            type: Number,
            default: 0
        },
        leaveDelay: {
            type: Number,
            default: 0
        },
        placement: {
            type: String,
            default: "bottom-start"
        },
        popoverClass: [String, Object, Array],
        transition: {
            default: null
        },
        hideOnBlur: {
            default: !0
        }
    },
    emits: ["open", "close", "update:show"],
    expose: ["open", "close"],
    data() {
        return {
            popoverContainerClass: "body-container",
            showPopup: !1,
            targetWidth: null,
            pointerOverTargetOrPopup: !1
        }
    },
    watch: {
        show(t) {
            t ? this.open() : this.close()
        }
    },
    created() {
        if (!(typeof window > "u") && !document.getElementById("frappeui-popper-root")) {
            const t = document.createElement("div");
            t.id = "frappeui-popper-root",
                document.body.appendChild(t)
        }
    },
    mounted() {
        this.listener = t => {
            const e = t.target
                , n = this.$refs.reference
                , r = this.$refs.popover;
            if (e === n || e === r || n?.contains(e) || r?.contains(e))
                return;
            if (!document.getElementById("frappeui-popper-root").contains(e))
                return this.close();
            const a = `.${this.popoverContainerClass}`
                , l = e?.closest(a)
                , c = n?.closest(a);
            l && c && l === c && this.close()
        }
            ,
            this.hideOnBlur && (document.addEventListener("click", this.listener),
                document.addEventListener("mousedown", this.listener)),
            this.$nextTick(() => {
                this.targetWidth = this.$refs.target.clientWidth
            }
            )
    },
    beforeDestroy() {
        this.popper && this.popper.destroy(),
            document.removeEventListener("click", this.listener),
            document.removeEventListener("mousedown", this.listener)
    },
    computed: {
        showPropPassed() {
            return this.show != null
        },
        isOpen: {
            get() {
                return this.showPropPassed ? this.show : this.showPopup
            },
            set(t) {
                t = !!t,
                    this.showPropPassed ? this.$emit("update:show", t) : this.showPopup = t,
                    t === !1 ? this.$emit("close") : t === !0 && this.$emit("open")
            }
        },
        popupTransition() {
            let t = {
                default: {
                    enterActiveClass: "transition duration-150 ease-out",
                    enterFromClass: "translate-y-1 opacity-0",
                    enterToClass: "translate-y-0 opacity-100",
                    leaveActiveClass: "transition duration-150 ease-in",
                    leaveFromClass: "translate-y-0 opacity-100",
                    leaveToClass: "translate-y-1 opacity-0"
                }
            };
            return typeof this.transition == "string" ? t[this.transition] : this.transition
        }
    },
    methods: {
        setupPopper() {
            this.popper ? this.updatePosition() : this.popper = CB(this.$refs.reference, this.$refs.popover, {
                placement: this.placement
            })
        },
        updatePosition() {
            this.popper && this.popper.update()
        },
        togglePopover(t) {
            t instanceof Event && (t = null),
                t == null && (t = !this.isOpen),
                t = !!t,
                t ? this.open() : this.close()
        },
        open() {
            this.isOpen = !0,
                this.$nextTick(() => this.setupPopper())
        },
        close() {
            this.isOpen = !1
        },
        onMouseover() {
            this.pointerOverTargetOrPopup = !0,
                this.leaveTimer && (clearTimeout(this.leaveTimer),
                    this.leaveTimer = null),
                this.trigger === "hover" && (this.hoverDelay ? this.hoverTimer = setTimeout(() => {
                    this.pointerOverTargetOrPopup && this.open()
                }
                    , Number(this.hoverDelay) * 1e3) : this.open())
        },
        onMouseleave(t) {
            this.pointerOverTargetOrPopup = !1,
                this.hoverTimer && (clearTimeout(this.hoverTimer),
                    this.hoverTimer = null),
                this.trigger === "hover" && (this.leaveTimer && clearTimeout(this.leaveTimer),
                    this.leaveDelay ? this.leaveTimer = setTimeout(() => {
                        this.pointerOverTargetOrPopup || this.close()
                    }
                        , Number(this.leaveDelay) * 1e3) : this.pointerOverTargetOrPopup || this.close())
        }
    }
}
    , TB = {
        ref: "reference"
    }
    , AB = {
        class: "rounded-lg border border-gray-100 bg-white shadow-xl"
    };
function OB(t, e, n, r, i, s) {
    return oe(),
        Ae("div", TB, [Xe("div", {
            ref: "target",
            class: mt(["flex", t.$attrs.class]),
            onClick: e[0] || (e[0] = (...o) => s.updatePosition && s.updatePosition(...o)),
            onFocusin: e[1] || (e[1] = (...o) => s.updatePosition && s.updatePosition(...o)),
            onKeydown: e[2] || (e[2] = (...o) => s.updatePosition && s.updatePosition(...o)),
            onMouseover: e[3] || (e[3] = (...o) => s.onMouseover && s.onMouseover(...o)),
            onMouseleave: e[4] || (e[4] = (...o) => s.onMouseleave && s.onMouseleave(...o))
        }, [Ue(t.$slots, "target", xi(_i({
            togglePopover: s.togglePopover,
            updatePosition: s.updatePosition,
            open: s.open,
            close: s.close,
            isOpen: s.isOpen
        })))], 34), (oe(),
            gt(im, {
                to: "#frappeui-popper-root"
            }, [Xe("div", {
                ref: "popover",
                class: mt(["relative z-[100]", [i.popoverContainerClass, n.popoverClass]]),
                style: Vo({
                    minWidth: i.targetWidth ? i.targetWidth + "px" : null
                }),
                onMouseover: e[5] || (e[5] = o => i.pointerOverTargetOrPopup = !0),
                onMouseleave: e[6] || (e[6] = (...o) => s.onMouseleave && s.onMouseleave(...o))
            }, [$e(oL, xi(_i(s.popupTransition)), {
                default: tt(() => [Rh(Xe("div", null, [Ue(t.$slots, "body", xi(_i({
                    togglePopover: s.togglePopover,
                    updatePosition: s.updatePosition,
                    open: s.open,
                    close: s.close,
                    isOpen: s.isOpen
                })), () => [Xe("div", AB, [Ue(t.$slots, "body-main", xi(_i({
                    togglePopover: s.togglePopover,
                    updatePosition: s.updatePosition,
                    open: s.open,
                    close: s.close,
                    isOpen: s.isOpen
                })))])])], 512), [[Oc, s.isOpen]])]),
                _: 3
            }, 16)], 38)]))], 512)
}
const MB = Ua(EB, [["render", OB]]);
var ua = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function tE(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
function YQ(t) {
    if (t.__esModule)
        return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }),
        Object.keys(t).forEach(function (r) {
            var i = Object.getOwnPropertyDescriptor(t, r);
            Object.defineProperty(n, r, i.get ? i : {
                enumerable: !0,
                get: function () {
                    return t[r]
                }
            })
        }),
        n
}
var nE = {
    exports: {}
};
(function (t, e) {
    (function (r, i) {
        t.exports = i()
    }
    )(typeof self < "u" ? self : ua, function () {
        return function (n) {
            var r = {};
            function i(s) {
                if (r[s])
                    return r[s].exports;
                var o = r[s] = {
                    i: s,
                    l: !1,
                    exports: {}
                };
                return n[s].call(o.exports, o, o.exports, i),
                    o.l = !0,
                    o.exports
            }
            return i.m = n,
                i.c = r,
                i.d = function (s, o, a) {
                    i.o(s, o) || Object.defineProperty(s, o, {
                        configurable: !1,
                        enumerable: !0,
                        get: a
                    })
                }
                ,
                i.r = function (s) {
                    Object.defineProperty(s, "__esModule", {
                        value: !0
                    })
                }
                ,
                i.n = function (s) {
                    var o = s && s.__esModule ? function () {
                        return s.default
                    }
                        : function () {
                            return s
                        }
                        ;
                    return i.d(o, "a", o),
                        o
                }
                ,
                i.o = function (s, o) {
                    return Object.prototype.hasOwnProperty.call(s, o)
                }
                ,
                i.p = "",
                i(i.s = 0)
        }({
            "./dist/icons.json": function (n) {
                n.exports = {
                    activity: '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>',
                    airplay: '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>',
                    "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>',
                    "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>',
                    "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>',
                    "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>',
                    "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>',
                    "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>',
                    "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>',
                    anchor: '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>',
                    aperture: '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>',
                    archive: '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>',
                    "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>',
                    "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>',
                    "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>',
                    "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>',
                    "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>',
                    "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>',
                    "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>',
                    "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>',
                    "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>',
                    "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>',
                    "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>',
                    "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>',
                    "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>',
                    award: '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>',
                    "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>',
                    "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>',
                    "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>',
                    battery: '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>',
                    "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    bell: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>',
                    bluetooth: '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>',
                    bold: '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>',
                    "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>',
                    book: '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>',
                    bookmark: '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>',
                    box: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
                    briefcase: '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>',
                    calendar: '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>',
                    "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>',
                    camera: '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>',
                    cast: '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>',
                    "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>',
                    "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>',
                    check: '<polyline points="20 6 9 17 4 12"></polyline>',
                    "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>',
                    "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>',
                    "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>',
                    "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>',
                    "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>',
                    "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>',
                    "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>',
                    "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>',
                    chrome: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>',
                    circle: '<circle cx="12" cy="12" r="10"></circle>',
                    clipboard: '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>',
                    clock: '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>',
                    "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>',
                    "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>',
                    "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>',
                    "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>',
                    cloud: '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>',
                    code: '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>',
                    codepen: '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>',
                    codesandbox: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
                    coffee: '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>',
                    columns: '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>',
                    command: '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>',
                    compass: '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>',
                    copy: '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>',
                    "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>',
                    "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>',
                    "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>',
                    "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>',
                    "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>',
                    "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>',
                    "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>',
                    "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>',
                    cpu: '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>',
                    "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>',
                    crop: '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>',
                    crosshair: '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>',
                    database: '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>',
                    delete: '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>',
                    disc: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>',
                    "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>',
                    "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>',
                    divide: '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>',
                    "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>',
                    "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>',
                    download: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>',
                    dribbble: '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>',
                    droplet: '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>',
                    "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>',
                    "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>',
                    edit: '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>',
                    "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>',
                    "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    eye: '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>',
                    facebook: '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>',
                    "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>',
                    feather: '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>',
                    figma: '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>',
                    "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>',
                    "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>',
                    "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>',
                    file: '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>',
                    film: '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>',
                    filter: '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>',
                    flag: '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>',
                    "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>',
                    "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>',
                    folder: '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>',
                    framer: '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>',
                    frown: '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
                    gift: '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>',
                    "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>',
                    "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>',
                    "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>',
                    "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>',
                    github: '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>',
                    gitlab: '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>',
                    globe: '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>',
                    grid: '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>',
                    "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>',
                    hash: '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>',
                    headphones: '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>',
                    heart: '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>',
                    "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>',
                    hexagon: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>',
                    home: '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>',
                    image: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>',
                    inbox: '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>',
                    info: '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>',
                    instagram: '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>',
                    italic: '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>',
                    key: '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>',
                    layers: '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>',
                    layout: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>',
                    "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>',
                    "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>',
                    link: '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>',
                    linkedin: '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>',
                    list: '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>',
                    loader: '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>',
                    lock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>',
                    "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>',
                    "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>',
                    mail: '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>',
                    "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>',
                    map: '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>',
                    "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>',
                    maximize: '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>',
                    meh: '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
                    menu: '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>',
                    "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>',
                    "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>',
                    "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>',
                    mic: '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>',
                    "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>',
                    minimize: '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>',
                    "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>',
                    "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>',
                    minus: '<line x1="5" y1="12" x2="19" y2="12"></line>',
                    monitor: '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>',
                    moon: '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>',
                    "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>',
                    "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>',
                    "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>',
                    move: '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>',
                    music: '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>',
                    "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>',
                    navigation: '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>',
                    octagon: '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>',
                    package: '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
                    paperclip: '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>',
                    "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>',
                    pause: '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>',
                    "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>',
                    percent: '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>',
                    "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>',
                    "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    phone: '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>',
                    "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>',
                    play: '<polygon points="5 3 19 12 5 21 5 3"></polygon>',
                    "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>',
                    "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>',
                    plus: '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>',
                    pocket: '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>',
                    power: '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>',
                    printer: '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>',
                    radio: '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>',
                    "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>',
                    "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>',
                    repeat: '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>',
                    rewind: '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>',
                    "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>',
                    "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>',
                    rss: '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>',
                    save: '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>',
                    scissors: '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>',
                    search: '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>',
                    send: '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>',
                    server: '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>',
                    settings: '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>',
                    "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>',
                    share: '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>',
                    "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    shield: '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>',
                    "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>',
                    "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>',
                    shuffle: '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>',
                    sidebar: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>',
                    "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>',
                    "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>',
                    slack: '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>',
                    slash: '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>',
                    sliders: '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>',
                    smartphone: '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>',
                    smile: '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
                    speaker: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>',
                    square: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>',
                    star: '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>',
                    "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>',
                    sun: '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>',
                    sunrise: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>',
                    sunset: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>',
                    table: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path>',
                    tablet: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>',
                    tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>',
                    target: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>',
                    terminal: '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>',
                    thermometer: '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>',
                    "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>',
                    "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>',
                    "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>',
                    "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>',
                    tool: '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>',
                    "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>',
                    trash: '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>',
                    trello: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>',
                    "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>',
                    "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>',
                    triangle: '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>',
                    truck: '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>',
                    tv: '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>',
                    twitch: '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path>',
                    twitter: '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>',
                    type: '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>',
                    umbrella: '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>',
                    underline: '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>',
                    unlock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>',
                    "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>',
                    upload: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>',
                    "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>',
                    "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>',
                    "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>',
                    "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>',
                    user: '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>',
                    users: '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>',
                    "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    video: '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>',
                    voicemail: '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>',
                    "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
                    "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
                    "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>',
                    volume: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>',
                    watch: '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>',
                    "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>',
                    wifi: '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>',
                    wind: '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>',
                    "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>',
                    "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>',
                    "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>',
                    x: '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>',
                    youtube: '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>',
                    "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>',
                    zap: '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>',
                    "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>',
                    "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>'
                }
            },
            "./node_modules/classnames/dedupe.js": function (n, r, i) {
                var s, o;
                /*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
                (function () {
                    var a = function () {
                        function l() { }
                        l.prototype = Object.create(null);
                        function c(k, A) {
                            for (var C = A.length, m = 0; m < C; ++m)
                                x(k, A[m])
                        }
                        var d = {}.hasOwnProperty;
                        function h(k, A) {
                            k[A] = !0
                        }
                        function p(k, A) {
                            for (var C in A)
                                d.call(A, C) && (k[C] = !!A[C])
                        }
                        var g = /\s+/;
                        function y(k, A) {
                            for (var C = A.split(g), m = C.length, b = 0; b < m; ++b)
                                k[C[b]] = !0
                        }
                        function x(k, A) {
                            if (A) {
                                var C = typeof A;
                                C === "string" ? y(k, A) : Array.isArray(A) ? c(k, A) : C === "object" ? p(k, A) : C === "number" && h(k, A)
                            }
                        }
                        function S() {
                            for (var k = arguments.length, A = Array(k), C = 0; C < k; C++)
                                A[C] = arguments[C];
                            var m = new l;
                            c(m, A);
                            var b = [];
                            for (var w in m)
                                m[w] && b.push(w);
                            return b.join(" ")
                        }
                        return S
                    }();
                    typeof n < "u" && n.exports ? n.exports = a : (s = [],
                        o = function () {
                            return a
                        }
                            .apply(r, s),
                        o !== void 0 && (n.exports = o))
                }
                )()
            },
            "./node_modules/core-js/es/array/from.js": function (n, r, i) {
                i("./node_modules/core-js/modules/es.string.iterator.js"),
                    i("./node_modules/core-js/modules/es.array.from.js");
                var s = i("./node_modules/core-js/internals/path.js");
                n.exports = s.Array.from
            },
            "./node_modules/core-js/internals/a-function.js": function (n, r) {
                n.exports = function (i) {
                    if (typeof i != "function")
                        throw TypeError(String(i) + " is not a function");
                    return i
                }
            },
            "./node_modules/core-js/internals/an-object.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/is-object.js");
                n.exports = function (o) {
                    if (!s(o))
                        throw TypeError(String(o) + " is not an object");
                    return o
                }
            },
            "./node_modules/core-js/internals/array-from.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/bind-context.js")
                    , o = i("./node_modules/core-js/internals/to-object.js")
                    , a = i("./node_modules/core-js/internals/call-with-safe-iteration-closing.js")
                    , l = i("./node_modules/core-js/internals/is-array-iterator-method.js")
                    , c = i("./node_modules/core-js/internals/to-length.js")
                    , d = i("./node_modules/core-js/internals/create-property.js")
                    , h = i("./node_modules/core-js/internals/get-iterator-method.js");
                n.exports = function (g) {
                    var y = o(g), x = typeof this == "function" ? this : Array, S = arguments.length, k = S > 1 ? arguments[1] : void 0, A = k !== void 0, C = 0, m = h(y), b, w, T, O;
                    if (A && (k = s(k, S > 2 ? arguments[2] : void 0, 2)),
                        m != null && !(x == Array && l(m)))
                        for (O = m.call(y),
                            w = new x; !(T = O.next()).done; C++)
                            d(w, C, A ? a(O, k, [T.value, C], !0) : T.value);
                    else
                        for (b = c(y.length),
                            w = new x(b); b > C; C++)
                            d(w, C, A ? k(y[C], C) : y[C]);
                    return w.length = C,
                        w
                }
            },
            "./node_modules/core-js/internals/array-includes.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/to-indexed-object.js")
                    , o = i("./node_modules/core-js/internals/to-length.js")
                    , a = i("./node_modules/core-js/internals/to-absolute-index.js");
                n.exports = function (l) {
                    return function (c, d, h) {
                        var p = s(c), g = o(p.length), y = a(h, g), x;
                        if (l && d != d) {
                            for (; g > y;)
                                if (x = p[y++],
                                    x != x)
                                    return !0
                        } else
                            for (; g > y; y++)
                                if ((l || y in p) && p[y] === d)
                                    return l || y || 0;
                        return !l && -1
                    }
                }
            },
            "./node_modules/core-js/internals/bind-context.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/a-function.js");
                n.exports = function (o, a, l) {
                    if (s(o),
                        a === void 0)
                        return o;
                    switch (l) {
                        case 0:
                            return function () {
                                return o.call(a)
                            }
                                ;
                        case 1:
                            return function (c) {
                                return o.call(a, c)
                            }
                                ;
                        case 2:
                            return function (c, d) {
                                return o.call(a, c, d)
                            }
                                ;
                        case 3:
                            return function (c, d, h) {
                                return o.call(a, c, d, h)
                            }
                    }
                    return function () {
                        return o.apply(a, arguments)
                    }
                }
            },
            "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/an-object.js");
                n.exports = function (o, a, l, c) {
                    try {
                        return c ? a(s(l)[0], l[1]) : a(l)
                    } catch (h) {
                        var d = o.return;
                        throw d !== void 0 && s(d.call(o)),
                        h
                    }
                }
            },
            "./node_modules/core-js/internals/check-correctness-of-iteration.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/well-known-symbol.js")
                    , o = s("iterator")
                    , a = !1;
                try {
                    var l = 0
                        , c = {
                            next: function () {
                                return {
                                    done: !!l++
                                }
                            },
                            return: function () {
                                a = !0
                            }
                        };
                    c[o] = function () {
                        return this
                    }
                        ,
                        Array.from(c, function () {
                            throw 2
                        })
                } catch { }
                n.exports = function (d, h) {
                    if (!h && !a)
                        return !1;
                    var p = !1;
                    try {
                        var g = {};
                        g[o] = function () {
                            return {
                                next: function () {
                                    return {
                                        done: p = !0
                                    }
                                }
                            }
                        }
                            ,
                            d(g)
                    } catch { }
                    return p
                }
            },
            "./node_modules/core-js/internals/classof-raw.js": function (n, r) {
                var i = {}.toString;
                n.exports = function (s) {
                    return i.call(s).slice(8, -1)
                }
            },
            "./node_modules/core-js/internals/classof.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/classof-raw.js")
                    , o = i("./node_modules/core-js/internals/well-known-symbol.js")
                    , a = o("toStringTag")
                    , l = s(function () {
                        return arguments
                    }()) == "Arguments"
                    , c = function (d, h) {
                        try {
                            return d[h]
                        } catch { }
                    };
                n.exports = function (d) {
                    var h, p, g;
                    return d === void 0 ? "Undefined" : d === null ? "Null" : typeof (p = c(h = Object(d), a)) == "string" ? p : l ? s(h) : (g = s(h)) == "Object" && typeof h.callee == "function" ? "Arguments" : g
                }
            },
            "./node_modules/core-js/internals/copy-constructor-properties.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/has.js")
                    , o = i("./node_modules/core-js/internals/own-keys.js")
                    , a = i("./node_modules/core-js/internals/object-get-own-property-descriptor.js")
                    , l = i("./node_modules/core-js/internals/object-define-property.js");
                n.exports = function (c, d) {
                    for (var h = o(d), p = l.f, g = a.f, y = 0; y < h.length; y++) {
                        var x = h[y];
                        s(c, x) || p(c, x, g(d, x))
                    }
                }
            },
            "./node_modules/core-js/internals/correct-prototype-getter.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/fails.js");
                n.exports = !s(function () {
                    function o() { }
                    return o.prototype.constructor = null,
                        Object.getPrototypeOf(new o) !== o.prototype
                })
            },
            "./node_modules/core-js/internals/create-iterator-constructor.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/iterators-core.js").IteratorPrototype
                    , o = i("./node_modules/core-js/internals/object-create.js")
                    , a = i("./node_modules/core-js/internals/create-property-descriptor.js")
                    , l = i("./node_modules/core-js/internals/set-to-string-tag.js")
                    , c = i("./node_modules/core-js/internals/iterators.js")
                    , d = function () {
                        return this
                    };
                n.exports = function (h, p, g) {
                    var y = p + " Iterator";
                    return h.prototype = o(s, {
                        next: a(1, g)
                    }),
                        l(h, y, !1, !0),
                        c[y] = d,
                        h
                }
            },
            "./node_modules/core-js/internals/create-property-descriptor.js": function (n, r) {
                n.exports = function (i, s) {
                    return {
                        enumerable: !(i & 1),
                        configurable: !(i & 2),
                        writable: !(i & 4),
                        value: s
                    }
                }
            },
            "./node_modules/core-js/internals/create-property.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/to-primitive.js")
                    , o = i("./node_modules/core-js/internals/object-define-property.js")
                    , a = i("./node_modules/core-js/internals/create-property-descriptor.js");
                n.exports = function (l, c, d) {
                    var h = s(c);
                    h in l ? o.f(l, h, a(0, d)) : l[h] = d
                }
            },
            "./node_modules/core-js/internals/define-iterator.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/export.js")
                    , o = i("./node_modules/core-js/internals/create-iterator-constructor.js")
                    , a = i("./node_modules/core-js/internals/object-get-prototype-of.js")
                    , l = i("./node_modules/core-js/internals/object-set-prototype-of.js")
                    , c = i("./node_modules/core-js/internals/set-to-string-tag.js")
                    , d = i("./node_modules/core-js/internals/hide.js")
                    , h = i("./node_modules/core-js/internals/redefine.js")
                    , p = i("./node_modules/core-js/internals/well-known-symbol.js")
                    , g = i("./node_modules/core-js/internals/is-pure.js")
                    , y = i("./node_modules/core-js/internals/iterators.js")
                    , x = i("./node_modules/core-js/internals/iterators-core.js")
                    , S = x.IteratorPrototype
                    , k = x.BUGGY_SAFARI_ITERATORS
                    , A = p("iterator")
                    , C = "keys"
                    , m = "values"
                    , b = "entries"
                    , w = function () {
                        return this
                    };
                n.exports = function (T, O, M, E, N, j, z) {
                    o(M, O, E);
                    var V = function (Ke) {
                        if (Ke === N && re)
                            return re;
                        if (!k && Ke in F)
                            return F[Ke];
                        switch (Ke) {
                            case C:
                                return function () {
                                    return new M(this, Ke)
                                }
                                    ;
                            case m:
                                return function () {
                                    return new M(this, Ke)
                                }
                                    ;
                            case b:
                                return function () {
                                    return new M(this, Ke)
                                }
                        }
                        return function () {
                            return new M(this)
                        }
                    }, W = O + " Iterator", P = !1, F = T.prototype, K = F[A] || F["@@iterator"] || N && F[N], re = !k && K || V(N), Te = O == "Array" && F.entries || K, ee, Se, Ze;
                    if (Te && (ee = a(Te.call(new T)),
                        S !== Object.prototype && ee.next && (!g && a(ee) !== S && (l ? l(ee, S) : typeof ee[A] != "function" && d(ee, A, w)),
                            c(ee, W, !0, !0),
                            g && (y[W] = w))),
                        N == m && K && K.name !== m && (P = !0,
                            re = function () {
                                return K.call(this)
                            }
                        ),
                        (!g || z) && F[A] !== re && d(F, A, re),
                        y[O] = re,
                        N)
                        if (Se = {
                            values: V(m),
                            keys: j ? re : V(C),
                            entries: V(b)
                        },
                            z)
                            for (Ze in Se)
                                (k || P || !(Ze in F)) && h(F, Ze, Se[Ze]);
                        else
                            s({
                                target: O,
                                proto: !0,
                                forced: k || P
                            }, Se);
                    return Se
                }
            },
            "./node_modules/core-js/internals/descriptors.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/fails.js");
                n.exports = !s(function () {
                    return Object.defineProperty({}, "a", {
                        get: function () {
                            return 7
                        }
                    }).a != 7
                })
            },
            "./node_modules/core-js/internals/document-create-element.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = i("./node_modules/core-js/internals/is-object.js")
                    , a = s.document
                    , l = o(a) && o(a.createElement);
                n.exports = function (c) {
                    return l ? a.createElement(c) : {}
                }
            },
            "./node_modules/core-js/internals/enum-bug-keys.js": function (n, r) {
                n.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
            },
            "./node_modules/core-js/internals/export.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = i("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f
                    , a = i("./node_modules/core-js/internals/hide.js")
                    , l = i("./node_modules/core-js/internals/redefine.js")
                    , c = i("./node_modules/core-js/internals/set-global.js")
                    , d = i("./node_modules/core-js/internals/copy-constructor-properties.js")
                    , h = i("./node_modules/core-js/internals/is-forced.js");
                n.exports = function (p, g) {
                    var y = p.target, x = p.global, S = p.stat, k, A, C, m, b, w;
                    if (x ? A = s : S ? A = s[y] || c(y, {}) : A = (s[y] || {}).prototype,
                        A)
                        for (C in g) {
                            if (b = g[C],
                                p.noTargetGet ? (w = o(A, C),
                                    m = w && w.value) : m = A[C],
                                k = h(x ? C : y + (S ? "." : "#") + C, p.forced),
                                !k && m !== void 0) {
                                if (typeof b == typeof m)
                                    continue;
                                d(b, m)
                            }
                            (p.sham || m && m.sham) && a(b, "sham", !0),
                                l(A, C, b, p)
                        }
                }
            },
            "./node_modules/core-js/internals/fails.js": function (n, r) {
                n.exports = function (i) {
                    try {
                        return !!i()
                    } catch {
                        return !0
                    }
                }
            },
            "./node_modules/core-js/internals/function-to-string.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/shared.js");
                n.exports = s("native-function-to-string", Function.toString)
            },
            "./node_modules/core-js/internals/get-iterator-method.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/classof.js")
                    , o = i("./node_modules/core-js/internals/iterators.js")
                    , a = i("./node_modules/core-js/internals/well-known-symbol.js")
                    , l = a("iterator");
                n.exports = function (c) {
                    if (c != null)
                        return c[l] || c["@@iterator"] || o[s(c)]
                }
            },
            "./node_modules/core-js/internals/global.js": function (n, r, i) {
                (function (s) {
                    var o = "object"
                        , a = function (l) {
                            return l && l.Math == Math && l
                        };
                    n.exports = a(typeof globalThis == o && globalThis) || a(typeof window == o && window) || a(typeof self == o && self) || a(typeof s == o && s) || Function("return this")()
                }
                ).call(this, i("./node_modules/webpack/buildin/global.js"))
            },
            "./node_modules/core-js/internals/has.js": function (n, r) {
                var i = {}.hasOwnProperty;
                n.exports = function (s, o) {
                    return i.call(s, o)
                }
            },
            "./node_modules/core-js/internals/hidden-keys.js": function (n, r) {
                n.exports = {}
            },
            "./node_modules/core-js/internals/hide.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/descriptors.js")
                    , o = i("./node_modules/core-js/internals/object-define-property.js")
                    , a = i("./node_modules/core-js/internals/create-property-descriptor.js");
                n.exports = s ? function (l, c, d) {
                    return o.f(l, c, a(1, d))
                }
                    : function (l, c, d) {
                        return l[c] = d,
                            l
                    }
            },
            "./node_modules/core-js/internals/html.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = s.document;
                n.exports = o && o.documentElement
            },
            "./node_modules/core-js/internals/ie8-dom-define.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/descriptors.js")
                    , o = i("./node_modules/core-js/internals/fails.js")
                    , a = i("./node_modules/core-js/internals/document-create-element.js");
                n.exports = !s && !o(function () {
                    return Object.defineProperty(a("div"), "a", {
                        get: function () {
                            return 7
                        }
                    }).a != 7
                })
            },
            "./node_modules/core-js/internals/indexed-object.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/fails.js")
                    , o = i("./node_modules/core-js/internals/classof-raw.js")
                    , a = "".split;
                n.exports = s(function () {
                    return !Object("z").propertyIsEnumerable(0)
                }) ? function (l) {
                    return o(l) == "String" ? a.call(l, "") : Object(l)
                }
                    : Object
            },
            "./node_modules/core-js/internals/internal-state.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/native-weak-map.js"), o = i("./node_modules/core-js/internals/global.js"), a = i("./node_modules/core-js/internals/is-object.js"), l = i("./node_modules/core-js/internals/hide.js"), c = i("./node_modules/core-js/internals/has.js"), d = i("./node_modules/core-js/internals/shared-key.js"), h = i("./node_modules/core-js/internals/hidden-keys.js"), p = o.WeakMap, g, y, x, S = function (T) {
                    return x(T) ? y(T) : g(T, {})
                }, k = function (T) {
                    return function (O) {
                        var M;
                        if (!a(O) || (M = y(O)).type !== T)
                            throw TypeError("Incompatible receiver, " + T + " required");
                        return M
                    }
                };
                if (s) {
                    var A = new p
                        , C = A.get
                        , m = A.has
                        , b = A.set;
                    g = function (T, O) {
                        return b.call(A, T, O),
                            O
                    }
                        ,
                        y = function (T) {
                            return C.call(A, T) || {}
                        }
                        ,
                        x = function (T) {
                            return m.call(A, T)
                        }
                } else {
                    var w = d("state");
                    h[w] = !0,
                        g = function (T, O) {
                            return l(T, w, O),
                                O
                        }
                        ,
                        y = function (T) {
                            return c(T, w) ? T[w] : {}
                        }
                        ,
                        x = function (T) {
                            return c(T, w)
                        }
                }
                n.exports = {
                    set: g,
                    get: y,
                    has: x,
                    enforce: S,
                    getterFor: k
                }
            },
            "./node_modules/core-js/internals/is-array-iterator-method.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/well-known-symbol.js")
                    , o = i("./node_modules/core-js/internals/iterators.js")
                    , a = s("iterator")
                    , l = Array.prototype;
                n.exports = function (c) {
                    return c !== void 0 && (o.Array === c || l[a] === c)
                }
            },
            "./node_modules/core-js/internals/is-forced.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/fails.js")
                    , o = /#|\.prototype\./
                    , a = function (p, g) {
                        var y = c[l(p)];
                        return y == h ? !0 : y == d ? !1 : typeof g == "function" ? s(g) : !!g
                    }
                    , l = a.normalize = function (p) {
                        return String(p).replace(o, ".").toLowerCase()
                    }
                    , c = a.data = {}
                    , d = a.NATIVE = "N"
                    , h = a.POLYFILL = "P";
                n.exports = a
            },
            "./node_modules/core-js/internals/is-object.js": function (n, r) {
                n.exports = function (i) {
                    return typeof i == "object" ? i !== null : typeof i == "function"
                }
            },
            "./node_modules/core-js/internals/is-pure.js": function (n, r) {
                n.exports = !1
            },
            "./node_modules/core-js/internals/iterators-core.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/object-get-prototype-of.js"), o = i("./node_modules/core-js/internals/hide.js"), a = i("./node_modules/core-js/internals/has.js"), l = i("./node_modules/core-js/internals/well-known-symbol.js"), c = i("./node_modules/core-js/internals/is-pure.js"), d = l("iterator"), h = !1, p = function () {
                    return this
                }, g, y, x;
                [].keys && (x = [].keys(),
                    "next" in x ? (y = s(s(x)),
                        y !== Object.prototype && (g = y)) : h = !0),
                    g == null && (g = {}),
                    !c && !a(g, d) && o(g, d, p),
                    n.exports = {
                        IteratorPrototype: g,
                        BUGGY_SAFARI_ITERATORS: h
                    }
            },
            "./node_modules/core-js/internals/iterators.js": function (n, r) {
                n.exports = {}
            },
            "./node_modules/core-js/internals/native-symbol.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/fails.js");
                n.exports = !!Object.getOwnPropertySymbols && !s(function () {
                    return !String(Symbol())
                })
            },
            "./node_modules/core-js/internals/native-weak-map.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = i("./node_modules/core-js/internals/function-to-string.js")
                    , a = s.WeakMap;
                n.exports = typeof a == "function" && /native code/.test(o.call(a))
            },
            "./node_modules/core-js/internals/object-create.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/an-object.js")
                    , o = i("./node_modules/core-js/internals/object-define-properties.js")
                    , a = i("./node_modules/core-js/internals/enum-bug-keys.js")
                    , l = i("./node_modules/core-js/internals/hidden-keys.js")
                    , c = i("./node_modules/core-js/internals/html.js")
                    , d = i("./node_modules/core-js/internals/document-create-element.js")
                    , h = i("./node_modules/core-js/internals/shared-key.js")
                    , p = h("IE_PROTO")
                    , g = "prototype"
                    , y = function () { }
                    , x = function () {
                        var S = d("iframe"), k = a.length, A = "<", C = "script", m = ">", b = "java" + C + ":", w;
                        for (S.style.display = "none",
                            c.appendChild(S),
                            S.src = String(b),
                            w = S.contentWindow.document,
                            w.open(),
                            w.write(A + C + m + "document.F=Object" + A + "/" + C + m),
                            w.close(),
                            x = w.F; k--;)
                            delete x[g][a[k]];
                        return x()
                    };
                n.exports = Object.create || function (k, A) {
                    var C;
                    return k !== null ? (y[g] = s(k),
                        C = new y,
                        y[g] = null,
                        C[p] = k) : C = x(),
                        A === void 0 ? C : o(C, A)
                }
                    ,
                    l[p] = !0
            },
            "./node_modules/core-js/internals/object-define-properties.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/descriptors.js")
                    , o = i("./node_modules/core-js/internals/object-define-property.js")
                    , a = i("./node_modules/core-js/internals/an-object.js")
                    , l = i("./node_modules/core-js/internals/object-keys.js");
                n.exports = s ? Object.defineProperties : function (d, h) {
                    a(d);
                    for (var p = l(h), g = p.length, y = 0, x; g > y;)
                        o.f(d, x = p[y++], h[x]);
                    return d
                }
            },
            "./node_modules/core-js/internals/object-define-property.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/descriptors.js")
                    , o = i("./node_modules/core-js/internals/ie8-dom-define.js")
                    , a = i("./node_modules/core-js/internals/an-object.js")
                    , l = i("./node_modules/core-js/internals/to-primitive.js")
                    , c = Object.defineProperty;
                r.f = s ? c : function (h, p, g) {
                    if (a(h),
                        p = l(p, !0),
                        a(g),
                        o)
                        try {
                            return c(h, p, g)
                        } catch { }
                    if ("get" in g || "set" in g)
                        throw TypeError("Accessors not supported");
                    return "value" in g && (h[p] = g.value),
                        h
                }
            },
            "./node_modules/core-js/internals/object-get-own-property-descriptor.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/descriptors.js")
                    , o = i("./node_modules/core-js/internals/object-property-is-enumerable.js")
                    , a = i("./node_modules/core-js/internals/create-property-descriptor.js")
                    , l = i("./node_modules/core-js/internals/to-indexed-object.js")
                    , c = i("./node_modules/core-js/internals/to-primitive.js")
                    , d = i("./node_modules/core-js/internals/has.js")
                    , h = i("./node_modules/core-js/internals/ie8-dom-define.js")
                    , p = Object.getOwnPropertyDescriptor;
                r.f = s ? p : function (y, x) {
                    if (y = l(y),
                        x = c(x, !0),
                        h)
                        try {
                            return p(y, x)
                        } catch { }
                    if (d(y, x))
                        return a(!o.f.call(y, x), y[x])
                }
            },
            "./node_modules/core-js/internals/object-get-own-property-names.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/object-keys-internal.js")
                    , o = i("./node_modules/core-js/internals/enum-bug-keys.js")
                    , a = o.concat("length", "prototype");
                r.f = Object.getOwnPropertyNames || function (c) {
                    return s(c, a)
                }
            },
            "./node_modules/core-js/internals/object-get-own-property-symbols.js": function (n, r) {
                r.f = Object.getOwnPropertySymbols
            },
            "./node_modules/core-js/internals/object-get-prototype-of.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/has.js")
                    , o = i("./node_modules/core-js/internals/to-object.js")
                    , a = i("./node_modules/core-js/internals/shared-key.js")
                    , l = i("./node_modules/core-js/internals/correct-prototype-getter.js")
                    , c = a("IE_PROTO")
                    , d = Object.prototype;
                n.exports = l ? Object.getPrototypeOf : function (h) {
                    return h = o(h),
                        s(h, c) ? h[c] : typeof h.constructor == "function" && h instanceof h.constructor ? h.constructor.prototype : h instanceof Object ? d : null
                }
            },
            "./node_modules/core-js/internals/object-keys-internal.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/has.js")
                    , o = i("./node_modules/core-js/internals/to-indexed-object.js")
                    , a = i("./node_modules/core-js/internals/array-includes.js")
                    , l = i("./node_modules/core-js/internals/hidden-keys.js")
                    , c = a(!1);
                n.exports = function (d, h) {
                    var p = o(d), g = 0, y = [], x;
                    for (x in p)
                        !s(l, x) && s(p, x) && y.push(x);
                    for (; h.length > g;)
                        s(p, x = h[g++]) && (~c(y, x) || y.push(x));
                    return y
                }
            },
            "./node_modules/core-js/internals/object-keys.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/object-keys-internal.js")
                    , o = i("./node_modules/core-js/internals/enum-bug-keys.js");
                n.exports = Object.keys || function (l) {
                    return s(l, o)
                }
            },
            "./node_modules/core-js/internals/object-property-is-enumerable.js": function (n, r, i) {
                var s = {}.propertyIsEnumerable
                    , o = Object.getOwnPropertyDescriptor
                    , a = o && !s.call({
                        1: 2
                    }, 1);
                r.f = a ? function (c) {
                    var d = o(this, c);
                    return !!d && d.enumerable
                }
                    : s
            },
            "./node_modules/core-js/internals/object-set-prototype-of.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");
                n.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () {
                    var o = !1, a = {}, l;
                    try {
                        l = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set,
                            l.call(a, []),
                            o = a instanceof Array
                    } catch { }
                    return function (d, h) {
                        return s(d, h),
                            o ? l.call(d, h) : d.__proto__ = h,
                            d
                    }
                }() : void 0)
            },
            "./node_modules/core-js/internals/own-keys.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = i("./node_modules/core-js/internals/object-get-own-property-names.js")
                    , a = i("./node_modules/core-js/internals/object-get-own-property-symbols.js")
                    , l = i("./node_modules/core-js/internals/an-object.js")
                    , c = s.Reflect;
                n.exports = c && c.ownKeys || function (h) {
                    var p = o.f(l(h))
                        , g = a.f;
                    return g ? p.concat(g(h)) : p
                }
            },
            "./node_modules/core-js/internals/path.js": function (n, r, i) {
                n.exports = i("./node_modules/core-js/internals/global.js")
            },
            "./node_modules/core-js/internals/redefine.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = i("./node_modules/core-js/internals/shared.js")
                    , a = i("./node_modules/core-js/internals/hide.js")
                    , l = i("./node_modules/core-js/internals/has.js")
                    , c = i("./node_modules/core-js/internals/set-global.js")
                    , d = i("./node_modules/core-js/internals/function-to-string.js")
                    , h = i("./node_modules/core-js/internals/internal-state.js")
                    , p = h.get
                    , g = h.enforce
                    , y = String(d).split("toString");
                o("inspectSource", function (x) {
                    return d.call(x)
                }),
                    (n.exports = function (x, S, k, A) {
                        var C = A ? !!A.unsafe : !1
                            , m = A ? !!A.enumerable : !1
                            , b = A ? !!A.noTargetGet : !1;
                        if (typeof k == "function" && (typeof S == "string" && !l(k, "name") && a(k, "name", S),
                            g(k).source = y.join(typeof S == "string" ? S : "")),
                            x === s) {
                            m ? x[S] = k : c(S, k);
                            return
                        } else
                            C ? !b && x[S] && (m = !0) : delete x[S];
                        m ? x[S] = k : a(x, S, k)
                    }
                    )(Function.prototype, "toString", function () {
                        return typeof this == "function" && p(this).source || d.call(this)
                    })
            },
            "./node_modules/core-js/internals/require-object-coercible.js": function (n, r) {
                n.exports = function (i) {
                    if (i == null)
                        throw TypeError("Can't call method on " + i);
                    return i
                }
            },
            "./node_modules/core-js/internals/set-global.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = i("./node_modules/core-js/internals/hide.js");
                n.exports = function (a, l) {
                    try {
                        o(s, a, l)
                    } catch {
                        s[a] = l
                    }
                    return l
                }
            },
            "./node_modules/core-js/internals/set-to-string-tag.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/object-define-property.js").f
                    , o = i("./node_modules/core-js/internals/has.js")
                    , a = i("./node_modules/core-js/internals/well-known-symbol.js")
                    , l = a("toStringTag");
                n.exports = function (c, d, h) {
                    c && !o(c = h ? c : c.prototype, l) && s(c, l, {
                        configurable: !0,
                        value: d
                    })
                }
            },
            "./node_modules/core-js/internals/shared-key.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/shared.js")
                    , o = i("./node_modules/core-js/internals/uid.js")
                    , a = s("keys");
                n.exports = function (l) {
                    return a[l] || (a[l] = o(l))
                }
            },
            "./node_modules/core-js/internals/shared.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = i("./node_modules/core-js/internals/set-global.js")
                    , a = i("./node_modules/core-js/internals/is-pure.js")
                    , l = "__core-js_shared__"
                    , c = s[l] || o(l, {});
                (n.exports = function (d, h) {
                    return c[d] || (c[d] = h !== void 0 ? h : {})
                }
                )("versions", []).push({
                    version: "3.1.3",
                    mode: a ? "pure" : "global",
                    copyright: " 2019 Denis Pushkarev (zloirock.ru)"
                })
            },
            "./node_modules/core-js/internals/string-at.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/to-integer.js")
                    , o = i("./node_modules/core-js/internals/require-object-coercible.js");
                n.exports = function (a, l, c) {
                    var d = String(o(a)), h = s(l), p = d.length, g, y;
                    return h < 0 || h >= p ? c ? "" : void 0 : (g = d.charCodeAt(h),
                        g < 55296 || g > 56319 || h + 1 === p || (y = d.charCodeAt(h + 1)) < 56320 || y > 57343 ? c ? d.charAt(h) : g : c ? d.slice(h, h + 2) : (g - 55296 << 10) + (y - 56320) + 65536)
                }
            },
            "./node_modules/core-js/internals/to-absolute-index.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/to-integer.js")
                    , o = Math.max
                    , a = Math.min;
                n.exports = function (l, c) {
                    var d = s(l);
                    return d < 0 ? o(d + c, 0) : a(d, c)
                }
            },
            "./node_modules/core-js/internals/to-indexed-object.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/indexed-object.js")
                    , o = i("./node_modules/core-js/internals/require-object-coercible.js");
                n.exports = function (a) {
                    return s(o(a))
                }
            },
            "./node_modules/core-js/internals/to-integer.js": function (n, r) {
                var i = Math.ceil
                    , s = Math.floor;
                n.exports = function (o) {
                    return isNaN(o = +o) ? 0 : (o > 0 ? s : i)(o)
                }
            },
            "./node_modules/core-js/internals/to-length.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/to-integer.js")
                    , o = Math.min;
                n.exports = function (a) {
                    return a > 0 ? o(s(a), 9007199254740991) : 0
                }
            },
            "./node_modules/core-js/internals/to-object.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/require-object-coercible.js");
                n.exports = function (o) {
                    return Object(s(o))
                }
            },
            "./node_modules/core-js/internals/to-primitive.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/is-object.js");
                n.exports = function (o, a) {
                    if (!s(o))
                        return o;
                    var l, c;
                    if (a && typeof (l = o.toString) == "function" && !s(c = l.call(o)) || typeof (l = o.valueOf) == "function" && !s(c = l.call(o)) || !a && typeof (l = o.toString) == "function" && !s(c = l.call(o)))
                        return c;
                    throw TypeError("Can't convert object to primitive value")
                }
            },
            "./node_modules/core-js/internals/uid.js": function (n, r) {
                var i = 0
                    , s = Math.random();
                n.exports = function (o) {
                    return "Symbol(".concat(o === void 0 ? "" : o, ")_", (++i + s).toString(36))
                }
            },
            "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/is-object.js")
                    , o = i("./node_modules/core-js/internals/an-object.js");
                n.exports = function (a, l) {
                    if (o(a),
                        !s(l) && l !== null)
                        throw TypeError("Can't set " + String(l) + " as a prototype")
                }
            },
            "./node_modules/core-js/internals/well-known-symbol.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/global.js")
                    , o = i("./node_modules/core-js/internals/shared.js")
                    , a = i("./node_modules/core-js/internals/uid.js")
                    , l = i("./node_modules/core-js/internals/native-symbol.js")
                    , c = s.Symbol
                    , d = o("wks");
                n.exports = function (h) {
                    return d[h] || (d[h] = l && c[h] || (l ? c : a)("Symbol." + h))
                }
            },
            "./node_modules/core-js/modules/es.array.from.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/export.js")
                    , o = i("./node_modules/core-js/internals/array-from.js")
                    , a = i("./node_modules/core-js/internals/check-correctness-of-iteration.js")
                    , l = !a(function (c) {
                        Array.from(c)
                    });
                s({
                    target: "Array",
                    stat: !0,
                    forced: l
                }, {
                    from: o
                })
            },
            "./node_modules/core-js/modules/es.string.iterator.js": function (n, r, i) {
                var s = i("./node_modules/core-js/internals/string-at.js")
                    , o = i("./node_modules/core-js/internals/internal-state.js")
                    , a = i("./node_modules/core-js/internals/define-iterator.js")
                    , l = "String Iterator"
                    , c = o.set
                    , d = o.getterFor(l);
                a(String, "String", function (h) {
                    c(this, {
                        type: l,
                        string: String(h),
                        index: 0
                    })
                }, function () {
                    var p = d(this), g = p.string, y = p.index, x;
                    return y >= g.length ? {
                        value: void 0,
                        done: !0
                    } : (x = s(g, y, !0),
                        p.index += x.length,
                    {
                        value: x,
                        done: !1
                    })
                })
            },
            "./node_modules/webpack/buildin/global.js": function (n, r) {
                var i;
                i = function () {
                    return this
                }();
                try {
                    i = i || Function("return this")() || (0,
                        eval)("this")
                } catch {
                    typeof window == "object" && (i = window)
                }
                n.exports = i
            },
            "./src/default-attrs.json": function (n) {
                n.exports = {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: 24,
                    height: 24,
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    "stroke-width": 2,
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round"
                }
            },
            "./src/icon.js": function (n, r, i) {
                Object.defineProperty(r, "__esModule", {
                    value: !0
                });
                var s = Object.assign || function (x) {
                    for (var S = 1; S < arguments.length; S++) {
                        var k = arguments[S];
                        for (var A in k)
                            Object.prototype.hasOwnProperty.call(k, A) && (x[A] = k[A])
                    }
                    return x
                }
                    , o = function () {
                        function x(S, k) {
                            for (var A = 0; A < k.length; A++) {
                                var C = k[A];
                                C.enumerable = C.enumerable || !1,
                                    C.configurable = !0,
                                    "value" in C && (C.writable = !0),
                                    Object.defineProperty(S, C.key, C)
                            }
                        }
                        return function (S, k, A) {
                            return k && x(S.prototype, k),
                                A && x(S, A),
                                S
                        }
                    }()
                    , a = i("./node_modules/classnames/dedupe.js")
                    , l = h(a)
                    , c = i("./src/default-attrs.json")
                    , d = h(c);
                function h(x) {
                    return x && x.__esModule ? x : {
                        default: x
                    }
                }
                function p(x, S) {
                    if (!(x instanceof S))
                        throw new TypeError("Cannot call a class as a function")
                }
                var g = function () {
                    function x(S, k) {
                        var A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                        p(this, x),
                            this.name = S,
                            this.contents = k,
                            this.tags = A,
                            this.attrs = s({}, d.default, {
                                class: "feather feather-" + S
                            })
                    }
                    return o(x, [{
                        key: "toSvg",
                        value: function () {
                            var k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
                                , A = s({}, this.attrs, k, {
                                    class: (0,
                                        l.default)(this.attrs.class, k.class)
                                });
                            return "<svg " + y(A) + ">" + this.contents + "</svg>"
                        }
                    }, {
                        key: "toString",
                        value: function () {
                            return this.contents
                        }
                    }]),
                        x
                }();
                function y(x) {
                    return Object.keys(x).map(function (S) {
                        return S + '="' + x[S] + '"'
                    }).join(" ")
                }
                r.default = g
            },
            "./src/icons.js": function (n, r, i) {
                Object.defineProperty(r, "__esModule", {
                    value: !0
                });
                var s = i("./src/icon.js")
                    , o = h(s)
                    , a = i("./dist/icons.json")
                    , l = h(a)
                    , c = i("./src/tags.json")
                    , d = h(c);
                function h(p) {
                    return p && p.__esModule ? p : {
                        default: p
                    }
                }
                r.default = Object.keys(l.default).map(function (p) {
                    return new o.default(p, l.default[p], d.default[p])
                }).reduce(function (p, g) {
                    return p[g.name] = g,
                        p
                }, {})
            },
            "./src/index.js": function (n, r, i) {
                var s = i("./src/icons.js")
                    , o = h(s)
                    , a = i("./src/to-svg.js")
                    , l = h(a)
                    , c = i("./src/replace.js")
                    , d = h(c);
                function h(p) {
                    return p && p.__esModule ? p : {
                        default: p
                    }
                }
                n.exports = {
                    icons: o.default,
                    toSvg: l.default,
                    replace: d.default
                }
            },
            "./src/replace.js": function (n, r, i) {
                Object.defineProperty(r, "__esModule", {
                    value: !0
                });
                var s = Object.assign || function (y) {
                    for (var x = 1; x < arguments.length; x++) {
                        var S = arguments[x];
                        for (var k in S)
                            Object.prototype.hasOwnProperty.call(S, k) && (y[k] = S[k])
                    }
                    return y
                }
                    , o = i("./node_modules/classnames/dedupe.js")
                    , a = d(o)
                    , l = i("./src/icons.js")
                    , c = d(l);
                function d(y) {
                    return y && y.__esModule ? y : {
                        default: y
                    }
                }
                function h() {
                    var y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    if (typeof document > "u")
                        throw new Error("`feather.replace()` only works in a browser environment.");
                    var x = document.querySelectorAll("[data-feather]");
                    Array.from(x).forEach(function (S) {
                        return p(S, y)
                    })
                }
                function p(y) {
                    var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                        , S = g(y)
                        , k = S["data-feather"];
                    if (delete S["data-feather"],
                        c.default[k] === void 0) {
                        console.warn("feather: '" + k + "' is not a valid icon");
                        return
                    }
                    var A = c.default[k].toSvg(s({}, x, S, {
                        class: (0,
                            a.default)(x.class, S.class)
                    }))
                        , C = new DOMParser().parseFromString(A, "image/svg+xml")
                        , m = C.querySelector("svg");
                    y.parentNode.replaceChild(m, y)
                }
                function g(y) {
                    return Array.from(y.attributes).reduce(function (x, S) {
                        return x[S.name] = S.value,
                            x
                    }, {})
                }
                r.default = h
            },
            "./src/tags.json": function (n) {
                n.exports = {
                    activity: ["pulse", "health", "action", "motion"],
                    airplay: ["stream", "cast", "mirroring"],
                    "alert-circle": ["warning", "alert", "danger"],
                    "alert-octagon": ["warning", "alert", "danger"],
                    "alert-triangle": ["warning", "alert", "danger"],
                    "align-center": ["text alignment", "center"],
                    "align-justify": ["text alignment", "justified"],
                    "align-left": ["text alignment", "left"],
                    "align-right": ["text alignment", "right"],
                    anchor: [],
                    archive: ["index", "box"],
                    "at-sign": ["mention", "at", "email", "message"],
                    award: ["achievement", "badge"],
                    aperture: ["camera", "photo"],
                    "bar-chart": ["statistics", "diagram", "graph"],
                    "bar-chart-2": ["statistics", "diagram", "graph"],
                    battery: ["power", "electricity"],
                    "battery-charging": ["power", "electricity"],
                    bell: ["alarm", "notification", "sound"],
                    "bell-off": ["alarm", "notification", "silent"],
                    bluetooth: ["wireless"],
                    "book-open": ["read", "library"],
                    book: ["read", "dictionary", "booklet", "magazine", "library"],
                    bookmark: ["read", "clip", "marker", "tag"],
                    box: ["cube"],
                    briefcase: ["work", "bag", "baggage", "folder"],
                    calendar: ["date"],
                    camera: ["photo"],
                    cast: ["chromecast", "airplay"],
                    "chevron-down": ["expand"],
                    "chevron-up": ["collapse"],
                    circle: ["off", "zero", "record"],
                    clipboard: ["copy"],
                    clock: ["time", "watch", "alarm"],
                    "cloud-drizzle": ["weather", "shower"],
                    "cloud-lightning": ["weather", "bolt"],
                    "cloud-rain": ["weather"],
                    "cloud-snow": ["weather", "blizzard"],
                    cloud: ["weather"],
                    codepen: ["logo"],
                    codesandbox: ["logo"],
                    code: ["source", "programming"],
                    coffee: ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"],
                    columns: ["layout"],
                    command: ["keyboard", "cmd", "terminal", "prompt"],
                    compass: ["navigation", "safari", "travel", "direction"],
                    copy: ["clone", "duplicate"],
                    "corner-down-left": ["arrow", "return"],
                    "corner-down-right": ["arrow"],
                    "corner-left-down": ["arrow"],
                    "corner-left-up": ["arrow"],
                    "corner-right-down": ["arrow"],
                    "corner-right-up": ["arrow"],
                    "corner-up-left": ["arrow"],
                    "corner-up-right": ["arrow"],
                    cpu: ["processor", "technology"],
                    "credit-card": ["purchase", "payment", "cc"],
                    crop: ["photo", "image"],
                    crosshair: ["aim", "target"],
                    database: ["storage", "memory"],
                    delete: ["remove"],
                    disc: ["album", "cd", "dvd", "music"],
                    "dollar-sign": ["currency", "money", "payment"],
                    droplet: ["water"],
                    edit: ["pencil", "change"],
                    "edit-2": ["pencil", "change"],
                    "edit-3": ["pencil", "change"],
                    eye: ["view", "watch"],
                    "eye-off": ["view", "watch", "hide", "hidden"],
                    "external-link": ["outbound"],
                    facebook: ["logo", "social"],
                    "fast-forward": ["music"],
                    figma: ["logo", "design", "tool"],
                    "file-minus": ["delete", "remove", "erase"],
                    "file-plus": ["add", "create", "new"],
                    "file-text": ["data", "txt", "pdf"],
                    film: ["movie", "video"],
                    filter: ["funnel", "hopper"],
                    flag: ["report"],
                    "folder-minus": ["directory"],
                    "folder-plus": ["directory"],
                    folder: ["directory"],
                    framer: ["logo", "design", "tool"],
                    frown: ["emoji", "face", "bad", "sad", "emotion"],
                    gift: ["present", "box", "birthday", "party"],
                    "git-branch": ["code", "version control"],
                    "git-commit": ["code", "version control"],
                    "git-merge": ["code", "version control"],
                    "git-pull-request": ["code", "version control"],
                    github: ["logo", "version control"],
                    gitlab: ["logo", "version control"],
                    globe: ["world", "browser", "language", "translate"],
                    "hard-drive": ["computer", "server", "memory", "data"],
                    hash: ["hashtag", "number", "pound"],
                    headphones: ["music", "audio", "sound"],
                    heart: ["like", "love", "emotion"],
                    "help-circle": ["question mark"],
                    hexagon: ["shape", "node.js", "logo"],
                    home: ["house", "living"],
                    image: ["picture"],
                    inbox: ["email"],
                    instagram: ["logo", "camera"],
                    key: ["password", "login", "authentication", "secure"],
                    layers: ["stack"],
                    layout: ["window", "webpage"],
                    "life-buoy": ["help", "life ring", "support"],
                    link: ["chain", "url"],
                    "link-2": ["chain", "url"],
                    linkedin: ["logo", "social media"],
                    list: ["options"],
                    lock: ["security", "password", "secure"],
                    "log-in": ["sign in", "arrow", "enter"],
                    "log-out": ["sign out", "arrow", "exit"],
                    mail: ["email", "message"],
                    "map-pin": ["location", "navigation", "travel", "marker"],
                    map: ["location", "navigation", "travel"],
                    maximize: ["fullscreen"],
                    "maximize-2": ["fullscreen", "arrows", "expand"],
                    meh: ["emoji", "face", "neutral", "emotion"],
                    menu: ["bars", "navigation", "hamburger"],
                    "message-circle": ["comment", "chat"],
                    "message-square": ["comment", "chat"],
                    "mic-off": ["record", "sound", "mute"],
                    mic: ["record", "sound", "listen"],
                    minimize: ["exit fullscreen", "close"],
                    "minimize-2": ["exit fullscreen", "arrows", "close"],
                    minus: ["subtract"],
                    monitor: ["tv", "screen", "display"],
                    moon: ["dark", "night"],
                    "more-horizontal": ["ellipsis"],
                    "more-vertical": ["ellipsis"],
                    "mouse-pointer": ["arrow", "cursor"],
                    move: ["arrows"],
                    music: ["note"],
                    navigation: ["location", "travel"],
                    "navigation-2": ["location", "travel"],
                    octagon: ["stop"],
                    package: ["box", "container"],
                    paperclip: ["attachment"],
                    pause: ["music", "stop"],
                    "pause-circle": ["music", "audio", "stop"],
                    "pen-tool": ["vector", "drawing"],
                    percent: ["discount"],
                    "phone-call": ["ring"],
                    "phone-forwarded": ["call"],
                    "phone-incoming": ["call"],
                    "phone-missed": ["call"],
                    "phone-off": ["call", "mute"],
                    "phone-outgoing": ["call"],
                    phone: ["call"],
                    play: ["music", "start"],
                    "pie-chart": ["statistics", "diagram"],
                    "play-circle": ["music", "start"],
                    plus: ["add", "new"],
                    "plus-circle": ["add", "new"],
                    "plus-square": ["add", "new"],
                    pocket: ["logo", "save"],
                    power: ["on", "off"],
                    printer: ["fax", "office", "device"],
                    radio: ["signal"],
                    "refresh-cw": ["synchronise", "arrows"],
                    "refresh-ccw": ["arrows"],
                    repeat: ["loop", "arrows"],
                    rewind: ["music"],
                    "rotate-ccw": ["arrow"],
                    "rotate-cw": ["arrow"],
                    rss: ["feed", "subscribe"],
                    save: ["floppy disk"],
                    scissors: ["cut"],
                    search: ["find", "magnifier", "magnifying glass"],
                    send: ["message", "mail", "email", "paper airplane", "paper aeroplane"],
                    settings: ["cog", "edit", "gear", "preferences"],
                    "share-2": ["network", "connections"],
                    shield: ["security", "secure"],
                    "shield-off": ["security", "insecure"],
                    "shopping-bag": ["ecommerce", "cart", "purchase", "store"],
                    "shopping-cart": ["ecommerce", "cart", "purchase", "store"],
                    shuffle: ["music"],
                    "skip-back": ["music"],
                    "skip-forward": ["music"],
                    slack: ["logo"],
                    slash: ["ban", "no"],
                    sliders: ["settings", "controls"],
                    smartphone: ["cellphone", "device"],
                    smile: ["emoji", "face", "happy", "good", "emotion"],
                    speaker: ["audio", "music"],
                    star: ["bookmark", "favorite", "like"],
                    "stop-circle": ["media", "music"],
                    sun: ["brightness", "weather", "light"],
                    sunrise: ["weather", "time", "morning", "day"],
                    sunset: ["weather", "time", "evening", "night"],
                    tablet: ["device"],
                    tag: ["label"],
                    target: ["logo", "bullseye"],
                    terminal: ["code", "command line", "prompt"],
                    thermometer: ["temperature", "celsius", "fahrenheit", "weather"],
                    "thumbs-down": ["dislike", "bad", "emotion"],
                    "thumbs-up": ["like", "good", "emotion"],
                    "toggle-left": ["on", "off", "switch"],
                    "toggle-right": ["on", "off", "switch"],
                    tool: ["settings", "spanner"],
                    trash: ["garbage", "delete", "remove", "bin"],
                    "trash-2": ["garbage", "delete", "remove", "bin"],
                    triangle: ["delta"],
                    truck: ["delivery", "van", "shipping", "transport", "lorry"],
                    tv: ["television", "stream"],
                    twitch: ["logo"],
                    twitter: ["logo", "social"],
                    type: ["text"],
                    umbrella: ["rain", "weather"],
                    unlock: ["security"],
                    "user-check": ["followed", "subscribed"],
                    "user-minus": ["delete", "remove", "unfollow", "unsubscribe"],
                    "user-plus": ["new", "add", "create", "follow", "subscribe"],
                    "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"],
                    user: ["person", "account"],
                    users: ["group"],
                    "video-off": ["camera", "movie", "film"],
                    video: ["camera", "movie", "film"],
                    voicemail: ["phone"],
                    volume: ["music", "sound", "mute"],
                    "volume-1": ["music", "sound"],
                    "volume-2": ["music", "sound"],
                    "volume-x": ["music", "sound", "mute"],
                    watch: ["clock", "time"],
                    "wifi-off": ["disabled"],
                    wifi: ["connection", "signal", "wireless"],
                    wind: ["weather", "air"],
                    "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"],
                    "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"],
                    "x-square": ["cancel", "close", "delete", "remove", "times", "clear"],
                    x: ["cancel", "close", "delete", "remove", "times", "clear"],
                    youtube: ["logo", "video", "play"],
                    "zap-off": ["flash", "camera", "lightning"],
                    zap: ["flash", "camera", "lightning"],
                    "zoom-in": ["magnifying glass"],
                    "zoom-out": ["magnifying glass"]
                }
            },
            "./src/to-svg.js": function (n, r, i) {
                Object.defineProperty(r, "__esModule", {
                    value: !0
                });
                var s = i("./src/icons.js")
                    , o = a(s);
                function a(c) {
                    return c && c.__esModule ? c : {
                        default: c
                    }
                }
                function l(c) {
                    var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    if (console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead."),
                        !c)
                        throw new Error("The required `key` (icon name) parameter is missing.");
                    if (!o.default[c])
                        throw new Error("No icon matching '" + c + "'. See the complete list of icons at https://feathericons.com");
                    return o.default[c].toSvg(d)
                }
                r.default = l
            },
            0: function (n, r, i) {
                i("./node_modules/core-js/es/array/from.js"),
                    n.exports = i("./src/index.js")
            }
        })
    })
}
)(nE);
var RB = nE.exports;
const T1 = tE(RB)
    , e_ = Object.keys(T1.icons)
    , ko = {
        props: {
            name: {
                type: String,
                required: !0,
                validator(t) {
                    const e = e_.includes(t);
                    return e || (console.groupCollapsed("[frappe-ui] name property for feather-icon must be one of "),
                        console.dir(e_),
                        console.groupEnd()),
                        e
                }
            },
            color: {
                type: String,
                default: null
            },
            strokeWidth: {
                type: Number,
                default: 1.5
            }
        },
        render() {
            let t = T1.icons[this.name];
            return t || (t = T1.icons.circle),
                Mt("svg", Wt(t.attrs, {
                    fill: "none",
                    stroke: "currentColor",
                    color: this.color,
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": this.strokeWidth,
                    width: null,
                    height: null,
                    class: [t.attrs.class, "shrink-0"],
                    innerHTML: t.contents
                }, this.$attrs))
        }
    }
    , PB = {
        name: "LoadingIndicator"
    }
    , NB = {
        class: "max-w-xs animate-spin",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
    };
function IB(t, e, n, r, i, s) {
    return oe(),
        Ae("svg", NB, e[0] || (e[0] = [Xe("circle", {
            class: "opacity-25",
            cx: "12",
            cy: "12",
            r: "10",
            stroke: "currentColor",
            "stroke-width": "4"
        }, null, -1), Xe("path", {
            class: "opacity-75",
            fill: "currentColor",
            d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        }, null, -1)]))
}
const LB = Ua(PB, [["render", IB]]);
/*!
  * vue-router v4.4.5
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const xl = typeof document < "u";
function rE(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}
function DB(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module" || t.default && rE(t.default)
}
const Lt = Object.assign;
function y0(t, e) {
    const n = {};
    for (const r in e) {
        const i = e[r];
        n[r] = Ai(i) ? i.map(t) : t(i)
    }
    return n
}
const cc = () => { }
    , Ai = Array.isArray
    , iE = /#/g
    , jB = /&/g
    , BB = /\//g
    , $B = /=/g
    , zB = /\?/g
    , sE = /\+/g
    , FB = /%5B/g
    , HB = /%5D/g
    , oE = /%5E/g
    , VB = /%60/g
    , aE = /%7B/g
    , WB = /%7C/g
    , lE = /%7D/g
    , UB = /%20/g;
function pv(t) {
    return encodeURI("" + t).replace(WB, "|").replace(FB, "[").replace(HB, "]")
}
function KB(t) {
    return pv(t).replace(aE, "{").replace(lE, "}").replace(oE, "^")
}
function A1(t) {
    return pv(t).replace(sE, "%2B").replace(UB, "+").replace(iE, "%23").replace(jB, "%26").replace(VB, "`").replace(aE, "{").replace(lE, "}").replace(oE, "^")
}
function qB(t) {
    return A1(t).replace($B, "%3D")
}
function GB(t) {
    return pv(t).replace(iE, "%23").replace(zB, "%3F")
}
function JB(t) {
    return t == null ? "" : GB(t).replace(BB, "%2F")
}
function Nc(t) {
    try {
        return decodeURIComponent("" + t)
    } catch { }
    return "" + t
}
const ZB = /\/$/
    , YB = t => t.replace(ZB, "");
function v0(t, e, n = "/") {
    let r, i = {}, s = "", o = "";
    const a = e.indexOf("#");
    let l = e.indexOf("?");
    return a < l && a >= 0 && (l = -1),
        l > -1 && (r = e.slice(0, l),
            s = e.slice(l + 1, a > -1 ? a : e.length),
            i = t(s)),
        a > -1 && (r = r || e.slice(0, a),
            o = e.slice(a, e.length)),
        r = t$(r ?? e, n),
    {
        fullPath: r + (s && "?") + s + o,
        path: r,
        query: i,
        hash: Nc(o)
    }
}
function XB(t, e) {
    const n = e.query ? t(e.query) : "";
    return e.path + (n && "?") + n + (e.hash || "")
}
function t_(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}
function QB(t, e, n) {
    const r = e.matched.length - 1
        , i = n.matched.length - 1;
    return r > -1 && r === i && Xl(e.matched[r], n.matched[i]) && uE(e.params, n.params) && t(e.query) === t(n.query) && e.hash === n.hash
}
function Xl(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}
function uE(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length)
        return !1;
    for (const n in t)
        if (!e$(t[n], e[n]))
            return !1;
    return !0
}
function e$(t, e) {
    return Ai(t) ? n_(t, e) : Ai(e) ? n_(e, t) : t === e
}
function n_(t, e) {
    return Ai(e) ? t.length === e.length && t.every((n, r) => n === e[r]) : t.length === 1 && t[0] === e
}
function t$(t, e) {
    if (t.startsWith("/"))
        return t;
    if (!t)
        return e;
    const n = e.split("/")
        , r = t.split("/")
        , i = r[r.length - 1];
    (i === ".." || i === ".") && r.push("");
    let s = n.length - 1, o, a;
    for (o = 0; o < r.length; o++)
        if (a = r[o],
            a !== ".")
            if (a === "..")
                s > 1 && s--;
            else
                break;
    return n.slice(0, s).join("/") + "/" + r.slice(o).join("/")
}
const Xs = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var Ic;
(function (t) {
    t.pop = "pop",
        t.push = "push"
}
)(Ic || (Ic = {}));
var dc;
(function (t) {
    t.back = "back",
        t.forward = "forward",
        t.unknown = ""
}
)(dc || (dc = {}));
function n$(t) {
    if (!t)
        if (xl) {
            const e = document.querySelector("base");
            t = e && e.getAttribute("href") || "/",
                t = t.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t),
        YB(t)
}
const r$ = /^[^#]+#/;
function i$(t, e) {
    return t.replace(r$, "#") + e
}
function s$(t, e) {
    const n = document.documentElement.getBoundingClientRect()
        , r = t.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: r.left - n.left - (e.left || 0),
        top: r.top - n.top - (e.top || 0)
    }
}
const pm = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function o$(t) {
    let e;
    if ("el" in t) {
        const n = t.el
            , r = typeof n == "string" && n.startsWith("#")
            , i = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!i)
            return;
        e = s$(i, t)
    } else
        e = t;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY)
}
function r_(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const O1 = new Map;
function a$(t, e) {
    O1.set(t, e)
}
function l$(t) {
    const e = O1.get(t);
    return O1.delete(t),
        e
}
let u$ = () => location.protocol + "//" + location.host;
function cE(t, e) {
    const { pathname: n, search: r, hash: i } = e
        , s = t.indexOf("#");
    if (s > -1) {
        let a = i.includes(t.slice(s)) ? t.slice(s).length : 1
            , l = i.slice(a);
        return l[0] !== "/" && (l = "/" + l),
            t_(l, "")
    }
    return t_(n, t) + r + i
}
function c$(t, e, n, r) {
    let i = []
        , s = []
        , o = null;
    const a = ({ state: p }) => {
        const g = cE(t, location)
            , y = n.value
            , x = e.value;
        let S = 0;
        if (p) {
            if (n.value = g,
                e.value = p,
                o && o === y) {
                o = null;
                return
            }
            S = x ? p.position - x.position : 0
        } else
            r(g);
        i.forEach(k => {
            k(n.value, y, {
                delta: S,
                type: Ic.pop,
                direction: S ? S > 0 ? dc.forward : dc.back : dc.unknown
            })
        }
        )
    }
        ;
    function l() {
        o = n.value
    }
    function c(p) {
        i.push(p);
        const g = () => {
            const y = i.indexOf(p);
            y > -1 && i.splice(y, 1)
        }
            ;
        return s.push(g),
            g
    }
    function d() {
        const { history: p } = window;
        p.state && p.replaceState(Lt({}, p.state, {
            scroll: pm()
        }), "")
    }
    function h() {
        for (const p of s)
            p();
        s = [],
            window.removeEventListener("popstate", a),
            window.removeEventListener("beforeunload", d)
    }
    return window.addEventListener("popstate", a),
        window.addEventListener("beforeunload", d, {
            passive: !0
        }),
    {
        pauseListeners: l,
        listen: c,
        destroy: h
    }
}
function i_(t, e, n, r = !1, i = !1) {
    return {
        back: t,
        current: e,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: i ? pm() : null
    }
}
function d$(t) {
    const { history: e, location: n } = window
        , r = {
            value: cE(t, n)
        }
        , i = {
            value: e.state
        };
    i.value || s(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function s(l, c, d) {
        const h = t.indexOf("#")
            , p = h > -1 ? (n.host && document.querySelector("base") ? t : t.slice(h)) + l : u$() + t + l;
        try {
            e[d ? "replaceState" : "pushState"](c, "", p),
                i.value = c
        } catch (g) {
            console.error(g),
                n[d ? "replace" : "assign"](p)
        }
    }
    function o(l, c) {
        const d = Lt({}, e.state, i_(i.value.back, l, i.value.forward, !0), c, {
            position: i.value.position
        });
        s(l, d, !0),
            r.value = l
    }
    function a(l, c) {
        const d = Lt({}, i.value, e.state, {
            forward: l,
            scroll: pm()
        });
        s(d.current, d, !0);
        const h = Lt({}, i_(r.value, l, null), {
            position: d.position + 1
        }, c);
        s(l, h, !1),
            r.value = l
    }
    return {
        location: r,
        state: i,
        push: a,
        replace: o
    }
}
function f$(t) {
    t = n$(t);
    const e = d$(t)
        , n = c$(t, e.state, e.location, e.replace);
    function r(s, o = !0) {
        o || n.pauseListeners(),
            history.go(s)
    }
    const i = Lt({
        location: "",
        base: t,
        go: r,
        createHref: i$.bind(null, t)
    }, e, n);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => e.location.value
    }),
        Object.defineProperty(i, "state", {
            enumerable: !0,
            get: () => e.state.value
        }),
        i
}
function h$(t) {
    return typeof t == "string" || t && typeof t == "object"
}
function dE(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const fE = Symbol("");
var s_;
(function (t) {
    t[t.aborted = 4] = "aborted",
        t[t.cancelled = 8] = "cancelled",
        t[t.duplicated = 16] = "duplicated"
}
)(s_ || (s_ = {}));
function Ql(t, e) {
    return Lt(new Error, {
        type: t,
        [fE]: !0
    }, e)
}
function ws(t, e) {
    return t instanceof Error && fE in t && (e == null || !!(t.type & e))
}
const o_ = "[^/]+?"
    , p$ = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    }
    , m$ = /[.+*?^${}()[\]/\\]/g;
function g$(t, e) {
    const n = Lt({}, p$, e)
        , r = [];
    let i = n.start ? "^" : "";
    const s = [];
    for (const c of t) {
        const d = c.length ? [] : [90];
        n.strict && !c.length && (i += "/");
        for (let h = 0; h < c.length; h++) {
            const p = c[h];
            let g = 40 + (n.sensitive ? .25 : 0);
            if (p.type === 0)
                h || (i += "/"),
                    i += p.value.replace(m$, "\\$&"),
                    g += 40;
            else if (p.type === 1) {
                const { value: y, repeatable: x, optional: S, regexp: k } = p;
                s.push({
                    name: y,
                    repeatable: x,
                    optional: S
                });
                const A = k || o_;
                if (A !== o_) {
                    g += 10;
                    try {
                        new RegExp(`(${A})`)
                    } catch (m) {
                        throw new Error(`Invalid custom RegExp for param "${y}" (${A}): ` + m.message)
                    }
                }
                let C = x ? `((?:${A})(?:/(?:${A}))*)` : `(${A})`;
                h || (C = S && c.length < 2 ? `(?:/${C})` : "/" + C),
                    S && (C += "?"),
                    i += C,
                    g += 20,
                    S && (g += -8),
                    x && (g += -20),
                    A === ".*" && (g += -50)
            }
            d.push(g)
        }
        r.push(d)
    }
    if (n.strict && n.end) {
        const c = r.length - 1;
        r[c][r[c].length - 1] += .7000000000000001
    }
    n.strict || (i += "/?"),
        n.end ? i += "$" : n.strict && (i += "(?:/|$)");
    const o = new RegExp(i, n.sensitive ? "" : "i");
    function a(c) {
        const d = c.match(o)
            , h = {};
        if (!d)
            return null;
        for (let p = 1; p < d.length; p++) {
            const g = d[p] || ""
                , y = s[p - 1];
            h[y.name] = g && y.repeatable ? g.split("/") : g
        }
        return h
    }
    function l(c) {
        let d = ""
            , h = !1;
        for (const p of t) {
            (!h || !d.endsWith("/")) && (d += "/"),
                h = !1;
            for (const g of p)
                if (g.type === 0)
                    d += g.value;
                else if (g.type === 1) {
                    const { value: y, repeatable: x, optional: S } = g
                        , k = y in c ? c[y] : "";
                    if (Ai(k) && !x)
                        throw new Error(`Provided param "${y}" is an array but it is not repeatable (* or + modifiers)`);
                    const A = Ai(k) ? k.join("/") : k;
                    if (!A)
                        if (S)
                            p.length < 2 && (d.endsWith("/") ? d = d.slice(0, -1) : h = !0);
                        else
                            throw new Error(`Missing required param "${y}"`);
                    d += A
                }
        }
        return d || "/"
    }
    return {
        re: o,
        score: r,
        keys: s,
        parse: a,
        stringify: l
    }
}
function y$(t, e) {
    let n = 0;
    for (; n < t.length && n < e.length;) {
        const r = e[n] - t[n];
        if (r)
            return r;
        n++
    }
    return t.length < e.length ? t.length === 1 && t[0] === 40 + 40 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}
function hE(t, e) {
    let n = 0;
    const r = t.score
        , i = e.score;
    for (; n < r.length && n < i.length;) {
        const s = y$(r[n], i[n]);
        if (s)
            return s;
        n++
    }
    if (Math.abs(i.length - r.length) === 1) {
        if (a_(r))
            return 1;
        if (a_(i))
            return -1
    }
    return i.length - r.length
}
function a_(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0
}
const v$ = {
    type: 0,
    value: ""
}
    , b$ = /[a-zA-Z0-9_]/;
function w$(t) {
    if (!t)
        return [[]];
    if (t === "/")
        return [[v$]];
    if (!t.startsWith("/"))
        throw new Error(`Invalid path "${t}"`);
    function e(g) {
        throw new Error(`ERR (${n})/"${c}": ${g}`)
    }
    let n = 0
        , r = n;
    const i = [];
    let s;
    function o() {
        s && i.push(s),
            s = []
    }
    let a = 0, l, c = "", d = "";
    function h() {
        c && (n === 0 ? s.push({
            type: 0,
            value: c
        }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
            s.push({
                type: 1,
                value: c,
                regexp: d,
                repeatable: l === "*" || l === "+",
                optional: l === "*" || l === "?"
            })) : e("Invalid state to consume buffer"),
            c = "")
    }
    function p() {
        c += l
    }
    for (; a < t.length;) {
        if (l = t[a++],
            l === "\\" && n !== 2) {
            r = n,
                n = 4;
            continue
        }
        switch (n) {
            case 0:
                l === "/" ? (c && h(),
                    o()) : l === ":" ? (h(),
                        n = 1) : p();
                break;
            case 4:
                p(),
                    n = r;
                break;
            case 1:
                l === "(" ? n = 2 : b$.test(l) ? p() : (h(),
                    n = 0,
                    l !== "*" && l !== "?" && l !== "+" && a--);
                break;
            case 2:
                l === ")" ? d[d.length - 1] == "\\" ? d = d.slice(0, -1) + l : n = 3 : d += l;
                break;
            case 3:
                h(),
                    n = 0,
                    l !== "*" && l !== "?" && l !== "+" && a--,
                    d = "";
                break;
            default:
                e("Unknown state");
                break
        }
    }
    return n === 2 && e(`Unfinished custom RegExp for param "${c}"`),
        h(),
        o(),
        i
}
function x$(t, e, n) {
    const r = g$(w$(t.path), n)
        , i = Lt(r, {
            record: t,
            parent: e,
            children: [],
            alias: []
        });
    return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i),
        i
}
function _$(t, e) {
    const n = []
        , r = new Map;
    e = d_({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);
    function i(h) {
        return r.get(h)
    }
    function s(h, p, g) {
        const y = !g
            , x = u_(h);
        x.aliasOf = g && g.record;
        const S = d_(e, h)
            , k = [x];
        if ("alias" in h) {
            const m = typeof h.alias == "string" ? [h.alias] : h.alias;
            for (const b of m)
                k.push(u_(Lt({}, x, {
                    components: g ? g.record.components : x.components,
                    path: b,
                    aliasOf: g ? g.record : x
                })))
        }
        let A, C;
        for (const m of k) {
            const { path: b } = m;
            if (p && b[0] !== "/") {
                const w = p.record.path
                    , T = w[w.length - 1] === "/" ? "" : "/";
                m.path = p.record.path + (b && T + b)
            }
            if (A = x$(m, p, S),
                g ? g.alias.push(A) : (C = C || A,
                    C !== A && C.alias.push(A),
                    y && h.name && !c_(A) && o(h.name)),
                pE(A) && l(A),
                x.children) {
                const w = x.children;
                for (let T = 0; T < w.length; T++)
                    s(w[T], A, g && g.children[T])
            }
            g = g || A
        }
        return C ? () => {
            o(C)
        }
            : cc
    }
    function o(h) {
        if (dE(h)) {
            const p = r.get(h);
            p && (r.delete(h),
                n.splice(n.indexOf(p), 1),
                p.children.forEach(o),
                p.alias.forEach(o))
        } else {
            const p = n.indexOf(h);
            p > -1 && (n.splice(p, 1),
                h.record.name && r.delete(h.record.name),
                h.children.forEach(o),
                h.alias.forEach(o))
        }
    }
    function a() {
        return n
    }
    function l(h) {
        const p = C$(h, n);
        n.splice(p, 0, h),
            h.record.name && !c_(h) && r.set(h.record.name, h)
    }
    function c(h, p) {
        let g, y = {}, x, S;
        if ("name" in h && h.name) {
            if (g = r.get(h.name),
                !g)
                throw Ql(1, {
                    location: h
                });
            S = g.record.name,
                y = Lt(l_(p.params, g.keys.filter(C => !C.optional).concat(g.parent ? g.parent.keys.filter(C => C.optional) : []).map(C => C.name)), h.params && l_(h.params, g.keys.map(C => C.name))),
                x = g.stringify(y)
        } else if (h.path != null)
            x = h.path,
                g = n.find(C => C.re.test(x)),
                g && (y = g.parse(x),
                    S = g.record.name);
        else {
            if (g = p.name ? r.get(p.name) : n.find(C => C.re.test(p.path)),
                !g)
                throw Ql(1, {
                    location: h,
                    currentLocation: p
                });
            S = g.record.name,
                y = Lt({}, p.params, h.params),
                x = g.stringify(y)
        }
        const k = [];
        let A = g;
        for (; A;)
            k.unshift(A.record),
                A = A.parent;
        return {
            name: S,
            path: x,
            params: y,
            matched: k,
            meta: k$(k)
        }
    }
    t.forEach(h => s(h));
    function d() {
        n.length = 0,
            r.clear()
    }
    return {
        addRoute: s,
        resolve: c,
        removeRoute: o,
        clearRoutes: d,
        getRoutes: a,
        getRecordMatcher: i
    }
}
function l_(t, e) {
    const n = {};
    for (const r of e)
        r in t && (n[r] = t[r]);
    return n
}
function u_(t) {
    const e = {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: t.aliasOf,
        beforeEnter: t.beforeEnter,
        props: S$(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in t ? t.components || null : t.component && {
            default: t.component
        }
    };
    return Object.defineProperty(e, "mods", {
        value: {}
    }),
        e
}
function S$(t) {
    const e = {}
        , n = t.props || !1;
    if ("component" in t)
        e.default = n;
    else
        for (const r in t.components)
            e[r] = typeof n == "object" ? n[r] : n;
    return e
}
function c_(t) {
    for (; t;) {
        if (t.record.aliasOf)
            return !0;
        t = t.parent
    }
    return !1
}
function k$(t) {
    return t.reduce((e, n) => Lt(e, n.meta), {})
}
function d_(t, e) {
    const n = {};
    for (const r in t)
        n[r] = r in e ? e[r] : t[r];
    return n
}
function C$(t, e) {
    let n = 0
        , r = e.length;
    for (; n !== r;) {
        const s = n + r >> 1;
        hE(t, e[s]) < 0 ? r = s : n = s + 1
    }
    const i = E$(t);
    return i && (r = e.lastIndexOf(i, r - 1)),
        r
}
function E$(t) {
    let e = t;
    for (; e = e.parent;)
        if (pE(e) && hE(t, e) === 0)
            return e
}
function pE({ record: t }) {
    return !!(t.name || t.components && Object.keys(t.components).length || t.redirect)
}
function T$(t) {
    const e = {};
    if (t === "" || t === "?")
        return e;
    const r = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let i = 0; i < r.length; ++i) {
        const s = r[i].replace(sE, " ")
            , o = s.indexOf("=")
            , a = Nc(o < 0 ? s : s.slice(0, o))
            , l = o < 0 ? null : Nc(s.slice(o + 1));
        if (a in e) {
            let c = e[a];
            Ai(c) || (c = e[a] = [c]),
                c.push(l)
        } else
            e[a] = l
    }
    return e
}
function f_(t) {
    let e = "";
    for (let n in t) {
        const r = t[n];
        if (n = qB(n),
            r == null) {
            r !== void 0 && (e += (e.length ? "&" : "") + n);
            continue
        }
        (Ai(r) ? r.map(s => s && A1(s)) : [r && A1(r)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + n,
                s != null && (e += "=" + s))
        }
        )
    }
    return e
}
function A$(t) {
    const e = {};
    for (const n in t) {
        const r = t[n];
        r !== void 0 && (e[n] = Ai(r) ? r.map(i => i == null ? null : "" + i) : r == null ? r : "" + r)
    }
    return e
}
const O$ = Symbol("")
    , h_ = Symbol("")
    , mm = Symbol("")
    , mv = Symbol("")
    , M1 = Symbol("");
function Fu() {
    let t = [];
    function e(r) {
        return t.push(r),
            () => {
                const i = t.indexOf(r);
                i > -1 && t.splice(i, 1)
            }
    }
    function n() {
        t = []
    }
    return {
        add: e,
        list: () => t.slice(),
        reset: n
    }
}
function ao(t, e, n, r, i, s = o => o()) {
    const o = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () => new Promise((a, l) => {
        const c = p => {
            p === !1 ? l(Ql(4, {
                from: n,
                to: e
            })) : p instanceof Error ? l(p) : h$(p) ? l(Ql(2, {
                from: e,
                to: p
            })) : (o && r.enterCallbacks[i] === o && typeof p == "function" && o.push(p),
                a())
        }
            , d = s(() => t.call(r && r.instances[i], e, n, c));
        let h = Promise.resolve(d);
        t.length < 3 && (h = h.then(c)),
            h.catch(p => l(p))
    }
    )
}
function b0(t, e, n, r, i = s => s()) {
    const s = [];
    for (const o of t)
        for (const a in o.components) {
            let l = o.components[a];
            if (!(e !== "beforeRouteEnter" && !o.instances[a]))
                if (rE(l)) {
                    const d = (l.__vccOpts || l)[e];
                    d && s.push(ao(d, n, r, o, a, i))
                } else {
                    let c = l();
                    s.push(() => c.then(d => {
                        if (!d)
                            throw new Error(`Couldn't resolve component "${a}" at "${o.path}"`);
                        const h = DB(d) ? d.default : d;
                        o.mods[a] = d,
                            o.components[a] = h;
                        const g = (h.__vccOpts || h)[e];
                        return g && ao(g, n, r, o, a, i)()
                    }
                    ))
                }
        }
    return s
}
function p_(t) {
    const e = Dt(mm)
        , n = Dt(mv)
        , r = G(() => {
            const l = ie(t.to);
            return e.resolve(l)
        }
        )
        , i = G(() => {
            const { matched: l } = r.value
                , { length: c } = l
                , d = l[c - 1]
                , h = n.matched;
            if (!d || !h.length)
                return -1;
            const p = h.findIndex(Xl.bind(null, d));
            if (p > -1)
                return p;
            const g = m_(l[c - 2]);
            return c > 1 && m_(d) === g && h[h.length - 1].path !== g ? h.findIndex(Xl.bind(null, l[c - 2])) : p
        }
        )
        , s = G(() => i.value > -1 && N$(n.params, r.value.params))
        , o = G(() => i.value > -1 && i.value === n.matched.length - 1 && uE(n.params, r.value.params));
    function a(l = {}) {
        return P$(l) ? e[ie(t.replace) ? "replace" : "push"](ie(t.to)).catch(cc) : Promise.resolve()
    }
    return {
        route: r,
        href: G(() => r.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const M$ = je({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: p_,
    setup(t, { slots: e }) {
        const n = wn(p_(t))
            , { options: r } = Dt(mm)
            , i = G(() => ({
                [g_(t.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
                [g_(t.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
            }));
        return () => {
            const s = e.default && e.default(n);
            return t.custom ? s : Mt("a", {
                "aria-current": n.isExactActive ? t.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: i.value
            }, s)
        }
    }
})
    , R$ = M$;
function P$(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e))
                return
        }
        return t.preventDefault && t.preventDefault(),
            !0
    }
}
function N$(t, e) {
    for (const n in e) {
        const r = e[n]
            , i = t[n];
        if (typeof r == "string") {
            if (r !== i)
                return !1
        } else if (!Ai(i) || i.length !== r.length || r.some((s, o) => s !== i[o]))
            return !1
    }
    return !0
}
function m_(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : ""
}
const g_ = (t, e, n) => t ?? e ?? n
    , I$ = je({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(t, { attrs: e, slots: n }) {
            const r = Dt(M1)
                , i = G(() => t.route || r.value)
                , s = Dt(h_, 0)
                , o = G(() => {
                    let c = ie(s);
                    const { matched: d } = i.value;
                    let h;
                    for (; (h = d[c]) && !h.components;)
                        c++;
                    return c
                }
                )
                , a = G(() => i.value.matched[o.value]);
            Hn(h_, G(() => o.value + 1)),
                Hn(O$, a),
                Hn(M1, i);
            const l = ce();
            return vt(() => [l.value, a.value, t.name], ([c, d, h], [p, g, y]) => {
                d && (d.instances[h] = c,
                    g && g !== d && c && c === p && (d.leaveGuards.size || (d.leaveGuards = g.leaveGuards),
                        d.updateGuards.size || (d.updateGuards = g.updateGuards))),
                    c && d && (!g || !Xl(d, g) || !p) && (d.enterCallbacks[h] || []).forEach(x => x(c))
            }
                , {
                    flush: "post"
                }),
                () => {
                    const c = i.value
                        , d = t.name
                        , h = a.value
                        , p = h && h.components[d];
                    if (!p)
                        return y_(n.default, {
                            Component: p,
                            route: c
                        });
                    const g = h.props[d]
                        , y = g ? g === !0 ? c.params : typeof g == "function" ? g(c) : g : null
                        , S = Mt(p, Lt({}, y, e, {
                            onVnodeUnmounted: k => {
                                k.component.isUnmounted && (h.instances[d] = null)
                            }
                            ,
                            ref: l
                        }));
                    return y_(n.default, {
                        Component: S,
                        route: c
                    }) || S
                }
        }
    });
function y_(t, e) {
    if (!t)
        return null;
    const n = t(e);
    return n.length === 1 ? n[0] : n
}
const L$ = I$;
function D$(t) {
    const e = _$(t.routes, t)
        , n = t.parseQuery || T$
        , r = t.stringifyQuery || f_
        , i = t.history
        , s = Fu()
        , o = Fu()
        , a = Fu()
        , l = Wa(Xs);
    let c = Xs;
    xl && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const d = y0.bind(null, Y => "" + Y)
        , h = y0.bind(null, JB)
        , p = y0.bind(null, Nc);
    function g(Y, he) {
        let ge, Ee;
        return dE(Y) ? (ge = e.getRecordMatcher(Y),
            Ee = he) : Ee = Y,
            e.addRoute(Ee, ge)
    }
    function y(Y) {
        const he = e.getRecordMatcher(Y);
        he && e.removeRoute(he)
    }
    function x() {
        return e.getRoutes().map(Y => Y.record)
    }
    function S(Y) {
        return !!e.getRecordMatcher(Y)
    }
    function k(Y, he) {
        if (he = Lt({}, he || l.value),
            typeof Y == "string") {
            const B = v0(n, Y, he.path)
                , J = e.resolve({
                    path: B.path
                }, he)
                , ae = i.createHref(B.fullPath);
            return Lt(B, J, {
                params: p(J.params),
                hash: Nc(B.hash),
                redirectedFrom: void 0,
                href: ae
            })
        }
        let ge;
        if (Y.path != null)
            ge = Lt({}, Y, {
                path: v0(n, Y.path, he.path).path
            });
        else {
            const B = Lt({}, Y.params);
            for (const J in B)
                B[J] == null && delete B[J];
            ge = Lt({}, Y, {
                params: h(B)
            }),
                he.params = h(he.params)
        }
        const Ee = e.resolve(ge, he)
            , st = Y.hash || "";
        Ee.params = d(p(Ee.params));
        const xt = XB(r, Lt({}, Y, {
            hash: KB(st),
            path: Ee.path
        }))
            , D = i.createHref(xt);
        return Lt({
            fullPath: xt,
            hash: st,
            query: r === f_ ? A$(Y.query) : Y.query || {}
        }, Ee, {
            redirectedFrom: void 0,
            href: D
        })
    }
    function A(Y) {
        return typeof Y == "string" ? v0(n, Y, l.value.path) : Lt({}, Y)
    }
    function C(Y, he) {
        if (c !== Y)
            return Ql(8, {
                from: he,
                to: Y
            })
    }
    function m(Y) {
        return T(Y)
    }
    function b(Y) {
        return m(Lt(A(Y), {
            replace: !0
        }))
    }
    function w(Y) {
        const he = Y.matched[Y.matched.length - 1];
        if (he && he.redirect) {
            const { redirect: ge } = he;
            let Ee = typeof ge == "function" ? ge(Y) : ge;
            return typeof Ee == "string" && (Ee = Ee.includes("?") || Ee.includes("#") ? Ee = A(Ee) : {
                path: Ee
            },
                Ee.params = {}),
                Lt({
                    query: Y.query,
                    hash: Y.hash,
                    params: Ee.path != null ? {} : Y.params
                }, Ee)
        }
    }
    function T(Y, he) {
        const ge = c = k(Y)
            , Ee = l.value
            , st = Y.state
            , xt = Y.force
            , D = Y.replace === !0
            , B = w(ge);
        if (B)
            return T(Lt(A(B), {
                state: typeof B == "object" ? Lt({}, st, B.state) : st,
                force: xt,
                replace: D
            }), he || ge);
        const J = ge;
        J.redirectedFrom = he;
        let ae;
        return !xt && QB(r, Ee, ge) && (ae = Ql(16, {
            to: J,
            from: Ee
        }),
            ee(Ee, Ee, !0, !1)),
            (ae ? Promise.resolve(ae) : E(J, Ee)).catch(X => ws(X) ? ws(X, 2) ? X : Te(X) : K(X, J, Ee)).then(X => {
                if (X) {
                    if (ws(X, 2))
                        return T(Lt({
                            replace: D
                        }, A(X.to), {
                            state: typeof X.to == "object" ? Lt({}, st, X.to.state) : st,
                            force: xt
                        }), he || J)
                } else
                    X = j(J, Ee, !0, D, st);
                return N(J, Ee, X),
                    X
            }
            )
    }
    function O(Y, he) {
        const ge = C(Y, he);
        return ge ? Promise.reject(ge) : Promise.resolve()
    }
    function M(Y) {
        const he = Ke.values().next().value;
        return he && typeof he.runWithContext == "function" ? he.runWithContext(Y) : Y()
    }
    function E(Y, he) {
        let ge;
        const [Ee, st, xt] = j$(Y, he);
        ge = b0(Ee.reverse(), "beforeRouteLeave", Y, he);
        for (const B of Ee)
            B.leaveGuards.forEach(J => {
                ge.push(ao(J, Y, he))
            }
            );
        const D = O.bind(null, Y, he);
        return ge.push(D),
            Qe(ge).then(() => {
                ge = [];
                for (const B of s.list())
                    ge.push(ao(B, Y, he));
                return ge.push(D),
                    Qe(ge)
            }
            ).then(() => {
                ge = b0(st, "beforeRouteUpdate", Y, he);
                for (const B of st)
                    B.updateGuards.forEach(J => {
                        ge.push(ao(J, Y, he))
                    }
                    );
                return ge.push(D),
                    Qe(ge)
            }
            ).then(() => {
                ge = [];
                for (const B of xt)
                    if (B.beforeEnter)
                        if (Ai(B.beforeEnter))
                            for (const J of B.beforeEnter)
                                ge.push(ao(J, Y, he));
                        else
                            ge.push(ao(B.beforeEnter, Y, he));
                return ge.push(D),
                    Qe(ge)
            }
            ).then(() => (Y.matched.forEach(B => B.enterCallbacks = {}),
                ge = b0(xt, "beforeRouteEnter", Y, he, M),
                ge.push(D),
                Qe(ge))).then(() => {
                    ge = [];
                    for (const B of o.list())
                        ge.push(ao(B, Y, he));
                    return ge.push(D),
                        Qe(ge)
                }
                ).catch(B => ws(B, 8) ? B : Promise.reject(B))
    }
    function N(Y, he, ge) {
        a.list().forEach(Ee => M(() => Ee(Y, he, ge)))
    }
    function j(Y, he, ge, Ee, st) {
        const xt = C(Y, he);
        if (xt)
            return xt;
        const D = he === Xs
            , B = xl ? history.state : {};
        ge && (Ee || D ? i.replace(Y.fullPath, Lt({
            scroll: D && B && B.scroll
        }, st)) : i.push(Y.fullPath, st)),
            l.value = Y,
            ee(Y, he, ge, D),
            Te()
    }
    let z;
    function V() {
        z || (z = i.listen((Y, he, ge) => {
            if (!Ye.listening)
                return;
            const Ee = k(Y)
                , st = w(Ee);
            if (st) {
                T(Lt(st, {
                    replace: !0
                }), Ee).catch(cc);
                return
            }
            c = Ee;
            const xt = l.value;
            xl && a$(r_(xt.fullPath, ge.delta), pm()),
                E(Ee, xt).catch(D => ws(D, 12) ? D : ws(D, 2) ? (T(D.to, Ee).then(B => {
                    ws(B, 20) && !ge.delta && ge.type === Ic.pop && i.go(-1, !1)
                }
                ).catch(cc),
                    Promise.reject()) : (ge.delta && i.go(-ge.delta, !1),
                        K(D, Ee, xt))).then(D => {
                            D = D || j(Ee, xt, !1),
                                D && (ge.delta && !ws(D, 8) ? i.go(-ge.delta, !1) : ge.type === Ic.pop && ws(D, 20) && i.go(-1, !1)),
                                N(Ee, xt, D)
                        }
                        ).catch(cc)
        }
        ))
    }
    let W = Fu(), P = Fu(), F;
    function K(Y, he, ge) {
        Te(Y);
        const Ee = P.list();
        return Ee.length ? Ee.forEach(st => st(Y, he, ge)) : console.error(Y),
            Promise.reject(Y)
    }
    function re() {
        return F && l.value !== Xs ? Promise.resolve() : new Promise((Y, he) => {
            W.add([Y, he])
        }
        )
    }
    function Te(Y) {
        return F || (F = !Y,
            V(),
            W.list().forEach(([he, ge]) => Y ? ge(Y) : he()),
            W.reset()),
            Y
    }
    function ee(Y, he, ge, Ee) {
        const { scrollBehavior: st } = t;
        if (!xl || !st)
            return Promise.resolve();
        const xt = !ge && l$(r_(Y.fullPath, 0)) || (Ee || !ge) && history.state && history.state.scroll || null;
        return un().then(() => st(Y, he, xt)).then(D => D && o$(D)).catch(D => K(D, Y, he))
    }
    const Se = Y => i.go(Y);
    let Ze;
    const Ke = new Set
        , Ye = {
            currentRoute: l,
            listening: !0,
            addRoute: g,
            removeRoute: y,
            clearRoutes: e.clearRoutes,
            hasRoute: S,
            getRoutes: x,
            resolve: k,
            options: t,
            push: m,
            replace: b,
            go: Se,
            back: () => Se(-1),
            forward: () => Se(1),
            beforeEach: s.add,
            beforeResolve: o.add,
            afterEach: a.add,
            onError: P.add,
            isReady: re,
            install(Y) {
                const he = this;
                Y.component("RouterLink", R$),
                    Y.component("RouterView", L$),
                    Y.config.globalProperties.$router = he,
                    Object.defineProperty(Y.config.globalProperties, "$route", {
                        enumerable: !0,
                        get: () => ie(l)
                    }),
                    xl && !Ze && l.value === Xs && (Ze = !0,
                        m(i.location).catch(st => { }
                        ));
                const ge = {};
                for (const st in Xs)
                    Object.defineProperty(ge, st, {
                        get: () => l.value[st],
                        enumerable: !0
                    });
                Y.provide(mm, he),
                    Y.provide(mv, GS(ge)),
                    Y.provide(M1, l);
                const Ee = Y.unmount;
                Ke.add(Y),
                    Y.unmount = function () {
                        Ke.delete(Y),
                            Ke.size < 1 && (c = Xs,
                                z && z(),
                                z = null,
                                l.value = Xs,
                                Ze = !1,
                                F = !1),
                            Ee()
                    }
            }
        };
    function Qe(Y) {
        return Y.reduce((he, ge) => he.then(() => M(ge)), Promise.resolve())
    }
    return Ye
}
function j$(t, e) {
    const n = []
        , r = []
        , i = []
        , s = Math.max(e.matched.length, t.matched.length);
    for (let o = 0; o < s; o++) {
        const a = e.matched[o];
        a && (t.matched.find(c => Xl(c, a)) ? r.push(a) : n.push(a));
        const l = t.matched[o];
        l && (e.matched.find(c => Xl(c, l)) || i.push(l))
    }
    return [n, r, i]
}
function B$() {
    return Dt(mm)
}
function XQ(t) {
    return Dt(mv)
}
const $$ = ["disabled", "ariaLabel"]
    , gv = je({
        __name: "Button",
        props: {
            theme: {
                default: "gray"
            },
            size: {
                default: "sm"
            },
            variant: {
                default: "subtle"
            },
            label: {},
            icon: {},
            iconLeft: {},
            iconRight: {},
            loading: {
                type: Boolean,
                default: !1
            },
            loadingText: {},
            disabled: {
                type: Boolean,
                default: !1
            },
            route: {},
            link: {}
        },
        setup(t) {
            const e = t
                , n = om()
                , r = B$()
                , i = G(() => {
                    let d = {
                        gray: "text-white bg-gray-900 hover:bg-gray-800 active:bg-gray-700",
                        blue: "text-white bg-blue-500 hover:bg-blue-600 active:bg-blue-700",
                        green: "text-white bg-green-600 hover:bg-green-700 active:bg-green-800",
                        red: "text-white bg-red-600 hover:bg-red-700 active:bg-red-800"
                    }[e.theme]
                        , h = {
                            gray: "text-gray-800 bg-gray-100 hover:bg-gray-200 active:bg-gray-300",
                            blue: "text-blue-600 bg-blue-100 hover:bg-blue-200 active:bg-blue-300",
                            green: "text-green-800 bg-green-100 hover:bg-green-200 active:bg-green-300",
                            red: "text-red-700 bg-red-100 hover:bg-red-200 active:bg-red-300"
                        }[e.theme]
                        , p = {
                            gray: "text-gray-800 bg-white border border-gray-300 hover:border-gray-400 active:border-gray-400 active:bg-gray-300",
                            blue: "text-blue-600 bg-white border border-blue-300 hover:border-blue-400 active:border-blue-400 active:bg-blue-300",
                            green: "text-green-800 bg-white border border-green-400 hover:border-green-500 active:border-green-500 active:bg-green-300",
                            red: "text-red-700 bg-white border border-red-300 hover:border-red-400 active:border-red-400 active:bg-red-200"
                        }[e.theme]
                        , g = {
                            gray: "text-gray-800 bg-transparent hover:bg-gray-200 active:bg-gray-300",
                            blue: "text-blue-600 bg-transparent hover:bg-blue-200 active:bg-blue-300",
                            green: "text-green-800 bg-transparent hover:bg-green-200 active:bg-green-300",
                            red: "text-red-700 bg-transparent hover:bg-red-200 active:bg-red-300"
                        }[e.theme]
                        , y = {
                            gray: "focus-visible:ring focus-visible:ring-gray-400",
                            blue: "focus-visible:ring focus-visible:ring-blue-400",
                            green: "focus-visible:ring focus-visible:ring-green-400",
                            red: "focus-visible:ring focus-visible:ring-red-400"
                        }[e.theme]
                        , x = {
                            subtle: h,
                            solid: d,
                            outline: p,
                            ghost: g
                        }[e.variant]
                        , S = `${e.theme}-${e.variant}`
                        , k = {
                            gray: "bg-gray-100 text-gray-500",
                            "gray-outline": "bg-gray-100 text-gray-500 border border-gray-300",
                            "gray-ghost": "text-gray-500",
                            "blue-solid": "bg-blue-300 text-white",
                            "blue-subtle": "bg-blue-100 text-blue-400",
                            "blue-outline": "bg-blue-100 text-blue-400 border border-blue-300",
                            "blue-ghost": "text-blue-400",
                            green: "bg-green-100 text-green-500",
                            "green-outline": "bg-green-100 text-green-500 border border-green-400",
                            "green-ghost": "text-green-500",
                            red: "bg-red-100 text-red-400",
                            "red-outline": "bg-red-100 text-red-400 border border-red-300",
                            "red-ghost": "text-red-400"
                        }
                        , A = k[S] || k[e.theme]
                        , C = {
                            sm: "h-7 text-base px-2 rounded",
                            md: "h-8 text-base font-medium px-2.5 rounded",
                            lg: "h-10 text-lg font-medium px-3 rounded-md",
                            xl: "h-11.5 text-xl font-medium px-3.5 rounded-lg",
                            "2xl": "h-13 text-2xl font-medium px-3.5 rounded-xl"
                        }[e.size];
                    return l.value && (C = {
                        sm: "h-7 w-7 rounded",
                        md: "h-8 w-8 rounded",
                        lg: "h-10 w-10 rounded-md",
                        xl: "h-11.5 w-11.5 rounded-lg",
                        "2xl": "h-13 w-13 rounded-xl"
                    }[e.size]),
                        ["inline-flex items-center justify-center gap-2 transition-colors focus:outline-none", o.value ? A : x, y, C]
                }
                )
                , s = G(() => ({
                    sm: "h-4",
                    md: "h-4.5",
                    lg: "h-5",
                    xl: "h-6",
                    "2xl": "h-6"
                })[e.size])
                , o = G(() => e.disabled || e.loading)
                , a = G(() => l.value ? e.label : null)
                , l = G(() => e.icon || n.icon)
                , c = () => {
                    if (e.route)
                        return r.push(e.route);
                    if (e.link)
                        return window.open(e.link, "_blank")
                }
                ;
            return (d, h) => (oe(),
                Ae("button", Wt(d.$attrs, {
                    class: i.value,
                    onClick: c,
                    disabled: o.value,
                    ariaLabel: a.value
                }), [d.loading ? (oe(),
                    gt(LB, {
                        key: 0,
                        class: mt({
                            "h-3 w-3": d.size == "sm",
                            "h-[13.5px] w-[13.5px]": d.size == "md",
                            "h-[15px] w-[15px]": d.size == "lg",
                            "h-4.5 w-4.5": d.size == "xl" || d.size == "2xl"
                        })
                    }, null, 8, ["class"])) : d.$slots.prefix || d.iconLeft ? Ue(d.$slots, "prefix", {
                        key: 1
                    }, () => [d.iconLeft ? (oe(),
                        gt(ko, {
                            key: 0,
                            name: d.iconLeft,
                            class: mt(s.value),
                            "aria-hidden": "true"
                        }, null, 8, ["name", "class"])) : pt("", !0)]) : pt("", !0), d.loading && d.loadingText ? (oe(),
                            Ae(Rt, {
                                key: 2
                            }, [Pa(Vt(d.loadingText), 1)], 64)) : l.value && !d.loading ? (oe(),
                                Ae(Rt, {
                                    key: 3
                                }, [d.icon ? (oe(),
                                    gt(ko, {
                                        key: 0,
                                        name: d.icon,
                                        class: mt(s.value),
                                        "aria-label": d.label
                                    }, null, 8, ["name", "class", "aria-label"])) : d.$slots.icon ? Ue(d.$slots, "icon", {
                                        key: 1
                                    }) : pt("", !0)], 64)) : (oe(),
                                        Ae("span", {
                                            key: 4,
                                            class: mt({
                                                "sr-only": l.value
                                            })
                                        }, [Ue(d.$slots, "default", {}, () => [Pa(Vt(d.label), 1)])], 2)), Ue(d.$slots, "suffix", {}, () => [d.iconRight ? (oe(),
                                            gt(ko, {
                                                key: 0,
                                                name: d.iconRight,
                                                class: mt(s.value),
                                                "aria-hidden": "true"
                                            }, null, 8, ["name", "class"])) : pt("", !0)])], 16, $$))
        }
    })
    , z$ = {
        name: "Autocomplete",
        props: ["modelValue", "options", "placeholder", "bodyClasses", "multiple", "hideSearch"],
        emits: ["update:modelValue", "update:query", "change"],
        components: {
            Popover: MB,
            Button: gv,
            FeatherIcon: ko,
            Combobox: LD,
            ComboboxInput: jD,
            ComboboxOptions: BD,
            ComboboxOption: $D,
            ComboboxButton: DD
        },
        expose: ["togglePopover"],
        data() {
            return {
                query: "",
                showOptions: !1
            }
        },
        computed: {
            selectedValue: {
                get() {
                    return this.multiple ? Hu(this.modelValue?.[0]) === "value" ? this.modelValue?.map(t => this.findOption(t)) : this.modelValue : this.findOption(this.modelValue)
                },
                set(t) {
                    if (this.query = "",
                        t && !this.multiple && (this.showOptions = !1),
                        !this.multiple) {
                        this.$emit("update:modelValue", t);
                        return
                    }
                    this.$emit("update:modelValue", t)
                }
            },
            groups() {
                return !this.options || this.options.length == 0 ? [] : (this.options[0]?.group ? this.options : [{
                    group: "",
                    items: this.sanitizeOptions(this.options)
                }]).map((e, n) => ({
                    key: n,
                    group: e.group,
                    hideLabel: e.hideLabel || !1,
                    items: this.filterOptions(this.sanitizeOptions(e.items))
                })).filter(e => e.items.length > 0)
            },
            allOptions() {
                return this.groups.flatMap(t => t.items)
            },
            areAllOptionsSelected() {
                return this.multiple ? this.allOptions.length === this.selectedValue?.length : !1
            }
        },
        watch: {
            query(t) {
                this.$emit("update:query", t)
            },
            showOptions(t) {
                t && un(() => this.$refs.searchInput?.$el?.focus())
            }
        },
        methods: {
            togglePopover(t) {
                this.showOptions = t ?? !this.showOptions
            },
            findOption(t) {
                if (!t)
                    return t;
                const e = Hu(t) === "value" ? t : t.value;
                return this.allOptions.find(n => n.value === e)
            },
            filterOptions(t) {
                return this.query ? t.filter(e => e.label.toLowerCase().includes(this.query.trim().toLowerCase()) || e.value.toLowerCase().includes(this.query.trim().toLowerCase())) : t
            },
            displayValue(t) {
                return t ? this.multiple ? Array.isArray(t) ? t.map(e => this.getLabel(this.findOption(e))).join(", ") : "" : this.getLabel(this.findOption(t)) : ""
            },
            getLabel(t) {
                return Hu(t) === "value" ? t : t?.label || t?.value || "No label"
            },
            sanitizeOptions(t) {
                return t ? t.map(e => Hu(e) === "option" ? e : {
                    label: e,
                    value: e
                }) : []
            },
            isOptionSelected(t) {
                if (!this.selectedValue)
                    return !1;
                const e = Hu(t) === "value" ? t : t.value;
                return this.multiple ? this.selectedValue?.find(n => n && n.value === e) : this.selectedValue?.value === e
            },
            selectAll() {
                this.selectedValue = this.allOptions
            },
            clearAll() {
                this.selectedValue = []
            }
        }
    };
function Hu(t) {
    return typeof t == "object" ? "option" : "value"
}
const F$ = {
    class: "w-full"
}
    , H$ = ["onClick"]
    , V$ = {
        class: "flex items-center overflow-hidden"
    }
    , W$ = {
        key: 0,
        class: "truncate text-base leading-5"
    }
    , U$ = {
        key: 1,
        class: "text-base leading-5 text-gray-500"
    }
    , K$ = {
        key: 0,
        class: "sticky top-0 z-10 flex items-stretch space-x-1.5 bg-white py-1.5"
    }
    , q$ = {
        class: "relative w-full"
    }
    , G$ = {
        key: 0,
        class: "sticky top-10 truncate bg-white px-2.5 py-1.5 text-sm font-medium text-gray-600"
    }
    , J$ = {
        class: "flex flex-1 gap-2 overflow-hidden"
    }
    , Z$ = {
        key: 0,
        class: "flex-shrink-0"
    }
    , Y$ = {
        key: 1,
        class: "h-4 w-4"
    }
    , X$ = {
        class: "flex-1 truncate"
    }
    , Q$ = {
        key: 0,
        class: "ml-2 flex-shrink-0"
    }
    , e9 = {
        key: 0,
        class: "text-sm text-gray-600"
    }
    , t9 = {
        key: 1,
        class: "rounded-md px-2.5 py-1.5 text-base text-gray-600"
    }
    , n9 = {
        key: 0,
        class: "border-t p-1"
    }
    , r9 = {
        key: 0,
        class: "flex items-center justify-end"
    };
function i9(t, e, n, r, i, s) {
    const o = Cn("FeatherIcon")
        , a = Cn("ComboboxInput")
        , l = Cn("ComboboxOption")
        , c = Cn("ComboboxOptions")
        , d = Cn("Button")
        , h = Cn("Popover")
        , p = Cn("Combobox");
    return oe(),
        gt(p, {
            modelValue: s.selectedValue,
            "onUpdate:modelValue": e[3] || (e[3] = g => s.selectedValue = g),
            multiple: n.multiple,
            nullable: ""
        }, {
            default: tt(({ open: g }) => [$e(h, {
                class: "w-full",
                show: i.showOptions,
                "onUpdate:show": e[2] || (e[2] = y => i.showOptions = y)
            }, {
                target: tt(({ open: y, togglePopover: x }) => [Ue(t.$slots, "target", xi(_i({
                    open: y,
                    togglePopover: x
                })), () => [Xe("div", F$, [Xe("button", {
                    class: mt(["flex h-7 w-full items-center justify-between gap-2 rounded bg-gray-100 px-2 py-1 transition-colors hover:bg-gray-200 focus:ring-2 focus:ring-gray-400", {
                        "bg-gray-200": g
                    }]),
                    onClick: () => x()
                }, [Xe("div", V$, [Ue(t.$slots, "prefix"), s.selectedValue ? (oe(),
                    Ae("span", W$, Vt(s.displayValue(s.selectedValue)), 1)) : (oe(),
                        Ae("span", U$, Vt(n.placeholder || ""), 1))]), $e(o, {
                            name: "chevron-down",
                            class: "h-4 w-4 text-gray-600",
                            "aria-hidden": "true"
                        })], 10, H$)])])]),
                body: tt(({ isOpen: y, togglePopover: x }) => [Rh(Xe("div", null, [Xe("div", {
                    class: mt(["relative mt-1 rounded-lg bg-white text-base shadow-2xl", n.bodyClasses])
                }, [$e(c, {
                    class: mt(["max-h-[15rem] overflow-y-auto px-1.5 pb-1.5", {
                        "pt-1.5": n.hideSearch
                    }]),
                    static: ""
                }, {
                    default: tt(() => [n.hideSearch ? pt("", !0) : (oe(),
                        Ae("div", K$, [Xe("div", q$, [$e(a, {
                            ref: "searchInput",
                            class: "form-input w-full",
                            type: "text",
                            onChange: e[0] || (e[0] = S => {
                                i.query = S.target.value
                            }
                            ),
                            value: i.query,
                            autocomplete: "off",
                            placeholder: "Search"
                        }, null, 8, ["value"]), Xe("button", {
                            class: "absolute right-0 inline-flex h-7 w-7 items-center justify-center",
                            onClick: e[1] || (e[1] = S => s.selectedValue = null)
                        }, [$e(o, {
                            name: "x",
                            class: "w-4"
                        })])])])), (oe(!0),
                            Ae(Rt, null, Oa(s.groups, S => Rh((oe(),
                                Ae("div", {
                                    key: S.key
                                }, [S.group && !S.hideLabel ? (oe(),
                                    Ae("div", G$, Vt(S.group), 1)) : pt("", !0), (oe(!0),
                                        Ae(Rt, null, Oa(S.items.slice(0, 50), (k, A) => (oe(),
                                            gt(l, {
                                                as: "template",
                                                key: k?.value || A,
                                                value: k
                                            }, {
                                                default: tt(({ active: C, selected: m }) => [Xe("li", {
                                                    class: mt(["flex cursor-pointer items-center justify-between rounded px-2.5 py-1.5 text-base", {
                                                        "bg-gray-100": C
                                                    }])
                                                }, [Xe("div", J$, [t.$slots["item-prefix"] || t.$props.multiple ? (oe(),
                                                    Ae("div", Z$, [Ue(t.$slots, "item-prefix", Wt({
                                                        ref_for: !0
                                                    }, {
                                                        active: C,
                                                        selected: m,
                                                        option: k
                                                    }), () => [s.isOptionSelected(k) ? (oe(),
                                                        gt(o, {
                                                            key: 0,
                                                            name: "check",
                                                            class: "h-4 w-4 text-gray-700"
                                                        })) : (oe(),
                                                            Ae("div", Y$))])])) : pt("", !0), Xe("span", X$, Vt(s.getLabel(k)), 1)]), t.$slots["item-suffix"] || k?.description ? (oe(),
                                                                Ae("div", Q$, [Ue(t.$slots, "item-suffix", Wt({
                                                                    ref_for: !0
                                                                }, {
                                                                    active: C,
                                                                    selected: m,
                                                                    option: k
                                                                }), () => [k?.description ? (oe(),
                                                                    Ae("div", e9, Vt(k.description), 1)) : pt("", !0)])])) : pt("", !0)], 2)]),
                                                _: 2
                                            }, 1032, ["value"]))), 128))])), [[Oc, S.items.length > 0]])), 128)), s.groups.length == 0 ? (oe(),
                                                Ae("li", t9, " No results found ")) : pt("", !0)]),
                    _: 3
                }, 8, ["class"]), t.$slots.footer || n.multiple ? (oe(),
                    Ae("div", n9, [Ue(t.$slots, "footer", xi(_i({
                        togglePopover: x
                    })), () => [n.multiple ? (oe(),
                        Ae("div", r9, [s.areAllOptionsSelected ? pt("", !0) : (oe(),
                            gt(d, {
                                key: 0,
                                label: "Select All",
                                onClick: m1(s.selectAll, ["stop"])
                            }, null, 8, ["onClick"])), s.areAllOptionsSelected ? (oe(),
                                gt(d, {
                                    key: 1,
                                    label: "Clear All",
                                    onClick: m1(s.clearAll, ["stop"])
                                }, null, 8, ["onClick"])) : pt("", !0)])) : pt("", !0)])])) : pt("", !0)], 2)], 512), [[Oc, y]])]),
                _: 2
            }, 1032, ["show"])]),
            _: 3
        }, 8, ["modelValue", "multiple"])
}
const s9 = Ua(z$, [["render", i9]])
    , mE = je({
        __name: "Badge",
        props: {
            theme: {
                default: "gray"
            },
            size: {
                default: "md"
            },
            variant: {
                default: "subtle"
            },
            label: {}
        },
        setup(t) {
            const e = t
                , n = G(() => {
                    let r = {
                        gray: "text-white bg-gray-900",
                        blue: "text-white bg-blue-500",
                        green: "text-white bg-green-600",
                        orange: "text-white bg-amber-600",
                        red: "text-white bg-red-600"
                    }[e.theme]
                        , i = {
                            gray: "text-gray-700 bg-gray-100",
                            blue: "text-blue-600 bg-blue-100",
                            green: "text-green-800 bg-green-200",
                            orange: "text-amber-700 bg-amber-100",
                            red: "text-red-600 bg-red-100"
                        }[e.theme]
                        , s = {
                            gray: "text-gray-700 bg-white border border-gray-300",
                            blue: "text-blue-600 bg-white border border-blue-300",
                            green: "text-green-800 bg-white border border-green-300",
                            orange: "text-amber-700 bg-white border border-amber-300",
                            red: "text-red-600 bg-white border border-red-300"
                        }[e.theme]
                        , o = {
                            gray: "text-gray-700 bg-transparent",
                            blue: "text-blue-600 bg-transparent",
                            green: "text-green-800 bg-transparent",
                            orange: "text-amber-700 bg-transparent",
                            red: "text-red-600 bg-transparent"
                        }[e.theme]
                        , a = {
                            subtle: i,
                            solid: r,
                            outline: s,
                            ghost: o
                        }[e.variant]
                        , l = {
                            sm: "h-4 text-xs px-1.5",
                            md: "h-5 text-xs px-1.5",
                            lg: "h-6 text-sm px-2"
                        }[e.size];
                    return [a, l]
                }
                );
            return (r, i) => (oe(),
                Ae("div", {
                    class: mt(["inline-flex select-none items-center gap-1 rounded-full", n.value])
                }, [r.$slots.prefix ? (oe(),
                    Ae("div", {
                        key: 0,
                        class: mt([e.size == "lg" ? "max-h-6" : "max-h-4"])
                    }, [Ue(r.$slots, "prefix")], 2)) : pt("", !0), Ue(r.$slots, "default", {}, () => [Pa(Vt(e.label?.toString()), 1)]), r.$slots.suffix ? (oe(),
                        Ae("div", {
                            key: 1,
                            class: mt([e.size == "lg" ? "max-h-6" : "max-h-4"])
                        }, [Ue(r.$slots, "suffix")], 2)) : pt("", !0)], 2))
        }
    });
function eu(t) {
    return ud() ? (cd(t),
        !0) : !1
}
function Ar(t) {
    return typeof t == "function" ? t() : ie(t)
}
const Vh = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const o9 = t => t != null
    , a9 = Object.prototype.toString
    , l9 = t => a9.call(t) === "[object Object]"
    , qi = () => { }
    , u9 = c9();
function c9() {
    var t, e;
    return Vh && ((t = window?.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window?.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent))
}
function gE(t, e) {
    function n(...r) {
        return new Promise((i, s) => {
            Promise.resolve(t(() => e.apply(this, r), {
                fn: e,
                thisArg: this,
                args: r
            })).then(i).catch(s)
        }
        )
    }
    return n
}
const yE = t => t();
function vE(t, e = {}) {
    let n, r, i = qi;
    const s = a => {
        clearTimeout(a),
            i(),
            i = qi
    }
        ;
    return a => {
        const l = Ar(t)
            , c = Ar(e.maxWait);
        return n && s(n),
            l <= 0 || c !== void 0 && c <= 0 ? (r && (s(r),
                r = null),
                Promise.resolve(a())) : new Promise((d, h) => {
                    i = e.rejectOnCancel ? h : d,
                        c && !r && (r = setTimeout(() => {
                            n && s(n),
                                r = null,
                                d(a())
                        }
                            , c)),
                        n = setTimeout(() => {
                            r && s(r),
                                r = null,
                                d(a())
                        }
                            , l)
                }
                )
    }
}
function d9(t = yE) {
    const e = ce(!0);
    function n() {
        e.value = !1
    }
    function r() {
        e.value = !0
    }
    const i = (...s) => {
        e.value && t(...s)
    }
        ;
    return {
        isActive: du(e),
        pause: n,
        resume: r,
        eventFilter: i
    }
}
function f9(t) {
    return t || pn()
}
function QQ(t, e = 200, n = {}) {
    return gE(vE(e, n), t)
}
function bE(t, e, n = {}) {
    const { eventFilter: r = yE, ...i } = n;
    return vt(t, gE(r, e), i)
}
function h9(t, e, n = {}) {
    const { eventFilter: r, ...i } = n
        , { eventFilter: s, pause: o, resume: a, isActive: l } = d9(r);
    return {
        stop: bE(t, e, {
            ...i,
            eventFilter: s
        }),
        pause: o,
        resume: a,
        isActive: l
    }
}
function wE(t, e = !0, n) {
    f9() ? Nt(t, n) : e ? t() : un(t)
}
const p9 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[T\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/i
    , m9 = /[YMDHhms]o|\[([^\]]+)\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
function g9(t, e, n, r) {
    let i = t < 12 ? "AM" : "PM";
    return r && (i = i.split("").reduce((s, o) => s += `${o}.`, "")),
        n ? i.toLowerCase() : i
}
function la(t) {
    const e = ["th", "st", "nd", "rd"]
        , n = t % 100;
    return t + (e[(n - 20) % 10] || e[n] || e[0])
}
function y9(t, e, n = {}) {
    var r;
    const i = t.getFullYear()
        , s = t.getMonth()
        , o = t.getDate()
        , a = t.getHours()
        , l = t.getMinutes()
        , c = t.getSeconds()
        , d = t.getMilliseconds()
        , h = t.getDay()
        , p = (r = n.customMeridiem) != null ? r : g9
        , g = {
            Yo: () => la(i),
            YY: () => String(i).slice(-2),
            YYYY: () => i,
            M: () => s + 1,
            Mo: () => la(s + 1),
            MM: () => `${s + 1}`.padStart(2, "0"),
            MMM: () => t.toLocaleDateString(n.locales, {
                month: "short"
            }),
            MMMM: () => t.toLocaleDateString(n.locales, {
                month: "long"
            }),
            D: () => String(o),
            Do: () => la(o),
            DD: () => `${o}`.padStart(2, "0"),
            H: () => String(a),
            Ho: () => la(a),
            HH: () => `${a}`.padStart(2, "0"),
            h: () => `${a % 12 || 12}`.padStart(1, "0"),
            ho: () => la(a % 12 || 12),
            hh: () => `${a % 12 || 12}`.padStart(2, "0"),
            m: () => String(l),
            mo: () => la(l),
            mm: () => `${l}`.padStart(2, "0"),
            s: () => String(c),
            so: () => la(c),
            ss: () => `${c}`.padStart(2, "0"),
            SSS: () => `${d}`.padStart(3, "0"),
            d: () => h,
            dd: () => t.toLocaleDateString(n.locales, {
                weekday: "narrow"
            }),
            ddd: () => t.toLocaleDateString(n.locales, {
                weekday: "short"
            }),
            dddd: () => t.toLocaleDateString(n.locales, {
                weekday: "long"
            }),
            A: () => p(a, l),
            AA: () => p(a, l, !1, !0),
            a: () => p(a, l, !0),
            aa: () => p(a, l, !0, !0)
        };
    return e.replace(m9, (y, x) => {
        var S, k;
        return (k = x ?? ((S = g[y]) == null ? void 0 : S.call(g))) != null ? k : y
    }
    )
}
function v9(t) {
    if (t === null)
        return new Date(Number.NaN);
    if (t === void 0)
        return new Date;
    if (t instanceof Date)
        return new Date(t);
    if (typeof t == "string" && !/Z$/i.test(t)) {
        const e = t.match(p9);
        if (e) {
            const n = e[2] - 1 || 0
                , r = (e[7] || "0").substring(0, 3);
            return new Date(e[1], n, e[3] || 1, e[4] || 0, e[5] || 0, e[6] || 0, r)
        }
    }
    return new Date(t)
}
function b9(t, e = "HH:mm:ss", n = {}) {
    return G(() => y9(v9(Ar(t)), Ar(e), n))
}
function w9(t, e = 1e3, n = {}) {
    const { immediate: r = !0, immediateCallback: i = !1 } = n;
    let s = null;
    const o = ce(!1);
    function a() {
        s && (clearInterval(s),
            s = null)
    }
    function l() {
        o.value = !1,
            a()
    }
    function c() {
        const d = Ar(e);
        d <= 0 || (o.value = !0,
            i && t(),
            a(),
            s = setInterval(t, d))
    }
    if (r && Vh && c(),
        Yt(e) || typeof e == "function") {
        const d = vt(e, () => {
            o.value && Vh && c()
        }
        );
        eu(d)
    }
    return eu(l),
    {
        isActive: o,
        pause: l,
        resume: c
    }
}
function eee(t, e, n = {}) {
    const { debounce: r = 0, maxWait: i = void 0, ...s } = n;
    return bE(t, e, {
        ...s,
        eventFilter: vE(r, {
            maxWait: i
        })
    })
}
function vo(t) {
    var e;
    const n = Ar(t);
    return (e = n?.$el) != null ? e : n
}
const Xi = Vh ? window : void 0;
function Vi(...t) {
    let e, n, r, i;
    if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, r, i] = t,
        e = Xi) : [e, n, r, i] = t,
        !e)
        return qi;
    Array.isArray(n) || (n = [n]),
        Array.isArray(r) || (r = [r]);
    const s = []
        , o = () => {
            s.forEach(d => d()),
                s.length = 0
        }
        , a = (d, h, p, g) => (d.addEventListener(h, p, g),
            () => d.removeEventListener(h, p, g))
        , l = vt(() => [vo(e), Ar(i)], ([d, h]) => {
            if (o(),
                !d)
                return;
            const p = l9(h) ? {
                ...h
            } : h;
            s.push(...n.flatMap(g => r.map(y => a(d, g, y, p))))
        }
            , {
                immediate: !0,
                flush: "post"
            })
        , c = () => {
            l(),
                o()
        }
        ;
    return eu(c),
        c
}
let v_ = !1;
function tee(t, e, n = {}) {
    const { window: r = Xi, ignore: i = [], capture: s = !0, detectIframe: o = !1 } = n;
    if (!r)
        return qi;
    u9 && !v_ && (v_ = !0,
        Array.from(r.document.body.children).forEach(p => p.addEventListener("click", qi)),
        r.document.documentElement.addEventListener("click", qi));
    let a = !0;
    const l = p => i.some(g => {
        if (typeof g == "string")
            return Array.from(r.document.querySelectorAll(g)).some(y => y === p.target || p.composedPath().includes(y));
        {
            const y = vo(g);
            return y && (p.target === y || p.composedPath().includes(y))
        }
    }
    )
        , d = [Vi(r, "click", p => {
            const g = vo(t);
            if (!(!g || g === p.target || p.composedPath().includes(g))) {
                if (p.detail === 0 && (a = !l(p)),
                    !a) {
                    a = !0;
                    return
                }
                e(p)
            }
        }
            , {
                passive: !0,
                capture: s
            }), Vi(r, "pointerdown", p => {
                const g = vo(t);
                a = !l(p) && !!(g && !p.composedPath().includes(g))
            }
                , {
                    passive: !0
                }), o && Vi(r, "blur", p => {
                    setTimeout(() => {
                        var g;
                        const y = vo(t);
                        ((g = r.document.activeElement) == null ? void 0 : g.tagName) === "IFRAME" && !y?.contains(r.document.activeElement) && e(p)
                    }
                        , 0)
                }
                )].filter(Boolean);
    return () => d.forEach(p => p())
}
function x9() {
    const t = ce(!1)
        , e = pn();
    return e && Nt(() => {
        t.value = !0
    }
        , e),
        t
}
function xE(t) {
    const e = x9();
    return G(() => (e.value,
        !!t()))
}
function _9(t, e = {}) {
    const { immediate: n = !0, fpsLimit: r = void 0, window: i = Xi } = e
        , s = ce(!1)
        , o = r ? 1e3 / r : null;
    let a = 0
        , l = null;
    function c(p) {
        if (!s.value || !i)
            return;
        a || (a = p);
        const g = p - a;
        if (o && g < o) {
            l = i.requestAnimationFrame(c);
            return
        }
        a = p,
            t({
                delta: g,
                timestamp: p
            }),
            l = i.requestAnimationFrame(c)
    }
    function d() {
        !s.value && i && (s.value = !0,
            a = 0,
            l = i.requestAnimationFrame(c))
    }
    function h() {
        s.value = !1,
            l != null && i && (i.cancelAnimationFrame(l),
                l = null)
    }
    return n && d(),
        eu(h),
    {
        isActive: du(s),
        pause: h,
        resume: d
    }
}
function S9(t, e = {}) {
    const { window: n = Xi } = e
        , r = xE(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
    let i;
    const s = ce(!1)
        , o = c => {
            s.value = c.matches
        }
        , a = () => {
            i && ("removeEventListener" in i ? i.removeEventListener("change", o) : i.removeListener(o))
        }
        , l = Ft(() => {
            r.value && (a(),
                i = n.matchMedia(Ar(t)),
                "addEventListener" in i ? i.addEventListener("change", o) : i.addListener(o),
                s.value = i.matches)
        }
        );
    return eu(() => {
        l(),
            a(),
            i = void 0
    }
    ),
        s
}
const jf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
    , Bf = "__vueuse_ssr_handlers__"
    , k9 = C9();
function C9() {
    return Bf in jf || (jf[Bf] = jf[Bf] || {}),
        jf[Bf]
}
function E9(t, e) {
    return k9[t] || e
}
function T9(t) {
    return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number"
}
const A9 = {
    boolean: {
        read: t => t === "true",
        write: t => String(t)
    },
    object: {
        read: t => JSON.parse(t),
        write: t => JSON.stringify(t)
    },
    number: {
        read: t => Number.parseFloat(t),
        write: t => String(t)
    },
    any: {
        read: t => t,
        write: t => String(t)
    },
    string: {
        read: t => t,
        write: t => String(t)
    },
    map: {
        read: t => new Map(JSON.parse(t)),
        write: t => JSON.stringify(Array.from(t.entries()))
    },
    set: {
        read: t => new Set(JSON.parse(t)),
        write: t => JSON.stringify(Array.from(t))
    },
    date: {
        read: t => new Date(t),
        write: t => t.toISOString()
    }
}
    , b_ = "vueuse-storage";
function O9(t, e, n, r = {}) {
    var i;
    const { flush: s = "pre", deep: o = !0, listenToStorageChanges: a = !0, writeDefaults: l = !0, mergeDefaults: c = !1, shallow: d, window: h = Xi, eventFilter: p, onError: g = E => {
        console.error(E)
    }
        , initOnMounted: y } = r
        , x = (d ? Wa : ce)(typeof e == "function" ? e() : e);
    if (!n)
        try {
            n = E9("getDefaultStorage", () => {
                var E;
                return (E = Xi) == null ? void 0 : E.localStorage
            }
            )()
        } catch (E) {
            g(E)
        }
    if (!n)
        return x;
    const S = Ar(e)
        , k = T9(S)
        , A = (i = r.serializer) != null ? i : A9[k]
        , { pause: C, resume: m } = h9(x, () => w(x.value), {
            flush: s,
            deep: o,
            eventFilter: p
        });
    h && a && wE(() => {
        Vi(h, "storage", O),
            Vi(h, b_, M),
            y && O()
    }
    ),
        y || O();
    function b(E, N) {
        h && h.dispatchEvent(new CustomEvent(b_, {
            detail: {
                key: t,
                oldValue: E,
                newValue: N,
                storageArea: n
            }
        }))
    }
    function w(E) {
        try {
            const N = n.getItem(t);
            if (E == null)
                b(N, null),
                    n.removeItem(t);
            else {
                const j = A.write(E);
                N !== j && (n.setItem(t, j),
                    b(N, j))
            }
        } catch (N) {
            g(N)
        }
    }
    function T(E) {
        const N = E ? E.newValue : n.getItem(t);
        if (N == null)
            return l && S != null && n.setItem(t, A.write(S)),
                S;
        if (!E && c) {
            const j = A.read(N);
            return typeof c == "function" ? c(j, S) : k === "object" && !Array.isArray(j) ? {
                ...S,
                ...j
            } : j
        } else
            return typeof N != "string" ? N : A.read(N)
    }
    function O(E) {
        if (!(E && E.storageArea !== n)) {
            if (E && E.key == null) {
                x.value = S;
                return
            }
            if (!(E && E.key !== t)) {
                C();
                try {
                    E?.newValue !== A.write(x.value) && (x.value = T(E))
                } catch (N) {
                    g(N)
                } finally {
                    E ? un(m) : m()
                }
            }
        }
    }
    function M(E) {
        O(E.detail)
    }
    return x
}
function M9(t, e, n = {}) {
    const { root: r, rootMargin: i = "0px", threshold: s = .1, window: o = Xi, immediate: a = !0 } = n
        , l = xE(() => o && "IntersectionObserver" in o)
        , c = G(() => {
            const y = Ar(t);
            return (Array.isArray(y) ? y : [y]).map(vo).filter(o9)
        }
        );
    let d = qi;
    const h = ce(a)
        , p = l.value ? vt(() => [c.value, vo(r), h.value], ([y, x]) => {
            if (d(),
                !h.value || !y.length)
                return;
            const S = new IntersectionObserver(e, {
                root: vo(x),
                rootMargin: i,
                threshold: s
            });
            y.forEach(k => k && S.observe(k)),
                d = () => {
                    S.disconnect(),
                        d = qi
                }
        }
            , {
                immediate: a,
                flush: "post"
            }) : qi
        , g = () => {
            d(),
                p(),
                h.value = !1
        }
        ;
    return eu(g),
    {
        isSupported: l,
        isActive: h,
        pause() {
            d(),
                h.value = !1
        },
        resume() {
            h.value = !0
        },
        stop: g
    }
}
function nee(t, e = {}) {
    const { window: n = Xi, scrollTarget: r, threshold: i = 0 } = e
        , s = ce(!1);
    return M9(t, o => {
        let a = s.value
            , l = 0;
        for (const c of o)
            c.time >= l && (l = c.time,
                a = c.isIntersecting);
        s.value = a
    }
        , {
            root: r,
            window: n,
            threshold: i
        }),
        s
}
const R9 = {
    ctrl: "control",
    command: "meta",
    cmd: "meta",
    option: "alt",
    up: "arrowup",
    down: "arrowdown",
    left: "arrowleft",
    right: "arrowright"
};
function P9(t = {}) {
    const { reactive: e = !1, target: n = Xi, aliasMap: r = R9, passive: i = !0, onEventFired: s = qi } = t
        , o = wn(new Set)
        , a = {
            toJSON() {
                return {}
            },
            current: o
        }
        , l = e ? wn(a) : a
        , c = new Set
        , d = new Set;
    function h(x, S) {
        x in l && (e ? l[x] = S : l[x].value = S)
    }
    function p() {
        o.clear();
        for (const x of d)
            h(x, !1)
    }
    function g(x, S) {
        var k, A;
        const C = (k = x.key) == null ? void 0 : k.toLowerCase()
            , b = [(A = x.code) == null ? void 0 : A.toLowerCase(), C].filter(Boolean);
        C && (S ? o.add(C) : o.delete(C));
        for (const w of b)
            d.add(w),
                h(w, S);
        C === "meta" && !S ? (c.forEach(w => {
            o.delete(w),
                h(w, !1)
        }
        ),
            c.clear()) : typeof x.getModifierState == "function" && x.getModifierState("Meta") && S && [...o, ...b].forEach(w => c.add(w))
    }
    Vi(n, "keydown", x => (g(x, !0),
        s(x)), {
        passive: i
    }),
        Vi(n, "keyup", x => (g(x, !1),
            s(x)), {
            passive: i
        }),
        Vi("blur", p, {
            passive: !0
        }),
        Vi("focus", p, {
            passive: !0
        });
    const y = new Proxy(l, {
        get(x, S, k) {
            if (typeof S != "string")
                return Reflect.get(x, S, k);
            if (S = S.toLowerCase(),
                S in r && (S = r[S]),
                !(S in l))
                if (/[+_-]/.test(S)) {
                    const C = S.split(/[+_-]/g).map(m => m.trim());
                    l[S] = G(() => C.every(m => Ar(y[m])))
                } else
                    l[S] = ce(!1);
            const A = Reflect.get(x, S, k);
            return e ? Ar(A) : A
        }
    });
    return y
}
function N9(t = {}) {
    const { controls: e = !1, interval: n = "requestAnimationFrame" } = t
        , r = ce(new Date)
        , i = () => r.value = new Date
        , s = n === "requestAnimationFrame" ? _9(i, {
            immediate: !0
        }) : w9(i, n, {
            immediate: !0
        });
    return e ? {
        now: r,
        ...s
    } : r
}
const I9 = [{
    max: 6e4,
    value: 1e3,
    name: "second"
}, {
    max: 276e4,
    value: 6e4,
    name: "minute"
}, {
    max: 72e6,
    value: 36e5,
    name: "hour"
}, {
    max: 5184e5,
    value: 864e5,
    name: "day"
}, {
    max: 24192e5,
    value: 6048e5,
    name: "week"
}, {
    max: 28512e6,
    value: 2592e6,
    name: "month"
}, {
    max: Number.POSITIVE_INFINITY,
    value: 31536e6,
    name: "year"
}]
    , L9 = {
        justNow: "just now",
        past: t => t.match(/\d/) ? `${t} ago` : t,
        future: t => t.match(/\d/) ? `in ${t}` : t,
        month: (t, e) => t === 1 ? e ? "last month" : "next month" : `${t} month${t > 1 ? "s" : ""}`,
        year: (t, e) => t === 1 ? e ? "last year" : "next year" : `${t} year${t > 1 ? "s" : ""}`,
        day: (t, e) => t === 1 ? e ? "yesterday" : "tomorrow" : `${t} day${t > 1 ? "s" : ""}`,
        week: (t, e) => t === 1 ? e ? "last week" : "next week" : `${t} week${t > 1 ? "s" : ""}`,
        hour: t => `${t} hour${t > 1 ? "s" : ""}`,
        minute: t => `${t} minute${t > 1 ? "s" : ""}`,
        second: t => `${t} second${t > 1 ? "s" : ""}`,
        invalid: ""
    };
function D9(t) {
    return t.toISOString().slice(0, 10)
}
function j9(t, e = {}) {
    const { controls: n = !1, updateInterval: r = 3e4 } = e
        , { now: i, ...s } = N9({
            interval: r,
            controls: !0
        })
        , o = G(() => B9(new Date(Ar(t)), e, Ar(i)));
    return n ? {
        timeAgo: o,
        ...s
    } : o
}
function B9(t, e = {}, n = Date.now()) {
    var r;
    const { max: i, messages: s = L9, fullDateFormatter: o = D9, units: a = I9, showSecond: l = !1, rounding: c = "round" } = e
        , d = typeof c == "number" ? S => +S.toFixed(c) : Math[c]
        , h = +n - +t
        , p = Math.abs(h);
    function g(S, k) {
        return d(Math.abs(S) / k.value)
    }
    function y(S, k) {
        const A = g(S, k)
            , C = S > 0
            , m = x(k.name, A, C);
        return x(C ? "past" : "future", m, C)
    }
    function x(S, k, A) {
        const C = s[S];
        return typeof C == "function" ? C(k, A) : C.replace("{0}", k.toString())
    }
    if (p < 6e4 && !l)
        return s.justNow;
    if (typeof i == "number" && p > i)
        return o(new Date(t));
    if (typeof i == "string") {
        const S = (r = a.find(k => k.name === i)) == null ? void 0 : r.max;
        if (S && p > S)
            return o(new Date(t))
    }
    for (const [S, k] of a.entries()) {
        if (g(h, k) <= 0 && a[S - 1])
            return y(h, a[S - 1]);
        if (p < k.max)
            return y(h, k)
    }
    return s.invalid
}
function ree(t = {}) {
    const { window: e = Xi, initialWidth: n = Number.POSITIVE_INFINITY, initialHeight: r = Number.POSITIVE_INFINITY, listenOrientation: i = !0, includeScrollbar: s = !0 } = t
        , o = ce(n)
        , a = ce(r)
        , l = () => {
            e && (s ? (o.value = e.innerWidth,
                a.value = e.innerHeight) : (o.value = e.document.documentElement.clientWidth,
                    a.value = e.document.documentElement.clientHeight))
        }
        ;
    if (l(),
        wE(l),
        Vi("resize", l, {
            passive: !0
        }),
        i) {
        const c = S9("(orientation: portrait)");
        vt(c, () => l())
    }
    return {
        width: o,
        height: a
    }
}
let $9 = 0;
function z9() {
    return ++$9
}
function _E() {
    return "frappe-ui-" + z9()
}
const F9 = ["disabled", "id", "checked"]
    , H9 = ["for"]
    , V9 = je({
        __name: "Checkbox",
        props: {
            size: {
                default: "sm"
            },
            label: {},
            checked: {
                type: Boolean
            },
            disabled: {
                type: Boolean
            },
            padding: {
                type: Boolean,
                default: !1
            },
            modelValue: {
                type: [Boolean, Number]
            },
            id: {}
        },
        setup(t) {
            const e = t
                , n = hd()
                , r = e.id ?? _E()
                , i = G(() => [{
                    sm: "text-base font-medium",
                    md: "text-lg font-medium"
                }[e.size], e.disabled ? "text-gray-500" : "text-gray-800", "select-none"])
                , s = G(() => {
                    let o = e.disabled ? "border-gray-300 bg-gray-50 text-gray-400" : "border-gray-500 text-gray-900 hover:border-gray-600 focus:ring-offset-0 focus:border-gray-900 active:border-gray-700 transition"
                        , a = e.disabled ? "" : e.padding ? "focus:ring-0" : "hover:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400 active:bg-gray-100"
                        , l = {
                            sm: "w-3.5 h-3.5",
                            md: "w-4 h-4"
                        }[e.size];
                    return [o, a, l]
                }
                );
            return (o, a) => (oe(),
                Ae("div", {
                    class: mt(["inline-flex items-center space-x-2 rounded transition", {
                        "px-2.5 py-1.5": o.padding && o.size === "sm",
                        "px-3 py-2": o.padding && o.size === "md",
                        "focus-within:bg-gray-100 focus-within:ring-2 focus-within:ring-gray-400 hover:bg-gray-200 active:bg-gray-300": o.padding && !o.disabled
                    }])
                }, [Xe("input", Wt({
                    class: ["rounded-sm", s.value],
                    type: "checkbox",
                    disabled: o.disabled,
                    id: ie(r),
                    checked: !!o.modelValue,
                    onChange: a[0] || (a[0] = l => o.$emit("update:modelValue", l.target.checked))
                }, ie(n)), null, 16, F9), o.label ? (oe(),
                    Ae("label", {
                        key: 0,
                        class: mt(["block", i.value]),
                        for: ie(r)
                    }, Vt(o.label), 11, H9)) : pt("", !0)], 2))
        }
    });
function gm(t, e, n) {
    var r;
    return function () {
        var i = this
            , s = arguments
            , o = function () {
                r = void 0,
                    n || t.apply(i, s)
            }
            , a = n && !r;
        clearTimeout(r),
            r = window.setTimeout(o, e),
            a && t.apply(i, s)
    }
}
const W9 = {
    name: "Input",
    inheritAttrs: !1,
    expose: ["getInputValue"],
    components: {
        FeatherIcon: ko
    },
    props: {
        label: {
            type: String
        },
        type: {
            type: String,
            default: "text",
            validator(t) {
                let e = ["text", "number", "checkbox", "textarea", "select", "email", "password", "date"].includes(t);
                return e || console.warn(`Invalid value "${t}" for "type" prop for Input`),
                    e
            }
        },
        modelValue: {
            type: [String, Number, Boolean, Object, Array]
        },
        inputClass: {
            type: [String, Array, Object]
        },
        debounce: {
            type: Number
        },
        options: {
            type: Array
        },
        disabled: {
            type: Boolean
        },
        rows: {
            type: Number,
            default: 3
        },
        placeholder: {
            type: String
        },
        iconLeft: {
            type: String
        }
    },
    emits: ["input", "change", "update:modelValue"],
    methods: {
        focus() {
            this.$refs.input.focus()
        },
        blur() {
            this.$refs.input.blur()
        },
        getInputValue(t) {
            let e = t ? t.target : this.$refs.input
                , n = e.value;
            return this.type == "checkbox" && (n = e.checked),
                n
        }
    },
    computed: {
        passedInputValue() {
            return "value" in this.$attrs ? this.$attrs.value : this.modelValue || null
        },
        inputAttributes() {
            let t = {}
                , e = n => {
                    this.$emit("input", this.getInputValue(n))
                }
                ;
            return this.debounce && (e = gm(e, this.debounce)),
                this.type == "checkbox" && (t.checked = this.passedInputValue),
                Object.assign(t, this.$attrs, {
                    onInput: e,
                    onChange: n => {
                        this.$emit("change", this.getInputValue(n)),
                            this.$emit("update:modelValue", this.getInputValue(n))
                    }
                })
        },
        selectOptions() {
            return this.options.map(t => typeof t == "string" ? {
                label: t,
                value: t
            } : t).filter(Boolean)
        },
        isNormalInput() {
            return ["text", "number", "checkbox", "email", "password", "date"].includes(this.type)
        }
    }
}
    , U9 = {
        key: 0,
        class: "mb-2 block text-sm leading-4 text-gray-700"
    }
    , K9 = ["type", "disabled", "placeholder", "value"]
    , q9 = ["placeholder", "value", "disabled", "rows"]
    , G9 = ["disabled"]
    , J9 = ["value", "disabled", "selected"]
    , Z9 = {
        key: 1,
        class: "ml-2 inline-block text-base leading-4"
    };
function Y9(t, e, n, r, i, s) {
    const o = Cn("FeatherIcon");
    return oe(),
        Ae("label", {
            class: mt([n.type == "checkbox" ? "flex" : "block", t.$attrs.class])
        }, [n.label && n.type != "checkbox" ? (oe(),
            Ae("span", U9, Vt(n.label), 1)) : pt("", !0), Xe("div", {
                class: mt(["relative flex", {
                    "items-center": s.isNormalInput || n.type == "select"
                }])
            }, [n.iconLeft && n.type != "checkbox" ? (oe(),
                gt(o, {
                    key: 0,
                    name: n.iconLeft,
                    class: mt(["absolute mx-2 h-4 w-4 text-gray-600", {
                        "mt-2": n.type == "textarea"
                    }])
                }, null, 8, ["name", "class"])) : pt("", !0), s.isNormalInput ? (oe(),
                    Ae("input", Wt({
                        key: 1
                    }, s.inputAttributes, {
                        class: ["border-gray-400 placeholder-gray-500", [{
                            "form-input block w-full": n.type != "checkbox",
                            "form-checkbox": n.type == "checkbox",
                            "pl-8": n.iconLeft && n.type != "checkbox"
                        }, n.inputClass]],
                        ref: "input",
                        type: n.type || "text",
                        disabled: n.disabled,
                        placeholder: n.placeholder,
                        value: s.passedInputValue
                    }), null, 16, K9)) : pt("", !0), n.type === "textarea" ? (oe(),
                        Ae("textarea", Wt({
                            key: 2
                        }, s.inputAttributes, {
                            placeholder: n.placeholder,
                            class: ["placeholder-gray-500", ["form-textarea block w-full resize-none", n.inputClass, {
                                "pl-8": n.iconLeft
                            }]],
                            ref: "input",
                            value: s.passedInputValue,
                            disabled: n.disabled,
                            rows: n.rows
                        }), null, 16, q9)) : pt("", !0), n.type === "select" ? (oe(),
                            Ae("select", Wt({
                                key: 3
                            }, s.inputAttributes, {
                                class: ["form-select block w-full", {
                                    "pl-8": n.iconLeft
                                }],
                                ref: "input",
                                disabled: n.disabled
                            }), [(oe(!0),
                                Ae(Rt, null, Oa(s.selectOptions, a => (oe(),
                                    Ae("option", {
                                        key: a.value,
                                        value: a.value,
                                        disabled: a.disabled || !1,
                                        selected: s.passedInputValue === a.value
                                    }, Vt(a.label), 9, J9))), 128))], 16, G9)) : pt("", !0)], 2), n.label && n.type == "checkbox" ? (oe(),
                                        Ae("span", Z9, Vt(n.label), 1)) : pt("", !0)], 2)
}
const X9 = Ua(W9, [["render", Y9]])
    , Q9 = {
        class: "relative flex items-center"
    }
    , e7 = ["type", "placeholder", "disabled", "id", "value"]
    , SE = je({
        __name: "TextInput",
        props: {
            type: {
                default: "text"
            },
            size: {
                default: "sm"
            },
            variant: {
                default: "subtle"
            },
            placeholder: {},
            disabled: {
                type: Boolean
            },
            id: {},
            modelValue: {},
            debounce: {}
        },
        emits: ["update:modelValue"],
        setup(t, { expose: e, emit: n }) {
            const r = t
                , i = n
                , s = om()
                , o = hd()
                , a = ce(null);
            e({
                el: a
            });
            const l = G(() => r.disabled ? "text-gray-600" : "text-gray-800")
                , c = G(() => {
                    let y = {
                        sm: "text-base rounded h-7",
                        md: "text-base rounded h-8",
                        lg: "text-lg rounded-md h-10",
                        xl: "text-xl rounded-md h-10"
                    }[r.size]
                        , x = {
                            sm: ["py-1.5", s.prefix ? "pl-8" : "pl-2", s.suffix ? "pr-8" : "pr-2"],
                            md: ["py-1.5", s.prefix ? "pl-9" : "pl-2.5", s.suffix ? "pr-9" : "pr-2.5"],
                            lg: ["py-1.5", s.prefix ? "pl-10" : "pl-3", s.suffix ? "pr-10" : "pr-3"],
                            xl: ["py-1.5", s.prefix ? "pl-10" : "pl-3", s.suffix ? "pr-10" : "pr-3"]
                        }[r.size]
                        , S = r.disabled ? "disabled" : r.variant
                        , k = {
                            subtle: "border border-gray-100 bg-gray-100 placeholder-gray-500 hover:border-gray-200 hover:bg-gray-200 focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
                            outline: "border border-gray-300 bg-white placeholder-gray-500 hover:border-gray-400 hover:shadow-sm focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
                            disabled: ["border bg-gray-50 placeholder-gray-400", r.variant === "outline" ? "border-gray-300" : "border-transparent"]
                        }[S];
                    return [y, x, k, l.value, "transition-colors w-full"]
                }
                );
            let d = G(() => ({
                sm: "pl-2",
                md: "pl-2.5",
                lg: "pl-3",
                xl: "pl-3"
            })[r.size])
                , h = G(() => ({
                    sm: "pr-2",
                    md: "pr-2.5",
                    lg: "pr-3",
                    xl: "pr-3"
                })[r.size])
                , p = y => {
                    i("update:modelValue", y)
                }
                ;
            r.debounce && (p = gm(p, r.debounce));
            let g = y => {
                p(y.target.value)
            }
                ;
            return (y, x) => (oe(),
                Ae("div", Q9, [y.$slots.prefix ? (oe(),
                    Ae("div", {
                        key: 0,
                        class: mt(["absolute inset-y-0 left-0 flex items-center", l.value, ie(d)])
                    }, [Ue(y.$slots, "prefix")], 2)) : pt("", !0), Xe("input", Wt({
                        ref_key: "inputRef",
                        ref: a,
                        type: y.type,
                        placeholder: y.placeholder,
                        class: c.value,
                        disabled: y.disabled,
                        id: y.id,
                        value: y.modelValue,
                        onInput: x[0] || (x[0] = (...S) => ie(g) && ie(g)(...S)),
                        onChange: x[1] || (x[1] = (...S) => ie(g) && ie(g)(...S))
                    }, ie(o)), null, 16, e7), y.$slots.suffix ? (oe(),
                        Ae("div", {
                            key: 1,
                            class: mt(["absolute inset-y-0 right-0 flex items-center", l.value, ie(h)])
                        }, [Ue(y.$slots, "suffix")], 2)) : pt("", !0)]))
        }
    });
const t7 = {
    name: "Dialog",
    props: {
        modelValue: {
            type: Boolean,
            required: !0
        },
        options: {
            type: Object,
            default() {
                return {}
            }
        },
        disableOutsideClickToClose: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["update:modelValue", "close", "after-leave"],
    components: {
        HDialog: cj,
        DialogPanel: dj,
        DialogTitle: fj,
        TransitionChild: WC,
        TransitionRoot: UC,
        Button: gv,
        FeatherIcon: ko
    },
    data() {
        return {
            dialogActions: []
        }
    },
    watch: {
        "options.actions": {
            handler(t) {
                t && (this.dialogActions = t.map(e => {
                    let n = ce(!1);
                    return {
                        ...e,
                        loading: n,
                        onClick: e.onClick ? async () => {
                            n.value = !0;
                            try {
                                await e.onClick(this.close)
                            } finally {
                                n.value = !1
                            }
                        }
                            : this.close
                    }
                }
                ))
            },
            immediate: !0
        }
    },
    methods: {
        close() {
            this.open = !1
        }
    },
    computed: {
        open: {
            get() {
                return this.modelValue
            },
            set(t) {
                this.$emit("update:modelValue", t),
                    t || this.$emit("close")
            }
        },
        icon() {
            if (!this.options?.icon)
                return null;
            let t = this.options.icon;
            return typeof t == "string" && (t = {
                name: t
            }),
                t
        },
        dialogPositionClasses() {
            let t = this.options?.position || "center";
            return {
                "justify-center": t === "center",
                "pt-[20vh]": t === "top"
            }
        }
    }
}
    , n7 = ["data-dialog"]
    , r7 = {
        class: "bg-white px-4 pb-6 pt-5 sm:px-6"
    }
    , i7 = {
        class: "flex"
    }
    , s7 = {
        class: "w-full flex-1"
    }
    , o7 = {
        class: "mb-6 flex items-center justify-between"
    }
    , a7 = {
        class: "flex items-center space-x-2"
    }
    , l7 = {
        class: "text-2xl font-semibold leading-6 text-gray-900"
    }
    , u7 = {
        key: 0,
        class: "text-p-base text-gray-700"
    }
    , c7 = {
        key: 0,
        class: "px-4 pb-7 pt-4 sm:px-6"
    }
    , d7 = {
        class: "space-y-2"
    };
function f7(t, e, n, r, i, s) {
    const o = Cn("TransitionChild")
        , a = Cn("FeatherIcon")
        , l = Cn("DialogTitle")
        , c = Cn("Button")
        , d = Cn("DialogPanel")
        , h = Cn("HDialog")
        , p = Cn("TransitionRoot");
    return oe(),
        gt(p, {
            as: "template",
            show: s.open,
            onAfterLeave: e[1] || (e[1] = g => t.$emit("after-leave"))
        }, {
            default: tt(() => [$e(h, {
                as: "div",
                class: "fixed inset-0 z-10 overflow-y-auto",
                onClose: e[0] || (e[0] = g => !n.disableOutsideClickToClose && s.close())
            }, {
                default: tt(() => [Xe("div", {
                    class: mt(["flex min-h-screen flex-col items-center px-4 py-4 text-center", s.dialogPositionClasses])
                }, [$e(o, {
                    as: "template",
                    enter: "ease-out duration-150",
                    "enter-from": "opacity-0",
                    "enter-to": "opacity-100",
                    leave: "ease-in duration-150",
                    "leave-from": "opacity-100",
                    "leave-to": "opacity-0"
                }, {
                    default: tt(() => [Xe("div", {
                        class: "fixed inset-0 bg-black-overlay-200 transition-opacity",
                        "data-dialog": n.options.title
                    }, null, 8, n7)]),
                    _: 1
                }), $e(o, {
                    as: "template",
                    enter: "ease-out duration-150",
                    "enter-from": "opacity-50 translate-y-2 scale-95",
                    "enter-to": "opacity-100 translate-y-0 scale-100",
                    leave: "ease-in duration-150",
                    "leave-from": "opacity-100 translate-y-0 scale-100",
                    "leave-to": "opacity-50 translate-y-4 translate-y-4 scale-95"
                }, {
                    default: tt(() => [$e(d, {
                        class: mt(["my-8 inline-block w-full transform overflow-hidden rounded-xl bg-white text-left align-middle shadow-xl transition-all", {
                            "max-w-7xl": n.options.size === "7xl",
                            "max-w-6xl": n.options.size === "6xl",
                            "max-w-5xl": n.options.size === "5xl",
                            "max-w-4xl": n.options.size === "4xl",
                            "max-w-3xl": n.options.size === "3xl",
                            "max-w-2xl": n.options.size === "2xl",
                            "max-w-xl": n.options.size === "xl",
                            "max-w-lg": n.options.size === "lg" || !n.options.size,
                            "max-w-md": n.options.size === "md",
                            "max-w-sm": n.options.size === "sm",
                            "max-w-xs": n.options.size === "xs"
                        }])
                    }, {
                        default: tt(() => [Ue(t.$slots, "body", {}, () => [Ue(t.$slots, "body-main", {}, () => [Xe("div", r7, [Xe("div", i7, [Xe("div", s7, [Xe("div", o7, [Xe("div", a7, [s.icon ? (oe(),
                            Ae("div", {
                                key: 0,
                                class: mt(["flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full", {
                                    "bg-gray-100": !s.icon.appearance,
                                    "bg-yellow-100": s.icon.appearance === "warning",
                                    "bg-blue-100": s.icon.appearance === "info",
                                    "bg-red-100": s.icon.appearance === "danger",
                                    "bg-green-100": s.icon.appearance === "success"
                                }])
                            }, [$e(a, {
                                name: s.icon.name,
                                class: mt(["h-4 w-4", {
                                    "text-gray-600": !s.icon.appearance,
                                    "text-yellow-600": s.icon.appearance === "warning",
                                    "text-blue-600": s.icon.appearance === "info",
                                    "text-red-600": s.icon.appearance === "danger",
                                    "text-green-600": s.icon.appearance === "success"
                                }]),
                                "aria-hidden": "true"
                            }, null, 8, ["name", "class"])], 2)) : pt("", !0), $e(l, {
                                as: "header"
                            }, {
                                default: tt(() => [Ue(t.$slots, "body-title", {}, () => [Xe("h3", l7, Vt(n.options.title || "Untitled"), 1)])]),
                                _: 3
                            })]), $e(c, {
                                variant: "ghost",
                                onClick: s.close
                            }, {
                                icon: tt(() => e[2] || (e[2] = [Xe("svg", {
                                    width: "16",
                                    height: "16",
                                    viewBox: "0 0 16 16",
                                    fill: "none",
                                    xmlns: "http://www.w3.org/2000/svg"
                                }, [Xe("path", {
                                    "fill-rule": "evenodd",
                                    "clip-rule": "evenodd",
                                    d: "M12.8567 3.85355C13.052 3.65829 13.052 3.34171 12.8567 3.14645C12.6615 2.95118 12.3449 2.95118 12.1496 3.14645L8.00201 7.29405L3.85441 3.14645C3.65914 2.95118 3.34256 2.95118 3.1473 3.14645C2.95204 3.34171 2.95204 3.65829 3.1473 3.85355L7.29491 8.00116L3.14645 12.1496C2.95118 12.3449 2.95118 12.6615 3.14645 12.8567C3.34171 13.052 3.65829 13.052 3.85355 12.8567L8.00201 8.70827L12.1505 12.8567C12.3457 13.052 12.6623 13.052 12.8576 12.8567C13.0528 12.6615 13.0528 12.3449 12.8576 12.1496L8.70912 8.00116L12.8567 3.85355Z",
                                    fill: "#383838"
                                })], -1)])),
                                _: 1
                            }, 8, ["onClick"])]), Ue(t.$slots, "body-content", {}, () => [n.options.message ? (oe(),
                                Ae("p", u7, Vt(n.options.message), 1)) : pt("", !0)])])])])]), i.dialogActions.length || t.$slots.actions ? (oe(),
                                    Ae("div", c7, [Ue(t.$slots, "actions", xi(_i({
                                        close: s.close
                                    })), () => [Xe("div", d7, [(oe(!0),
                                        Ae(Rt, null, Oa(i.dialogActions, g => (oe(),
                                            gt(c, Wt({
                                                class: "w-full",
                                                key: g.label,
                                                ref_for: !0
                                            }, g), {
                                                default: tt(() => [Pa(Vt(g.label), 1)]),
                                                _: 2
                                            }, 1040))), 128))])])])) : pt("", !0)])]),
                        _: 3
                    }, 8, ["class"])]),
                    _: 3
                })], 2)]),
                _: 3
            })]),
            _: 3
        }, 8, ["show"])
}
const h7 = Ua(t7, [["render", f7]]);
ce([]);
const p7 = {
    name: "ErrorMessage",
    props: ["message"],
    computed: {
        errorMessage() {
            return this.message ? this.message instanceof Error ? this.message.messages || this.message.message : this.message : ""
        }
    }
}
    , m7 = ["innerHTML"];
function g7(t, e, n, r, i, s) {
    return n.message ? (oe(),
        Ae("div", {
            key: 0,
            class: "whitespace-pre-line text-sm text-red-600",
            role: "alert",
            innerHTML: s.errorMessage
        }, null, 8, m7)) : pt("", !0)
}
const y7 = Ua(p7, [["render", g7]])
    , v7 = {
        class: "relative flex items-center"
    }
    , b7 = ["disabled", "id", "value"]
    , w7 = ["value", "disabled", "selected"]
    , x7 = je({
        inheritAttrs: !1,
        __name: "Select",
        props: {
            size: {
                default: "sm"
            },
            variant: {
                default: "subtle"
            },
            placeholder: {},
            disabled: {
                type: Boolean
            },
            id: {},
            modelValue: {},
            options: {}
        },
        emits: ["update:modelValue"],
        setup(t, { emit: e }) {
            const n = t
                , r = e;
            om();
            const i = hd();
            function s(p) {
                r("update:modelValue", p.target.value)
            }
            const o = G(() => n.options?.map(p => typeof p == "string" ? {
                label: p,
                value: p
            } : p).filter(Boolean) || [])
                , a = G(() => n.disabled ? "text-gray-500" : "text-gray-800")
                , l = G(() => ({
                    sm: "text-base",
                    md: "text-base",
                    lg: "text-lg",
                    xl: "text-xl"
                })[n.size])
                , c = G(() => ({
                    sm: "px-2",
                    md: "px-2.5",
                    lg: "px-3",
                    xl: "px-3"
                })[n.size])
                , d = G(() => {
                    let p = {
                        sm: "rounded h-7",
                        md: "rounded h-8",
                        lg: "rounded-md h-10",
                        xl: "rounded-md h-10"
                    }[n.size]
                        , g = n.disabled ? "disabled" : n.variant
                        , y = {
                            subtle: "border border-gray-100 bg-gray-100 hover:border-gray-200 hover:bg-gray-200 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
                            outline: "border border-gray-300 bg-white hover:border-gray-400 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
                            ghost: "bg-transparent border-transparent hover:bg-gray-200 focus:bg-gray-200 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
                            disabled: ["border", n.variant !== "ghost" ? "bg-gray-50" : "", n.variant === "outline" ? "border-gray-300" : "border-transparent"]
                        }[g];
                    return [p, l.value, c.value, y, a.value, "transition-colors w-full py-0"]
                }
                );
            let h = G(() => ({
                sm: "pl-2",
                md: "pl-2.5",
                lg: "pl-3",
                xl: "pl-3"
            })[n.size]);
            return (p, g) => (oe(),
                Ae("div", v7, [p.$slots.prefix ? (oe(),
                    Ae("div", {
                        key: 0,
                        class: mt(["absolute inset-y-0 left-0 flex items-center", a.value, ie(h)])
                    }, [Ue(p.$slots, "prefix")], 2)) : pt("", !0), p.placeholder ? Rh((oe(),
                        Ae("div", {
                            key: 1,
                            class: mt(["pointer-events-none absolute text-gray-500", [l.value, c.value]])
                        }, Vt(p.placeholder), 3)), [[Oc, !p.modelValue]]) : pt("", !0), Xe("select", Wt({
                            class: d.value,
                            disabled: p.disabled,
                            id: p.id,
                            value: p.modelValue,
                            onChange: s
                        }, ie(i)), [(oe(!0),
                            Ae(Rt, null, Oa(o.value, y => (oe(),
                                Ae("option", {
                                    key: y.value,
                                    value: y.value,
                                    disabled: y.disabled || !1,
                                    selected: p.modelValue === y.value
                                }, Vt(y.label), 9, w7))), 128))], 16, b7)]))
        }
    })
    , _7 = {
        class: "space-y-1.5"
    }
    , S7 = ["for"]
    , k7 = ["placeholder", "disabled", "id", "value", "rows"]
    , C7 = je({
        __name: "Textarea",
        props: {
            size: {
                default: "sm"
            },
            variant: {
                default: "subtle"
            },
            placeholder: {},
            disabled: {
                type: Boolean
            },
            id: {},
            modelValue: {},
            debounce: {},
            rows: {
                default: 3
            },
            label: {}
        },
        emits: ["update:modelValue"],
        setup(t, { emit: e }) {
            const n = t
                , r = e
                , i = hd()
                , s = G(() => {
                    let c = {
                        sm: "text-base rounded",
                        md: "text-base rounded",
                        lg: "text-lg rounded-md",
                        xl: "text-xl rounded-md"
                    }[n.size]
                        , d = {
                            sm: ["py-1.5 px-2"],
                            md: ["py-1.5 px-2.5"],
                            lg: ["py-1.5 px-3"],
                            xl: ["py-1.5 px-3"]
                        }[n.size]
                        , h = n.disabled ? "disabled" : n.variant
                        , p = {
                            subtle: "border border-gray-100 bg-gray-100 placeholder-gray-500 hover:border-gray-200 hover:bg-gray-200 focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
                            outline: "border border-gray-300 bg-white placeholder-gray-500 hover:border-gray-400 hover:shadow-sm focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
                            disabled: ["border bg-gray-50 placeholder-gray-400", n.variant === "outline" ? "border-gray-300" : "border-transparent"]
                        }[h];
                    return [c, d, p, n.disabled ? "text-gray-600" : "text-gray-800", "transition-colors w-full block"]
                }
                )
                , o = G(() => [{
                    sm: "text-xs",
                    md: "text-base",
                    lg: "text-lg",
                    xl: "text-xl"
                }[n.size], "text-gray-600"]);
            let a = c => {
                r("update:modelValue", c)
            }
                ;
            n.debounce && (a = gm(a, n.debounce));
            let l = c => {
                a(c.target.value)
            }
                ;
            return (c, d) => (oe(),
                Ae("div", _7, [c.label ? (oe(),
                    Ae("label", {
                        key: 0,
                        class: mt(["block", o.value]),
                        for: c.id
                    }, Vt(c.label), 11, S7)) : pt("", !0), Xe("textarea", Wt({
                        placeholder: c.placeholder,
                        class: s.value,
                        disabled: c.disabled,
                        id: c.id,
                        value: c.modelValue,
                        rows: c.rows,
                        onInput: d[0] || (d[0] = (...h) => ie(l) && ie(l)(...h)),
                        onChange: d[1] || (d[1] = (...h) => ie(l) && ie(l)(...h))
                    }, ie(i)), null, 16, k7)]))
        }
    })
    , E7 = ["for"]
    , T7 = {
        inheritAttrs: !1
    }
    , A7 = je({
        ...T7,
        __name: "FormControl",
        props: {
            label: {},
            description: {},
            type: {
                default: "text"
            },
            size: {
                default: "sm"
            }
        },
        setup(t) {
            const e = _E()
                , n = t
                , r = hd()
                , i = G(() => {
                    let a = {};
                    for (let l in r)
                        l !== "class" && l !== "style" && (a[l] = r[l]);
                    return a
                }
                )
                , s = G(() => [{
                    sm: "text-xs",
                    md: "text-base"
                }[n.size], "text-gray-600"])
                , o = G(() => [{
                    sm: "text-xs",
                    md: "text-base"
                }[n.size], "text-gray-600"]);
            return (a, l) => a.type != "checkbox" ? (oe(),
                Ae("div", {
                    key: 0,
                    class: mt(["space-y-1.5", ie(r).class])
                }, [a.label ? (oe(),
                    Ae("label", {
                        key: 0,
                        class: mt(["block", s.value]),
                        for: ie(e)
                    }, Vt(a.label), 11, E7)) : pt("", !0), a.type === "select" ? (oe(),
                        gt(x7, Wt({
                            key: 1,
                            id: ie(e)
                        }, {
                            ...i.value,
                            size: a.size
                        }), o0({
                            _: 2
                        }, [a.$slots.prefix ? {
                            name: "prefix",
                            fn: tt(() => [Ue(a.$slots, "prefix")]),
                            key: "0"
                        } : void 0]), 1040, ["id"])) : a.type === "autocomplete" ? (oe(),
                            gt(s9, xi(Wt({
                                key: 2
                            }, {
                                ...i.value
                            })), o0({
                                _: 2
                            }, [a.$slots.prefix ? {
                                name: "prefix",
                                fn: tt(() => [Ue(a.$slots, "prefix")]),
                                key: "0"
                            } : void 0, a.$slots["item-prefix"] ? {
                                name: "item-prefix",
                                fn: tt(c => [Ue(a.$slots, "item-prefix", xi(_i(c)))]),
                                key: "1"
                            } : void 0]), 1040)) : a.type === "textarea" ? (oe(),
                                gt(C7, Wt({
                                    key: 3,
                                    id: ie(e)
                                }, {
                                    ...i.value,
                                    size: a.size
                                }), null, 16, ["id"])) : (oe(),
                                    gt(SE, Wt({
                                        key: 4,
                                        id: ie(e)
                                    }, {
                                        ...i.value,
                                        type: a.type,
                                        size: a.size
                                    }), o0({
                                        _: 2
                                    }, [a.$slots.prefix ? {
                                        name: "prefix",
                                        fn: tt(() => [Ue(a.$slots, "prefix")]),
                                        key: "0"
                                    } : void 0, a.$slots.suffix ? {
                                        name: "suffix",
                                        fn: tt(() => [Ue(a.$slots, "suffix")]),
                                        key: "1"
                                    } : void 0]), 1040, ["id"])), Ue(a.$slots, "description", {}, () => [a.description ? (oe(),
                                        Ae("p", {
                                            key: 0,
                                            class: mt(o.value)
                                        }, Vt(a.description), 3)) : pt("", !0)])], 2)) : (oe(),
                                            gt(V9, Wt({
                                                key: 1,
                                                id: ie(e)
                                            }, {
                                                ...i.value,
                                                label: a.label,
                                                size: a.size,
                                                class: ie(r).class
                                            }), null, 16, ["id"]))
        }
    });
function Ln(t) {
    this.content = t
}
Ln.prototype = {
    constructor: Ln,
    find: function (t) {
        for (var e = 0; e < this.content.length; e += 2)
            if (this.content[e] === t)
                return e;
        return -1
    },
    get: function (t) {
        var e = this.find(t);
        return e == -1 ? void 0 : this.content[e + 1]
    },
    update: function (t, e, n) {
        var r = n && n != t ? this.remove(n) : this
            , i = r.find(t)
            , s = r.content.slice();
        return i == -1 ? s.push(n || t, e) : (s[i + 1] = e,
            n && (s[i] = n)),
            new Ln(s)
    },
    remove: function (t) {
        var e = this.find(t);
        if (e == -1)
            return this;
        var n = this.content.slice();
        return n.splice(e, 2),
            new Ln(n)
    },
    addToStart: function (t, e) {
        return new Ln([t, e].concat(this.remove(t).content))
    },
    addToEnd: function (t, e) {
        var n = this.remove(t).content.slice();
        return n.push(t, e),
            new Ln(n)
    },
    addBefore: function (t, e, n) {
        var r = this.remove(e)
            , i = r.content.slice()
            , s = r.find(t);
        return i.splice(s == -1 ? i.length : s, 0, e, n),
            new Ln(i)
    },
    forEach: function (t) {
        for (var e = 0; e < this.content.length; e += 2)
            t(this.content[e], this.content[e + 1])
    },
    prepend: function (t) {
        return t = Ln.from(t),
            t.size ? new Ln(t.content.concat(this.subtract(t).content)) : this
    },
    append: function (t) {
        return t = Ln.from(t),
            t.size ? new Ln(this.subtract(t).content.concat(t.content)) : this
    },
    subtract: function (t) {
        var e = this;
        t = Ln.from(t);
        for (var n = 0; n < t.content.length; n += 2)
            e = e.remove(t.content[n]);
        return e
    },
    toObject: function () {
        var t = {};
        return this.forEach(function (e, n) {
            t[e] = n
        }),
            t
    },
    get size() {
        return this.content.length >> 1
    }
};
Ln.from = function (t) {
    if (t instanceof Ln)
        return t;
    var e = [];
    if (t)
        for (var n in t)
            e.push(n, t[n]);
    return new Ln(e)
}
    ;
function kE(t, e, n) {
    for (let r = 0; ; r++) {
        if (r == t.childCount || r == e.childCount)
            return t.childCount == e.childCount ? null : n;
        let i = t.child(r)
            , s = e.child(r);
        if (i == s) {
            n += i.nodeSize;
            continue
        }
        if (!i.sameMarkup(s))
            return n;
        if (i.isText && i.text != s.text) {
            for (let o = 0; i.text[o] == s.text[o]; o++)
                n++;
            return n
        }
        if (i.content.size || s.content.size) {
            let o = kE(i.content, s.content, n + 1);
            if (o != null)
                return o
        }
        n += i.nodeSize
    }
}
function CE(t, e, n, r) {
    for (let i = t.childCount, s = e.childCount; ;) {
        if (i == 0 || s == 0)
            return i == s ? null : {
                a: n,
                b: r
            };
        let o = t.child(--i)
            , a = e.child(--s)
            , l = o.nodeSize;
        if (o == a) {
            n -= l,
                r -= l;
            continue
        }
        if (!o.sameMarkup(a))
            return {
                a: n,
                b: r
            };
        if (o.isText && o.text != a.text) {
            let c = 0
                , d = Math.min(o.text.length, a.text.length);
            for (; c < d && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1];)
                c++,
                    n--,
                    r--;
            return {
                a: n,
                b: r
            }
        }
        if (o.content.size || a.content.size) {
            let c = CE(o.content, a.content, n - 1, r - 1);
            if (c)
                return c
        }
        n -= l,
            r -= l
    }
}
class se {
    constructor(e, n) {
        if (this.content = e,
            this.size = n || 0,
            n == null)
            for (let r = 0; r < e.length; r++)
                this.size += e[r].nodeSize
    }
    nodesBetween(e, n, r, i = 0, s) {
        for (let o = 0, a = 0; a < n; o++) {
            let l = this.content[o]
                , c = a + l.nodeSize;
            if (c > e && r(l, i + a, s || null, o) !== !1 && l.content.size) {
                let d = a + 1;
                l.nodesBetween(Math.max(0, e - d), Math.min(l.content.size, n - d), r, i + d)
            }
            a = c
        }
    }
    descendants(e) {
        this.nodesBetween(0, this.size, e)
    }
    textBetween(e, n, r, i) {
        let s = ""
            , o = !0;
        return this.nodesBetween(e, n, (a, l) => {
            let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
            a.isBlock && (a.isLeaf && c || a.isTextblock) && r && (o ? o = !1 : s += r),
                s += c
        }
            , 0),
            s
    }
    append(e) {
        if (!e.size)
            return this;
        if (!this.size)
            return e;
        let n = this.lastChild
            , r = e.firstChild
            , i = this.content.slice()
            , s = 0;
        for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text),
            s = 1); s < e.content.length; s++)
            i.push(e.content[s]);
        return new se(i, this.size + e.size)
    }
    cut(e, n = this.size) {
        if (e == 0 && n == this.size)
            return this;
        let r = []
            , i = 0;
        if (n > e)
            for (let s = 0, o = 0; o < n; s++) {
                let a = this.content[s]
                    , l = o + a.nodeSize;
                l > e && ((o < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1))),
                    r.push(a),
                    i += a.nodeSize),
                    o = l
            }
        return new se(r, i)
    }
    cutByIndex(e, n) {
        return e == n ? se.empty : e == 0 && n == this.content.length ? this : new se(this.content.slice(e, n))
    }
    replaceChild(e, n) {
        let r = this.content[e];
        if (r == n)
            return this;
        let i = this.content.slice()
            , s = this.size + n.nodeSize - r.nodeSize;
        return i[e] = n,
            new se(i, s)
    }
    addToStart(e) {
        return new se([e].concat(this.content), this.size + e.nodeSize)
    }
    addToEnd(e) {
        return new se(this.content.concat(e), this.size + e.nodeSize)
    }
    eq(e) {
        if (this.content.length != e.content.length)
            return !1;
        for (let n = 0; n < this.content.length; n++)
            if (!this.content[n].eq(e.content[n]))
                return !1;
        return !0
    }
    get firstChild() {
        return this.content.length ? this.content[0] : null
    }
    get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null
    }
    get childCount() {
        return this.content.length
    }
    child(e) {
        let n = this.content[e];
        if (!n)
            throw new RangeError("Index " + e + " out of range for " + this);
        return n
    }
    maybeChild(e) {
        return this.content[e] || null
    }
    forEach(e) {
        for (let n = 0, r = 0; n < this.content.length; n++) {
            let i = this.content[n];
            e(i, r, n),
                r += i.nodeSize
        }
    }
    findDiffStart(e, n = 0) {
        return kE(this, e, n)
    }
    findDiffEnd(e, n = this.size, r = e.size) {
        return CE(this, e, n, r)
    }
    findIndex(e, n = -1) {
        if (e == 0)
            return $f(0, e);
        if (e == this.size)
            return $f(this.content.length, e);
        if (e > this.size || e < 0)
            throw new RangeError(`Position ${e} outside of fragment (${this})`);
        for (let r = 0, i = 0; ; r++) {
            let s = this.child(r)
                , o = i + s.nodeSize;
            if (o >= e)
                return o == e || n > 0 ? $f(r + 1, o) : $f(r, i);
            i = o
        }
    }
    toString() {
        return "<" + this.toStringInner() + ">"
    }
    toStringInner() {
        return this.content.join(", ")
    }
    toJSON() {
        return this.content.length ? this.content.map(e => e.toJSON()) : null
    }
    static fromJSON(e, n) {
        if (!n)
            return se.empty;
        if (!Array.isArray(n))
            throw new RangeError("Invalid input for Fragment.fromJSON");
        return new se(n.map(e.nodeFromJSON))
    }
    static fromArray(e) {
        if (!e.length)
            return se.empty;
        let n, r = 0;
        for (let i = 0; i < e.length; i++) {
            let s = e[i];
            r += s.nodeSize,
                i && s.isText && e[i - 1].sameMarkup(s) ? (n || (n = e.slice(0, i)),
                    n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s)
        }
        return new se(n || e, r)
    }
    static from(e) {
        if (!e)
            return se.empty;
        if (e instanceof se)
            return e;
        if (Array.isArray(e))
            return this.fromArray(e);
        if (e.attrs)
            return new se([e], e.nodeSize);
        throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
    }
}
se.empty = new se([], 0);
const w0 = {
    index: 0,
    offset: 0
};
function $f(t, e) {
    return w0.index = t,
        w0.offset = e,
        w0
}
function Wh(t, e) {
    if (t === e)
        return !0;
    if (!(t && typeof t == "object") || !(e && typeof e == "object"))
        return !1;
    let n = Array.isArray(t);
    if (Array.isArray(e) != n)
        return !1;
    if (n) {
        if (t.length != e.length)
            return !1;
        for (let r = 0; r < t.length; r++)
            if (!Wh(t[r], e[r]))
                return !1
    } else {
        for (let r in t)
            if (!(r in e) || !Wh(t[r], e[r]))
                return !1;
        for (let r in e)
            if (!(r in t))
                return !1
    }
    return !0
}
let zt = class R1 {
    constructor(e, n) {
        this.type = e,
            this.attrs = n
    }
    addToSet(e) {
        let n, r = !1;
        for (let i = 0; i < e.length; i++) {
            let s = e[i];
            if (this.eq(s))
                return e;
            if (this.type.excludes(s.type))
                n || (n = e.slice(0, i));
            else {
                if (s.type.excludes(this.type))
                    return e;
                !r && s.type.rank > this.type.rank && (n || (n = e.slice(0, i)),
                    n.push(this),
                    r = !0),
                    n && n.push(s)
            }
        }
        return n || (n = e.slice()),
            r || n.push(this),
            n
    }
    removeFromSet(e) {
        for (let n = 0; n < e.length; n++)
            if (this.eq(e[n]))
                return e.slice(0, n).concat(e.slice(n + 1));
        return e
    }
    isInSet(e) {
        for (let n = 0; n < e.length; n++)
            if (this.eq(e[n]))
                return !0;
        return !1
    }
    eq(e) {
        return this == e || this.type == e.type && Wh(this.attrs, e.attrs)
    }
    toJSON() {
        let e = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            e.attrs = this.attrs;
            break
        }
        return e
    }
    static fromJSON(e, n) {
        if (!n)
            throw new RangeError("Invalid input for Mark.fromJSON");
        let r = e.marks[n.type];
        if (!r)
            throw new RangeError(`There is no mark type ${n.type} in this schema`);
        let i = r.create(n.attrs);
        return r.checkAttrs(i.attrs),
            i
    }
    static sameSet(e, n) {
        if (e == n)
            return !0;
        if (e.length != n.length)
            return !1;
        for (let r = 0; r < e.length; r++)
            if (!e[r].eq(n[r]))
                return !1;
        return !0
    }
    static setFrom(e) {
        if (!e || Array.isArray(e) && e.length == 0)
            return R1.none;
        if (e instanceof R1)
            return [e];
        let n = e.slice();
        return n.sort((r, i) => r.type.rank - i.type.rank),
            n
    }
}
    ;
zt.none = [];
class Uh extends Error {
}
class ve {
    constructor(e, n, r) {
        this.content = e,
            this.openStart = n,
            this.openEnd = r
    }
    get size() {
        return this.content.size - this.openStart - this.openEnd
    }
    insertAt(e, n) {
        let r = TE(this.content, e + this.openStart, n);
        return r && new ve(r, this.openStart, this.openEnd)
    }
    removeBetween(e, n) {
        return new ve(EE(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd)
    }
    eq(e) {
        return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd
    }
    toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")"
    }
    toJSON() {
        if (!this.content.size)
            return null;
        let e = {
            content: this.content.toJSON()
        };
        return this.openStart > 0 && (e.openStart = this.openStart),
            this.openEnd > 0 && (e.openEnd = this.openEnd),
            e
    }
    static fromJSON(e, n) {
        if (!n)
            return ve.empty;
        let r = n.openStart || 0
            , i = n.openEnd || 0;
        if (typeof r != "number" || typeof i != "number")
            throw new RangeError("Invalid input for Slice.fromJSON");
        return new ve(se.fromJSON(e, n.content), r, i)
    }
    static maxOpen(e, n = !0) {
        let r = 0
            , i = 0;
        for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
            r++;
        for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
            i++;
        return new ve(e, r, i)
    }
}
ve.empty = new ve(se.empty, 0, 0);
function EE(t, e, n) {
    let { index: r, offset: i } = t.findIndex(e)
        , s = t.maybeChild(r)
        , { index: o, offset: a } = t.findIndex(n);
    if (i == e || s.isText) {
        if (a != n && !t.child(o).isText)
            throw new RangeError("Removing non-flat range");
        return t.cut(0, e).append(t.cut(n))
    }
    if (r != o)
        throw new RangeError("Removing non-flat range");
    return t.replaceChild(r, s.copy(EE(s.content, e - i - 1, n - i - 1)))
}
function TE(t, e, n, r) {
    let { index: i, offset: s } = t.findIndex(e)
        , o = t.maybeChild(i);
    if (s == e || o.isText)
        return r && !r.canReplace(i, i, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
    let a = TE(o.content, e - s - 1, n);
    return a && t.replaceChild(i, o.copy(a))
}
function O7(t, e, n) {
    if (n.openStart > t.depth)
        throw new Uh("Inserted content deeper than insertion position");
    if (t.depth - n.openStart != e.depth - n.openEnd)
        throw new Uh("Inconsistent open depths");
    return AE(t, e, n, 0)
}
function AE(t, e, n, r) {
    let i = t.index(r)
        , s = t.node(r);
    if (i == e.index(r) && r < t.depth - n.openStart) {
        let o = AE(t, e, n, r + 1);
        return s.copy(s.content.replaceChild(i, o))
    } else if (n.content.size)
        if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
            let o = t.parent
                , a = o.content;
            return xa(o, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)))
        } else {
            let { start: o, end: a } = M7(n, t);
            return xa(s, ME(t, o, a, e, r))
        }
    else
        return xa(s, Kh(t, e, r))
}
function OE(t, e) {
    if (!e.type.compatibleContent(t.type))
        throw new Uh("Cannot join " + e.type.name + " onto " + t.type.name)
}
function P1(t, e, n) {
    let r = t.node(n);
    return OE(r, e.node(n)),
        r
}
function wa(t, e) {
    let n = e.length - 1;
    n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t)
}
function fc(t, e, n, r) {
    let i = (e || t).node(n)
        , s = 0
        , o = e ? e.index(n) : i.childCount;
    t && (s = t.index(n),
        t.depth > n ? s++ : t.textOffset && (wa(t.nodeAfter, r),
            s++));
    for (let a = s; a < o; a++)
        wa(i.child(a), r);
    e && e.depth == n && e.textOffset && wa(e.nodeBefore, r)
}
function xa(t, e) {
    return t.type.checkContent(e),
        t.copy(e)
}
function ME(t, e, n, r, i) {
    let s = t.depth > i && P1(t, e, i + 1)
        , o = r.depth > i && P1(n, r, i + 1)
        , a = [];
    return fc(null, t, i, a),
        s && o && e.index(i) == n.index(i) ? (OE(s, o),
            wa(xa(s, ME(t, e, n, r, i + 1)), a)) : (s && wa(xa(s, Kh(t, e, i + 1)), a),
                fc(e, n, i, a),
                o && wa(xa(o, Kh(n, r, i + 1)), a)),
        fc(r, null, i, a),
        new se(a)
}
function Kh(t, e, n) {
    let r = [];
    if (fc(null, t, n, r),
        t.depth > n) {
        let i = P1(t, e, n + 1);
        wa(xa(i, Kh(t, e, n + 1)), r)
    }
    return fc(e, null, n, r),
        new se(r)
}
function M7(t, e) {
    let n = e.depth - t.openStart
        , i = e.node(n).copy(t.content);
    for (let s = n - 1; s >= 0; s--)
        i = e.node(s).copy(se.from(i));
    return {
        start: i.resolveNoCache(t.openStart + n),
        end: i.resolveNoCache(i.content.size - t.openEnd - n)
    }
}
class Lc {
    constructor(e, n, r) {
        this.pos = e,
            this.path = n,
            this.parentOffset = r,
            this.depth = n.length / 3 - 1
    }
    resolveDepth(e) {
        return e == null ? this.depth : e < 0 ? this.depth + e : e
    }
    get parent() {
        return this.node(this.depth)
    }
    get doc() {
        return this.node(0)
    }
    node(e) {
        return this.path[this.resolveDepth(e) * 3]
    }
    index(e) {
        return this.path[this.resolveDepth(e) * 3 + 1]
    }
    indexAfter(e) {
        return e = this.resolveDepth(e),
            this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
    }
    start(e) {
        return e = this.resolveDepth(e),
            e == 0 ? 0 : this.path[e * 3 - 1] + 1
    }
    end(e) {
        return e = this.resolveDepth(e),
            this.start(e) + this.node(e).content.size
    }
    before(e) {
        if (e = this.resolveDepth(e),
            !e)
            throw new RangeError("There is no position before the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1]
    }
    after(e) {
        if (e = this.resolveDepth(e),
            !e)
            throw new RangeError("There is no position after the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize
    }
    get textOffset() {
        return this.pos - this.path[this.path.length - 1]
    }
    get nodeAfter() {
        let e = this.parent
            , n = this.index(this.depth);
        if (n == e.childCount)
            return null;
        let r = this.pos - this.path[this.path.length - 1]
            , i = e.child(n);
        return r ? e.child(n).cut(r) : i
    }
    get nodeBefore() {
        let e = this.index(this.depth)
            , n = this.pos - this.path[this.path.length - 1];
        return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1)
    }
    posAtIndex(e, n) {
        n = this.resolveDepth(n);
        let r = this.path[n * 3]
            , i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
        for (let s = 0; s < e; s++)
            i += r.child(s).nodeSize;
        return i
    }
    marks() {
        let e = this.parent
            , n = this.index();
        if (e.content.size == 0)
            return zt.none;
        if (this.textOffset)
            return e.child(n).marks;
        let r = e.maybeChild(n - 1)
            , i = e.maybeChild(n);
        if (!r) {
            let a = r;
            r = i,
                i = a
        }
        let s = r.marks;
        for (var o = 0; o < s.length; o++)
            s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
        return s
    }
    marksAcross(e) {
        let n = this.parent.maybeChild(this.index());
        if (!n || !n.isInline)
            return null;
        let r = n.marks
            , i = e.parent.maybeChild(e.index());
        for (var s = 0; s < r.length; s++)
            r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
        return r
    }
    sharedDepth(e) {
        for (let n = this.depth; n > 0; n--)
            if (this.start(n) <= e && this.end(n) >= e)
                return n;
        return 0
    }
    blockRange(e = this, n) {
        if (e.pos < this.pos)
            return e.blockRange(this);
        for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
            if (e.pos <= this.end(r) && (!n || n(this.node(r))))
                return new qh(this, e, r);
        return null
    }
    sameParent(e) {
        return this.pos - this.parentOffset == e.pos - e.parentOffset
    }
    max(e) {
        return e.pos > this.pos ? e : this
    }
    min(e) {
        return e.pos < this.pos ? e : this
    }
    toString() {
        let e = "";
        for (let n = 1; n <= this.depth; n++)
            e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
        return e + ":" + this.parentOffset
    }
    static resolve(e, n) {
        if (!(n >= 0 && n <= e.content.size))
            throw new RangeError("Position " + n + " out of range");
        let r = []
            , i = 0
            , s = n;
        for (let o = e; ;) {
            let { index: a, offset: l } = o.content.findIndex(s)
                , c = s - l;
            if (r.push(o, a, i + l),
                !c || (o = o.child(a),
                    o.isText))
                break;
            s = c - 1,
                i += l + 1
        }
        return new Lc(n, r, s)
    }
    static resolveCached(e, n) {
        let r = w_.get(e);
        if (r)
            for (let s = 0; s < r.elts.length; s++) {
                let o = r.elts[s];
                if (o.pos == n)
                    return o
            }
        else
            w_.set(e, r = new R7);
        let i = r.elts[r.i] = Lc.resolve(e, n);
        return r.i = (r.i + 1) % P7,
            i
    }
}
class R7 {
    constructor() {
        this.elts = [],
            this.i = 0
    }
}
const P7 = 12
    , w_ = new WeakMap;
class qh {
    constructor(e, n, r) {
        this.$from = e,
            this.$to = n,
            this.depth = r
    }
    get start() {
        return this.$from.before(this.depth + 1)
    }
    get end() {
        return this.$to.after(this.depth + 1)
    }
    get parent() {
        return this.$from.node(this.depth)
    }
    get startIndex() {
        return this.$from.index(this.depth)
    }
    get endIndex() {
        return this.$to.indexAfter(this.depth)
    }
}
const N7 = Object.create(null);
let _a = class N1 {
    constructor(e, n, r, i = zt.none) {
        this.type = e,
            this.attrs = n,
            this.marks = i,
            this.content = r || se.empty
    }
    get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size
    }
    get childCount() {
        return this.content.childCount
    }
    child(e) {
        return this.content.child(e)
    }
    maybeChild(e) {
        return this.content.maybeChild(e)
    }
    forEach(e) {
        this.content.forEach(e)
    }
    nodesBetween(e, n, r, i = 0) {
        this.content.nodesBetween(e, n, r, i, this)
    }
    descendants(e) {
        this.nodesBetween(0, this.content.size, e)
    }
    get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "")
    }
    textBetween(e, n, r, i) {
        return this.content.textBetween(e, n, r, i)
    }
    get firstChild() {
        return this.content.firstChild
    }
    get lastChild() {
        return this.content.lastChild
    }
    eq(e) {
        return this == e || this.sameMarkup(e) && this.content.eq(e.content)
    }
    sameMarkup(e) {
        return this.hasMarkup(e.type, e.attrs, e.marks)
    }
    hasMarkup(e, n, r) {
        return this.type == e && Wh(this.attrs, n || e.defaultAttrs || N7) && zt.sameSet(this.marks, r || zt.none)
    }
    copy(e = null) {
        return e == this.content ? this : new N1(this.type, this.attrs, e, this.marks)
    }
    mark(e) {
        return e == this.marks ? this : new N1(this.type, this.attrs, this.content, e)
    }
    cut(e, n = this.content.size) {
        return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n))
    }
    slice(e, n = this.content.size, r = !1) {
        if (e == n)
            return ve.empty;
        let i = this.resolve(e)
            , s = this.resolve(n)
            , o = r ? 0 : i.sharedDepth(n)
            , a = i.start(o)
            , c = i.node(o).content.cut(i.pos - a, s.pos - a);
        return new ve(c, i.depth - o, s.depth - o)
    }
    replace(e, n, r) {
        return O7(this.resolve(e), this.resolve(n), r)
    }
    nodeAt(e) {
        for (let n = this; ;) {
            let { index: r, offset: i } = n.content.findIndex(e);
            if (n = n.maybeChild(r),
                !n)
                return null;
            if (i == e || n.isText)
                return n;
            e -= i + 1
        }
    }
    childAfter(e) {
        let { index: n, offset: r } = this.content.findIndex(e);
        return {
            node: this.content.maybeChild(n),
            index: n,
            offset: r
        }
    }
    childBefore(e) {
        if (e == 0)
            return {
                node: null,
                index: 0,
                offset: 0
            };
        let { index: n, offset: r } = this.content.findIndex(e);
        if (r < e)
            return {
                node: this.content.child(n),
                index: n,
                offset: r
            };
        let i = this.content.child(n - 1);
        return {
            node: i,
            index: n - 1,
            offset: r - i.nodeSize
        }
    }
    resolve(e) {
        return Lc.resolveCached(this, e)
    }
    resolveNoCache(e) {
        return Lc.resolve(this, e)
    }
    rangeHasMark(e, n, r) {
        let i = !1;
        return n > e && this.nodesBetween(e, n, s => (r.isInSet(s.marks) && (i = !0),
            !i)),
            i
    }
    get isBlock() {
        return this.type.isBlock
    }
    get isTextblock() {
        return this.type.isTextblock
    }
    get inlineContent() {
        return this.type.inlineContent
    }
    get isInline() {
        return this.type.isInline
    }
    get isText() {
        return this.type.isText
    }
    get isLeaf() {
        return this.type.isLeaf
    }
    get isAtom() {
        return this.type.isAtom
    }
    toString() {
        if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
        let e = this.type.name;
        return this.content.size && (e += "(" + this.content.toStringInner() + ")"),
            RE(this.marks, e)
    }
    contentMatchAt(e) {
        let n = this.type.contentMatch.matchFragment(this.content, 0, e);
        if (!n)
            throw new Error("Called contentMatchAt on a node with invalid content");
        return n
    }
    canReplace(e, n, r = se.empty, i = 0, s = r.childCount) {
        let o = this.contentMatchAt(e).matchFragment(r, i, s)
            , a = o && o.matchFragment(this.content, n);
        if (!a || !a.validEnd)
            return !1;
        for (let l = i; l < s; l++)
            if (!this.type.allowsMarks(r.child(l).marks))
                return !1;
        return !0
    }
    canReplaceWith(e, n, r, i) {
        if (i && !this.type.allowsMarks(i))
            return !1;
        let s = this.contentMatchAt(e).matchType(r)
            , o = s && s.matchFragment(this.content, n);
        return o ? o.validEnd : !1
    }
    canAppend(e) {
        return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type)
    }
    check() {
        this.type.checkContent(this.content),
            this.type.checkAttrs(this.attrs);
        let e = zt.none;
        for (let n = 0; n < this.marks.length; n++) {
            let r = this.marks[n];
            r.type.checkAttrs(r.attrs),
                e = r.addToSet(e)
        }
        if (!zt.sameSet(e, this.marks))
            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(n => n.type.name)}`);
        this.content.forEach(n => n.check())
    }
    toJSON() {
        let e = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            e.attrs = this.attrs;
            break
        }
        return this.content.size && (e.content = this.content.toJSON()),
            this.marks.length && (e.marks = this.marks.map(n => n.toJSON())),
            e
    }
    static fromJSON(e, n) {
        if (!n)
            throw new RangeError("Invalid input for Node.fromJSON");
        let r;
        if (n.marks) {
            if (!Array.isArray(n.marks))
                throw new RangeError("Invalid mark data for Node.fromJSON");
            r = n.marks.map(e.markFromJSON)
        }
        if (n.type == "text") {
            if (typeof n.text != "string")
                throw new RangeError("Invalid text node in JSON");
            return e.text(n.text, r)
        }
        let i = se.fromJSON(e, n.content)
            , s = e.nodeType(n.type).create(n.attrs, i, r);
        return s.type.checkAttrs(s.attrs),
            s
    }
}
    ;
_a.prototype.text = void 0;
class Gh extends _a {
    constructor(e, n, r, i) {
        if (super(e, n, null, i),
            !r)
            throw new RangeError("Empty text nodes are not allowed");
        this.text = r
    }
    toString() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : RE(this.marks, JSON.stringify(this.text))
    }
    get textContent() {
        return this.text
    }
    textBetween(e, n) {
        return this.text.slice(e, n)
    }
    get nodeSize() {
        return this.text.length
    }
    mark(e) {
        return e == this.marks ? this : new Gh(this.type, this.attrs, this.text, e)
    }
    withText(e) {
        return e == this.text ? this : new Gh(this.type, this.attrs, e, this.marks)
    }
    cut(e = 0, n = this.text.length) {
        return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n))
    }
    eq(e) {
        return this.sameMarkup(e) && this.text == e.text
    }
    toJSON() {
        let e = super.toJSON();
        return e.text = this.text,
            e
    }
}
function RE(t, e) {
    for (let n = t.length - 1; n >= 0; n--)
        e = t[n].type.name + "(" + e + ")";
    return e
}
class La {
    constructor(e) {
        this.validEnd = e,
            this.next = [],
            this.wrapCache = []
    }
    static parse(e, n) {
        let r = new I7(e, n);
        if (r.next == null)
            return La.empty;
        let i = PE(r);
        r.next && r.err("Unexpected trailing text");
        let s = F7(z7(i));
        return H7(s, r),
            s
    }
    matchType(e) {
        for (let n = 0; n < this.next.length; n++)
            if (this.next[n].type == e)
                return this.next[n].next;
        return null
    }
    matchFragment(e, n = 0, r = e.childCount) {
        let i = this;
        for (let s = n; i && s < r; s++)
            i = i.matchType(e.child(s).type);
        return i
    }
    get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline
    }
    get defaultType() {
        for (let e = 0; e < this.next.length; e++) {
            let { type: n } = this.next[e];
            if (!(n.isText || n.hasRequiredAttrs()))
                return n
        }
        return null
    }
    compatible(e) {
        for (let n = 0; n < this.next.length; n++)
            for (let r = 0; r < e.next.length; r++)
                if (this.next[n].type == e.next[r].type)
                    return !0;
        return !1
    }
    fillBefore(e, n = !1, r = 0) {
        let i = [this];
        function s(o, a) {
            let l = o.matchFragment(e, r);
            if (l && (!n || l.validEnd))
                return se.from(a.map(c => c.createAndFill()));
            for (let c = 0; c < o.next.length; c++) {
                let { type: d, next: h } = o.next[c];
                if (!(d.isText || d.hasRequiredAttrs()) && i.indexOf(h) == -1) {
                    i.push(h);
                    let p = s(h, a.concat(d));
                    if (p)
                        return p
                }
            }
            return null
        }
        return s(this, [])
    }
    findWrapping(e) {
        for (let r = 0; r < this.wrapCache.length; r += 2)
            if (this.wrapCache[r] == e)
                return this.wrapCache[r + 1];
        let n = this.computeWrapping(e);
        return this.wrapCache.push(e, n),
            n
    }
    computeWrapping(e) {
        let n = Object.create(null)
            , r = [{
                match: this,
                type: null,
                via: null
            }];
        for (; r.length;) {
            let i = r.shift()
                , s = i.match;
            if (s.matchType(e)) {
                let o = [];
                for (let a = i; a.type; a = a.via)
                    o.push(a.type);
                return o.reverse()
            }
            for (let o = 0; o < s.next.length; o++) {
                let { type: a, next: l } = s.next[o];
                !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || l.validEnd) && (r.push({
                    match: a.contentMatch,
                    type: a,
                    via: i
                }),
                    n[a.name] = !0)
            }
        }
        return null
    }
    get edgeCount() {
        return this.next.length
    }
    edge(e) {
        if (e >= this.next.length)
            throw new RangeError(`There's no ${e}th edge in this content match`);
        return this.next[e]
    }
    toString() {
        let e = [];
        function n(r) {
            e.push(r);
            for (let i = 0; i < r.next.length; i++)
                e.indexOf(r.next[i].next) == -1 && n(r.next[i].next)
        }
        return n(this),
            e.map((r, i) => {
                let s = i + (r.validEnd ? "*" : " ") + " ";
                for (let o = 0; o < r.next.length; o++)
                    s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
                return s
            }
            ).join(`
`)
    }
}
La.empty = new La(!0);
class I7 {
    constructor(e, n) {
        this.string = e,
            this.nodeTypes = n,
            this.inline = null,
            this.pos = 0,
            this.tokens = e.split(/\s*(?=\b|\W|$)/),
            this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
            this.tokens[0] == "" && this.tokens.shift()
    }
    get next() {
        return this.tokens[this.pos]
    }
    eat(e) {
        return this.next == e && (this.pos++ || !0)
    }
    err(e) {
        throw new SyntaxError(e + " (in content expression '" + this.string + "')")
    }
}
function PE(t) {
    let e = [];
    do
        e.push(L7(t));
    while (t.eat("|"));
    return e.length == 1 ? e[0] : {
        type: "choice",
        exprs: e
    }
}
function L7(t) {
    let e = [];
    do
        e.push(D7(t));
    while (t.next && t.next != ")" && t.next != "|");
    return e.length == 1 ? e[0] : {
        type: "seq",
        exprs: e
    }
}
function D7(t) {
    let e = $7(t);
    for (; ;)
        if (t.eat("+"))
            e = {
                type: "plus",
                expr: e
            };
        else if (t.eat("*"))
            e = {
                type: "star",
                expr: e
            };
        else if (t.eat("?"))
            e = {
                type: "opt",
                expr: e
            };
        else if (t.eat("{"))
            e = j7(t, e);
        else
            break;
    return e
}
function x_(t) {
    /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
    let e = Number(t.next);
    return t.pos++,
        e
}
function j7(t, e) {
    let n = x_(t)
        , r = n;
    return t.eat(",") && (t.next != "}" ? r = x_(t) : r = -1),
        t.eat("}") || t.err("Unclosed braced range"),
    {
        type: "range",
        min: n,
        max: r,
        expr: e
    }
}
function B7(t, e) {
    let n = t.nodeTypes
        , r = n[e];
    if (r)
        return [r];
    let i = [];
    for (let s in n) {
        let o = n[s];
        o.groups.indexOf(e) > -1 && i.push(o)
    }
    return i.length == 0 && t.err("No node type or group '" + e + "' found"),
        i
}
function $7(t) {
    if (t.eat("(")) {
        let e = PE(t);
        return t.eat(")") || t.err("Missing closing paren"),
            e
    } else if (/\W/.test(t.next))
        t.err("Unexpected token '" + t.next + "'");
    else {
        let e = B7(t, t.next).map(n => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"),
        {
            type: "name",
            value: n
        }));
        return t.pos++,
            e.length == 1 ? e[0] : {
                type: "choice",
                exprs: e
            }
    }
}
function z7(t) {
    let e = [[]];
    return i(s(t, 0), n()),
        e;
    function n() {
        return e.push([]) - 1
    }
    function r(o, a, l) {
        let c = {
            term: l,
            to: a
        };
        return e[o].push(c),
            c
    }
    function i(o, a) {
        o.forEach(l => l.to = a)
    }
    function s(o, a) {
        if (o.type == "choice")
            return o.exprs.reduce((l, c) => l.concat(s(c, a)), []);
        if (o.type == "seq")
            for (let l = 0; ; l++) {
                let c = s(o.exprs[l], a);
                if (l == o.exprs.length - 1)
                    return c;
                i(c, a = n())
            }
        else if (o.type == "star") {
            let l = n();
            return r(a, l),
                i(s(o.expr, l), l),
                [r(l)]
        } else if (o.type == "plus") {
            let l = n();
            return i(s(o.expr, a), l),
                i(s(o.expr, l), l),
                [r(l)]
        } else {
            if (o.type == "opt")
                return [r(a)].concat(s(o.expr, a));
            if (o.type == "range") {
                let l = a;
                for (let c = 0; c < o.min; c++) {
                    let d = n();
                    i(s(o.expr, l), d),
                        l = d
                }
                if (o.max == -1)
                    i(s(o.expr, l), l);
                else
                    for (let c = o.min; c < o.max; c++) {
                        let d = n();
                        r(l, d),
                            i(s(o.expr, l), d),
                            l = d
                    }
                return [r(l)]
            } else {
                if (o.type == "name")
                    return [r(a, void 0, o.value)];
                throw new Error("Unknown expr type")
            }
        }
    }
}
function NE(t, e) {
    return e - t
}
function __(t, e) {
    let n = [];
    return r(e),
        n.sort(NE);
    function r(i) {
        let s = t[i];
        if (s.length == 1 && !s[0].term)
            return r(s[0].to);
        n.push(i);
        for (let o = 0; o < s.length; o++) {
            let { term: a, to: l } = s[o];
            !a && n.indexOf(l) == -1 && r(l)
        }
    }
}
function F7(t) {
    let e = Object.create(null);
    return n(__(t, 0));
    function n(r) {
        let i = [];
        r.forEach(o => {
            t[o].forEach(({ term: a, to: l }) => {
                if (!a)
                    return;
                let c;
                for (let d = 0; d < i.length; d++)
                    i[d][0] == a && (c = i[d][1]);
                __(t, l).forEach(d => {
                    c || i.push([a, c = []]),
                        c.indexOf(d) == -1 && c.push(d)
                }
                )
            }
            )
        }
        );
        let s = e[r.join(",")] = new La(r.indexOf(t.length - 1) > -1);
        for (let o = 0; o < i.length; o++) {
            let a = i[o][1].sort(NE);
            s.next.push({
                type: i[o][0],
                next: e[a.join(",")] || n(a)
            })
        }
        return s
    }
}
function H7(t, e) {
    for (let n = 0, r = [t]; n < r.length; n++) {
        let i = r[n]
            , s = !i.validEnd
            , o = [];
        for (let a = 0; a < i.next.length; a++) {
            let { type: l, next: c } = i.next[a];
            o.push(l.name),
                s && !(l.isText || l.hasRequiredAttrs()) && (s = !1),
                r.indexOf(c) == -1 && r.push(c)
        }
        s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)")
    }
}
function IE(t) {
    let e = Object.create(null);
    for (let n in t) {
        let r = t[n];
        if (!r.hasDefault)
            return null;
        e[n] = r.default
    }
    return e
}
function LE(t, e) {
    let n = Object.create(null);
    for (let r in t) {
        let i = e && e[r];
        if (i === void 0) {
            let s = t[r];
            if (s.hasDefault)
                i = s.default;
            else
                throw new RangeError("No value supplied for attribute " + r)
        }
        n[r] = i
    }
    return n
}
function DE(t, e, n, r) {
    for (let i in e)
        if (!(i in t))
            throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
    for (let i in t) {
        let s = t[i];
        s.validate && s.validate(e[i])
    }
}
function jE(t, e) {
    let n = Object.create(null);
    if (e)
        for (let r in e)
            n[r] = new W7(t, r, e[r]);
    return n
}
let S_ = class BE {
    constructor(e, n, r) {
        this.name = e,
            this.schema = n,
            this.spec = r,
            this.markSet = null,
            this.groups = r.group ? r.group.split(" ") : [],
            this.attrs = jE(e, r.attrs),
            this.defaultAttrs = IE(this.attrs),
            this.contentMatch = null,
            this.inlineContent = null,
            this.isBlock = !(r.inline || e == "text"),
            this.isText = e == "text"
    }
    get isInline() {
        return !this.isBlock
    }
    get isTextblock() {
        return this.isBlock && this.inlineContent
    }
    get isLeaf() {
        return this.contentMatch == La.empty
    }
    get isAtom() {
        return this.isLeaf || !!this.spec.atom
    }
    get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal")
    }
    hasRequiredAttrs() {
        for (let e in this.attrs)
            if (this.attrs[e].isRequired)
                return !0;
        return !1
    }
    compatibleContent(e) {
        return this == e || this.contentMatch.compatible(e.contentMatch)
    }
    computeAttrs(e) {
        return !e && this.defaultAttrs ? this.defaultAttrs : LE(this.attrs, e)
    }
    create(e = null, n, r) {
        if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
        return new _a(this, this.computeAttrs(e), se.from(n), zt.setFrom(r))
    }
    createChecked(e = null, n, r) {
        return n = se.from(n),
            this.checkContent(n),
            new _a(this, this.computeAttrs(e), n, zt.setFrom(r))
    }
    createAndFill(e = null, n, r) {
        if (e = this.computeAttrs(e),
            n = se.from(n),
            n.size) {
            let o = this.contentMatch.fillBefore(n);
            if (!o)
                return null;
            n = o.append(n)
        }
        let i = this.contentMatch.matchFragment(n)
            , s = i && i.fillBefore(se.empty, !0);
        return s ? new _a(this, e, n.append(s), zt.setFrom(r)) : null
    }
    validContent(e) {
        let n = this.contentMatch.matchFragment(e);
        if (!n || !n.validEnd)
            return !1;
        for (let r = 0; r < e.childCount; r++)
            if (!this.allowsMarks(e.child(r).marks))
                return !1;
        return !0
    }
    checkContent(e) {
        if (!this.validContent(e))
            throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`)
    }
    checkAttrs(e) {
        DE(this.attrs, e, "node", this.name)
    }
    allowsMarkType(e) {
        return this.markSet == null || this.markSet.indexOf(e) > -1
    }
    allowsMarks(e) {
        if (this.markSet == null)
            return !0;
        for (let n = 0; n < e.length; n++)
            if (!this.allowsMarkType(e[n].type))
                return !1;
        return !0
    }
    allowedMarks(e) {
        if (this.markSet == null)
            return e;
        let n;
        for (let r = 0; r < e.length; r++)
            this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
        return n ? n.length ? n : zt.none : e
    }
    static compile(e, n) {
        let r = Object.create(null);
        e.forEach((s, o) => r[s] = new BE(s, n, o));
        let i = n.spec.topNode || "doc";
        if (!r[i])
            throw new RangeError("Schema is missing its top node type ('" + i + "')");
        if (!r.text)
            throw new RangeError("Every schema needs a 'text' type");
        for (let s in r.text.attrs)
            throw new RangeError("The text node type should not have attributes");
        return r
    }
}
    ;
function V7(t, e, n) {
    let r = n.split("|");
    return i => {
        let s = i === null ? "null" : typeof i;
        if (r.indexOf(s) < 0)
            throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${s}`)
    }
}
class W7 {
    constructor(e, n, r) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"),
            this.default = r.default,
            this.validate = typeof r.validate == "string" ? V7(e, n, r.validate) : r.validate
    }
    get isRequired() {
        return !this.hasDefault
    }
}
class ym {
    constructor(e, n, r, i) {
        this.name = e,
            this.rank = n,
            this.schema = r,
            this.spec = i,
            this.attrs = jE(e, i.attrs),
            this.excluded = null;
        let s = IE(this.attrs);
        this.instance = s ? new zt(this, s) : null
    }
    create(e = null) {
        return !e && this.instance ? this.instance : new zt(this, LE(this.attrs, e))
    }
    static compile(e, n) {
        let r = Object.create(null)
            , i = 0;
        return e.forEach((s, o) => r[s] = new ym(s, i++, n, o)),
            r
    }
    removeFromSet(e) {
        for (var n = 0; n < e.length; n++)
            e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)),
                n--);
        return e
    }
    isInSet(e) {
        for (let n = 0; n < e.length; n++)
            if (e[n].type == this)
                return e[n]
    }
    checkAttrs(e) {
        DE(this.attrs, e, "mark", this.name)
    }
    excludes(e) {
        return this.excluded.indexOf(e) > -1
    }
}
class $E {
    constructor(e) {
        this.linebreakReplacement = null,
            this.cached = Object.create(null);
        let n = this.spec = {};
        for (let i in e)
            n[i] = e[i];
        n.nodes = Ln.from(e.nodes),
            n.marks = Ln.from(e.marks || {}),
            this.nodes = S_.compile(this.spec.nodes, this),
            this.marks = ym.compile(this.spec.marks, this);
        let r = Object.create(null);
        for (let i in this.nodes) {
            if (i in this.marks)
                throw new RangeError(i + " can not be both a node and a mark");
            let s = this.nodes[i]
                , o = s.spec.content || ""
                , a = s.spec.marks;
            if (s.contentMatch = r[o] || (r[o] = La.parse(o, this.nodes)),
                s.inlineContent = s.contentMatch.inlineContent,
                s.spec.linebreakReplacement) {
                if (this.linebreakReplacement)
                    throw new RangeError("Multiple linebreak nodes defined");
                if (!s.isInline || !s.isLeaf)
                    throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
                this.linebreakReplacement = s
            }
            s.markSet = a == "_" ? null : a ? k_(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null
        }
        for (let i in this.marks) {
            let s = this.marks[i]
                , o = s.spec.excludes;
            s.excluded = o == null ? [s] : o == "" ? [] : k_(this, o.split(" "))
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this),
            this.markFromJSON = this.markFromJSON.bind(this),
            this.topNodeType = this.nodes[this.spec.topNode || "doc"],
            this.cached.wrappings = Object.create(null)
    }
    node(e, n = null, r, i) {
        if (typeof e == "string")
            e = this.nodeType(e);
        else if (e instanceof S_) {
            if (e.schema != this)
                throw new RangeError("Node type from different schema used (" + e.name + ")")
        } else
            throw new RangeError("Invalid node type: " + e);
        return e.createChecked(n, r, i)
    }
    text(e, n) {
        let r = this.nodes.text;
        return new Gh(r, r.defaultAttrs, e, zt.setFrom(n))
    }
    mark(e, n) {
        return typeof e == "string" && (e = this.marks[e]),
            e.create(n)
    }
    nodeFromJSON(e) {
        return _a.fromJSON(this, e)
    }
    markFromJSON(e) {
        return zt.fromJSON(this, e)
    }
    nodeType(e) {
        let n = this.nodes[e];
        if (!n)
            throw new RangeError("Unknown node type: " + e);
        return n
    }
}
function k_(t, e) {
    let n = [];
    for (let r = 0; r < e.length; r++) {
        let i = e[r]
            , s = t.marks[i]
            , o = s;
        if (s)
            n.push(s);
        else
            for (let a in t.marks) {
                let l = t.marks[a];
                (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(o = l)
            }
        if (!o)
            throw new SyntaxError("Unknown mark type: '" + e[r] + "'")
    }
    return n
}
function U7(t) {
    return t.tag != null
}
function K7(t) {
    return t.style != null
}
let hc = class I1 {
    constructor(e, n) {
        this.schema = e,
            this.rules = n,
            this.tags = [],
            this.styles = [];
        let r = this.matchedStyles = [];
        n.forEach(i => {
            if (U7(i))
                this.tags.push(i);
            else if (K7(i)) {
                let s = /[^=]*/.exec(i.style)[0];
                r.indexOf(s) < 0 && r.push(s),
                    this.styles.push(i)
            }
        }
        ),
            this.normalizeLists = !this.tags.some(i => {
                if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
                    return !1;
                let s = e.nodes[i.node];
                return s.contentMatch.matchType(s)
            }
            )
    }
    parse(e, n = {}) {
        let r = new E_(this, n, !1);
        return r.addAll(e, zt.none, n.from, n.to),
            r.finish()
    }
    parseSlice(e, n = {}) {
        let r = new E_(this, n, !0);
        return r.addAll(e, zt.none, n.from, n.to),
            ve.maxOpen(r.finish())
    }
    matchTag(e, n, r) {
        for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
            let s = this.tags[i];
            if (J7(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) {
                if (s.getAttrs) {
                    let o = s.getAttrs(e);
                    if (o === !1)
                        continue;
                    s.attrs = o || void 0
                }
                return s
            }
        }
    }
    matchStyle(e, n, r, i) {
        for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
            let o = this.styles[s]
                , a = o.style;
            if (!(a.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
                if (o.getAttrs) {
                    let l = o.getAttrs(n);
                    if (l === !1)
                        continue;
                    o.attrs = l || void 0
                }
                return o
            }
        }
    }
    static schemaRules(e) {
        let n = [];
        function r(i) {
            let s = i.priority == null ? 50 : i.priority
                , o = 0;
            for (; o < n.length; o++) {
                let a = n[o];
                if ((a.priority == null ? 50 : a.priority) < s)
                    break
            }
            n.splice(o, 0, i)
        }
        for (let i in e.marks) {
            let s = e.marks[i].spec.parseDOM;
            s && s.forEach(o => {
                r(o = T_(o)),
                    o.mark || o.ignore || o.clearMark || (o.mark = i)
            }
            )
        }
        for (let i in e.nodes) {
            let s = e.nodes[i].spec.parseDOM;
            s && s.forEach(o => {
                r(o = T_(o)),
                    o.node || o.ignore || o.mark || (o.node = i)
            }
            )
        }
        return n
    }
    static fromSchema(e) {
        return e.cached.domParser || (e.cached.domParser = new I1(e, I1.schemaRules(e)))
    }
}
    ;
const zE = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
}
    , q7 = {
        head: !0,
        noscript: !0,
        object: !0,
        script: !0,
        style: !0,
        title: !0
    }
    , FE = {
        ol: !0,
        ul: !0
    }
    , Jh = 1
    , Zh = 2
    , pc = 4;
function C_(t, e, n) {
    return e != null ? (e ? Jh : 0) | (e === "full" ? Zh : 0) : t && t.whitespace == "pre" ? Jh | Zh : n & ~pc
}
class zf {
    constructor(e, n, r, i, s, o) {
        this.type = e,
            this.attrs = n,
            this.marks = r,
            this.solid = i,
            this.options = o,
            this.content = [],
            this.activeMarks = zt.none,
            this.match = s || (o & pc ? null : e.contentMatch)
    }
    findWrapping(e) {
        if (!this.match) {
            if (!this.type)
                return [];
            let n = this.type.contentMatch.fillBefore(se.from(e));
            if (n)
                this.match = this.type.contentMatch.matchFragment(n);
            else {
                let r = this.type.contentMatch, i;
                return (i = r.findWrapping(e.type)) ? (this.match = r,
                    i) : null
            }
        }
        return this.match.findWrapping(e.type)
    }
    finish(e) {
        if (!(this.options & Jh)) {
            let r = this.content[this.content.length - 1], i;
            if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
                let s = r;
                r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length))
            }
        }
        let n = se.from(this.content);
        return !e && this.match && (n = n.append(this.match.fillBefore(se.empty, !0))),
            this.type ? this.type.create(this.attrs, n, this.marks) : n
    }
    inlineContext(e) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !zE.hasOwnProperty(e.parentNode.nodeName.toLowerCase())
    }
}
class E_ {
    constructor(e, n, r) {
        this.parser = e,
            this.options = n,
            this.isOpen = r,
            this.open = 0;
        let i = n.topNode, s, o = C_(null, n.preserveWhitespace, 0) | (r ? pc : 0);
        i ? s = new zf(i.type, i.attrs, zt.none, !0, n.topMatch || i.type.contentMatch, o) : r ? s = new zf(null, null, zt.none, !0, null, o) : s = new zf(e.schema.topNodeType, null, zt.none, !0, null, o),
            this.nodes = [s],
            this.find = n.findPositions,
            this.needsBlock = !1
    }
    get top() {
        return this.nodes[this.open]
    }
    addDOM(e, n) {
        e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n)
    }
    addTextNode(e, n) {
        let r = e.nodeValue
            , i = this.top;
        if (i.options & Zh || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
            if (i.options & Jh)
                i.options & Zh ? r = r.replace(/\r\n?/g, `
`) : r = r.replace(/\r?\n|\r/g, " ");
            else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "),
                /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
                let s = i.content[i.content.length - 1]
                    , o = e.previousSibling;
                (!s || o && o.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (r = r.slice(1))
            }
            r && this.insertNode(this.parser.schema.text(r), n),
                this.findInText(e)
        } else
            this.findInside(e)
    }
    addElement(e, n, r) {
        let i = e.nodeName.toLowerCase(), s;
        FE.hasOwnProperty(i) && this.parser.normalizeLists && G7(e);
        let o = this.options.ruleFromNode && this.options.ruleFromNode(e) || (s = this.parser.matchTag(e, this, r));
        if (o ? o.ignore : q7.hasOwnProperty(i))
            this.findInside(e),
                this.ignoreFallback(e, n);
        else if (!o || o.skip || o.closeParent) {
            o && o.closeParent ? this.open = Math.max(0, this.open - 1) : o && o.skip.nodeType && (e = o.skip);
            let a, l = this.top, c = this.needsBlock;
            if (zE.hasOwnProperty(i))
                l.content.length && l.content[0].isInline && this.open && (this.open--,
                    l = this.top),
                    a = !0,
                    l.type || (this.needsBlock = !0);
            else if (!e.firstChild) {
                this.leafFallback(e, n);
                return
            }
            let d = o && o.skip ? n : this.readStyles(e, n);
            d && this.addAll(e, d),
                a && this.sync(l),
                this.needsBlock = c
        } else {
            let a = this.readStyles(e, n);
            a && this.addElementByRule(e, o, a, o.consuming === !1 ? s : void 0)
        }
    }
    leafFallback(e, n) {
        e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n)
    }
    ignoreFallback(e, n) {
        e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n)
    }
    readStyles(e, n) {
        let r = e.style;
        if (r && r.length)
            for (let i = 0; i < this.parser.matchedStyles.length; i++) {
                let s = this.parser.matchedStyles[i]
                    , o = r.getPropertyValue(s);
                if (o)
                    for (let a = void 0; ;) {
                        let l = this.parser.matchStyle(s, o, this, a);
                        if (!l)
                            break;
                        if (l.ignore)
                            return null;
                        if (l.clearMark ? n = n.filter(c => !l.clearMark(c)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)),
                            l.consuming === !1)
                            a = l;
                        else
                            break
                    }
            }
        return n
    }
    addElementByRule(e, n, r, i) {
        let s, o;
        if (n.node)
            if (o = this.parser.schema.nodes[n.node],
                o.isLeaf)
                this.insertNode(o.create(n.attrs), r) || this.leafFallback(e, r);
            else {
                let l = this.enter(o, n.attrs || null, r, n.preserveWhitespace);
                l && (s = !0,
                    r = l)
            }
        else {
            let l = this.parser.schema.marks[n.mark];
            r = r.concat(l.create(n.attrs))
        }
        let a = this.top;
        if (o && o.isLeaf)
            this.findInside(e);
        else if (i)
            this.addElement(e, r, i);
        else if (n.getContent)
            this.findInside(e),
                n.getContent(e, this.parser.schema).forEach(l => this.insertNode(l, r));
        else {
            let l = e;
            typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement),
                this.findAround(e, l, !0),
                this.addAll(l, r)
        }
        s && this.sync(a) && this.open--
    }
    addAll(e, n, r, i) {
        let s = r || 0;
        for (let o = r ? e.childNodes[r] : e.firstChild, a = i == null ? null : e.childNodes[i]; o != a; o = o.nextSibling,
            ++s)
            this.findAtPoint(e, s),
                this.addDOM(o, n);
        this.findAtPoint(e, s)
    }
    findPlace(e, n) {
        let r, i;
        for (let s = this.open; s >= 0; s--) {
            let o = this.nodes[s]
                , a = o.findWrapping(e);
            if (a && (!r || r.length > a.length) && (r = a,
                i = o,
                !a.length) || o.solid)
                break
        }
        if (!r)
            return null;
        this.sync(i);
        for (let s = 0; s < r.length; s++)
            n = this.enterInner(r[s], null, n, !1);
        return n
    }
    insertNode(e, n) {
        if (e.isInline && this.needsBlock && !this.top.type) {
            let i = this.textblockFromContext();
            i && (n = this.enterInner(i, null, n))
        }
        let r = this.findPlace(e, n);
        if (r) {
            this.closeExtra();
            let i = this.top;
            i.match && (i.match = i.match.matchType(e.type));
            let s = zt.none;
            for (let o of r.concat(e.marks))
                (i.type ? i.type.allowsMarkType(o.type) : A_(o.type, e.type)) && (s = o.addToSet(s));
            return i.content.push(e.mark(s)),
                !0
        }
        return !1
    }
    enter(e, n, r, i) {
        let s = this.findPlace(e.create(n), r);
        return s && (s = this.enterInner(e, n, r, !0, i)),
            s
    }
    enterInner(e, n, r, i = !1, s) {
        this.closeExtra();
        let o = this.top;
        o.match = o.match && o.match.matchType(e);
        let a = C_(e, s, o.options);
        o.options & pc && o.content.length == 0 && (a |= pc);
        let l = zt.none;
        return r = r.filter(c => (o.type ? o.type.allowsMarkType(c.type) : A_(c.type, e)) ? (l = c.addToSet(l),
            !1) : !0),
            this.nodes.push(new zf(e, n, l, i, null, a)),
            this.open++,
            r
    }
    closeExtra(e = !1) {
        let n = this.nodes.length - 1;
        if (n > this.open) {
            for (; n > this.open; n--)
                this.nodes[n - 1].content.push(this.nodes[n].finish(e));
            this.nodes.length = this.open + 1
        }
    }
    finish() {
        return this.open = 0,
            this.closeExtra(this.isOpen),
            this.nodes[0].finish(this.isOpen || this.options.topOpen)
    }
    sync(e) {
        for (let n = this.open; n >= 0; n--)
            if (this.nodes[n] == e)
                return this.open = n,
                    !0;
        return !1
    }
    get currentPos() {
        this.closeExtra();
        let e = 0;
        for (let n = this.open; n >= 0; n--) {
            let r = this.nodes[n].content;
            for (let i = r.length - 1; i >= 0; i--)
                e += r[i].nodeSize;
            n && e++
        }
        return e
    }
    findAtPoint(e, n) {
        if (this.find)
            for (let r = 0; r < this.find.length; r++)
                this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos)
    }
    findInside(e) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos)
    }
    findAround(e, n, r) {
        if (e != n && this.find)
            for (let i = 0; i < this.find.length; i++)
                this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos)
    }
    findInText(e) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset))
    }
    matchesContext(e) {
        if (e.indexOf("|") > -1)
            return e.split(/\s*\|\s*/).some(this.matchesContext, this);
        let n = e.split("/")
            , r = this.options.context
            , i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type)
            , s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1)
            , o = (a, l) => {
                for (; a >= 0; a--) {
                    let c = n[a];
                    if (c == "") {
                        if (a == n.length - 1 || a == 0)
                            continue;
                        for (; l >= s; l--)
                            if (o(a - 1, l))
                                return !0;
                        return !1
                    } else {
                        let d = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= s ? r.node(l - s).type : null;
                        if (!d || d.name != c && d.groups.indexOf(c) == -1)
                            return !1;
                        l--
                    }
                }
                return !0
            }
            ;
        return o(n.length - 1, this.open)
    }
    textblockFromContext() {
        let e = this.options.context;
        if (e)
            for (let n = e.depth; n >= 0; n--) {
                let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
                if (r && r.isTextblock && r.defaultAttrs)
                    return r
            }
        for (let n in this.parser.schema.nodes) {
            let r = this.parser.schema.nodes[n];
            if (r.isTextblock && r.defaultAttrs)
                return r
        }
    }
}
function G7(t) {
    for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
        let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
        r && FE.hasOwnProperty(r) && n ? (n.appendChild(e),
            e = n) : r == "li" ? n = e : r && (n = null)
    }
}
function J7(t, e) {
    return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e)
}
function T_(t) {
    let e = {};
    for (let n in t)
        e[n] = t[n];
    return e
}
function A_(t, e) {
    let n = e.schema.nodes;
    for (let r in n) {
        let i = n[r];
        if (!i.allowsMarkType(t))
            continue;
        let s = []
            , o = a => {
                s.push(a);
                for (let l = 0; l < a.edgeCount; l++) {
                    let { type: c, next: d } = a.edge(l);
                    if (c == e || s.indexOf(d) < 0 && o(d))
                        return !0
                }
            }
            ;
        if (o(i.contentMatch))
            return !0
    }
}
class Ka {
    constructor(e, n) {
        this.nodes = e,
            this.marks = n
    }
    serializeFragment(e, n = {}, r) {
        r || (r = x0(n).createDocumentFragment());
        let i = r
            , s = [];
        return e.forEach(o => {
            if (s.length || o.marks.length) {
                let a = 0
                    , l = 0;
                for (; a < s.length && l < o.marks.length;) {
                    let c = o.marks[l];
                    if (!this.marks[c.type.name]) {
                        l++;
                        continue
                    }
                    if (!c.eq(s[a][0]) || c.type.spec.spanning === !1)
                        break;
                    a++,
                        l++
                }
                for (; a < s.length;)
                    i = s.pop()[1];
                for (; l < o.marks.length;) {
                    let c = o.marks[l++]
                        , d = this.serializeMark(c, o.isInline, n);
                    d && (s.push([c, i]),
                        i.appendChild(d.dom),
                        i = d.contentDOM || d.dom)
                }
            }
            i.appendChild(this.serializeNodeInner(o, n))
        }
        ),
            r
    }
    serializeNodeInner(e, n) {
        let { dom: r, contentDOM: i } = dh(x0(n), this.nodes[e.type.name](e), null, e.attrs);
        if (i) {
            if (e.isLeaf)
                throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(e.content, n, i)
        }
        return r
    }
    serializeNode(e, n = {}) {
        let r = this.serializeNodeInner(e, n);
        for (let i = e.marks.length - 1; i >= 0; i--) {
            let s = this.serializeMark(e.marks[i], e.isInline, n);
            s && ((s.contentDOM || s.dom).appendChild(r),
                r = s.dom)
        }
        return r
    }
    serializeMark(e, n, r = {}) {
        let i = this.marks[e.type.name];
        return i && dh(x0(r), i(e, n), null, e.attrs)
    }
    static renderSpec(e, n, r = null, i) {
        return dh(e, n, r, i)
    }
    static fromSchema(e) {
        return e.cached.domSerializer || (e.cached.domSerializer = new Ka(this.nodesFromSchema(e), this.marksFromSchema(e)))
    }
    static nodesFromSchema(e) {
        let n = O_(e.nodes);
        return n.text || (n.text = r => r.text),
            n
    }
    static marksFromSchema(e) {
        return O_(e.marks)
    }
}
function O_(t) {
    let e = {};
    for (let n in t) {
        let r = t[n].spec.toDOM;
        r && (e[n] = r)
    }
    return e
}
function x0(t) {
    return t.document || window.document
}
const M_ = new WeakMap;
function Z7(t) {
    let e = M_.get(t);
    return e === void 0 && M_.set(t, e = Y7(t)),
        e
}
function Y7(t) {
    let e = null;
    function n(r) {
        if (r && typeof r == "object")
            if (Array.isArray(r))
                if (typeof r[0] == "string")
                    e || (e = []),
                        e.push(r);
                else
                    for (let i = 0; i < r.length; i++)
                        n(r[i]);
            else
                for (let i in r)
                    n(r[i])
    }
    return n(t),
        e
}
function dh(t, e, n, r) {
    if (typeof e == "string")
        return {
            dom: t.createTextNode(e)
        };
    if (e.nodeType != null)
        return {
            dom: e
        };
    if (e.dom && e.dom.nodeType != null)
        return e;
    let i = e[0], s;
    if (typeof i != "string")
        throw new RangeError("Invalid array passed to renderSpec");
    if (r && (s = Z7(r)) && s.indexOf(e) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    let o = i.indexOf(" ");
    o > 0 && (n = i.slice(0, o),
        i = i.slice(o + 1));
    let a, l = n ? t.createElementNS(n, i) : t.createElement(i), c = e[1], d = 1;
    if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
        d = 2;
        for (let h in c)
            if (c[h] != null) {
                let p = h.indexOf(" ");
                p > 0 ? l.setAttributeNS(h.slice(0, p), h.slice(p + 1), c[h]) : l.setAttribute(h, c[h])
            }
    }
    for (let h = d; h < e.length; h++) {
        let p = e[h];
        if (p === 0) {
            if (h < e.length - 1 || h > d)
                throw new RangeError("Content hole must be the only child of its parent node");
            return {
                dom: l,
                contentDOM: l
            }
        } else {
            let { dom: g, contentDOM: y } = dh(t, p, n, r);
            if (l.appendChild(g),
                y) {
                if (a)
                    throw new RangeError("Multiple content holes");
                a = y
            }
        }
    }
    return {
        dom: l,
        contentDOM: a
    }
}
const HE = 65535
    , VE = Math.pow(2, 16);
function X7(t, e) {
    return t + e * VE
}
function R_(t) {
    return t & HE
}
function Q7(t) {
    return (t - (t & HE)) / VE
}
const WE = 1
    , UE = 2
    , fh = 4
    , KE = 8;
class L1 {
    constructor(e, n, r) {
        this.pos = e,
            this.delInfo = n,
            this.recover = r
    }
    get deleted() {
        return (this.delInfo & KE) > 0
    }
    get deletedBefore() {
        return (this.delInfo & (WE | fh)) > 0
    }
    get deletedAfter() {
        return (this.delInfo & (UE | fh)) > 0
    }
    get deletedAcross() {
        return (this.delInfo & fh) > 0
    }
}
class Dr {
    constructor(e, n = !1) {
        if (this.ranges = e,
            this.inverted = n,
            !e.length && Dr.empty)
            return Dr.empty
    }
    recover(e) {
        let n = 0
            , r = R_(e);
        if (!this.inverted)
            for (let i = 0; i < r; i++)
                n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
        return this.ranges[r * 3] + n + Q7(e)
    }
    mapResult(e, n = 1) {
        return this._map(e, n, !1)
    }
    map(e, n = 1) {
        return this._map(e, n, !0)
    }
    _map(e, n, r) {
        let i = 0
            , s = this.inverted ? 2 : 1
            , o = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a] - (this.inverted ? i : 0);
            if (l > e)
                break;
            let c = this.ranges[a + s]
                , d = this.ranges[a + o]
                , h = l + c;
            if (e <= h) {
                let p = c ? e == l ? -1 : e == h ? 1 : n : n
                    , g = l + i + (p < 0 ? 0 : d);
                if (r)
                    return g;
                let y = e == (n < 0 ? l : h) ? null : X7(a / 3, e - l)
                    , x = e == l ? UE : e == h ? WE : fh;
                return (n < 0 ? e != l : e != h) && (x |= KE),
                    new L1(g, x, y)
            }
            i += d - c
        }
        return r ? e + i : new L1(e + i, 0, null)
    }
    touches(e, n) {
        let r = 0
            , i = R_(n)
            , s = this.inverted ? 2 : 1
            , o = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a] - (this.inverted ? r : 0);
            if (l > e)
                break;
            let c = this.ranges[a + s]
                , d = l + c;
            if (e <= d && a == i * 3)
                return !0;
            r += this.ranges[a + o] - c
        }
        return !1
    }
    forEach(e) {
        let n = this.inverted ? 2 : 1
            , r = this.inverted ? 1 : 2;
        for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
            let o = this.ranges[i]
                , a = o - (this.inverted ? s : 0)
                , l = o + (this.inverted ? 0 : s)
                , c = this.ranges[i + n]
                , d = this.ranges[i + r];
            e(a, a + c, l, l + d),
                s += d - c
        }
    }
    invert() {
        return new Dr(this.ranges, !this.inverted)
    }
    toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
    }
    static offset(e) {
        return e == 0 ? Dr.empty : new Dr(e < 0 ? [0, -e, 0] : [0, 0, e])
    }
}
Dr.empty = new Dr([]);
class $l {
    constructor(e = [], n, r = 0, i = e.length) {
        this.maps = e,
            this.mirror = n,
            this.from = r,
            this.to = i
    }
    slice(e = 0, n = this.maps.length) {
        return new $l(this.maps, this.mirror, e, n)
    }
    copy() {
        return new $l(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
    }
    appendMap(e, n) {
        this.to = this.maps.push(e),
            n != null && this.setMirror(this.maps.length - 1, n)
    }
    appendMapping(e) {
        for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
            let i = e.getMirror(n);
            this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0)
        }
    }
    getMirror(e) {
        if (this.mirror) {
            for (let n = 0; n < this.mirror.length; n++)
                if (this.mirror[n] == e)
                    return this.mirror[n + (n % 2 ? -1 : 1)]
        }
    }
    setMirror(e, n) {
        this.mirror || (this.mirror = []),
            this.mirror.push(e, n)
    }
    appendMappingInverted(e) {
        for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
            let i = e.getMirror(n);
            this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0)
        }
    }
    invert() {
        let e = new $l;
        return e.appendMappingInverted(this),
            e
    }
    map(e, n = 1) {
        if (this.mirror)
            return this._map(e, n, !0);
        for (let r = this.from; r < this.to; r++)
            e = this.maps[r].map(e, n);
        return e
    }
    mapResult(e, n = 1) {
        return this._map(e, n, !1)
    }
    _map(e, n, r) {
        let i = 0;
        for (let s = this.from; s < this.to; s++) {
            let o = this.maps[s]
                , a = o.mapResult(e, n);
            if (a.recover != null) {
                let l = this.getMirror(s);
                if (l != null && l > s && l < this.to) {
                    s = l,
                        e = this.maps[l].recover(a.recover);
                    continue
                }
            }
            i |= a.delInfo,
                e = a.pos
        }
        return r ? e : new L1(e, i, null)
    }
}
const _0 = Object.create(null);
class nr {
    getMap() {
        return Dr.empty
    }
    merge(e) {
        return null
    }
    static fromJSON(e, n) {
        if (!n || !n.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
        let r = _0[n.stepType];
        if (!r)
            throw new RangeError(`No step type ${n.stepType} defined`);
        return r.fromJSON(e, n)
    }
    static jsonID(e, n) {
        if (e in _0)
            throw new RangeError("Duplicate use of step JSON ID " + e);
        return _0[e] = n,
            n.prototype.jsonID = e,
            n
    }
}
class fn {
    constructor(e, n) {
        this.doc = e,
            this.failed = n
    }
    static ok(e) {
        return new fn(e, null)
    }
    static fail(e) {
        return new fn(null, e)
    }
    static fromReplace(e, n, r, i) {
        try {
            return fn.ok(e.replace(n, r, i))
        } catch (s) {
            if (s instanceof Uh)
                return fn.fail(s.message);
            throw s
        }
    }
}
function yv(t, e, n) {
    let r = [];
    for (let i = 0; i < t.childCount; i++) {
        let s = t.child(i);
        s.content.size && (s = s.copy(yv(s.content, e, s))),
            s.isInline && (s = e(s, n, i)),
            r.push(s)
    }
    return se.fromArray(r)
}
class bo extends nr {
    constructor(e, n, r) {
        super(),
            this.from = e,
            this.to = n,
            this.mark = r
    }
    apply(e) {
        let n = e.slice(this.from, this.to)
            , r = e.resolve(this.from)
            , i = r.node(r.sharedDepth(this.to))
            , s = new ve(yv(n.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), n.openStart, n.openEnd);
        return fn.fromReplace(e, this.from, this.to, s)
    }
    invert() {
        return new Wi(this.from, this.to, this.mark)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
            , r = e.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new bo(n.pos, r.pos, this.mark)
    }
    merge(e) {
        return e instanceof bo && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new bo(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null
    }
    toJSON() {
        return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new bo(n.from, n.to, e.markFromJSON(n.mark))
    }
}
nr.jsonID("addMark", bo);
class Wi extends nr {
    constructor(e, n, r) {
        super(),
            this.from = e,
            this.to = n,
            this.mark = r
    }
    apply(e) {
        let n = e.slice(this.from, this.to)
            , r = new ve(yv(n.content, i => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
        return fn.fromReplace(e, this.from, this.to, r)
    }
    invert() {
        return new bo(this.from, this.to, this.mark)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
            , r = e.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new Wi(n.pos, r.pos, this.mark)
    }
    merge(e) {
        return e instanceof Wi && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Wi(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null
    }
    toJSON() {
        return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new Wi(n.from, n.to, e.markFromJSON(n.mark))
    }
}
nr.jsonID("removeMark", Wi);
class wo extends nr {
    constructor(e, n) {
        super(),
            this.pos = e,
            this.mark = n
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return fn.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
        return fn.fromReplace(e, this.pos, this.pos + 1, new ve(se.from(r), 0, n.isLeaf ? 0 : 1))
    }
    invert(e) {
        let n = e.nodeAt(this.pos);
        if (n) {
            let r = this.mark.addToSet(n.marks);
            if (r.length == n.marks.length) {
                for (let i = 0; i < n.marks.length; i++)
                    if (!n.marks[i].isInSet(r))
                        return new wo(this.pos, n.marks[i]);
                return new wo(this.pos, this.mark)
            }
        }
        return new tu(this.pos, this.mark)
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new wo(n.pos, this.mark)
    }
    toJSON() {
        return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new wo(n.pos, e.markFromJSON(n.mark))
    }
}
nr.jsonID("addNodeMark", wo);
class tu extends nr {
    constructor(e, n) {
        super(),
            this.pos = e,
            this.mark = n
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return fn.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
        return fn.fromReplace(e, this.pos, this.pos + 1, new ve(se.from(r), 0, n.isLeaf ? 0 : 1))
    }
    invert(e) {
        let n = e.nodeAt(this.pos);
        return !n || !this.mark.isInSet(n.marks) ? this : new wo(this.pos, this.mark)
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new tu(n.pos, this.mark)
    }
    toJSON() {
        return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new tu(n.pos, e.markFromJSON(n.mark))
    }
}
nr.jsonID("removeNodeMark", tu);
class En extends nr {
    constructor(e, n, r, i = !1) {
        super(),
            this.from = e,
            this.to = n,
            this.slice = r,
            this.structure = i
    }
    apply(e) {
        return this.structure && D1(e, this.from, this.to) ? fn.fail("Structure replace would overwrite content") : fn.fromReplace(e, this.from, this.to, this.slice)
    }
    getMap() {
        return new Dr([this.from, this.to - this.from, this.slice.size])
    }
    invert(e) {
        return new En(this.from, this.from + this.slice.size, e.slice(this.from, this.to))
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
            , r = e.mapResult(this.to, -1);
        return n.deletedAcross && r.deletedAcross ? null : new En(n.pos, Math.max(n.pos, r.pos), this.slice)
    }
    merge(e) {
        if (!(e instanceof En) || e.structure || this.structure)
            return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
            let n = this.slice.size + e.slice.size == 0 ? ve.empty : new ve(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
            return new En(this.from, this.to + (e.to - e.from), n, this.structure)
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
            let n = this.slice.size + e.slice.size == 0 ? ve.empty : new ve(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
            return new En(e.from, this.to, n, this.structure)
        } else
            return null
    }
    toJSON() {
        let e = {
            stepType: "replace",
            from: this.from,
            to: this.to
        };
        return this.slice.size && (e.slice = this.slice.toJSON()),
            this.structure && (e.structure = !0),
            e
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new En(n.from, n.to, ve.fromJSON(e, n.slice), !!n.structure)
    }
}
nr.jsonID("replace", En);
class Tn extends nr {
    constructor(e, n, r, i, s, o, a = !1) {
        super(),
            this.from = e,
            this.to = n,
            this.gapFrom = r,
            this.gapTo = i,
            this.slice = s,
            this.insert = o,
            this.structure = a
    }
    apply(e) {
        if (this.structure && (D1(e, this.from, this.gapFrom) || D1(e, this.gapTo, this.to)))
            return fn.fail("Structure gap-replace would overwrite content");
        let n = e.slice(this.gapFrom, this.gapTo);
        if (n.openStart || n.openEnd)
            return fn.fail("Gap is not a flat range");
        let r = this.slice.insertAt(this.insert, n.content);
        return r ? fn.fromReplace(e, this.from, this.to, r) : fn.fail("Content does not fit in gap")
    }
    getMap() {
        return new Dr([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
    }
    invert(e) {
        let n = this.gapTo - this.gapFrom;
        return new Tn(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
            , r = e.mapResult(this.to, -1)
            , i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1)
            , s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
        return n.deletedAcross && r.deletedAcross || i < n.pos || s > r.pos ? null : new Tn(n.pos, r.pos, i, s, this.slice, this.insert, this.structure)
    }
    toJSON() {
        let e = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
        };
        return this.slice.size && (e.slice = this.slice.toJSON()),
            this.structure && (e.structure = !0),
            e
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new Tn(n.from, n.to, n.gapFrom, n.gapTo, ve.fromJSON(e, n.slice), n.insert, !!n.structure)
    }
}
nr.jsonID("replaceAround", Tn);
function D1(t, e, n) {
    let r = t.resolve(e)
        , i = n - e
        , s = r.depth;
    for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount;)
        s--,
            i--;
    if (i > 0) {
        let o = r.node(s).maybeChild(r.indexAfter(s));
        for (; i > 0;) {
            if (!o || o.isLeaf)
                return !0;
            o = o.firstChild,
                i--
        }
    }
    return !1
}
function ez(t, e, n, r) {
    let i = [], s = [], o, a;
    t.doc.nodesBetween(e, n, (l, c, d) => {
        if (!l.isInline)
            return;
        let h = l.marks;
        if (!r.isInSet(h) && d.type.allowsMarkType(r.type)) {
            let p = Math.max(c, e)
                , g = Math.min(c + l.nodeSize, n)
                , y = r.addToSet(h);
            for (let x = 0; x < h.length; x++)
                h[x].isInSet(y) || (o && o.to == p && o.mark.eq(h[x]) ? o.to = g : i.push(o = new Wi(p, g, h[x])));
            a && a.to == p ? a.to = g : s.push(a = new bo(p, g, r))
        }
    }
    ),
        i.forEach(l => t.step(l)),
        s.forEach(l => t.step(l))
}
function tz(t, e, n, r) {
    let i = []
        , s = 0;
    t.doc.nodesBetween(e, n, (o, a) => {
        if (!o.isInline)
            return;
        s++;
        let l = null;
        if (r instanceof ym) {
            let c = o.marks, d;
            for (; d = r.isInSet(c);)
                (l || (l = [])).push(d),
                    c = d.removeFromSet(c)
        } else
            r ? r.isInSet(o.marks) && (l = [r]) : l = o.marks;
        if (l && l.length) {
            let c = Math.min(a + o.nodeSize, n);
            for (let d = 0; d < l.length; d++) {
                let h = l[d], p;
                for (let g = 0; g < i.length; g++) {
                    let y = i[g];
                    y.step == s - 1 && h.eq(i[g].style) && (p = y)
                }
                p ? (p.to = c,
                    p.step = s) : i.push({
                        style: h,
                        from: Math.max(a, e),
                        to: c,
                        step: s
                    })
            }
        }
    }
    ),
        i.forEach(o => t.step(new Wi(o.from, o.to, o.style)))
}
function qE(t, e, n, r = n.contentMatch, i = !0) {
    let s = t.doc.nodeAt(e)
        , o = []
        , a = e + 1;
    for (let l = 0; l < s.childCount; l++) {
        let c = s.child(l)
            , d = a + c.nodeSize
            , h = r.matchType(c.type);
        if (!h)
            o.push(new En(a, d, ve.empty));
        else {
            r = h;
            for (let p = 0; p < c.marks.length; p++)
                n.allowsMarkType(c.marks[p].type) || t.step(new Wi(a, d, c.marks[p]));
            if (i && c.isText && n.whitespace != "pre") {
                let p, g = /\r?\n|\r/g, y;
                for (; p = g.exec(c.text);)
                    y || (y = new ve(se.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)),
                        o.push(new En(a + p.index, a + p.index + p[0].length, y))
            }
        }
        a = d
    }
    if (!r.validEnd) {
        let l = r.fillBefore(se.empty, !0);
        t.replace(a, a, new ve(l, 0, 0))
    }
    for (let l = o.length - 1; l >= 0; l--)
        t.step(o[l])
}
function nz(t, e, n) {
    return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n))
}
function pu(t) {
    let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
    for (let r = t.depth; ; --r) {
        let i = t.$from.node(r)
            , s = t.$from.index(r)
            , o = t.$to.indexAfter(r);
        if (r < t.depth && i.canReplace(s, o, n))
            return r;
        if (r == 0 || i.type.spec.isolating || !nz(i, s, o))
            break
    }
    return null
}
function rz(t, e, n) {
    let { $from: r, $to: i, depth: s } = e
        , o = r.before(s + 1)
        , a = i.after(s + 1)
        , l = o
        , c = a
        , d = se.empty
        , h = 0;
    for (let y = s, x = !1; y > n; y--)
        x || r.index(y) > 0 ? (x = !0,
            d = se.from(r.node(y).copy(d)),
            h++) : l--;
    let p = se.empty
        , g = 0;
    for (let y = s, x = !1; y > n; y--)
        x || i.after(y + 1) < i.end(y) ? (x = !0,
            p = se.from(i.node(y).copy(p)),
            g++) : c++;
    t.step(new Tn(l, c, o, a, new ve(d.append(p), h, g), d.size - h, !0))
}
function vv(t, e, n = null, r = t) {
    let i = iz(t, e)
        , s = i && sz(r, e);
    return s ? i.map(P_).concat({
        type: e,
        attrs: n
    }).concat(s.map(P_)) : null
}
function P_(t) {
    return {
        type: t,
        attrs: null
    }
}
function iz(t, e) {
    let { parent: n, startIndex: r, endIndex: i } = t
        , s = n.contentMatchAt(r).findWrapping(e);
    if (!s)
        return null;
    let o = s.length ? s[0] : e;
    return n.canReplaceWith(r, i, o) ? s : null
}
function sz(t, e) {
    let { parent: n, startIndex: r, endIndex: i } = t
        , s = n.child(r)
        , o = e.contentMatch.findWrapping(s.type);
    if (!o)
        return null;
    let l = (o.length ? o[o.length - 1] : e).contentMatch;
    for (let c = r; l && c < i; c++)
        l = l.matchType(n.child(c).type);
    return !l || !l.validEnd ? null : o
}
function oz(t, e, n) {
    let r = se.empty;
    for (let o = n.length - 1; o >= 0; o--) {
        if (r.size) {
            let a = n[o].type.contentMatch.matchFragment(r);
            if (!a || !a.validEnd)
                throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")
        }
        r = se.from(n[o].type.create(n[o].attrs, r))
    }
    let i = e.start
        , s = e.end;
    t.step(new Tn(i, s, i, s, new ve(r, 0, 0), n.length, !0))
}
function az(t, e, n, r, i) {
    if (!r.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
    let s = t.steps.length;
    t.doc.nodesBetween(e, n, (o, a) => {
        let l = typeof i == "function" ? i(o) : i;
        if (o.isTextblock && !o.hasMarkup(r, l) && cz(t.doc, t.mapping.slice(s).map(a), r)) {
            let c = null;
            if (r.schema.linebreakReplacement) {
                let g = r.whitespace == "pre"
                    , y = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
                g && !y ? c = !1 : !g && y && (c = !0)
            }
            c === !1 && uz(t, o, a, s),
                qE(t, t.mapping.slice(s).map(a, 1), r, void 0, c === null);
            let d = t.mapping.slice(s)
                , h = d.map(a, 1)
                , p = d.map(a + o.nodeSize, 1);
            return t.step(new Tn(h, p, h + 1, p - 1, new ve(se.from(r.create(l, null, o.marks)), 0, 0), 1, !0)),
                c === !0 && lz(t, o, a, s),
                !1
        }
    }
    )
}
function lz(t, e, n, r) {
    e.forEach((i, s) => {
        if (i.isText) {
            let o, a = /\r?\n|\r/g;
            for (; o = a.exec(i.text);) {
                let l = t.mapping.slice(r).map(n + 1 + s + o.index);
                t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create())
            }
        }
    }
    )
}
function uz(t, e, n, r) {
    e.forEach((i, s) => {
        if (i.type == i.type.schema.linebreakReplacement) {
            let o = t.mapping.slice(r).map(n + 1 + s);
            t.replaceWith(o, o + 1, e.type.schema.text(`
`))
        }
    }
    )
}
function cz(t, e, n) {
    let r = t.resolve(e)
        , i = r.index();
    return r.parent.canReplaceWith(i, i + 1, n)
}
function dz(t, e, n, r, i) {
    let s = t.doc.nodeAt(e);
    if (!s)
        throw new RangeError("No node at given position");
    n || (n = s.type);
    let o = n.create(r, null, i || s.marks);
    if (s.isLeaf)
        return t.replaceWith(e, e + s.nodeSize, o);
    if (!n.validContent(s.content))
        throw new RangeError("Invalid content for node type " + n.name);
    t.step(new Tn(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new ve(se.from(o), 0, 0), 1, !0))
}
function zl(t, e, n = 1, r) {
    let i = t.resolve(e)
        , s = i.depth - n
        , o = r && r[r.length - 1] || i.parent;
    if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
        return !1;
    for (let c = i.depth - 1, d = n - 2; c > s; c--,
        d--) {
        let h = i.node(c)
            , p = i.index(c);
        if (h.type.spec.isolating)
            return !1;
        let g = h.content.cutByIndex(p, h.childCount)
            , y = r && r[d + 1];
        y && (g = g.replaceChild(0, y.type.create(y.attrs)));
        let x = r && r[d] || h;
        if (!h.canReplace(p + 1, h.childCount) || !x.type.validContent(g))
            return !1
    }
    let a = i.indexAfter(s)
        , l = r && r[0];
    return i.node(s).canReplaceWith(a, a, l ? l.type : i.node(s + 1).type)
}
function fz(t, e, n = 1, r) {
    let i = t.doc.resolve(e)
        , s = se.empty
        , o = se.empty;
    for (let a = i.depth, l = i.depth - n, c = n - 1; a > l; a--,
        c--) {
        s = se.from(i.node(a).copy(s));
        let d = r && r[c];
        o = se.from(d ? d.type.create(d.attrs, o) : i.node(a).copy(o))
    }
    t.step(new En(e, e, new ve(s.append(o), n, n), !0))
}
function qo(t, e) {
    let n = t.resolve(e)
        , r = n.index();
    return GE(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
}
function GE(t, e) {
    return !!(t && e && !t.isLeaf && t.canAppend(e))
}
function vm(t, e, n = -1) {
    let r = t.resolve(e);
    for (let i = r.depth; ; i--) {
        let s, o, a = r.index(i);
        if (i == r.depth ? (s = r.nodeBefore,
            o = r.nodeAfter) : n > 0 ? (s = r.node(i + 1),
                a++,
                o = r.node(i).maybeChild(a)) : (s = r.node(i).maybeChild(a - 1),
                    o = r.node(i + 1)),
            s && !s.isTextblock && GE(s, o) && r.node(i).canReplace(a, a + 1))
            return e;
        if (i == 0)
            break;
        e = n < 0 ? r.before(i) : r.after(i)
    }
}
function hz(t, e, n) {
    let r = new En(e - n, e + n, ve.empty, !0);
    t.step(r)
}
function pz(t, e, n) {
    let r = t.resolve(e);
    if (r.parent.canReplaceWith(r.index(), r.index(), n))
        return e;
    if (r.parentOffset == 0)
        for (let i = r.depth - 1; i >= 0; i--) {
            let s = r.index(i);
            if (r.node(i).canReplaceWith(s, s, n))
                return r.before(i + 1);
            if (s > 0)
                return null
        }
    if (r.parentOffset == r.parent.content.size)
        for (let i = r.depth - 1; i >= 0; i--) {
            let s = r.indexAfter(i);
            if (r.node(i).canReplaceWith(s, s, n))
                return r.after(i + 1);
            if (s < r.node(i).childCount)
                return null
        }
    return null
}
function JE(t, e, n) {
    let r = t.resolve(e);
    if (!n.content.size)
        return e;
    let i = n.content;
    for (let s = 0; s < n.openStart; s++)
        i = i.firstChild.content;
    for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
        for (let o = r.depth; o >= 0; o--) {
            let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1
                , l = r.index(o) + (a > 0 ? 1 : 0)
                , c = r.node(o)
                , d = !1;
            if (s == 1)
                d = c.canReplace(l, l, i);
            else {
                let h = c.contentMatchAt(l).findWrapping(i.firstChild.type);
                d = h && c.canReplaceWith(l, l, h[0])
            }
            if (d)
                return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1)
        }
    return null
}
function bm(t, e, n = e, r = ve.empty) {
    if (e == n && !r.size)
        return null;
    let i = t.resolve(e)
        , s = t.resolve(n);
    return ZE(i, s, r) ? new En(e, n, r) : new mz(i, s, r).fit()
}
function ZE(t, e, n) {
    return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content)
}
class mz {
    constructor(e, n, r) {
        this.$from = e,
            this.$to = n,
            this.unplaced = r,
            this.frontier = [],
            this.placed = se.empty;
        for (let i = 0; i <= e.depth; i++) {
            let s = e.node(i);
            this.frontier.push({
                type: s.type,
                match: s.contentMatchAt(e.indexAfter(i))
            })
        }
        for (let i = e.depth; i > 0; i--)
            this.placed = se.from(e.node(i).copy(this.placed))
    }
    get depth() {
        return this.frontier.length - 1
    }
    fit() {
        for (; this.unplaced.size;) {
            let c = this.findFittable();
            c ? this.placeNodes(c) : this.openMore() || this.dropNode()
        }
        let e = this.mustMoveInline()
            , n = this.placed.size - this.depth - this.$from.depth
            , r = this.$from
            , i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
        if (!i)
            return null;
        let s = this.placed
            , o = r.depth
            , a = i.depth;
        for (; o && a && s.childCount == 1;)
            s = s.firstChild.content,
                o--,
                a--;
        let l = new ve(s, o, a);
        return e > -1 ? new Tn(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new En(r.pos, i.pos, l) : null
    }
    findFittable() {
        let e = this.unplaced.openStart;
        for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
            let s = n.firstChild;
            if (n.childCount > 1 && (i = 0),
                s.type.spec.isolating && i <= r) {
                e = r;
                break
            }
            n = s.content
        }
        for (let n = 1; n <= 2; n++)
            for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
                let i, s = null;
                r ? (s = S0(this.unplaced.content, r - 1).firstChild,
                    i = s.content) : i = this.unplaced.content;
                let o = i.firstChild;
                for (let a = this.depth; a >= 0; a--) {
                    let { type: l, match: c } = this.frontier[a], d, h = null;
                    if (n == 1 && (o ? c.matchType(o.type) || (h = c.fillBefore(se.from(o), !1)) : s && l.compatibleContent(s.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: a,
                            parent: s,
                            inject: h
                        };
                    if (n == 2 && o && (d = c.findWrapping(o.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: a,
                            parent: s,
                            wrap: d
                        };
                    if (s && c.matchType(s.type))
                        break
                }
            }
    }
    openMore() {
        let { content: e, openStart: n, openEnd: r } = this.unplaced
            , i = S0(e, n);
        return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new ve(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)),
            !0)
    }
    dropNode() {
        let { content: e, openStart: n, openEnd: r } = this.unplaced
            , i = S0(e, n);
        if (i.childCount <= 1 && n > 0) {
            let s = e.size - n <= n + i.size;
            this.unplaced = new ve(Gu(e, n - 1, 1), n - 1, s ? n - 1 : r)
        } else
            this.unplaced = new ve(Gu(e, n, 1), n, r)
    }
    placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: s }) {
        for (; this.depth > n;)
            this.closeFrontierNode();
        if (s)
            for (let x = 0; x < s.length; x++)
                this.openFrontierNode(s[x]);
        let o = this.unplaced
            , a = r ? r.content : o.content
            , l = o.openStart - e
            , c = 0
            , d = []
            , { match: h, type: p } = this.frontier[n];
        if (i) {
            for (let x = 0; x < i.childCount; x++)
                d.push(i.child(x));
            h = h.matchFragment(i)
        }
        let g = a.size + e - (o.content.size - o.openEnd);
        for (; c < a.childCount;) {
            let x = a.child(c)
                , S = h.matchType(x.type);
            if (!S)
                break;
            c++,
                (c > 1 || l == 0 || x.content.size) && (h = S,
                    d.push(YE(x.mark(p.allowedMarks(x.marks)), c == 1 ? l : 0, c == a.childCount ? g : -1)))
        }
        let y = c == a.childCount;
        y || (g = -1),
            this.placed = Ju(this.placed, n, se.from(d)),
            this.frontier[n].match = h,
            y && g < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let x = 0, S = a; x < g; x++) {
            let k = S.lastChild;
            this.frontier.push({
                type: k.type,
                match: k.contentMatchAt(k.childCount)
            }),
                S = k.content
        }
        this.unplaced = y ? e == 0 ? ve.empty : new ve(Gu(o.content, e - 1, 1), e - 1, g < 0 ? o.openEnd : e - 1) : new ve(Gu(o.content, e, c), o.openStart, o.openEnd)
    }
    mustMoveInline() {
        if (!this.$to.parent.isTextblock)
            return -1;
        let e = this.frontier[this.depth], n;
        if (!e.type.isTextblock || !k0(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
            return -1;
        let { depth: r } = this.$to
            , i = this.$to.after(r);
        for (; r > 1 && i == this.$to.end(--r);)
            ++i;
        return i
    }
    findCloseLevel(e) {
        e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
            let { match: r, type: i } = this.frontier[n]
                , s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1))
                , o = k0(e, n, i, r, s);
            if (o) {
                for (let a = n - 1; a >= 0; a--) {
                    let { match: l, type: c } = this.frontier[a]
                        , d = k0(e, a, c, l, !0);
                    if (!d || d.childCount)
                        continue e
                }
                return {
                    depth: n,
                    fit: o,
                    move: s ? e.doc.resolve(e.after(n + 1)) : e
                }
            }
        }
    }
    close(e) {
        let n = this.findCloseLevel(e);
        if (!n)
            return null;
        for (; this.depth > n.depth;)
            this.closeFrontierNode();
        n.fit.childCount && (this.placed = Ju(this.placed, n.depth, n.fit)),
            e = n.move;
        for (let r = n.depth + 1; r <= e.depth; r++) {
            let i = e.node(r)
                , s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
            this.openFrontierNode(i.type, i.attrs, s)
        }
        return e
    }
    openFrontierNode(e, n = null, r) {
        let i = this.frontier[this.depth];
        i.match = i.match.matchType(e),
            this.placed = Ju(this.placed, this.depth, se.from(e.create(n, r))),
            this.frontier.push({
                type: e,
                match: e.contentMatch
            })
    }
    closeFrontierNode() {
        let n = this.frontier.pop().match.fillBefore(se.empty, !0);
        n.childCount && (this.placed = Ju(this.placed, this.frontier.length, n))
    }
}
function Gu(t, e, n) {
    return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Gu(t.firstChild.content, e - 1, n)))
}
function Ju(t, e, n) {
    return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Ju(t.lastChild.content, e - 1, n)))
}
function S0(t, e) {
    for (let n = 0; n < e; n++)
        t = t.firstChild.content;
    return t
}
function YE(t, e, n) {
    if (e <= 0)
        return t;
    let r = t.content;
    return e > 1 && (r = r.replaceChild(0, YE(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))),
        e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r),
            n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(se.empty, !0)))),
        t.copy(r)
}
function k0(t, e, n, r, i) {
    let s = t.node(e)
        , o = i ? t.indexAfter(e) : t.index(e);
    if (o == s.childCount && !n.compatibleContent(s.type))
        return null;
    let a = r.fillBefore(s.content, !0, o);
    return a && !gz(n, s.content, o) ? a : null
}
function gz(t, e, n) {
    for (let r = n; r < e.childCount; r++)
        if (!t.allowsMarks(e.child(r).marks))
            return !0;
    return !1
}
function yz(t) {
    return t.spec.defining || t.spec.definingForContent
}
function vz(t, e, n, r) {
    if (!r.size)
        return t.deleteRange(e, n);
    let i = t.doc.resolve(e)
        , s = t.doc.resolve(n);
    if (ZE(i, s, r))
        return t.step(new En(e, n, r));
    let o = QE(i, t.doc.resolve(n));
    o[o.length - 1] == 0 && o.pop();
    let a = -(i.depth + 1);
    o.unshift(a);
    for (let p = i.depth, g = i.pos - 1; p > 0; p--,
        g--) {
        let y = i.node(p).type.spec;
        if (y.defining || y.definingAsContext || y.isolating)
            break;
        o.indexOf(p) > -1 ? a = p : i.before(p) == g && o.splice(1, 0, -p)
    }
    let l = o.indexOf(a)
        , c = []
        , d = r.openStart;
    for (let p = r.content, g = 0; ; g++) {
        let y = p.firstChild;
        if (c.push(y),
            g == r.openStart)
            break;
        p = y.content
    }
    for (let p = d - 1; p >= 0; p--) {
        let g = c[p]
            , y = yz(g.type);
        if (y && !g.sameMarkup(i.node(Math.abs(a) - 1)))
            d = p;
        else if (y || !g.type.isTextblock)
            break
    }
    for (let p = r.openStart; p >= 0; p--) {
        let g = (p + d + 1) % (r.openStart + 1)
            , y = c[g];
        if (y)
            for (let x = 0; x < o.length; x++) {
                let S = o[(x + l) % o.length]
                    , k = !0;
                S < 0 && (k = !1,
                    S = -S);
                let A = i.node(S - 1)
                    , C = i.index(S - 1);
                if (A.canReplaceWith(C, C, y.type, y.marks))
                    return t.replace(i.before(S), k ? s.after(S) : n, new ve(XE(r.content, 0, r.openStart, g), g, r.openEnd))
            }
    }
    let h = t.steps.length;
    for (let p = o.length - 1; p >= 0 && (t.replace(e, n, r),
        !(t.steps.length > h)); p--) {
        let g = o[p];
        g < 0 || (e = i.before(g),
            n = s.after(g))
    }
}
function XE(t, e, n, r, i) {
    if (e < n) {
        let s = t.firstChild;
        t = t.replaceChild(0, s.copy(XE(s.content, e + 1, n, r, s)))
    }
    if (e > r) {
        let s = i.contentMatchAt(0)
            , o = s.fillBefore(t).append(t);
        t = o.append(s.matchFragment(o).fillBefore(se.empty, !0))
    }
    return t
}
function bz(t, e, n, r) {
    if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
        let i = pz(t.doc, e, r.type);
        i != null && (e = n = i)
    }
    t.replaceRange(e, n, new ve(se.from(r), 0, 0))
}
function wz(t, e, n) {
    let r = t.doc.resolve(e)
        , i = t.doc.resolve(n)
        , s = QE(r, i);
    for (let o = 0; o < s.length; o++) {
        let a = s[o]
            , l = o == s.length - 1;
        if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
            return t.delete(r.start(a), i.end(a));
        if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
            return t.delete(r.before(a), i.after(a))
    }
    for (let o = 1; o <= r.depth && o <= i.depth; o++)
        if (e - r.start(o) == r.depth - o && n > r.end(o) && i.end(o) - n != i.depth - o)
            return t.delete(r.before(o), n);
    t.delete(e, n)
}
function QE(t, e) {
    let n = []
        , r = Math.min(t.depth, e.depth);
    for (let i = r; i >= 0; i--) {
        let s = t.start(i);
        if (s < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
            break;
        (s == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && n.push(i)
    }
    return n
}
class Fl extends nr {
    constructor(e, n, r) {
        super(),
            this.pos = e,
            this.attr = n,
            this.value = r
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return fn.fail("No node at attribute step's position");
        let r = Object.create(null);
        for (let s in n.attrs)
            r[s] = n.attrs[s];
        r[this.attr] = this.value;
        let i = n.type.create(r, null, n.marks);
        return fn.fromReplace(e, this.pos, this.pos + 1, new ve(se.from(i), 0, n.isLeaf ? 0 : 1))
    }
    getMap() {
        return Dr.empty
    }
    invert(e) {
        return new Fl(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr])
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Fl(n.pos, this.attr, this.value)
    }
    toJSON() {
        return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number" || typeof n.attr != "string")
            throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new Fl(n.pos, n.attr, n.value)
    }
}
nr.jsonID("attr", Fl);
class Dc extends nr {
    constructor(e, n) {
        super(),
            this.attr = e,
            this.value = n
    }
    apply(e) {
        let n = Object.create(null);
        for (let i in e.attrs)
            n[i] = e.attrs[i];
        n[this.attr] = this.value;
        let r = e.type.create(n, e.content, e.marks);
        return fn.ok(r)
    }
    getMap() {
        return Dr.empty
    }
    invert(e) {
        return new Dc(this.attr, e.attrs[this.attr])
    }
    map(e) {
        return this
    }
    toJSON() {
        return {
            stepType: "docAttr",
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(e, n) {
        if (typeof n.attr != "string")
            throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new Dc(n.attr, n.value)
    }
}
nr.jsonID("docAttr", Dc);
let nu = class extends Error {
}
    ;
nu = function t(e) {
    let n = Error.call(this, e);
    return n.__proto__ = t.prototype,
        n
}
    ;
nu.prototype = Object.create(Error.prototype);
nu.prototype.constructor = nu;
nu.prototype.name = "TransformError";
class bv {
    constructor(e) {
        this.doc = e,
            this.steps = [],
            this.docs = [],
            this.mapping = new $l
    }
    get before() {
        return this.docs.length ? this.docs[0] : this.doc
    }
    step(e) {
        let n = this.maybeStep(e);
        if (n.failed)
            throw new nu(n.failed);
        return this
    }
    maybeStep(e) {
        let n = e.apply(this.doc);
        return n.failed || this.addStep(e, n.doc),
            n
    }
    get docChanged() {
        return this.steps.length > 0
    }
    addStep(e, n) {
        this.docs.push(this.doc),
            this.steps.push(e),
            this.mapping.appendMap(e.getMap()),
            this.doc = n
    }
    replace(e, n = e, r = ve.empty) {
        let i = bm(this.doc, e, n, r);
        return i && this.step(i),
            this
    }
    replaceWith(e, n, r) {
        return this.replace(e, n, new ve(se.from(r), 0, 0))
    }
    delete(e, n) {
        return this.replace(e, n, ve.empty)
    }
    insert(e, n) {
        return this.replaceWith(e, e, n)
    }
    replaceRange(e, n, r) {
        return vz(this, e, n, r),
            this
    }
    replaceRangeWith(e, n, r) {
        return bz(this, e, n, r),
            this
    }
    deleteRange(e, n) {
        return wz(this, e, n),
            this
    }
    lift(e, n) {
        return rz(this, e, n),
            this
    }
    join(e, n = 1) {
        return hz(this, e, n),
            this
    }
    wrap(e, n) {
        return oz(this, e, n),
            this
    }
    setBlockType(e, n = e, r, i = null) {
        return az(this, e, n, r, i),
            this
    }
    setNodeMarkup(e, n, r = null, i) {
        return dz(this, e, n, r, i),
            this
    }
    setNodeAttribute(e, n, r) {
        return this.step(new Fl(e, n, r)),
            this
    }
    setDocAttribute(e, n) {
        return this.step(new Dc(e, n)),
            this
    }
    addNodeMark(e, n) {
        return this.step(new wo(e, n)),
            this
    }
    removeNodeMark(e, n) {
        if (!(n instanceof zt)) {
            let r = this.doc.nodeAt(e);
            if (!r)
                throw new RangeError("No node at position " + e);
            if (n = n.isInSet(r.marks),
                !n)
                return this
        }
        return this.step(new tu(e, n)),
            this
    }
    split(e, n = 1, r) {
        return fz(this, e, n, r),
            this
    }
    addMark(e, n, r) {
        return ez(this, e, n, r),
            this
    }
    removeMark(e, n, r) {
        return tz(this, e, n, r),
            this
    }
    clearIncompatible(e, n, r) {
        return qE(this, e, n, r),
            this
    }
}
const C0 = Object.create(null);
class Ve {
    constructor(e, n, r) {
        this.$anchor = e,
            this.$head = n,
            this.ranges = r || [new eT(e.min(n), e.max(n))]
    }
    get anchor() {
        return this.$anchor.pos
    }
    get head() {
        return this.$head.pos
    }
    get from() {
        return this.$from.pos
    }
    get to() {
        return this.$to.pos
    }
    get $from() {
        return this.ranges[0].$from
    }
    get $to() {
        return this.ranges[0].$to
    }
    get empty() {
        let e = this.ranges;
        for (let n = 0; n < e.length; n++)
            if (e[n].$from.pos != e[n].$to.pos)
                return !1;
        return !0
    }
    content() {
        return this.$from.doc.slice(this.from, this.to, !0)
    }
    replace(e, n = ve.empty) {
        let r = n.content.lastChild
            , i = null;
        for (let a = 0; a < n.openEnd; a++)
            i = r,
                r = r.lastChild;
        let s = e.steps.length
            , o = this.ranges;
        for (let a = 0; a < o.length; a++) {
            let { $from: l, $to: c } = o[a]
                , d = e.mapping.slice(s);
            e.replaceRange(d.map(l.pos), d.map(c.pos), a ? ve.empty : n),
                a == 0 && L_(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1)
        }
    }
    replaceWith(e, n) {
        let r = e.steps.length
            , i = this.ranges;
        for (let s = 0; s < i.length; s++) {
            let { $from: o, $to: a } = i[s]
                , l = e.mapping.slice(r)
                , c = l.map(o.pos)
                , d = l.map(a.pos);
            s ? e.deleteRange(c, d) : (e.replaceRangeWith(c, d, n),
                L_(e, r, n.isInline ? -1 : 1))
        }
    }
    static findFrom(e, n, r = !1) {
        let i = e.parent.inlineContent ? new De(e) : _l(e.node(0), e.parent, e.pos, e.index(), n, r);
        if (i)
            return i;
        for (let s = e.depth - 1; s >= 0; s--) {
            let o = n < 0 ? _l(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, r) : _l(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, r);
            if (o)
                return o
        }
        return null
    }
    static near(e, n = 1) {
        return this.findFrom(e, n) || this.findFrom(e, -n) || new Ci(e.node(0))
    }
    static atStart(e) {
        return _l(e, e, 0, 0, 1) || new Ci(e)
    }
    static atEnd(e) {
        return _l(e, e, e.content.size, e.childCount, -1) || new Ci(e)
    }
    static fromJSON(e, n) {
        if (!n || !n.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
        let r = C0[n.type];
        if (!r)
            throw new RangeError(`No selection type ${n.type} defined`);
        return r.fromJSON(e, n)
    }
    static jsonID(e, n) {
        if (e in C0)
            throw new RangeError("Duplicate use of selection JSON ID " + e);
        return C0[e] = n,
            n.prototype.jsonID = e,
            n
    }
    getBookmark() {
        return De.between(this.$anchor, this.$head).getBookmark()
    }
}
Ve.prototype.visible = !0;
class eT {
    constructor(e, n) {
        this.$from = e,
            this.$to = n
    }
}
let N_ = !1;
function I_(t) {
    !N_ && !t.parent.inlineContent && (N_ = !0,
        console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"))
}
class De extends Ve {
    constructor(e, n = e) {
        I_(e),
            I_(n),
            super(e, n)
    }
    get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null
    }
    map(e, n) {
        let r = e.resolve(n.map(this.head));
        if (!r.parent.inlineContent)
            return Ve.near(r);
        let i = e.resolve(n.map(this.anchor));
        return new De(i.parent.inlineContent ? i : r, r)
    }
    replace(e, n = ve.empty) {
        if (super.replace(e, n),
            n == ve.empty) {
            let r = this.$from.marksAcross(this.$to);
            r && e.ensureMarks(r)
        }
    }
    eq(e) {
        return e instanceof De && e.anchor == this.anchor && e.head == this.head
    }
    getBookmark() {
        return new wm(this.anchor, this.head)
    }
    toJSON() {
        return {
            type: "text",
            anchor: this.anchor,
            head: this.head
        }
    }
    static fromJSON(e, n) {
        if (typeof n.anchor != "number" || typeof n.head != "number")
            throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new De(e.resolve(n.anchor), e.resolve(n.head))
    }
    static create(e, n, r = n) {
        let i = e.resolve(n);
        return new this(i, r == n ? i : e.resolve(r))
    }
    static between(e, n, r) {
        let i = e.pos - n.pos;
        if ((!r || i) && (r = i >= 0 ? 1 : -1),
            !n.parent.inlineContent) {
            let s = Ve.findFrom(n, r, !0) || Ve.findFrom(n, -r, !0);
            if (s)
                n = s.$head;
            else
                return Ve.near(n, r)
        }
        return e.parent.inlineContent || (i == 0 ? e = n : (e = (Ve.findFrom(e, -r, !0) || Ve.findFrom(e, r, !0)).$anchor,
            e.pos < n.pos != i < 0 && (e = n))),
            new De(e, n)
    }
}
Ve.jsonID("text", De);
class wm {
    constructor(e, n) {
        this.anchor = e,
            this.head = n
    }
    map(e) {
        return new wm(e.map(this.anchor), e.map(this.head))
    }
    resolve(e) {
        return De.between(e.resolve(this.anchor), e.resolve(this.head))
    }
}
class Le extends Ve {
    constructor(e) {
        let n = e.nodeAfter
            , r = e.node(0).resolve(e.pos + n.nodeSize);
        super(e, r),
            this.node = n
    }
    map(e, n) {
        let { deleted: r, pos: i } = n.mapResult(this.anchor)
            , s = e.resolve(i);
        return r ? Ve.near(s) : new Le(s)
    }
    content() {
        return new ve(se.from(this.node), 0, 0)
    }
    eq(e) {
        return e instanceof Le && e.anchor == this.anchor
    }
    toJSON() {
        return {
            type: "node",
            anchor: this.anchor
        }
    }
    getBookmark() {
        return new wv(this.anchor)
    }
    static fromJSON(e, n) {
        if (typeof n.anchor != "number")
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new Le(e.resolve(n.anchor))
    }
    static create(e, n) {
        return new Le(e.resolve(n))
    }
    static isSelectable(e) {
        return !e.isText && e.type.spec.selectable !== !1
    }
}
Le.prototype.visible = !1;
Ve.jsonID("node", Le);
class wv {
    constructor(e) {
        this.anchor = e
    }
    map(e) {
        let { deleted: n, pos: r } = e.mapResult(this.anchor);
        return n ? new wm(r, r) : new wv(r)
    }
    resolve(e) {
        let n = e.resolve(this.anchor)
            , r = n.nodeAfter;
        return r && Le.isSelectable(r) ? new Le(n) : Ve.near(n)
    }
}
class Ci extends Ve {
    constructor(e) {
        super(e.resolve(0), e.resolve(e.content.size))
    }
    replace(e, n = ve.empty) {
        if (n == ve.empty) {
            e.delete(0, e.doc.content.size);
            let r = Ve.atStart(e.doc);
            r.eq(e.selection) || e.setSelection(r)
        } else
            super.replace(e, n)
    }
    toJSON() {
        return {
            type: "all"
        }
    }
    static fromJSON(e) {
        return new Ci(e)
    }
    map(e) {
        return new Ci(e)
    }
    eq(e) {
        return e instanceof Ci
    }
    getBookmark() {
        return xz
    }
}
Ve.jsonID("all", Ci);
const xz = {
    map() {
        return this
    },
    resolve(t) {
        return new Ci(t)
    }
};
function _l(t, e, n, r, i, s = !1) {
    if (e.inlineContent)
        return De.create(t, n);
    for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
        let a = e.child(o);
        if (a.isAtom) {
            if (!s && Le.isSelectable(a))
                return Le.create(t, n - (i < 0 ? a.nodeSize : 0))
        } else {
            let l = _l(t, a, n + i, i < 0 ? a.childCount : 0, i, s);
            if (l)
                return l
        }
        n += a.nodeSize * i
    }
    return null
}
function L_(t, e, n) {
    let r = t.steps.length - 1;
    if (r < e)
        return;
    let i = t.steps[r];
    if (!(i instanceof En || i instanceof Tn))
        return;
    let s = t.mapping.maps[r], o;
    s.forEach((a, l, c, d) => {
        o == null && (o = d)
    }
    ),
        t.setSelection(Ve.near(t.doc.resolve(o), n))
}
const D_ = 1
    , Ff = 2
    , j_ = 4;
class _z extends bv {
    constructor(e) {
        super(e.doc),
            this.curSelectionFor = 0,
            this.updated = 0,
            this.meta = Object.create(null),
            this.time = Date.now(),
            this.curSelection = e.selection,
            this.storedMarks = e.storedMarks
    }
    get selection() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)),
            this.curSelectionFor = this.steps.length),
            this.curSelection
    }
    setSelection(e) {
        if (e.$from.doc != this.doc)
            throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = e,
            this.curSelectionFor = this.steps.length,
            this.updated = (this.updated | D_) & ~Ff,
            this.storedMarks = null,
            this
    }
    get selectionSet() {
        return (this.updated & D_) > 0
    }
    setStoredMarks(e) {
        return this.storedMarks = e,
            this.updated |= Ff,
            this
    }
    ensureMarks(e) {
        return zt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e),
            this
    }
    addStoredMark(e) {
        return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()))
    }
    removeStoredMark(e) {
        return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()))
    }
    get storedMarksSet() {
        return (this.updated & Ff) > 0
    }
    addStep(e, n) {
        super.addStep(e, n),
            this.updated = this.updated & ~Ff,
            this.storedMarks = null
    }
    setTime(e) {
        return this.time = e,
            this
    }
    replaceSelection(e) {
        return this.selection.replace(this, e),
            this
    }
    replaceSelectionWith(e, n = !0) {
        let r = this.selection;
        return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || zt.none))),
            r.replaceWith(this, e),
            this
    }
    deleteSelection() {
        return this.selection.replace(this),
            this
    }
    insertText(e, n, r) {
        let i = this.doc.type.schema;
        if (n == null)
            return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
        {
            if (r == null && (r = n),
                r = r ?? n,
                !e)
                return this.deleteRange(n, r);
            let s = this.storedMarks;
            if (!s) {
                let o = this.doc.resolve(n);
                s = r == n ? o.marks() : o.marksAcross(this.doc.resolve(r))
            }
            return this.replaceRangeWith(n, r, i.text(e, s)),
                this.selection.empty || this.setSelection(Ve.near(this.selection.$to)),
                this
        }
    }
    setMeta(e, n) {
        return this.meta[typeof e == "string" ? e : e.key] = n,
            this
    }
    getMeta(e) {
        return this.meta[typeof e == "string" ? e : e.key]
    }
    get isGeneric() {
        for (let e in this.meta)
            return !1;
        return !0
    }
    scrollIntoView() {
        return this.updated |= j_,
            this
    }
    get scrolledIntoView() {
        return (this.updated & j_) > 0
    }
}
function B_(t, e) {
    return !e || !t ? t : t.bind(e)
}
class Zu {
    constructor(e, n, r) {
        this.name = e,
            this.init = B_(n.init, r),
            this.apply = B_(n.apply, r)
    }
}
const Sz = [new Zu("doc", {
    init(t) {
        return t.doc || t.schema.topNodeType.createAndFill()
    },
    apply(t) {
        return t.doc
    }
}), new Zu("selection", {
    init(t, e) {
        return t.selection || Ve.atStart(e.doc)
    },
    apply(t) {
        return t.selection
    }
}), new Zu("storedMarks", {
    init(t) {
        return t.storedMarks || null
    },
    apply(t, e, n, r) {
        return r.selection.$cursor ? t.storedMarks : null
    }
}), new Zu("scrollToSelection", {
    init() {
        return 0
    },
    apply(t, e) {
        return t.scrolledIntoView ? e + 1 : e
    }
})];
class E0 {
    constructor(e, n) {
        this.schema = e,
            this.plugins = [],
            this.pluginsByKey = Object.create(null),
            this.fields = Sz.slice(),
            n && n.forEach(r => {
                if (this.pluginsByKey[r.key])
                    throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
                this.plugins.push(r),
                    this.pluginsByKey[r.key] = r,
                    r.spec.state && this.fields.push(new Zu(r.key, r.spec.state, r))
            }
            )
    }
}
class Ol {
    constructor(e) {
        this.config = e
    }
    get schema() {
        return this.config.schema
    }
    get plugins() {
        return this.config.plugins
    }
    apply(e) {
        return this.applyTransaction(e).state
    }
    filterTransaction(e, n = -1) {
        for (let r = 0; r < this.config.plugins.length; r++)
            if (r != n) {
                let i = this.config.plugins[r];
                if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
                    return !1
            }
        return !0
    }
    applyTransaction(e) {
        if (!this.filterTransaction(e))
            return {
                state: this,
                transactions: []
            };
        let n = [e]
            , r = this.applyInner(e)
            , i = null;
        for (; ;) {
            let s = !1;
            for (let o = 0; o < this.config.plugins.length; o++) {
                let a = this.config.plugins[o];
                if (a.spec.appendTransaction) {
                    let l = i ? i[o].n : 0
                        , c = i ? i[o].state : this
                        , d = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r);
                    if (d && r.filterTransaction(d, o)) {
                        if (d.setMeta("appendedTransaction", e),
                            !i) {
                            i = [];
                            for (let h = 0; h < this.config.plugins.length; h++)
                                i.push(h < o ? {
                                    state: r,
                                    n: n.length
                                } : {
                                    state: this,
                                    n: 0
                                })
                        }
                        n.push(d),
                            r = r.applyInner(d),
                            s = !0
                    }
                    i && (i[o] = {
                        state: r,
                        n: n.length
                    })
                }
            }
            if (!s)
                return {
                    state: r,
                    transactions: n
                }
        }
    }
    applyInner(e) {
        if (!e.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
        let n = new Ol(this.config)
            , r = this.config.fields;
        for (let i = 0; i < r.length; i++) {
            let s = r[i];
            n[s.name] = s.apply(e, this[s.name], this, n)
        }
        return n
    }
    get tr() {
        return new _z(this)
    }
    static create(e) {
        let n = new E0(e.doc ? e.doc.type.schema : e.schema, e.plugins)
            , r = new Ol(n);
        for (let i = 0; i < n.fields.length; i++)
            r[n.fields[i].name] = n.fields[i].init(e, r);
        return r
    }
    reconfigure(e) {
        let n = new E0(this.schema, e.plugins)
            , r = n.fields
            , i = new Ol(n);
        for (let s = 0; s < r.length; s++) {
            let o = r[s].name;
            i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i)
        }
        return i
    }
    toJSON(e) {
        let n = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON()
        };
        if (this.storedMarks && (n.storedMarks = this.storedMarks.map(r => r.toJSON())),
            e && typeof e == "object")
            for (let r in e) {
                if (r == "doc" || r == "selection")
                    throw new RangeError("The JSON fields `doc` and `selection` are reserved");
                let i = e[r]
                    , s = i.spec.state;
                s && s.toJSON && (n[r] = s.toJSON.call(i, this[i.key]))
            }
        return n
    }
    static fromJSON(e, n, r) {
        if (!n)
            throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!e.schema)
            throw new RangeError("Required config field 'schema' missing");
        let i = new E0(e.schema, e.plugins)
            , s = new Ol(i);
        return i.fields.forEach(o => {
            if (o.name == "doc")
                s.doc = _a.fromJSON(e.schema, n.doc);
            else if (o.name == "selection")
                s.selection = Ve.fromJSON(s.doc, n.selection);
            else if (o.name == "storedMarks")
                n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
            else {
                if (r)
                    for (let a in r) {
                        let l = r[a]
                            , c = l.spec.state;
                        if (l.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
                            s[o.name] = c.fromJSON.call(l, e, n[a], s);
                            return
                        }
                    }
                s[o.name] = o.init(e, s)
            }
        }
        ),
            s
    }
}
function tT(t, e, n) {
    for (let r in t) {
        let i = t[r];
        i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = tT(i, e, {})),
            n[r] = i
    }
    return n
}
class sn {
    constructor(e) {
        this.spec = e,
            this.props = {},
            e.props && tT(e.props, this, this.props),
            this.key = e.key ? e.key.key : nT("plugin")
    }
    getState(e) {
        return e[this.key]
    }
}
const T0 = Object.create(null);
function nT(t) {
    return t in T0 ? t + "$" + ++T0[t] : (T0[t] = 0,
        t + "$")
}
class _n {
    constructor(e = "key") {
        this.key = nT(e)
    }
    get(e) {
        return e.config.pluginsByKey[this.key]
    }
    getState(e) {
        return e[this.key]
    }
}
const Bn = function (t) {
    for (var e = 0; ; e++)
        if (t = t.previousSibling,
            !t)
            return e
}
    , jc = function (t) {
        let e = t.assignedSlot || t.parentNode;
        return e && e.nodeType == 11 ? e.host : e
    };
let j1 = null;
const As = function (t, e, n) {
    let r = j1 || (j1 = document.createRange());
    return r.setEnd(t, n ?? t.nodeValue.length),
        r.setStart(t, e || 0),
        r
}
    , kz = function () {
        j1 = null
    }
    , Da = function (t, e, n, r) {
        return n && ($_(t, e, n, r, -1) || $_(t, e, n, r, 1))
    }
    , Cz = /^(img|br|input|textarea|hr)$/i;
function $_(t, e, n, r, i) {
    for (; ;) {
        if (t == n && e == r)
            return !0;
        if (e == (i < 0 ? 0 : ni(t))) {
            let s = t.parentNode;
            if (!s || s.nodeType != 1 || xd(t) || Cz.test(t.nodeName) || t.contentEditable == "false")
                return !1;
            e = Bn(t) + (i < 0 ? 0 : 1),
                t = s
        } else if (t.nodeType == 1) {
            if (t = t.childNodes[e + (i < 0 ? -1 : 0)],
                t.contentEditable == "false")
                return !1;
            e = i < 0 ? ni(t) : 0
        } else
            return !1
    }
}
function ni(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function Ez(t, e) {
    for (; ;) {
        if (t.nodeType == 3 && e)
            return t;
        if (t.nodeType == 1 && e > 0) {
            if (t.contentEditable == "false")
                return null;
            t = t.childNodes[e - 1],
                e = ni(t)
        } else if (t.parentNode && !xd(t))
            e = Bn(t),
                t = t.parentNode;
        else
            return null
    }
}
function Tz(t, e) {
    for (; ;) {
        if (t.nodeType == 3 && e < t.nodeValue.length)
            return t;
        if (t.nodeType == 1 && e < t.childNodes.length) {
            if (t.contentEditable == "false")
                return null;
            t = t.childNodes[e],
                e = 0
        } else if (t.parentNode && !xd(t))
            e = Bn(t) + 1,
                t = t.parentNode;
        else
            return null
    }
}
function Az(t, e, n) {
    for (let r = e == 0, i = e == ni(t); r || i;) {
        if (t == n)
            return !0;
        let s = Bn(t);
        if (t = t.parentNode,
            !t)
            return !1;
        r = r && s == 0,
            i = i && s == ni(t)
    }
}
function xd(t) {
    let e;
    for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
        ;
    return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t)
}
const xm = function (t) {
    return t.focusNode && Da(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
};
function ca(t, e) {
    let n = document.createEvent("Event");
    return n.initEvent("keydown", !0, !0),
        n.keyCode = t,
        n.key = n.code = e,
        n
}
function Oz(t) {
    let e = t.activeElement;
    for (; e && e.shadowRoot;)
        e = e.shadowRoot.activeElement;
    return e
}
function Mz(t, e, n) {
    if (t.caretPositionFromPoint)
        try {
            let r = t.caretPositionFromPoint(e, n);
            if (r)
                return {
                    node: r.offsetNode,
                    offset: Math.min(ni(r.offsetNode), r.offset)
                }
        } catch { }
    if (t.caretRangeFromPoint) {
        let r = t.caretRangeFromPoint(e, n);
        if (r)
            return {
                node: r.startContainer,
                offset: Math.min(ni(r.startContainer), r.startOffset)
            }
    }
}
const Qi = typeof navigator < "u" ? navigator : null
    , z_ = typeof document < "u" ? document : null
    , Go = Qi && Qi.userAgent || ""
    , B1 = /Edge\/(\d+)/.exec(Go)
    , rT = /MSIE \d/.exec(Go)
    , $1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Go)
    , Tr = !!(rT || $1 || B1)
    , Co = rT ? document.documentMode : $1 ? +$1[1] : B1 ? +B1[1] : 0
    , Oi = !Tr && /gecko\/(\d+)/i.test(Go);
Oi && +(/Firefox\/(\d+)/.exec(Go) || [0, 0])[1];
const z1 = !Tr && /Chrome\/(\d+)/.exec(Go)
    , Yn = !!z1
    , iT = z1 ? +z1[1] : 0
    , dr = !Tr && !!Qi && /Apple Computer/.test(Qi.vendor)
    , ru = dr && (/Mobile\/\w+/.test(Go) || !!Qi && Qi.maxTouchPoints > 2)
    , ei = ru || (Qi ? /Mac/.test(Qi.platform) : !1)
    , Rz = Qi ? /Win/.test(Qi.platform) : !1
    , yi = /Android \d/.test(Go)
    , _d = !!z_ && "webkitFontSmoothing" in z_.documentElement.style
    , Pz = _d ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function Nz(t) {
    let e = t.defaultView && t.defaultView.visualViewport;
    return e ? {
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height
    } : {
        left: 0,
        right: t.documentElement.clientWidth,
        top: 0,
        bottom: t.documentElement.clientHeight
    }
}
function xs(t, e) {
    return typeof t == "number" ? t : t[e]
}
function Iz(t) {
    let e = t.getBoundingClientRect()
        , n = e.width / t.offsetWidth || 1
        , r = e.height / t.offsetHeight || 1;
    return {
        left: e.left,
        right: e.left + t.clientWidth * n,
        top: e.top,
        bottom: e.top + t.clientHeight * r
    }
}
function F_(t, e, n) {
    let r = t.someProp("scrollThreshold") || 0
        , i = t.someProp("scrollMargin") || 5
        , s = t.dom.ownerDocument;
    for (let o = n || t.dom; o; o = jc(o)) {
        if (o.nodeType != 1)
            continue;
        let a = o
            , l = a == s.body
            , c = l ? Nz(s) : Iz(a)
            , d = 0
            , h = 0;
        if (e.top < c.top + xs(r, "top") ? h = -(c.top - e.top + xs(i, "top")) : e.bottom > c.bottom - xs(r, "bottom") && (h = e.bottom - e.top > c.bottom - c.top ? e.top + xs(i, "top") - c.top : e.bottom - c.bottom + xs(i, "bottom")),
            e.left < c.left + xs(r, "left") ? d = -(c.left - e.left + xs(i, "left")) : e.right > c.right - xs(r, "right") && (d = e.right - c.right + xs(i, "right")),
            d || h)
            if (l)
                s.defaultView.scrollBy(d, h);
            else {
                let p = a.scrollLeft
                    , g = a.scrollTop;
                h && (a.scrollTop += h),
                    d && (a.scrollLeft += d);
                let y = a.scrollLeft - p
                    , x = a.scrollTop - g;
                e = {
                    left: e.left - y,
                    top: e.top - x,
                    right: e.right - y,
                    bottom: e.bottom - x
                }
            }
        if (l || /^(fixed|sticky)$/.test(getComputedStyle(o).position))
            break
    }
}
function Lz(t) {
    let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, i;
    for (let s = (e.left + e.right) / 2, o = n + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
        let a = t.root.elementFromPoint(s, o);
        if (!a || a == t.dom || !t.dom.contains(a))
            continue;
        let l = a.getBoundingClientRect();
        if (l.top >= n - 20) {
            r = a,
                i = l.top;
            break
        }
    }
    return {
        refDOM: r,
        refTop: i,
        stack: sT(t.dom)
    }
}
function sT(t) {
    let e = []
        , n = t.ownerDocument;
    for (let r = t; r && (e.push({
        dom: r,
        top: r.scrollTop,
        left: r.scrollLeft
    }),
        t != n); r = jc(r))
        ;
    return e
}
function Dz({ refDOM: t, refTop: e, stack: n }) {
    let r = t ? t.getBoundingClientRect().top : 0;
    oT(n, r == 0 ? 0 : r - e)
}
function oT(t, e) {
    for (let n = 0; n < t.length; n++) {
        let { dom: r, top: i, left: s } = t[n];
        r.scrollTop != i + e && (r.scrollTop = i + e),
            r.scrollLeft != s && (r.scrollLeft = s)
    }
}
let ml = null;
function jz(t) {
    if (t.setActive)
        return t.setActive();
    if (ml)
        return t.focus(ml);
    let e = sT(t);
    t.focus(ml == null ? {
        get preventScroll() {
            return ml = {
                preventScroll: !0
            },
                !0
        }
    } : void 0),
        ml || (ml = !1,
            oT(e, 0))
}
function aT(t, e) {
    let n, r = 2e8, i, s = 0, o = e.top, a = e.top, l, c;
    for (let d = t.firstChild, h = 0; d; d = d.nextSibling,
        h++) {
        let p;
        if (d.nodeType == 1)
            p = d.getClientRects();
        else if (d.nodeType == 3)
            p = As(d).getClientRects();
        else
            continue;
        for (let g = 0; g < p.length; g++) {
            let y = p[g];
            if (y.top <= o && y.bottom >= a) {
                o = Math.max(y.bottom, o),
                    a = Math.min(y.top, a);
                let x = y.left > e.left ? y.left - e.left : y.right < e.left ? e.left - y.right : 0;
                if (x < r) {
                    n = d,
                        r = x,
                        i = x && n.nodeType == 3 ? {
                            left: y.right < e.left ? y.right : y.left,
                            top: e.top
                        } : e,
                        d.nodeType == 1 && x && (s = h + (e.left >= (y.left + y.right) / 2 ? 1 : 0));
                    continue
                }
            } else
                y.top > e.top && !l && y.left <= e.left && y.right >= e.left && (l = d,
                    c = {
                        left: Math.max(y.left, Math.min(y.right, e.left)),
                        top: y.top
                    });
            !n && (e.left >= y.right && e.top >= y.top || e.left >= y.left && e.top >= y.bottom) && (s = h + 1)
        }
    }
    return !n && l && (n = l,
        i = c,
        r = 0),
        n && n.nodeType == 3 ? Bz(n, i) : !n || r && n.nodeType == 1 ? {
            node: t,
            offset: s
        } : aT(n, i)
}
function Bz(t, e) {
    let n = t.nodeValue.length
        , r = document.createRange();
    for (let i = 0; i < n; i++) {
        r.setEnd(t, i + 1),
            r.setStart(t, i);
        let s = no(r, 1);
        if (s.top != s.bottom && xv(e, s))
            return {
                node: t,
                offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0)
            }
    }
    return {
        node: t,
        offset: 0
    }
}
function xv(t, e) {
    return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1
}
function $z(t, e) {
    let n = t.parentNode;
    return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t
}
function zz(t, e, n) {
    let { node: r, offset: i } = aT(e, n)
        , s = -1;
    if (r.nodeType == 1 && !r.firstChild) {
        let o = r.getBoundingClientRect();
        s = o.left != o.right && n.left > (o.left + o.right) / 2 ? 1 : -1
    }
    return t.docView.posFromDOM(r, i, s)
}
function Fz(t, e, n, r) {
    let i = -1;
    for (let s = e, o = !1; s != t.dom;) {
        let a = t.docView.nearestDesc(s, !0);
        if (!a)
            return null;
        if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM)) {
            let l = a.dom.getBoundingClientRect();
            if (a.node.isBlock && a.parent && (!o && l.left > r.left || l.top > r.top ? i = a.posBefore : (!o && l.right < r.left || l.bottom < r.top) && (i = a.posAfter),
                o = !0),
                !a.contentDOM && i < 0 && !a.node.isText)
                return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter
        }
        s = a.dom.parentNode
    }
    return i > -1 ? i : t.docView.posFromDOM(e, n, -1)
}
function lT(t, e, n) {
    let r = t.childNodes.length;
    if (r && n.top < n.bottom)
        for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), s = i; ;) {
            let o = t.childNodes[s];
            if (o.nodeType == 1) {
                let a = o.getClientRects();
                for (let l = 0; l < a.length; l++) {
                    let c = a[l];
                    if (xv(e, c))
                        return lT(o, e, c)
                }
            }
            if ((s = (s + 1) % r) == i)
                break
        }
    return t
}
function Hz(t, e) {
    let n = t.dom.ownerDocument, r, i = 0, s = Mz(n, e.left, e.top);
    s && ({ node: r, offset: i } = s);
    let o = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
    if (!o || !t.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
        let c = t.dom.getBoundingClientRect();
        if (!xv(e, c) || (o = lT(t.dom, e, c),
            !o))
            return null
    }
    if (dr)
        for (let c = o; r && c; c = jc(c))
            c.draggable && (r = void 0);
    if (o = $z(o, e),
        r) {
        if (Oi && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length),
            i < r.childNodes.length)) {
            let d = r.childNodes[i], h;
            d.nodeName == "IMG" && (h = d.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++
        }
        let c;
        _d && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--,
            r == t.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = Fz(t, r, i, e))
    }
    a == null && (a = zz(t, o, e));
    let l = t.docView.nearestDesc(o, !0);
    return {
        pos: a,
        inside: l ? l.posAtStart - l.border : -1
    }
}
function H_(t) {
    return t.top < t.bottom || t.left < t.right
}
function no(t, e) {
    let n = t.getClientRects();
    if (n.length) {
        let r = n[e < 0 ? 0 : n.length - 1];
        if (H_(r))
            return r
    }
    return Array.prototype.find.call(n, H_) || t.getBoundingClientRect()
}
const Vz = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function uT(t, e, n) {
    let { node: r, offset: i, atom: s } = t.docView.domFromPos(e, n < 0 ? -1 : 1)
        , o = _d || Oi;
    if (r.nodeType == 3)
        if (o && (Vz.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
            let l = no(As(r, i, i), n);
            if (Oi && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
                let c = no(As(r, i - 1, i - 1), -1);
                if (c.top == l.top) {
                    let d = no(As(r, i, i + 1), -1);
                    if (d.top != l.top)
                        return Vu(d, d.left < c.left)
                }
            }
            return l
        } else {
            let l = i
                , c = i
                , d = n < 0 ? 1 : -1;
            return n < 0 && !i ? (c++,
                d = -1) : n >= 0 && i == r.nodeValue.length ? (l--,
                    d = 1) : n < 0 ? l-- : c++,
                Vu(no(As(r, l, c), d), d < 0)
        }
    if (!t.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
        if (s == null && i && (n < 0 || i == ni(r))) {
            let l = r.childNodes[i - 1];
            if (l.nodeType == 1)
                return A0(l.getBoundingClientRect(), !1)
        }
        if (s == null && i < ni(r)) {
            let l = r.childNodes[i];
            if (l.nodeType == 1)
                return A0(l.getBoundingClientRect(), !0)
        }
        return A0(r.getBoundingClientRect(), n >= 0)
    }
    if (s == null && i && (n < 0 || i == ni(r))) {
        let l = r.childNodes[i - 1]
            , c = l.nodeType == 3 ? As(l, ni(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
        if (c)
            return Vu(no(c, 1), !1)
    }
    if (s == null && i < ni(r)) {
        let l = r.childNodes[i];
        for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords;)
            l = l.nextSibling;
        let c = l ? l.nodeType == 3 ? As(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
        if (c)
            return Vu(no(c, -1), !0)
    }
    return Vu(no(r.nodeType == 3 ? As(r) : r, -n), n >= 0)
}
function Vu(t, e) {
    if (t.width == 0)
        return t;
    let n = e ? t.left : t.right;
    return {
        top: t.top,
        bottom: t.bottom,
        left: n,
        right: n
    }
}
function A0(t, e) {
    if (t.height == 0)
        return t;
    let n = e ? t.top : t.bottom;
    return {
        top: n,
        bottom: n,
        left: t.left,
        right: t.right
    }
}
function cT(t, e, n) {
    let r = t.state
        , i = t.root.activeElement;
    r != e && t.updateState(e),
        i != t.dom && t.focus();
    try {
        return n()
    } finally {
        r != e && t.updateState(r),
            i != t.dom && i && i.focus()
    }
}
function Wz(t, e, n) {
    let r = e.selection
        , i = n == "up" ? r.$from : r.$to;
    return cT(t, e, () => {
        let { node: s } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
        for (; ;) {
            let a = t.docView.nearestDesc(s, !0);
            if (!a)
                break;
            if (a.node.isBlock) {
                s = a.contentDOM || a.dom;
                break
            }
            s = a.dom.parentNode
        }
        let o = uT(t, i.pos, 1);
        for (let a = s.firstChild; a; a = a.nextSibling) {
            let l;
            if (a.nodeType == 1)
                l = a.getClientRects();
            else if (a.nodeType == 3)
                l = As(a, 0, a.nodeValue.length).getClientRects();
            else
                continue;
            for (let c = 0; c < l.length; c++) {
                let d = l[c];
                if (d.bottom > d.top + 1 && (n == "up" ? o.top - d.top > (d.bottom - o.top) * 2 : d.bottom - o.bottom > (o.bottom - d.top) * 2))
                    return !1
            }
        }
        return !0
    }
    )
}
const Uz = /[\u0590-\u08ac]/;
function Kz(t, e, n) {
    let { $head: r } = e.selection;
    if (!r.parent.isTextblock)
        return !1;
    let i = r.parentOffset
        , s = !i
        , o = i == r.parent.content.size
        , a = t.domSelection();
    return a ? !Uz.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? s : o : cT(t, e, () => {
        let { focusNode: l, focusOffset: c, anchorNode: d, anchorOffset: h } = t.domSelectionRange()
            , p = a.caretBidiLevel;
        a.modify("move", n, "character");
        let g = r.depth ? t.docView.domAfterPos(r.before()) : t.dom
            , { focusNode: y, focusOffset: x } = t.domSelectionRange()
            , S = y && !g.contains(y.nodeType == 1 ? y : y.parentNode) || l == y && c == x;
        try {
            a.collapse(d, h),
                l && (l != d || c != h) && a.extend && a.extend(l, c)
        } catch { }
        return p != null && (a.caretBidiLevel = p),
            S
    }
    ) : r.pos == r.start() || r.pos == r.end()
}
let V_ = null
    , W_ = null
    , U_ = !1;
function qz(t, e, n) {
    return V_ == e && W_ == n ? U_ : (V_ = e,
        W_ = n,
        U_ = n == "up" || n == "down" ? Wz(t, e, n) : Kz(t, e, n))
}
const li = 0
    , K_ = 1
    , ha = 2
    , es = 3;
class Sd {
    constructor(e, n, r, i) {
        this.parent = e,
            this.children = n,
            this.dom = r,
            this.contentDOM = i,
            this.dirty = li,
            r.pmViewDesc = this
    }
    matchesWidget(e) {
        return !1
    }
    matchesMark(e) {
        return !1
    }
    matchesNode(e, n, r) {
        return !1
    }
    matchesHack(e) {
        return !1
    }
    parseRule() {
        return null
    }
    stopEvent(e) {
        return !1
    }
    get size() {
        let e = 0;
        for (let n = 0; n < this.children.length; n++)
            e += this.children[n].size;
        return e
    }
    get border() {
        return 0
    }
    destroy() {
        this.parent = void 0,
            this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (let e = 0; e < this.children.length; e++)
            this.children[e].destroy()
    }
    posBeforeChild(e) {
        for (let n = 0, r = this.posAtStart; ; n++) {
            let i = this.children[n];
            if (i == e)
                return r;
            r += i.size
        }
    }
    get posBefore() {
        return this.parent.posBeforeChild(this)
    }
    get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
    }
    get posAfter() {
        return this.posBefore + this.size
    }
    get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border
    }
    localPosFromDOM(e, n, r) {
        if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
            if (r < 0) {
                let s, o;
                if (e == this.contentDOM)
                    s = e.childNodes[n - 1];
                else {
                    for (; e.parentNode != this.contentDOM;)
                        e = e.parentNode;
                    s = e.previousSibling
                }
                for (; s && !((o = s.pmViewDesc) && o.parent == this);)
                    s = s.previousSibling;
                return s ? this.posBeforeChild(o) + o.size : this.posAtStart
            } else {
                let s, o;
                if (e == this.contentDOM)
                    s = e.childNodes[n];
                else {
                    for (; e.parentNode != this.contentDOM;)
                        e = e.parentNode;
                    s = e.nextSibling
                }
                for (; s && !((o = s.pmViewDesc) && o.parent == this);)
                    s = s.nextSibling;
                return s ? this.posBeforeChild(o) : this.posAtEnd
            }
        let i;
        if (e == this.dom && this.contentDOM)
            i = n > Bn(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
            i = e.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
            if (n == 0)
                for (let s = e; ; s = s.parentNode) {
                    if (s == this.dom) {
                        i = !1;
                        break
                    }
                    if (s.previousSibling)
                        break
                }
            if (i == null && n == e.childNodes.length)
                for (let s = e; ; s = s.parentNode) {
                    if (s == this.dom) {
                        i = !0;
                        break
                    }
                    if (s.nextSibling)
                        break
                }
        }
        return i ?? r > 0 ? this.posAtEnd : this.posAtStart
    }
    nearestDesc(e, n = !1) {
        for (let r = !0, i = e; i; i = i.parentNode) {
            let s = this.getDesc(i), o;
            if (s && (!n || s.node))
                if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
                    r = !1;
                else
                    return s
        }
    }
    getDesc(e) {
        let n = e.pmViewDesc;
        for (let r = n; r; r = r.parent)
            if (r == this)
                return n
    }
    posFromDOM(e, n, r) {
        for (let i = e; i; i = i.parentNode) {
            let s = this.getDesc(i);
            if (s)
                return s.localPosFromDOM(e, n, r)
        }
        return -1
    }
    descAt(e) {
        for (let n = 0, r = 0; n < this.children.length; n++) {
            let i = this.children[n]
                , s = r + i.size;
            if (r == e && s != r) {
                for (; !i.border && i.children.length;)
                    i = i.children[0];
                return i
            }
            if (e < s)
                return i.descAt(e - r - i.border);
            r = s
        }
    }
    domFromPos(e, n) {
        if (!this.contentDOM)
            return {
                node: this.dom,
                offset: 0,
                atom: e + 1
            };
        let r = 0
            , i = 0;
        for (let s = 0; r < this.children.length; r++) {
            let o = this.children[r]
                , a = s + o.size;
            if (a > e || o instanceof fT) {
                i = e - s;
                break
            }
            s = a
        }
        if (i)
            return this.children[r].domFromPos(i - this.children[r].border, n);
        for (let s; r && !(s = this.children[r - 1]).size && s instanceof dT && s.side >= 0; r--)
            ;
        if (n <= 0) {
            let s, o = !0;
            for (; s = r ? this.children[r - 1] : null,
                !(!s || s.dom.parentNode == this.contentDOM); r--,
                o = !1)
                ;
            return s && n && o && !s.border && !s.domAtom ? s.domFromPos(s.size, n) : {
                node: this.contentDOM,
                offset: s ? Bn(s.dom) + 1 : 0
            }
        } else {
            let s, o = !0;
            for (; s = r < this.children.length ? this.children[r] : null,
                !(!s || s.dom.parentNode == this.contentDOM); r++,
                o = !1)
                ;
            return s && o && !s.border && !s.domAtom ? s.domFromPos(0, n) : {
                node: this.contentDOM,
                offset: s ? Bn(s.dom) : this.contentDOM.childNodes.length
            }
        }
    }
    parseRange(e, n, r = 0) {
        if (this.children.length == 0)
            return {
                node: this.contentDOM,
                from: e,
                to: n,
                fromOffset: 0,
                toOffset: this.contentDOM.childNodes.length
            };
        let i = -1
            , s = -1;
        for (let o = r, a = 0; ; a++) {
            let l = this.children[a]
                , c = o + l.size;
            if (i == -1 && e <= c) {
                let d = o + l.border;
                if (e >= d && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
                    return l.parseRange(e, n, d);
                e = o;
                for (let h = a; h > 0; h--) {
                    let p = this.children[h - 1];
                    if (p.size && p.dom.parentNode == this.contentDOM && !p.emptyChildAt(1)) {
                        i = Bn(p.dom) + 1;
                        break
                    }
                    e -= p.size
                }
                i == -1 && (i = 0)
            }
            if (i > -1 && (c > n || a == this.children.length - 1)) {
                n = c;
                for (let d = a + 1; d < this.children.length; d++) {
                    let h = this.children[d];
                    if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
                        s = Bn(h.dom);
                        break
                    }
                    n += h.size
                }
                s == -1 && (s = this.contentDOM.childNodes.length);
                break
            }
            o = c
        }
        return {
            node: this.contentDOM,
            from: e,
            to: n,
            fromOffset: i,
            toOffset: s
        }
    }
    emptyChildAt(e) {
        if (this.border || !this.contentDOM || !this.children.length)
            return !1;
        let n = this.children[e < 0 ? 0 : this.children.length - 1];
        return n.size == 0 || n.emptyChildAt(e)
    }
    domAfterPos(e) {
        let { node: n, offset: r } = this.domFromPos(e, 0);
        if (n.nodeType != 1 || r == n.childNodes.length)
            throw new RangeError("No node after pos " + e);
        return n.childNodes[r]
    }
    setSelection(e, n, r, i = !1) {
        let s = Math.min(e, n)
            , o = Math.max(e, n);
        for (let p = 0, g = 0; p < this.children.length; p++) {
            let y = this.children[p]
                , x = g + y.size;
            if (s > g && o < x)
                return y.setSelection(e - g - y.border, n - g - y.border, r, i);
            g = x
        }
        let a = this.domFromPos(e, e ? -1 : 1)
            , l = n == e ? a : this.domFromPos(n, n ? -1 : 1)
            , c = r.getSelection()
            , d = !1;
        if ((Oi || dr) && e == n) {
            let { node: p, offset: g } = a;
            if (p.nodeType == 3) {
                if (d = !!(g && p.nodeValue[g - 1] == `
`),
                    d && g == p.nodeValue.length)
                    for (let y = p, x; y; y = y.parentNode) {
                        if (x = y.nextSibling) {
                            x.nodeName == "BR" && (a = l = {
                                node: x.parentNode,
                                offset: Bn(x) + 1
                            });
                            break
                        }
                        let S = y.pmViewDesc;
                        if (S && S.node && S.node.isBlock)
                            break
                    }
            } else {
                let y = p.childNodes[g - 1];
                d = y && (y.nodeName == "BR" || y.contentEditable == "false")
            }
        }
        if (Oi && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) {
            let p = c.focusNode.childNodes[c.focusOffset];
            p && p.contentEditable == "false" && (i = !0)
        }
        if (!(i || d && dr) && Da(a.node, a.offset, c.anchorNode, c.anchorOffset) && Da(l.node, l.offset, c.focusNode, c.focusOffset))
            return;
        let h = !1;
        if ((c.extend || e == n) && !d) {
            c.collapse(a.node, a.offset);
            try {
                e != n && c.extend(l.node, l.offset),
                    h = !0
            } catch { }
        }
        if (!h) {
            if (e > n) {
                let g = a;
                a = l,
                    l = g
            }
            let p = document.createRange();
            p.setEnd(l.node, l.offset),
                p.setStart(a.node, a.offset),
                c.removeAllRanges(),
                c.addRange(p)
        }
    }
    ignoreMutation(e) {
        return !this.contentDOM && e.type != "selection"
    }
    get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
    }
    markDirty(e, n) {
        for (let r = 0, i = 0; i < this.children.length; i++) {
            let s = this.children[i]
                , o = r + s.size;
            if (r == o ? e <= o && n >= r : e < o && n > r) {
                let a = r + s.border
                    , l = o - s.border;
                if (e >= a && n <= l) {
                    this.dirty = e == r || n == o ? ha : K_,
                        e == a && n == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = es : s.markDirty(e - a, n - a);
                    return
                } else
                    s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? ha : es
            }
            r = o
        }
        this.dirty = ha
    }
    markParentsDirty() {
        let e = 1;
        for (let n = this.parent; n; n = n.parent,
            e++) {
            let r = e == 1 ? ha : K_;
            n.dirty < r && (n.dirty = r)
        }
    }
    get domAtom() {
        return !1
    }
    get ignoreForCoords() {
        return !1
    }
    isText(e) {
        return !1
    }
}
class dT extends Sd {
    constructor(e, n, r, i) {
        let s, o = n.type.toDOM;
        if (typeof o == "function" && (o = o(r, () => {
            if (!s)
                return i;
            if (s.parent)
                return s.parent.posBeforeChild(s)
        }
        )),
            !n.type.spec.raw) {
            if (o.nodeType != 1) {
                let a = document.createElement("span");
                a.appendChild(o),
                    o = a
            }
            o.contentEditable = "false",
                o.classList.add("ProseMirror-widget")
        }
        super(e, [], o, null),
            this.widget = n,
            this.widget = n,
            s = this
    }
    matchesWidget(e) {
        return this.dirty == li && e.type.eq(this.widget.type)
    }
    parseRule() {
        return {
            ignore: !0
        }
    }
    stopEvent(e) {
        let n = this.widget.spec.stopEvent;
        return n ? n(e) : !1
    }
    ignoreMutation(e) {
        return e.type != "selection" || this.widget.spec.ignoreSelection
    }
    destroy() {
        this.widget.type.destroy(this.dom),
            super.destroy()
    }
    get domAtom() {
        return !0
    }
    get side() {
        return this.widget.type.side
    }
}
class Gz extends Sd {
    constructor(e, n, r, i) {
        super(e, [], n, null),
            this.textDOM = r,
            this.text = i
    }
    get size() {
        return this.text.length
    }
    localPosFromDOM(e, n) {
        return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n
    }
    domFromPos(e) {
        return {
            node: this.textDOM,
            offset: e
        }
    }
    ignoreMutation(e) {
        return e.type === "characterData" && e.target.nodeValue == e.oldValue
    }
}
class ja extends Sd {
    constructor(e, n, r, i) {
        super(e, [], r, i),
            this.mark = n
    }
    static create(e, n, r, i) {
        let s = i.nodeViews[n.type.name]
            , o = s && s(n, i, r);
        return (!o || !o.dom) && (o = Ka.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)),
            new ja(e, n, o.dom, o.contentDOM || o.dom)
    }
    parseRule() {
        return this.dirty & es || this.mark.type.spec.reparseInView ? null : {
            mark: this.mark.type.name,
            attrs: this.mark.attrs,
            contentElement: this.contentDOM
        }
    }
    matchesMark(e) {
        return this.dirty != es && this.mark.eq(e)
    }
    markDirty(e, n) {
        if (super.markDirty(e, n),
            this.dirty != li) {
            let r = this.parent;
            for (; !r.node;)
                r = r.parent;
            r.dirty < this.dirty && (r.dirty = this.dirty),
                this.dirty = li
        }
    }
    slice(e, n, r) {
        let i = ja.create(this.parent, this.mark, !0, r)
            , s = this.children
            , o = this.size;
        n < o && (s = H1(s, n, o, r)),
            e > 0 && (s = H1(s, 0, e, r));
        for (let a = 0; a < s.length; a++)
            s[a].parent = i;
        return i.children = s,
            i
    }
}
class Eo extends Sd {
    constructor(e, n, r, i, s, o, a, l, c) {
        super(e, [], s, o),
            this.node = n,
            this.outerDeco = r,
            this.innerDeco = i,
            this.nodeDOM = a
    }
    static create(e, n, r, i, s, o) {
        let a = s.nodeViews[n.type.name], l, c = a && a(n, s, () => {
            if (!l)
                return o;
            if (l.parent)
                return l.parent.posBeforeChild(l)
        }
            , r, i), d = c && c.dom, h = c && c.contentDOM;
        if (n.isText) {
            if (!d)
                d = document.createTextNode(n.text);
            else if (d.nodeType != 3)
                throw new RangeError("Text must be rendered as a DOM text node")
        } else
            d || ({ dom: d, contentDOM: h } = Ka.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
        !h && !n.isText && d.nodeName != "BR" && (d.hasAttribute("contenteditable") || (d.contentEditable = "false"),
            n.type.spec.draggable && (d.draggable = !0));
        let p = d;
        return d = mT(d, r, n),
            c ? l = new Jz(e, n, r, i, d, h || null, p, c, s, o + 1) : n.isText ? new _m(e, n, r, i, d, p, s) : new Eo(e, n, r, i, d, h || null, p, s, o + 1)
    }
    parseRule() {
        if (this.node.type.spec.reparseInView)
            return null;
        let e = {
            node: this.node.type.name,
            attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"),
            !this.contentDOM)
            e.getContent = () => this.node.content;
        else if (!this.contentLost)
            e.contentElement = this.contentDOM;
        else {
            for (let n = this.children.length - 1; n >= 0; n--) {
                let r = this.children[n];
                if (this.dom.contains(r.dom.parentNode)) {
                    e.contentElement = r.dom.parentNode;
                    break
                }
            }
            e.contentElement || (e.getContent = () => se.empty)
        }
        return e
    }
    matchesNode(e, n, r) {
        return this.dirty == li && e.eq(this.node) && Yh(n, this.outerDeco) && r.eq(this.innerDeco)
    }
    get size() {
        return this.node.nodeSize
    }
    get border() {
        return this.node.isLeaf ? 0 : 1
    }
    updateChildren(e, n) {
        let r = this.node.inlineContent
            , i = n
            , s = e.composing ? this.localCompositionInfo(e, n) : null
            , o = s && s.pos > -1 ? s : null
            , a = s && s.pos < 0
            , l = new Yz(this, o && o.node, e);
        eF(this.node, this.innerDeco, (c, d, h) => {
            c.spec.marks ? l.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !h && l.syncToMarks(d == this.node.childCount ? zt.none : this.node.child(d).marks, r, e),
                l.placeWidget(c, e, i)
        }
            , (c, d, h, p) => {
                l.syncToMarks(c.marks, r, e);
                let g;
                l.findNodeMatch(c, d, h, p) || a && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (g = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(c, d, h, g, e) || l.updateNextNode(c, d, h, e, p, i) || l.addNode(c, d, h, e, i),
                    i += c.nodeSize
            }
        ),
            l.syncToMarks([], r, e),
            this.node.isTextblock && l.addTextblockHacks(),
            l.destroyRest(),
            (l.changed || this.dirty == ha) && (o && this.protectLocalComposition(e, o),
                hT(this.contentDOM, this.children, e),
                ru && tF(this.dom))
    }
    localCompositionInfo(e, n) {
        let { from: r, to: i } = e.state.selection;
        if (!(e.state.selection instanceof De) || r < n || i > n + this.node.content.size)
            return null;
        let s = e.input.compositionNode;
        if (!s || !this.dom.contains(s.parentNode))
            return null;
        if (this.node.inlineContent) {
            let o = s.nodeValue
                , a = nF(this.node.content, o, r - n, i - n);
            return a < 0 ? null : {
                node: s,
                pos: a,
                text: o
            }
        } else
            return {
                node: s,
                pos: -1,
                text: ""
            }
    }
    protectLocalComposition(e, { node: n, pos: r, text: i }) {
        if (this.getDesc(n))
            return;
        let s = n;
        for (; s.parentNode != this.contentDOM; s = s.parentNode) {
            for (; s.previousSibling;)
                s.parentNode.removeChild(s.previousSibling);
            for (; s.nextSibling;)
                s.parentNode.removeChild(s.nextSibling);
            s.pmViewDesc && (s.pmViewDesc = void 0)
        }
        let o = new Gz(this, s, n, i);
        e.input.compositionNodes.push(o),
            this.children = H1(this.children, r, r + i.length, e, o)
    }
    update(e, n, r, i) {
        return this.dirty == es || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i),
            !0)
    }
    updateInner(e, n, r, i) {
        this.updateOuterDeco(n),
            this.node = e,
            this.innerDeco = r,
            this.contentDOM && this.updateChildren(i, this.posAtStart),
            this.dirty = li
    }
    updateOuterDeco(e) {
        if (Yh(e, this.outerDeco))
            return;
        let n = this.nodeDOM.nodeType != 1
            , r = this.dom;
        this.dom = pT(this.dom, this.nodeDOM, F1(this.outerDeco, this.node, n), F1(e, this.node, n)),
            this.dom != r && (r.pmViewDesc = void 0,
                this.dom.pmViewDesc = this),
            this.outerDeco = e
    }
    selectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"),
            (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0)
    }
    deselectNode() {
        this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"),
            (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"))
    }
    get domAtom() {
        return this.node.isAtom
    }
}
function q_(t, e, n, r, i) {
    mT(r, e, t);
    let s = new Eo(void 0, t, e, n, r, r, r, i, 0);
    return s.contentDOM && s.updateChildren(i, 0),
        s
}
class _m extends Eo {
    constructor(e, n, r, i, s, o, a) {
        super(e, n, r, i, s, null, o, a, 0)
    }
    parseRule() {
        let e = this.nodeDOM.parentNode;
        for (; e && e != this.dom && !e.pmIsDeco;)
            e = e.parentNode;
        return {
            skip: e || !0
        }
    }
    update(e, n, r, i) {
        return this.dirty == es || this.dirty != li && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n),
            (this.dirty != li || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text,
                i.trackWrites == this.nodeDOM && (i.trackWrites = null)),
            this.node = e,
            this.dirty = li,
            !0)
    }
    inParent() {
        let e = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
            if (n == e)
                return !0;
        return !1
    }
    domFromPos(e) {
        return {
            node: this.nodeDOM,
            offset: e
        }
    }
    localPosFromDOM(e, n, r) {
        return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r)
    }
    ignoreMutation(e) {
        return e.type != "characterData" && e.type != "selection"
    }
    slice(e, n, r) {
        let i = this.node.cut(e, n)
            , s = document.createTextNode(i.text);
        return new _m(this.parent, i, this.outerDeco, this.innerDeco, s, s, r)
    }
    markDirty(e, n) {
        super.markDirty(e, n),
            this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = es)
    }
    get domAtom() {
        return !1
    }
    isText(e) {
        return this.node.text == e
    }
}
class fT extends Sd {
    parseRule() {
        return {
            ignore: !0
        }
    }
    matchesHack(e) {
        return this.dirty == li && this.dom.nodeName == e
    }
    get domAtom() {
        return !0
    }
    get ignoreForCoords() {
        return this.dom.nodeName == "IMG"
    }
}
class Jz extends Eo {
    constructor(e, n, r, i, s, o, a, l, c, d) {
        super(e, n, r, i, s, o, a, c, d),
            this.spec = l
    }
    update(e, n, r, i) {
        if (this.dirty == es)
            return !1;
        if (this.spec.update) {
            let s = this.spec.update(e, n, r);
            return s && this.updateInner(e, n, r, i),
                s
        } else
            return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i)
    }
    selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
    }
    deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
    }
    setSelection(e, n, r, i) {
        this.spec.setSelection ? this.spec.setSelection(e, n, r) : super.setSelection(e, n, r, i)
    }
    destroy() {
        this.spec.destroy && this.spec.destroy(),
            super.destroy()
    }
    stopEvent(e) {
        return this.spec.stopEvent ? this.spec.stopEvent(e) : !1
    }
    ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e)
    }
}
function hT(t, e, n) {
    let r = t.firstChild
        , i = !1;
    for (let s = 0; s < e.length; s++) {
        let o = e[s]
            , a = o.dom;
        if (a.parentNode == t) {
            for (; a != r;)
                r = G_(r),
                    i = !0;
            r = r.nextSibling
        } else
            i = !0,
                t.insertBefore(a, r);
        if (o instanceof ja) {
            let l = r ? r.previousSibling : t.lastChild;
            hT(o.contentDOM, o.children, n),
                r = l ? l.nextSibling : t.firstChild
        }
    }
    for (; r;)
        r = G_(r),
            i = !0;
    i && n.trackWrites == t && (n.trackWrites = null)
}
const mc = function (t) {
    t && (this.nodeName = t)
};
mc.prototype = Object.create(null);
const pa = [new mc];
function F1(t, e, n) {
    if (t.length == 0)
        return pa;
    let r = n ? pa[0] : new mc
        , i = [r];
    for (let s = 0; s < t.length; s++) {
        let o = t[s].type.attrs;
        if (o) {
            o.nodeName && i.push(r = new mc(o.nodeName));
            for (let a in o) {
                let l = o[a];
                l != null && (n && i.length == 1 && i.push(r = new mc(e.isInline ? "span" : "div")),
                    a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l))
            }
        }
    }
    return i
}
function pT(t, e, n, r) {
    if (n == pa && r == pa)
        return e;
    let i = e;
    for (let s = 0; s < r.length; s++) {
        let o = r[s]
            , a = n[s];
        if (s) {
            let l;
            a && a.nodeName == o.nodeName && i != t && (l = i.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName),
                l.pmIsDeco = !0,
                l.appendChild(i),
                a = pa[0]),
                i = l
        }
        Zz(i, a || pa[0], o)
    }
    return i
}
function Zz(t, e, n) {
    for (let r in e)
        r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
    for (let r in n)
        r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
    if (e.class != n.class) {
        let r = e.class ? e.class.split(" ").filter(Boolean) : []
            , i = n.class ? n.class.split(" ").filter(Boolean) : [];
        for (let s = 0; s < r.length; s++)
            i.indexOf(r[s]) == -1 && t.classList.remove(r[s]);
        for (let s = 0; s < i.length; s++)
            r.indexOf(i[s]) == -1 && t.classList.add(i[s]);
        t.classList.length == 0 && t.removeAttribute("class")
    }
    if (e.style != n.style) {
        if (e.style) {
            let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
            for (; i = r.exec(e.style);)
                t.style.removeProperty(i[1])
        }
        n.style && (t.style.cssText += n.style)
    }
}
function mT(t, e, n) {
    return pT(t, t, pa, F1(e, n, t.nodeType != 1))
}
function Yh(t, e) {
    if (t.length != e.length)
        return !1;
    for (let n = 0; n < t.length; n++)
        if (!t[n].type.eq(e[n].type))
            return !1;
    return !0
}
function G_(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t),
        e
}
class Yz {
    constructor(e, n, r) {
        this.lock = n,
            this.view = r,
            this.index = 0,
            this.stack = [],
            this.changed = !1,
            this.top = e,
            this.preMatch = Xz(e.node.content, e)
    }
    destroyBetween(e, n) {
        if (e != n) {
            for (let r = e; r < n; r++)
                this.top.children[r].destroy();
            this.top.children.splice(e, n - e),
                this.changed = !0
        }
    }
    destroyRest() {
        this.destroyBetween(this.index, this.top.children.length)
    }
    syncToMarks(e, n, r) {
        let i = 0
            , s = this.stack.length >> 1
            , o = Math.min(s, e.length);
        for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1;)
            i++;
        for (; i < s;)
            this.destroyRest(),
                this.top.dirty = li,
                this.index = this.stack.pop(),
                this.top = this.stack.pop(),
                s--;
        for (; s < e.length;) {
            this.stack.push(this.top, this.index + 1);
            let a = -1;
            for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
                let c = this.top.children[l];
                if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
                    a = l;
                    break
                }
            }
            if (a > -1)
                a > this.index && (this.changed = !0,
                    this.destroyBetween(this.index, a)),
                    this.top = this.top.children[this.index];
            else {
                let l = ja.create(this.top, e[s], n, r);
                this.top.children.splice(this.index, 0, l),
                    this.top = l,
                    this.changed = !0
            }
            this.index = 0,
                s++
        }
    }
    findNodeMatch(e, n, r, i) {
        let s = -1, o;
        if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, n, r))
            s = this.top.children.indexOf(o, this.index);
        else
            for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
                let c = this.top.children[a];
                if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
                    s = a;
                    break
                }
            }
        return s < 0 ? !1 : (this.destroyBetween(this.index, s),
            this.index++,
            !0)
    }
    updateNodeAt(e, n, r, i, s) {
        let o = this.top.children[i];
        return o.dirty == es && o.dom == o.contentDOM && (o.dirty = ha),
            o.update(e, n, r, s) ? (this.destroyBetween(this.index, i),
                this.index++,
                !0) : !1
    }
    findIndexWithChild(e) {
        for (; ;) {
            let n = e.parentNode;
            if (!n)
                return -1;
            if (n == this.top.contentDOM) {
                let r = e.pmViewDesc;
                if (r) {
                    for (let i = this.index; i < this.top.children.length; i++)
                        if (this.top.children[i] == r)
                            return i
                }
                return -1
            }
            e = n
        }
    }
    updateNextNode(e, n, r, i, s, o) {
        for (let a = this.index; a < this.top.children.length; a++) {
            let l = this.top.children[a];
            if (l instanceof Eo) {
                let c = this.preMatch.matched.get(l);
                if (c != null && c != s)
                    return !1;
                let d = l.dom, h, p = this.isLocked(d) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != es && Yh(n, l.outerDeco));
                if (!p && l.update(e, n, r, i))
                    return this.destroyBetween(this.index, a),
                        l.dom != d && (this.changed = !0),
                        this.index++,
                        !0;
                if (!p && (h = this.recreateWrapper(l, e, n, r, i, o)))
                    return this.destroyBetween(this.index, a),
                        this.top.children[this.index] = h,
                        h.contentDOM && (h.dirty = ha,
                            h.updateChildren(i, o + 1),
                            h.dirty = li),
                        this.changed = !0,
                        this.index++,
                        !0;
                break
            }
        }
        return !1
    }
    recreateWrapper(e, n, r, i, s, o) {
        if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !Yh(r, e.outerDeco) || !i.eq(e.innerDeco))
            return null;
        let a = Eo.create(this.top, n, r, i, s, o);
        if (a.contentDOM) {
            a.children = e.children,
                e.children = [];
            for (let l of a.children)
                l.parent = a
        }
        return e.destroy(),
            a
    }
    addNode(e, n, r, i, s) {
        let o = Eo.create(this.top, e, n, r, i, s);
        o.contentDOM && o.updateChildren(i, s + 1),
            this.top.children.splice(this.index++, 0, o),
            this.changed = !0
    }
    placeWidget(e, n, r) {
        let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
            this.index++;
        else {
            let s = new dT(this.top, e, n, r);
            this.top.children.splice(this.index++, 0, s),
                this.changed = !0
        }
    }
    addTextblockHacks() {
        let e = this.top.children[this.index - 1]
            , n = this.top;
        for (; e instanceof ja;)
            n = e,
                e = n.children[n.children.length - 1];
        (!e || !(e instanceof _m) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((dr || Yn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n),
            this.addHackNode("BR", this.top))
    }
    addHackNode(e, n) {
        if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
            this.index++;
        else {
            let r = document.createElement(e);
            e == "IMG" && (r.className = "ProseMirror-separator",
                r.alt = ""),
                e == "BR" && (r.className = "ProseMirror-trailingBreak");
            let i = new fT(this.top, [], r, null);
            n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i),
                this.changed = !0
        }
    }
    isLocked(e) {
        return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode))
    }
}
function Xz(t, e) {
    let n = e
        , r = n.children.length
        , i = t.childCount
        , s = new Map
        , o = [];
    e: for (; i > 0;) {
        let a;
        for (; ;)
            if (r) {
                let c = n.children[r - 1];
                if (c instanceof ja)
                    n = c,
                        r = c.children.length;
                else {
                    a = c,
                        r--;
                    break
                }
            } else {
                if (n == e)
                    break e;
                r = n.parent.children.indexOf(n),
                    n = n.parent
            }
        let l = a.node;
        if (l) {
            if (l != t.child(i - 1))
                break;
            --i,
                s.set(a, i),
                o.push(a)
        }
    }
    return {
        index: i,
        matched: s,
        matches: o.reverse()
    }
}
function Qz(t, e) {
    return t.type.side - e.type.side
}
function eF(t, e, n, r) {
    let i = e.locals(t)
        , s = 0;
    if (i.length == 0) {
        for (let c = 0; c < t.childCount; c++) {
            let d = t.child(c);
            r(d, i, e.forChild(s, d), c),
                s += d.nodeSize
        }
        return
    }
    let o = 0
        , a = []
        , l = null;
    for (let c = 0; ;) {
        let d, h;
        for (; o < i.length && i[o].to == s;) {
            let S = i[o++];
            S.widget && (d ? (h || (h = [d])).push(S) : d = S)
        }
        if (d)
            if (h) {
                h.sort(Qz);
                for (let S = 0; S < h.length; S++)
                    n(h[S], c, !!l)
            } else
                n(d, c, !!l);
        let p, g;
        if (l)
            g = -1,
                p = l,
                l = null;
        else if (c < t.childCount)
            g = c,
                p = t.child(c++);
        else
            break;
        for (let S = 0; S < a.length; S++)
            a[S].to <= s && a.splice(S--, 1);
        for (; o < i.length && i[o].from <= s && i[o].to > s;)
            a.push(i[o++]);
        let y = s + p.nodeSize;
        if (p.isText) {
            let S = y;
            o < i.length && i[o].from < S && (S = i[o].from);
            for (let k = 0; k < a.length; k++)
                a[k].to < S && (S = a[k].to);
            S < y && (l = p.cut(S - s),
                p = p.cut(0, S - s),
                y = S,
                g = -1)
        } else
            for (; o < i.length && i[o].to < y;)
                o++;
        let x = p.isInline && !p.isLeaf ? a.filter(S => !S.inline) : a.slice();
        r(p, x, e.forChild(s, p), g),
            s = y
    }
}
function tF(t) {
    if (t.nodeName == "UL" || t.nodeName == "OL") {
        let e = t.style.cssText;
        t.style.cssText = e + "; list-style: square !important",
            window.getComputedStyle(t).listStyle,
            t.style.cssText = e
    }
}
function nF(t, e, n, r) {
    for (let i = 0, s = 0; i < t.childCount && s <= r;) {
        let o = t.child(i++)
            , a = s;
        if (s += o.nodeSize,
            !o.isText)
            continue;
        let l = o.text;
        for (; i < t.childCount;) {
            let c = t.child(i++);
            if (s += c.nodeSize,
                !c.isText)
                break;
            l += c.text
        }
        if (s >= n) {
            if (s >= r && l.slice(r - e.length - a, r - a) == e)
                return r - e.length;
            let c = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
            if (c >= 0 && c + e.length + a >= n)
                return a + c;
            if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
                return r
        }
    }
    return -1
}
function H1(t, e, n, r, i) {
    let s = [];
    for (let o = 0, a = 0; o < t.length; o++) {
        let l = t[o]
            , c = a
            , d = a += l.size;
        c >= n || d <= e ? s.push(l) : (c < e && s.push(l.slice(0, e - c, r)),
            i && (s.push(i),
                i = void 0),
            d > n && s.push(l.slice(n - c, l.size, r)))
    }
    return s
}
function _v(t, e = null) {
    let n = t.domSelectionRange()
        , r = t.state.doc;
    if (!n.focusNode)
        return null;
    let i = t.docView.nearestDesc(n.focusNode)
        , s = i && i.size == 0
        , o = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
    if (o < 0)
        return null;
    let a = r.resolve(o), l, c;
    if (xm(n)) {
        for (l = o; i && !i.node;)
            i = i.parent;
        let h = i.node;
        if (i && h.isAtom && Le.isSelectable(h) && i.parent && !(h.isInline && Az(n.focusNode, n.focusOffset, i.dom))) {
            let p = i.posBefore;
            c = new Le(o == p ? a : r.resolve(p))
        }
    } else {
        if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
            let h = o
                , p = o;
            for (let g = 0; g < n.rangeCount; g++) {
                let y = n.getRangeAt(g);
                h = Math.min(h, t.docView.posFromDOM(y.startContainer, y.startOffset, 1)),
                    p = Math.max(p, t.docView.posFromDOM(y.endContainer, y.endOffset, -1))
            }
            if (h < 0)
                return null;
            [l, o] = p == t.state.selection.anchor ? [p, h] : [h, p],
                a = r.resolve(o)
        } else
            l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
        if (l < 0)
            return null
    }
    let d = r.resolve(l);
    if (!c) {
        let h = e == "pointer" || t.state.selection.head < a.pos && !s ? 1 : -1;
        c = Sv(t, d, a, h)
    }
    return c
}
function gT(t) {
    return t.editable ? t.hasFocus() : vT(t) && document.activeElement && document.activeElement.contains(t.dom)
}
function Is(t, e = !1) {
    let n = t.state.selection;
    if (yT(t, n),
        !!gT(t)) {
        if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Yn) {
            let r = t.domSelectionRange()
                , i = t.domObserver.currentSelection;
            if (r.anchorNode && i.anchorNode && Da(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
                t.input.mouseDown.delayedSelectionSync = !0,
                    t.domObserver.setCurSelection();
                return
            }
        }
        if (t.domObserver.disconnectSelection(),
            t.cursorWrapper)
            iF(t);
        else {
            let { anchor: r, head: i } = n, s, o;
            J_ && !(n instanceof De) && (n.$from.parent.inlineContent || (s = Z_(t, n.from)),
                !n.empty && !n.$from.parent.inlineContent && (o = Z_(t, n.to))),
                t.docView.setSelection(r, i, t.root, e),
                J_ && (s && Y_(s),
                    o && Y_(o)),
                n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"),
                    "onselectionchange" in document && rF(t))
        }
        t.domObserver.setCurSelection(),
            t.domObserver.connectSelection()
    }
}
const J_ = dr || Yn && iT < 63;
function Z_(t, e) {
    let { node: n, offset: r } = t.docView.domFromPos(e, 0)
        , i = r < n.childNodes.length ? n.childNodes[r] : null
        , s = r ? n.childNodes[r - 1] : null;
    if (dr && i && i.contentEditable == "false")
        return O0(i);
    if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
        if (i)
            return O0(i);
        if (s)
            return O0(s)
    }
}
function O0(t) {
    return t.contentEditable = "true",
        dr && t.draggable && (t.draggable = !1,
            t.wasDraggable = !0),
        t
}
function Y_(t) {
    t.contentEditable = "false",
        t.wasDraggable && (t.draggable = !0,
            t.wasDraggable = null)
}
function rF(t) {
    let e = t.dom.ownerDocument;
    e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
    let n = t.domSelectionRange()
        , r = n.anchorNode
        , i = n.anchorOffset;
    e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
        (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard),
            setTimeout(() => {
                (!gT(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection")
            }
                , 20))
    }
    )
}
function iF(t) {
    let e = t.domSelection()
        , n = document.createRange();
    if (!e)
        return;
    let r = t.cursorWrapper.dom
        , i = r.nodeName == "IMG";
    i ? n.setStart(r.parentNode, Bn(r) + 1) : n.setStart(r, 0),
        n.collapse(!0),
        e.removeAllRanges(),
        e.addRange(n),
        !i && !t.state.selection.visible && Tr && Co <= 11 && (r.disabled = !0,
            r.disabled = !1)
}
function yT(t, e) {
    if (e instanceof Le) {
        let n = t.docView.descAt(e.from);
        n != t.lastSelectedViewDesc && (X_(t),
            n && n.selectNode(),
            t.lastSelectedViewDesc = n)
    } else
        X_(t)
}
function X_(t) {
    t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
        t.lastSelectedViewDesc = void 0)
}
function Sv(t, e, n, r) {
    return t.someProp("createSelectionBetween", i => i(t, e, n)) || De.between(e, n, r)
}
function Q_(t) {
    return t.editable && !t.hasFocus() ? !1 : vT(t)
}
function vT(t) {
    let e = t.domSelectionRange();
    if (!e.anchorNode)
        return !1;
    try {
        return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode))
    } catch {
        return !1
    }
}
function sF(t) {
    let e = t.docView.domFromPos(t.state.selection.anchor, 0)
        , n = t.domSelectionRange();
    return Da(e.node, e.offset, n.anchorNode, n.anchorOffset)
}
function V1(t, e) {
    let { $anchor: n, $head: r } = t.selection
        , i = e > 0 ? n.max(r) : n.min(r)
        , s = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
    return s && Ve.findFrom(s, e)
}
function lo(t, e) {
    return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()),
        !0
}
function e3(t, e, n) {
    let r = t.state.selection;
    if (r instanceof De)
        if (n.indexOf("s") > -1) {
            let { $head: i } = r
                , s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
            if (!s || s.isText || !s.isLeaf)
                return !1;
            let o = t.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
            return lo(t, new De(r.$anchor, o))
        } else if (r.empty) {
            if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
                let i = V1(t.state, e);
                return i && i instanceof Le ? lo(t, i) : !1
            } else if (!(ei && n.indexOf("m") > -1)) {
                let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
                if (!s || s.isText)
                    return !1;
                let a = e < 0 ? i.pos - s.nodeSize : i.pos;
                return s.isAtom || (o = t.docView.descAt(a)) && !o.contentDOM ? Le.isSelectable(s) ? lo(t, new Le(e < 0 ? t.state.doc.resolve(i.pos - s.nodeSize) : i)) : _d ? lo(t, new De(t.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1
            }
        } else
            return !1;
    else {
        if (r instanceof Le && r.node.isInline)
            return lo(t, new De(e > 0 ? r.$to : r.$from));
        {
            let i = V1(t.state, e);
            return i ? lo(t, i) : !1
        }
    }
}
function Xh(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function gc(t, e) {
    let n = t.pmViewDesc;
    return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR")
}
function gl(t, e) {
    return e < 0 ? oF(t) : aF(t)
}
function oF(t) {
    let e = t.domSelectionRange()
        , n = e.focusNode
        , r = e.focusOffset;
    if (!n)
        return;
    let i, s, o = !1;
    for (Oi && n.nodeType == 1 && r < Xh(n) && gc(n.childNodes[r], -1) && (o = !0); ;)
        if (r > 0) {
            if (n.nodeType != 1)
                break;
            {
                let a = n.childNodes[r - 1];
                if (gc(a, -1))
                    i = n,
                        s = --r;
                else if (a.nodeType == 3)
                    n = a,
                        r = n.nodeValue.length;
                else
                    break
            }
        } else {
            if (bT(n))
                break;
            {
                let a = n.previousSibling;
                for (; a && gc(a, -1);)
                    i = n.parentNode,
                        s = Bn(a),
                        a = a.previousSibling;
                if (a)
                    n = a,
                        r = Xh(n);
                else {
                    if (n = n.parentNode,
                        n == t.dom)
                        break;
                    r = 0
                }
            }
        }
    o ? W1(t, n, r) : i && W1(t, i, s)
}
function aF(t) {
    let e = t.domSelectionRange()
        , n = e.focusNode
        , r = e.focusOffset;
    if (!n)
        return;
    let i = Xh(n), s, o;
    for (; ;)
        if (r < i) {
            if (n.nodeType != 1)
                break;
            let a = n.childNodes[r];
            if (gc(a, 1))
                s = n,
                    o = ++r;
            else
                break
        } else {
            if (bT(n))
                break;
            {
                let a = n.nextSibling;
                for (; a && gc(a, 1);)
                    s = a.parentNode,
                        o = Bn(a) + 1,
                        a = a.nextSibling;
                if (a)
                    n = a,
                        r = 0,
                        i = Xh(n);
                else {
                    if (n = n.parentNode,
                        n == t.dom)
                        break;
                    r = i = 0
                }
            }
        }
    s && W1(t, s, o)
}
function bT(t) {
    let e = t.pmViewDesc;
    return e && e.node && e.node.isBlock
}
function lF(t, e) {
    for (; t && e == t.childNodes.length && !xd(t);)
        e = Bn(t) + 1,
            t = t.parentNode;
    for (; t && e < t.childNodes.length;) {
        let n = t.childNodes[e];
        if (n.nodeType == 3)
            return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
            break;
        t = n,
            e = 0
    }
}
function uF(t, e) {
    for (; t && !e && !xd(t);)
        e = Bn(t),
            t = t.parentNode;
    for (; t && e;) {
        let n = t.childNodes[e - 1];
        if (n.nodeType == 3)
            return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
            break;
        t = n,
            e = t.childNodes.length
    }
}
function W1(t, e, n) {
    if (e.nodeType != 3) {
        let s, o;
        (o = lF(e, n)) ? (e = o,
            n = 0) : (s = uF(e, n)) && (e = s,
                n = s.nodeValue.length)
    }
    let r = t.domSelection();
    if (!r)
        return;
    if (xm(r)) {
        let s = document.createRange();
        s.setEnd(e, n),
            s.setStart(e, n),
            r.removeAllRanges(),
            r.addRange(s)
    } else
        r.extend && r.extend(e, n);
    t.domObserver.setCurSelection();
    let { state: i } = t;
    setTimeout(() => {
        t.state == i && Is(t)
    }
        , 50)
}
function t3(t, e) {
    let n = t.state.doc.resolve(e);
    if (!(Yn || Rz) && n.parent.inlineContent) {
        let i = t.coordsAtPos(e);
        if (e > n.start()) {
            let s = t.coordsAtPos(e - 1)
                , o = (s.top + s.bottom) / 2;
            if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
                return s.left < i.left ? "ltr" : "rtl"
        }
        if (e < n.end()) {
            let s = t.coordsAtPos(e + 1)
                , o = (s.top + s.bottom) / 2;
            if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
                return s.left > i.left ? "ltr" : "rtl"
        }
    }
    return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr"
}
function n3(t, e, n) {
    let r = t.state.selection;
    if (r instanceof De && !r.empty || n.indexOf("s") > -1 || ei && n.indexOf("m") > -1)
        return !1;
    let { $from: i, $to: s } = r;
    if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
        let o = V1(t.state, e);
        if (o && o instanceof Le)
            return lo(t, o)
    }
    if (!i.parent.inlineContent) {
        let o = e < 0 ? i : s
            , a = r instanceof Ci ? Ve.near(o, e) : Ve.findFrom(o, e);
        return a ? lo(t, a) : !1
    }
    return !1
}
function r3(t, e) {
    if (!(t.state.selection instanceof De))
        return !0;
    let { $head: n, $anchor: r, empty: i } = t.state.selection;
    if (!n.sameParent(r))
        return !0;
    if (!i)
        return !1;
    if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
        return !0;
    let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
    if (s && !s.isText) {
        let o = t.state.tr;
        return e < 0 ? o.delete(n.pos - s.nodeSize, n.pos) : o.delete(n.pos, n.pos + s.nodeSize),
            t.dispatch(o),
            !0
    }
    return !1
}
function i3(t, e, n) {
    t.domObserver.stop(),
        e.contentEditable = n,
        t.domObserver.start()
}
function cF(t) {
    if (!dr || t.state.selection.$head.parentOffset > 0)
        return !1;
    let { focusNode: e, focusOffset: n } = t.domSelectionRange();
    if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
        let r = e.firstChild;
        i3(t, r, "true"),
            setTimeout(() => i3(t, r, "false"), 20)
    }
    return !1
}
function dF(t) {
    let e = "";
    return t.ctrlKey && (e += "c"),
        t.metaKey && (e += "m"),
        t.altKey && (e += "a"),
        t.shiftKey && (e += "s"),
        e
}
function fF(t, e) {
    let n = e.keyCode
        , r = dF(e);
    if (n == 8 || ei && n == 72 && r == "c")
        return r3(t, -1) || gl(t, -1);
    if (n == 46 && !e.shiftKey || ei && n == 68 && r == "c")
        return r3(t, 1) || gl(t, 1);
    if (n == 13 || n == 27)
        return !0;
    if (n == 37 || ei && n == 66 && r == "c") {
        let i = n == 37 ? t3(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return e3(t, i, r) || gl(t, i)
    } else if (n == 39 || ei && n == 70 && r == "c") {
        let i = n == 39 ? t3(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return e3(t, i, r) || gl(t, i)
    } else {
        if (n == 38 || ei && n == 80 && r == "c")
            return n3(t, -1, r) || gl(t, -1);
        if (n == 40 || ei && n == 78 && r == "c")
            return cF(t) || n3(t, 1, r) || gl(t, 1);
        if (r == (ei ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
            return !0
    }
    return !1
}
function wT(t, e) {
    t.someProp("transformCopied", g => {
        e = g(e, t)
    }
    );
    let n = []
        , { content: r, openStart: i, openEnd: s } = e;
    for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1;) {
        i--,
            s--;
        let g = r.firstChild;
        n.push(g.type.name, g.attrs != g.type.defaultAttrs ? g.attrs : null),
            r = g.content
    }
    let o = t.someProp("clipboardSerializer") || Ka.fromSchema(t.state.schema)
        , a = ET()
        , l = a.createElement("div");
    l.appendChild(o.serializeFragment(r, {
        document: a
    }));
    let c = l.firstChild, d, h = 0;
    for (; c && c.nodeType == 1 && (d = CT[c.nodeName.toLowerCase()]);) {
        for (let g = d.length - 1; g >= 0; g--) {
            let y = a.createElement(d[g]);
            for (; l.firstChild;)
                y.appendChild(l.firstChild);
            l.appendChild(y),
                h++
        }
        c = l.firstChild
    }
    c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${h ? ` -${h}` : ""} ${JSON.stringify(n)}`);
    let p = t.someProp("clipboardTextSerializer", g => g(e, t)) || e.content.textBetween(0, e.content.size, `

`);
    return {
        dom: l,
        text: p,
        slice: e
    }
}
function xT(t, e, n, r, i) {
    let s = i.parent.type.spec.code, o, a;
    if (!n && !e)
        return null;
    let l = e && (r || s || !n);
    if (l) {
        if (t.someProp("transformPastedText", p => {
            e = p(e, s || r, t)
        }
        ),
            s)
            return e ? new ve(se.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : ve.empty;
        let h = t.someProp("clipboardTextParser", p => p(e, i, r, t));
        if (h)
            a = h;
        else {
            let p = i.marks()
                , { schema: g } = t.state
                , y = Ka.fromSchema(g);
            o = document.createElement("div"),
                e.split(/(?:\r\n?|\n)+/).forEach(x => {
                    let S = o.appendChild(document.createElement("p"));
                    x && S.appendChild(y.serializeNode(g.text(x, p)))
                }
                )
        }
    } else
        t.someProp("transformPastedHTML", h => {
            n = h(n, t)
        }
        ),
            o = gF(n),
            _d && yF(o);
    let c = o && o.querySelector("[data-pm-slice]")
        , d = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
    if (d && d[3])
        for (let h = +d[3]; h > 0; h--) {
            let p = o.firstChild;
            for (; p && p.nodeType != 1;)
                p = p.nextSibling;
            if (!p)
                break;
            o = p
        }
    if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || hc.fromSchema(t.state.schema)).parseSlice(o, {
        preserveWhitespace: !!(l || d),
        context: i,
        ruleFromNode(p) {
            return p.nodeName == "BR" && !p.nextSibling && p.parentNode && !hF.test(p.parentNode.nodeName) ? {
                ignore: !0
            } : null
        }
    })),
        d)
        a = vF(s3(a, +d[1], +d[2]), d[4]);
    else if (a = ve.maxOpen(pF(a.content, i), !0),
        a.openStart || a.openEnd) {
        let h = 0
            , p = 0;
        for (let g = a.content.firstChild; h < a.openStart && !g.type.spec.isolating; h++,
            g = g.firstChild)
            ;
        for (let g = a.content.lastChild; p < a.openEnd && !g.type.spec.isolating; p++,
            g = g.lastChild)
            ;
        a = s3(a, h, p)
    }
    return t.someProp("transformPasted", h => {
        a = h(a, t)
    }
    ),
        a
}
const hF = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function pF(t, e) {
    if (t.childCount < 2)
        return t;
    for (let n = e.depth; n >= 0; n--) {
        let i = e.node(n).contentMatchAt(e.index(n)), s, o = [];
        if (t.forEach(a => {
            if (!o)
                return;
            let l = i.findWrapping(a.type), c;
            if (!l)
                return o = null;
            if (c = o.length && s.length && ST(l, s, a, o[o.length - 1], 0))
                o[o.length - 1] = c;
            else {
                o.length && (o[o.length - 1] = kT(o[o.length - 1], s.length));
                let d = _T(a, l);
                o.push(d),
                    i = i.matchType(d.type),
                    s = l
            }
        }
        ),
            o)
            return se.from(o)
    }
    return t
}
function _T(t, e, n = 0) {
    for (let r = e.length - 1; r >= n; r--)
        t = e[r].create(null, se.from(t));
    return t
}
function ST(t, e, n, r, i) {
    if (i < t.length && i < e.length && t[i] == e[i]) {
        let s = ST(t, e, n, r.lastChild, i + 1);
        if (s)
            return r.copy(r.content.replaceChild(r.childCount - 1, s));
        if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
            return r.copy(r.content.append(se.from(_T(n, t, i + 1))))
    }
}
function kT(t, e) {
    if (e == 0)
        return t;
    let n = t.content.replaceChild(t.childCount - 1, kT(t.lastChild, e - 1))
        , r = t.contentMatchAt(t.childCount).fillBefore(se.empty, !0);
    return t.copy(n.append(r))
}
function U1(t, e, n, r, i, s) {
    let o = e < 0 ? t.firstChild : t.lastChild
        , a = o.content;
    return t.childCount > 1 && (s = 0),
        i < r - 1 && (a = U1(a, e, n, r, i + 1, s)),
        i >= n && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, s <= i).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(se.empty, !0))),
        t.replaceChild(e < 0 ? 0 : t.childCount - 1, o.copy(a))
}
function s3(t, e, n) {
    return e < t.openStart && (t = new ve(U1(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)),
        n < t.openEnd && (t = new ve(U1(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
        t
}
const CT = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
};
let o3 = null;
function ET() {
    return o3 || (o3 = document.implementation.createHTMLDocument("title"))
}
function mF(t) {
    let e = window.trustedTypes;
    return e ? e.createPolicy("detachedDocument", {
        createHTML: n => n
    }).createHTML(t) : t
}
function gF(t) {
    let e = /^(\s*<meta [^>]*>)*/.exec(t);
    e && (t = t.slice(e[0].length));
    let n = ET().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i;
    if ((i = r && CT[r[1].toLowerCase()]) && (t = i.map(s => "<" + s + ">").join("") + t + i.map(s => "</" + s + ">").reverse().join("")),
        n.innerHTML = mF(t),
        i)
        for (let s = 0; s < i.length; s++)
            n = n.querySelector(i[s]) || n;
    return n
}
function yF(t) {
    let e = t.querySelectorAll(Yn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let n = 0; n < e.length; n++) {
        let r = e[n];
        r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r)
    }
}
function vF(t, e) {
    if (!t.size)
        return t;
    let n = t.content.firstChild.type.schema, r;
    try {
        r = JSON.parse(e)
    } catch {
        return t
    }
    let { content: i, openStart: s, openEnd: o } = t;
    for (let a = r.length - 2; a >= 0; a -= 2) {
        let l = n.nodes[r[a]];
        if (!l || l.hasRequiredAttrs())
            break;
        i = se.from(l.create(r[a + 1], i)),
            s++,
            o++
    }
    return new ve(i, s, o)
}
const fr = {}
    , hr = {}
    , bF = {
        touchstart: !0,
        touchmove: !0
    };
class wF {
    constructor() {
        this.shiftKey = !1,
            this.mouseDown = null,
            this.lastKeyCode = null,
            this.lastKeyCodeTime = 0,
            this.lastClick = {
                time: 0,
                x: 0,
                y: 0,
                type: ""
            },
            this.lastSelectionOrigin = null,
            this.lastSelectionTime = 0,
            this.lastIOSEnter = 0,
            this.lastIOSEnterFallbackTimeout = -1,
            this.lastFocus = 0,
            this.lastTouch = 0,
            this.lastAndroidDelete = 0,
            this.composing = !1,
            this.compositionNode = null,
            this.composingTimeout = -1,
            this.compositionNodes = [],
            this.compositionEndedAt = -2e8,
            this.compositionID = 1,
            this.compositionPendingChanges = 0,
            this.domChangeCount = 0,
            this.eventHandlers = Object.create(null),
            this.hideSelectionGuard = null
    }
}
function xF(t) {
    for (let e in fr) {
        let n = fr[e];
        t.dom.addEventListener(e, t.input.eventHandlers[e] = r => {
            SF(t, r) && !kv(t, r) && (t.editable || !(r.type in hr)) && n(t, r)
        }
            , bF[e] ? {
                passive: !0
            } : void 0)
    }
    dr && t.dom.addEventListener("input", () => null),
        K1(t)
}
function xo(t, e) {
    t.input.lastSelectionOrigin = e,
        t.input.lastSelectionTime = Date.now()
}
function _F(t) {
    t.domObserver.stop();
    for (let e in t.input.eventHandlers)
        t.dom.removeEventListener(e, t.input.eventHandlers[e]);
    clearTimeout(t.input.composingTimeout),
        clearTimeout(t.input.lastIOSEnterFallbackTimeout)
}
function K1(t) {
    t.someProp("handleDOMEvents", e => {
        for (let n in e)
            t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = r => kv(t, r))
    }
    )
}
function kv(t, e) {
    return t.someProp("handleDOMEvents", n => {
        let r = n[e.type];
        return r ? r(t, e) || e.defaultPrevented : !1
    }
    )
}
function SF(t, e) {
    if (!e.bubbles)
        return !0;
    if (e.defaultPrevented)
        return !1;
    for (let n = e.target; n != t.dom; n = n.parentNode)
        if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
            return !1;
    return !0
}
function kF(t, e) {
    !kv(t, e) && fr[e.type] && (t.editable || !(e.type in hr)) && fr[e.type](t, e)
}
hr.keydown = (t, e) => {
    let n = e;
    if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey,
        !AT(t, n) && (t.input.lastKeyCode = n.keyCode,
            t.input.lastKeyCodeTime = Date.now(),
            !(yi && Yn && n.keyCode == 13)))
        if (t.domObserver.selectionChanged(t.domSelectionRange()) ? t.domObserver.flush() : n.keyCode != 229 && t.domObserver.forceFlush(),
            ru && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
            let r = Date.now();
            t.input.lastIOSEnter = r,
                t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
                    t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", i => i(t, ca(13, "Enter"))),
                        t.input.lastIOSEnter = 0)
                }
                    , 200)
        } else
            t.someProp("handleKeyDown", r => r(t, n)) || fF(t, n) ? n.preventDefault() : xo(t, "key")
}
    ;
hr.keyup = (t, e) => {
    e.keyCode == 16 && (t.input.shiftKey = !1)
}
    ;
hr.keypress = (t, e) => {
    let n = e;
    if (AT(t, n) || !n.charCode || n.ctrlKey && !n.altKey || ei && n.metaKey)
        return;
    if (t.someProp("handleKeyPress", i => i(t, n))) {
        n.preventDefault();
        return
    }
    let r = t.state.selection;
    if (!(r instanceof De) || !r.$from.sameParent(r.$to)) {
        let i = String.fromCharCode(n.charCode);
        !/[\r\n]/.test(i) && !t.someProp("handleTextInput", s => s(t, r.$from.pos, r.$to.pos, i)) && t.dispatch(t.state.tr.insertText(i).scrollIntoView()),
            n.preventDefault()
    }
}
    ;
function Sm(t) {
    return {
        left: t.clientX,
        top: t.clientY
    }
}
function CF(t, e) {
    let n = e.x - t.clientX
        , r = e.y - t.clientY;
    return n * n + r * r < 100
}
function Cv(t, e, n, r, i) {
    if (r == -1)
        return !1;
    let s = t.state.doc.resolve(r);
    for (let o = s.depth + 1; o > 0; o--)
        if (t.someProp(e, a => o > s.depth ? a(t, n, s.nodeAfter, s.before(o), i, !0) : a(t, n, s.node(o), s.before(o), i, !1)))
            return !0;
    return !1
}
function Hl(t, e, n) {
    if (t.focused || t.focus(),
        t.state.selection.eq(e))
        return;
    let r = t.state.tr.setSelection(e);
    n == "pointer" && r.setMeta("pointer", !0),
        t.dispatch(r)
}
function EF(t, e) {
    if (e == -1)
        return !1;
    let n = t.state.doc.resolve(e)
        , r = n.nodeAfter;
    return r && r.isAtom && Le.isSelectable(r) ? (Hl(t, new Le(n), "pointer"),
        !0) : !1
}
function TF(t, e) {
    if (e == -1)
        return !1;
    let n = t.state.selection, r, i;
    n instanceof Le && (r = n.node);
    let s = t.state.doc.resolve(e);
    for (let o = s.depth + 1; o > 0; o--) {
        let a = o > s.depth ? s.nodeAfter : s.node(o);
        if (Le.isSelectable(a)) {
            r && n.$from.depth > 0 && o >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? i = s.before(n.$from.depth) : i = s.before(o);
            break
        }
    }
    return i != null ? (Hl(t, Le.create(t.state.doc, i), "pointer"),
        !0) : !1
}
function AF(t, e, n, r, i) {
    return Cv(t, "handleClickOn", e, n, r) || t.someProp("handleClick", s => s(t, e, r)) || (i ? TF(t, n) : EF(t, n))
}
function OF(t, e, n, r) {
    return Cv(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", i => i(t, e, r))
}
function MF(t, e, n, r) {
    return Cv(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", i => i(t, e, r)) || RF(t, n, r)
}
function RF(t, e, n) {
    if (n.button != 0)
        return !1;
    let r = t.state.doc;
    if (e == -1)
        return r.inlineContent ? (Hl(t, De.create(r, 0, r.content.size), "pointer"),
            !0) : !1;
    let i = r.resolve(e);
    for (let s = i.depth + 1; s > 0; s--) {
        let o = s > i.depth ? i.nodeAfter : i.node(s)
            , a = i.before(s);
        if (o.inlineContent)
            Hl(t, De.create(r, a + 1, a + 1 + o.content.size), "pointer");
        else if (Le.isSelectable(o))
            Hl(t, Le.create(r, a), "pointer");
        else
            continue;
        return !0
    }
}
function Ev(t) {
    return Qh(t)
}
const TT = ei ? "metaKey" : "ctrlKey";
fr.mousedown = (t, e) => {
    let n = e;
    t.input.shiftKey = n.shiftKey;
    let r = Ev(t)
        , i = Date.now()
        , s = "singleClick";
    i - t.input.lastClick.time < 500 && CF(n, t.input.lastClick) && !n[TT] && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")),
        t.input.lastClick = {
            time: i,
            x: n.clientX,
            y: n.clientY,
            type: s
        };
    let o = t.posAtCoords(Sm(n));
    o && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(),
        t.input.mouseDown = new PF(t, o, n, !!r)) : (s == "doubleClick" ? OF : MF)(t, o.pos, o.inside, n) ? n.preventDefault() : xo(t, "pointer"))
}
    ;
class PF {
    constructor(e, n, r, i) {
        this.view = e,
            this.pos = n,
            this.event = r,
            this.flushed = i,
            this.delayedSelectionSync = !1,
            this.mightDrag = null,
            this.startDoc = e.state.doc,
            this.selectNode = !!r[TT],
            this.allowDefault = r.shiftKey;
        let s, o;
        if (n.inside > -1)
            s = e.state.doc.nodeAt(n.inside),
                o = n.inside;
        else {
            let d = e.state.doc.resolve(n.pos);
            s = d.parent,
                o = d.depth ? d.before() : 0
        }
        const a = i ? null : r.target
            , l = a ? e.docView.nearestDesc(a, !0) : null;
        this.target = l && l.dom.nodeType == 1 ? l.dom : null;
        let { selection: c } = e.state;
        (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof Le && c.from <= o && c.to > o) && (this.mightDrag = {
            node: s,
            pos: o,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && Oi && !this.target.hasAttribute("contentEditable"))
        }),
            this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(),
                this.mightDrag.addAttr && (this.target.draggable = !0),
                this.mightDrag.setUneditable && setTimeout(() => {
                    this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false")
                }
                    , 20),
                this.view.domObserver.start()),
            e.root.addEventListener("mouseup", this.up = this.up.bind(this)),
            e.root.addEventListener("mousemove", this.move = this.move.bind(this)),
            xo(e, "pointer")
    }
    done() {
        this.view.root.removeEventListener("mouseup", this.up),
            this.view.root.removeEventListener("mousemove", this.move),
            this.mightDrag && this.target && (this.view.domObserver.stop(),
                this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
                this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"),
                this.view.domObserver.start()),
            this.delayedSelectionSync && setTimeout(() => Is(this.view)),
            this.view.input.mouseDown = null
    }
    up(e) {
        if (this.done(),
            !this.view.dom.contains(e.target))
            return;
        let n = this.pos;
        this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Sm(e))),
            this.updateAllowDefault(e),
            this.allowDefault || !n ? xo(this.view, "pointer") : AF(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || dr && this.mightDrag && !this.mightDrag.node.isAtom || Yn && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Hl(this.view, Ve.near(this.view.state.doc.resolve(n.pos)), "pointer"),
                e.preventDefault()) : xo(this.view, "pointer")
    }
    move(e) {
        this.updateAllowDefault(e),
            xo(this.view, "pointer"),
            e.buttons == 0 && this.done()
    }
    updateAllowDefault(e) {
        !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0)
    }
}
fr.touchstart = t => {
    t.input.lastTouch = Date.now(),
        Ev(t),
        xo(t, "pointer")
}
    ;
fr.touchmove = t => {
    t.input.lastTouch = Date.now(),
        xo(t, "pointer")
}
    ;
fr.contextmenu = t => Ev(t);
function AT(t, e) {
    return t.composing ? !0 : dr && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8,
        !0) : !1
}
const NF = yi ? 5e3 : -1;
hr.compositionstart = hr.compositionupdate = t => {
    if (!t.composing) {
        t.domObserver.flush();
        let { state: e } = t
            , n = e.selection.$to;
        if (e.selection instanceof De && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(r => r.type.spec.inclusive === !1)))
            t.markCursor = t.state.storedMarks || n.marks(),
                Qh(t, !0),
                t.markCursor = null;
        else if (Qh(t, !e.selection.empty),
            Oi && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
            let r = t.domSelectionRange();
            for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0;) {
                let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
                if (!o)
                    break;
                if (o.nodeType == 3) {
                    let a = t.domSelection();
                    a && a.collapse(o, o.nodeValue.length);
                    break
                } else
                    i = o,
                        s = -1
            }
        }
        t.input.composing = !0
    }
    OT(t, NF)
}
    ;
hr.compositionend = (t, e) => {
    t.composing && (t.input.composing = !1,
        t.input.compositionEndedAt = e.timeStamp,
        t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0,
        t.input.compositionNode = null,
        t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()),
        t.input.compositionID++,
        OT(t, 20))
}
    ;
function OT(t, e) {
    clearTimeout(t.input.composingTimeout),
        e > -1 && (t.input.composingTimeout = setTimeout(() => Qh(t), e))
}
function MT(t) {
    for (t.composing && (t.input.composing = !1,
        t.input.compositionEndedAt = LF()); t.input.compositionNodes.length > 0;)
        t.input.compositionNodes.pop().markParentsDirty()
}
function IF(t) {
    let e = t.domSelectionRange();
    if (!e.focusNode)
        return null;
    let n = Ez(e.focusNode, e.focusOffset)
        , r = Tz(e.focusNode, e.focusOffset);
    if (n && r && n != r) {
        let i = r.pmViewDesc
            , s = t.domObserver.lastChangedTextNode;
        if (n == s || r == s)
            return s;
        if (!i || !i.isText(r.nodeValue))
            return r;
        if (t.input.compositionNode == r) {
            let o = n.pmViewDesc;
            if (!(!o || !o.isText(n.nodeValue)))
                return r
        }
    }
    return n || r
}
function LF() {
    let t = document.createEvent("Event");
    return t.initEvent("event", !0, !0),
        t.timeStamp
}
function Qh(t, e = !1) {
    if (!(yi && t.domObserver.flushingSoon >= 0)) {
        if (t.domObserver.forceFlush(),
            MT(t),
            e || t.docView && t.docView.dirty) {
            let n = _v(t);
            return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !t.state.selection.empty ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state),
                !0
        }
        return !1
    }
}
function DF(t, e) {
    if (!t.dom.parentNode)
        return;
    let n = t.dom.parentNode.appendChild(document.createElement("div"));
    n.appendChild(e),
        n.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let r = getSelection()
        , i = document.createRange();
    i.selectNodeContents(e),
        t.dom.blur(),
        r.removeAllRanges(),
        r.addRange(i),
        setTimeout(() => {
            n.parentNode && n.parentNode.removeChild(n),
                t.focus()
        }
            , 50)
}
const Bc = Tr && Co < 15 || ru && Pz < 604;
fr.copy = hr.cut = (t, e) => {
    let n = e
        , r = t.state.selection
        , i = n.type == "cut";
    if (r.empty)
        return;
    let s = Bc ? null : n.clipboardData
        , o = r.content()
        , { dom: a, text: l } = wT(t, o);
    s ? (n.preventDefault(),
        s.clearData(),
        s.setData("text/html", a.innerHTML),
        s.setData("text/plain", l)) : DF(t, a),
        i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"))
}
    ;
function jF(t) {
    return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null
}
function BF(t, e) {
    if (!t.dom.parentNode)
        return;
    let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code
        , r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
    n || (r.contentEditable = "true"),
        r.style.cssText = "position: fixed; left: -10000px; top: 10px",
        r.focus();
    let i = t.input.shiftKey && t.input.lastKeyCode != 45;
    setTimeout(() => {
        t.focus(),
            r.parentNode && r.parentNode.removeChild(r),
            n ? $c(t, r.value, null, i, e) : $c(t, r.textContent, r.innerHTML, i, e)
    }
        , 50)
}
function $c(t, e, n, r, i) {
    let s = xT(t, e, n, r, t.state.selection.$from);
    if (t.someProp("handlePaste", l => l(t, i, s || ve.empty)))
        return !0;
    if (!s)
        return !1;
    let o = jF(s)
        , a = o ? t.state.tr.replaceSelectionWith(o, r) : t.state.tr.replaceSelection(s);
    return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")),
        !0
}
function RT(t) {
    let e = t.getData("text/plain") || t.getData("Text");
    if (e)
        return e;
    let n = t.getData("text/uri-list");
    return n ? n.replace(/\r?\n/g, " ") : ""
}
hr.paste = (t, e) => {
    let n = e;
    if (t.composing && !yi)
        return;
    let r = Bc ? null : n.clipboardData
        , i = t.input.shiftKey && t.input.lastKeyCode != 45;
    r && $c(t, RT(r), r.getData("text/html"), i, n) ? n.preventDefault() : BF(t, n)
}
    ;
class PT {
    constructor(e, n, r) {
        this.slice = e,
            this.move = n,
            this.node = r
    }
}
const NT = ei ? "altKey" : "ctrlKey";
fr.dragstart = (t, e) => {
    let n = e
        , r = t.input.mouseDown;
    if (r && r.done(),
        !n.dataTransfer)
        return;
    let i = t.state.selection, s = i.empty ? null : t.posAtCoords(Sm(n)), o;
    if (!(s && s.pos >= i.from && s.pos <= (i instanceof Le ? i.to - 1 : i.to))) {
        if (r && r.mightDrag)
            o = Le.create(t.state.doc, r.mightDrag.pos);
        else if (n.target && n.target.nodeType == 1) {
            let h = t.docView.nearestDesc(n.target, !0);
            h && h.node.type.spec.draggable && h != t.docView && (o = Le.create(t.state.doc, h.posBefore))
        }
    }
    let a = (o || t.state.selection).content()
        , { dom: l, text: c, slice: d } = wT(t, a);
    (!n.dataTransfer.files.length || !Yn || iT > 120) && n.dataTransfer.clearData(),
        n.dataTransfer.setData(Bc ? "Text" : "text/html", l.innerHTML),
        n.dataTransfer.effectAllowed = "copyMove",
        Bc || n.dataTransfer.setData("text/plain", c),
        t.dragging = new PT(d, !n[NT], o)
}
    ;
fr.dragend = t => {
    let e = t.dragging;
    window.setTimeout(() => {
        t.dragging == e && (t.dragging = null)
    }
        , 50)
}
    ;
hr.dragover = hr.dragenter = (t, e) => e.preventDefault();
hr.drop = (t, e) => {
    let n = e
        , r = t.dragging;
    if (t.dragging = null,
        !n.dataTransfer)
        return;
    let i = t.posAtCoords(Sm(n));
    if (!i)
        return;
    let s = t.state.doc.resolve(i.pos)
        , o = r && r.slice;
    o ? t.someProp("transformPasted", y => {
        o = y(o, t)
    }
    ) : o = xT(t, RT(n.dataTransfer), Bc ? null : n.dataTransfer.getData("text/html"), !1, s);
    let a = !!(r && !n[NT]);
    if (t.someProp("handleDrop", y => y(t, n, o || ve.empty, a))) {
        n.preventDefault();
        return
    }
    if (!o)
        return;
    n.preventDefault();
    let l = o ? JE(t.state.doc, s.pos, o) : s.pos;
    l == null && (l = s.pos);
    let c = t.state.tr;
    if (a) {
        let { node: y } = r;
        y ? y.replace(c) : c.deleteSelection()
    }
    let d = c.mapping.map(l)
        , h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1
        , p = c.doc;
    if (h ? c.replaceRangeWith(d, d, o.content.firstChild) : c.replaceRange(d, d, o),
        c.doc.eq(p))
        return;
    let g = c.doc.resolve(d);
    if (h && Le.isSelectable(o.content.firstChild) && g.nodeAfter && g.nodeAfter.sameMarkup(o.content.firstChild))
        c.setSelection(new Le(g));
    else {
        let y = c.mapping.map(l);
        c.mapping.maps[c.mapping.maps.length - 1].forEach((x, S, k, A) => y = A),
            c.setSelection(Sv(t, g, c.doc.resolve(y)))
    }
    t.focus(),
        t.dispatch(c.setMeta("uiEvent", "drop"))
}
    ;
fr.focus = t => {
    t.input.lastFocus = Date.now(),
        t.focused || (t.domObserver.stop(),
            t.dom.classList.add("ProseMirror-focused"),
            t.domObserver.start(),
            t.focused = !0,
            setTimeout(() => {
                t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Is(t)
            }
                , 20))
}
    ;
fr.blur = (t, e) => {
    let n = e;
    t.focused && (t.domObserver.stop(),
        t.dom.classList.remove("ProseMirror-focused"),
        t.domObserver.start(),
        n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(),
        t.focused = !1)
}
    ;
fr.beforeinput = (t, e) => {
    if (Yn && yi && e.inputType == "deleteContentBackward") {
        t.domObserver.flushSoon();
        let { domChangeCount: r } = t.input;
        setTimeout(() => {
            if (t.input.domChangeCount != r || (t.dom.blur(),
                t.focus(),
                t.someProp("handleKeyDown", s => s(t, ca(8, "Backspace")))))
                return;
            let { $cursor: i } = t.state.selection;
            i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView())
        }
            , 50)
    }
}
    ;
for (let t in hr)
    fr[t] = hr[t];
function zc(t, e) {
    if (t == e)
        return !0;
    for (let n in t)
        if (t[n] !== e[n])
            return !1;
    for (let n in e)
        if (!(n in t))
            return !1;
    return !0
}
class ep {
    constructor(e, n) {
        this.toDOM = e,
            this.spec = n || Sa,
            this.side = this.spec.side || 0
    }
    map(e, n, r, i) {
        let { pos: s, deleted: o } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
        return o ? null : new Xn(s - r, s - r, this)
    }
    valid() {
        return !0
    }
    eq(e) {
        return this == e || e instanceof ep && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && zc(this.spec, e.spec))
    }
    destroy(e) {
        this.spec.destroy && this.spec.destroy(e)
    }
}
class To {
    constructor(e, n) {
        this.attrs = e,
            this.spec = n || Sa
    }
    map(e, n, r, i) {
        let s = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r
            , o = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
        return s >= o ? null : new Xn(s, o, this)
    }
    valid(e, n) {
        return n.from < n.to
    }
    eq(e) {
        return this == e || e instanceof To && zc(this.attrs, e.attrs) && zc(this.spec, e.spec)
    }
    static is(e) {
        return e.type instanceof To
    }
    destroy() { }
}
class Tv {
    constructor(e, n) {
        this.attrs = e,
            this.spec = n || Sa
    }
    map(e, n, r, i) {
        let s = e.mapResult(n.from + i, 1);
        if (s.deleted)
            return null;
        let o = e.mapResult(n.to + i, -1);
        return o.deleted || o.pos <= s.pos ? null : new Xn(s.pos - r, o.pos - r, this)
    }
    valid(e, n) {
        let { index: r, offset: i } = e.content.findIndex(n.from), s;
        return i == n.from && !(s = e.child(r)).isText && i + s.nodeSize == n.to
    }
    eq(e) {
        return this == e || e instanceof Tv && zc(this.attrs, e.attrs) && zc(this.spec, e.spec)
    }
    destroy() { }
}
class Xn {
    constructor(e, n, r) {
        this.from = e,
            this.to = n,
            this.type = r
    }
    copy(e, n) {
        return new Xn(e, n, this.type)
    }
    eq(e, n = 0) {
        return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to
    }
    map(e, n, r) {
        return this.type.map(e, this, n, r)
    }
    static widget(e, n, r) {
        return new Xn(e, e, new ep(n, r))
    }
    static inline(e, n, r, i) {
        return new Xn(e, n, new To(r, i))
    }
    static node(e, n, r, i) {
        return new Xn(e, n, new Tv(r, i))
    }
    get spec() {
        return this.type.spec
    }
    get inline() {
        return this.type instanceof To
    }
    get widget() {
        return this.type instanceof ep
    }
}
const Sl = []
    , Sa = {};
class Zt {
    constructor(e, n) {
        this.local = e.length ? e : Sl,
            this.children = n.length ? n : Sl
    }
    static create(e, n) {
        return n.length ? tp(n, e, 0, Sa) : qn
    }
    find(e, n, r) {
        let i = [];
        return this.findInner(e ?? 0, n ?? 1e9, i, 0, r),
            i
    }
    findInner(e, n, r, i, s) {
        for (let o = 0; o < this.local.length; o++) {
            let a = this.local[o];
            a.from <= n && a.to >= e && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i))
        }
        for (let o = 0; o < this.children.length; o += 3)
            if (this.children[o] < n && this.children[o + 1] > e) {
                let a = this.children[o] + 1;
                this.children[o + 2].findInner(e - a, n - a, r, i + a, s)
            }
    }
    map(e, n, r) {
        return this == qn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Sa)
    }
    mapInner(e, n, r, i, s) {
        let o;
        for (let a = 0; a < this.local.length; a++) {
            let l = this.local[a].map(e, r, i);
            l && l.type.valid(n, l) ? (o || (o = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec)
        }
        return this.children.length ? $F(this.children, o || [], e, n, r, i, s) : o ? new Zt(o.sort(ka), Sl) : qn
    }
    add(e, n) {
        return n.length ? this == qn ? Zt.create(e, n) : this.addInner(e, n, 0) : this
    }
    addInner(e, n, r) {
        let i, s = 0;
        e.forEach((a, l) => {
            let c = l + r, d;
            if (d = LT(n, a, c)) {
                for (i || (i = this.children.slice()); s < i.length && i[s] < l;)
                    s += 3;
                i[s] == l ? i[s + 2] = i[s + 2].addInner(a, d, c + 1) : i.splice(s, 0, l, l + a.nodeSize, tp(d, a, c + 1, Sa)),
                    s += 3
            }
        }
        );
        let o = IT(s ? DT(n) : n, -r);
        for (let a = 0; a < o.length; a++)
            o[a].type.valid(e, o[a]) || o.splice(a--, 1);
        return new Zt(o.length ? this.local.concat(o).sort(ka) : this.local, i || this.children)
    }
    remove(e) {
        return e.length == 0 || this == qn ? this : this.removeInner(e, 0)
    }
    removeInner(e, n) {
        let r = this.children
            , i = this.local;
        for (let s = 0; s < r.length; s += 3) {
            let o, a = r[s] + n, l = r[s + 1] + n;
            for (let d = 0, h; d < e.length; d++)
                (h = e[d]) && h.from > a && h.to < l && (e[d] = null,
                    (o || (o = [])).push(h));
            if (!o)
                continue;
            r == this.children && (r = this.children.slice());
            let c = r[s + 2].removeInner(o, a + 1);
            c != qn ? r[s + 2] = c : (r.splice(s, 3),
                s -= 3)
        }
        if (i.length) {
            for (let s = 0, o; s < e.length; s++)
                if (o = e[s])
                    for (let a = 0; a < i.length; a++)
                        i[a].eq(o, n) && (i == this.local && (i = this.local.slice()),
                            i.splice(a--, 1))
        }
        return r == this.children && i == this.local ? this : i.length || r.length ? new Zt(i, r) : qn
    }
    forChild(e, n) {
        if (this == qn)
            return this;
        if (n.isLeaf)
            return Zt.empty;
        let r, i;
        for (let a = 0; a < this.children.length; a += 3)
            if (this.children[a] >= e) {
                this.children[a] == e && (r = this.children[a + 2]);
                break
            }
        let s = e + 1
            , o = s + n.content.size;
        for (let a = 0; a < this.local.length; a++) {
            let l = this.local[a];
            if (l.from < o && l.to > s && l.type instanceof To) {
                let c = Math.max(s, l.from) - s
                    , d = Math.min(o, l.to) - s;
                c < d && (i || (i = [])).push(l.copy(c, d))
            }
        }
        if (i) {
            let a = new Zt(i.sort(ka), Sl);
            return r ? new ho([a, r]) : a
        }
        return r || qn
    }
    eq(e) {
        if (this == e)
            return !0;
        if (!(e instanceof Zt) || this.local.length != e.local.length || this.children.length != e.children.length)
            return !1;
        for (let n = 0; n < this.local.length; n++)
            if (!this.local[n].eq(e.local[n]))
                return !1;
        for (let n = 0; n < this.children.length; n += 3)
            if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
                return !1;
        return !0
    }
    locals(e) {
        return Av(this.localsInner(e))
    }
    localsInner(e) {
        if (this == qn)
            return Sl;
        if (e.inlineContent || !this.local.some(To.is))
            return this.local;
        let n = [];
        for (let r = 0; r < this.local.length; r++)
            this.local[r].type instanceof To || n.push(this.local[r]);
        return n
    }
    forEachSet(e) {
        e(this)
    }
}
Zt.empty = new Zt([], []);
Zt.removeOverlap = Av;
const qn = Zt.empty;
class ho {
    constructor(e) {
        this.members = e
    }
    map(e, n) {
        const r = this.members.map(i => i.map(e, n, Sa));
        return ho.from(r)
    }
    forChild(e, n) {
        if (n.isLeaf)
            return Zt.empty;
        let r = [];
        for (let i = 0; i < this.members.length; i++) {
            let s = this.members[i].forChild(e, n);
            s != qn && (s instanceof ho ? r = r.concat(s.members) : r.push(s))
        }
        return ho.from(r)
    }
    eq(e) {
        if (!(e instanceof ho) || e.members.length != this.members.length)
            return !1;
        for (let n = 0; n < this.members.length; n++)
            if (!this.members[n].eq(e.members[n]))
                return !1;
        return !0
    }
    locals(e) {
        let n, r = !0;
        for (let i = 0; i < this.members.length; i++) {
            let s = this.members[i].localsInner(e);
            if (s.length)
                if (!n)
                    n = s;
                else {
                    r && (n = n.slice(),
                        r = !1);
                    for (let o = 0; o < s.length; o++)
                        n.push(s[o])
                }
        }
        return n ? Av(r ? n : n.sort(ka)) : Sl
    }
    static from(e) {
        switch (e.length) {
            case 0:
                return qn;
            case 1:
                return e[0];
            default:
                return new ho(e.every(n => n instanceof Zt) ? e : e.reduce((n, r) => n.concat(r instanceof Zt ? r : r.members), []))
        }
    }
    forEachSet(e) {
        for (let n = 0; n < this.members.length; n++)
            this.members[n].forEachSet(e)
    }
}
function $F(t, e, n, r, i, s, o) {
    let a = t.slice();
    for (let c = 0, d = s; c < n.maps.length; c++) {
        let h = 0;
        n.maps[c].forEach((p, g, y, x) => {
            let S = x - y - (g - p);
            for (let k = 0; k < a.length; k += 3) {
                let A = a[k + 1];
                if (A < 0 || p > A + d - h)
                    continue;
                let C = a[k] + d - h;
                g >= C ? a[k + 1] = p <= C ? -2 : -1 : p >= d && S && (a[k] += S,
                    a[k + 1] += S)
            }
            h += S
        }
        ),
            d = n.maps[c].map(d, -1)
    }
    let l = !1;
    for (let c = 0; c < a.length; c += 3)
        if (a[c + 1] < 0) {
            if (a[c + 1] == -2) {
                l = !0,
                    a[c + 1] = -1;
                continue
            }
            let d = n.map(t[c] + s)
                , h = d - i;
            if (h < 0 || h >= r.content.size) {
                l = !0;
                continue
            }
            let p = n.map(t[c + 1] + s, -1)
                , g = p - i
                , { index: y, offset: x } = r.content.findIndex(h)
                , S = r.maybeChild(y);
            if (S && x == h && x + S.nodeSize == g) {
                let k = a[c + 2].mapInner(n, S, d + 1, t[c] + s + 1, o);
                k != qn ? (a[c] = h,
                    a[c + 1] = g,
                    a[c + 2] = k) : (a[c + 1] = -2,
                        l = !0)
            } else
                l = !0
        }
    if (l) {
        let c = zF(a, t, e, n, i, s, o)
            , d = tp(c, r, 0, o);
        e = d.local;
        for (let h = 0; h < a.length; h += 3)
            a[h + 1] < 0 && (a.splice(h, 3),
                h -= 3);
        for (let h = 0, p = 0; h < d.children.length; h += 3) {
            let g = d.children[h];
            for (; p < a.length && a[p] < g;)
                p += 3;
            a.splice(p, 0, d.children[h], d.children[h + 1], d.children[h + 2])
        }
    }
    return new Zt(e.sort(ka), a)
}
function IT(t, e) {
    if (!e || !t.length)
        return t;
    let n = [];
    for (let r = 0; r < t.length; r++) {
        let i = t[r];
        n.push(new Xn(i.from + e, i.to + e, i.type))
    }
    return n
}
function zF(t, e, n, r, i, s, o) {
    function a(l, c) {
        for (let d = 0; d < l.local.length; d++) {
            let h = l.local[d].map(r, i, c);
            h ? n.push(h) : o.onRemove && o.onRemove(l.local[d].spec)
        }
        for (let d = 0; d < l.children.length; d += 3)
            a(l.children[d + 2], l.children[d] + c + 1)
    }
    for (let l = 0; l < t.length; l += 3)
        t[l + 1] == -1 && a(t[l + 2], e[l] + s + 1);
    return n
}
function LT(t, e, n) {
    if (e.isLeaf)
        return null;
    let r = n + e.nodeSize
        , i = null;
    for (let s = 0, o; s < t.length; s++)
        (o = t[s]) && o.from > n && o.to < r && ((i || (i = [])).push(o),
            t[s] = null);
    return i
}
function DT(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
        t[n] != null && e.push(t[n]);
    return e
}
function tp(t, e, n, r) {
    let i = []
        , s = !1;
    e.forEach((a, l) => {
        let c = LT(t, a, l + n);
        if (c) {
            s = !0;
            let d = tp(c, a, n + l + 1, r);
            d != qn && i.push(l, l + a.nodeSize, d)
        }
    }
    );
    let o = IT(s ? DT(t) : t, -n).sort(ka);
    for (let a = 0; a < o.length; a++)
        o[a].type.valid(e, o[a]) || (r.onRemove && r.onRemove(o[a].spec),
            o.splice(a--, 1));
    return o.length || i.length ? new Zt(o, i) : qn
}
function ka(t, e) {
    return t.from - e.from || t.to - e.to
}
function Av(t) {
    let e = t;
    for (let n = 0; n < e.length - 1; n++) {
        let r = e[n];
        if (r.from != r.to)
            for (let i = n + 1; i < e.length; i++) {
                let s = e[i];
                if (s.from == r.from) {
                    s.to != r.to && (e == t && (e = t.slice()),
                        e[i] = s.copy(s.from, r.to),
                        a3(e, i + 1, s.copy(r.to, s.to)));
                    continue
                } else {
                    s.from < r.to && (e == t && (e = t.slice()),
                        e[n] = r.copy(r.from, s.from),
                        a3(e, i, r.copy(s.from, r.to)));
                    break
                }
            }
    }
    return e
}
function a3(t, e, n) {
    for (; e < t.length && ka(n, t[e]) > 0;)
        e++;
    t.splice(e, 0, n)
}
function M0(t) {
    let e = [];
    return t.someProp("decorations", n => {
        let r = n(t.state);
        r && r != qn && e.push(r)
    }
    ),
        t.cursorWrapper && e.push(Zt.create(t.state.doc, [t.cursorWrapper.deco])),
        ho.from(e)
}
const FF = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
}
    , HF = Tr && Co <= 11;
class VF {
    constructor() {
        this.anchorNode = null,
            this.anchorOffset = 0,
            this.focusNode = null,
            this.focusOffset = 0
    }
    set(e) {
        this.anchorNode = e.anchorNode,
            this.anchorOffset = e.anchorOffset,
            this.focusNode = e.focusNode,
            this.focusOffset = e.focusOffset
    }
    clear() {
        this.anchorNode = this.focusNode = null
    }
    eq(e) {
        return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset
    }
}
class WF {
    constructor(e, n) {
        this.view = e,
            this.handleDOMChange = n,
            this.queue = [],
            this.flushingSoon = -1,
            this.observer = null,
            this.currentSelection = new VF,
            this.onCharData = null,
            this.suppressingSelectionUpdates = !1,
            this.lastChangedTextNode = null,
            this.observer = window.MutationObserver && new window.MutationObserver(r => {
                for (let i = 0; i < r.length; i++)
                    this.queue.push(r[i]);
                Tr && Co <= 11 && r.some(i => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush()
            }
            ),
            HF && (this.onCharData = r => {
                this.queue.push({
                    target: r.target,
                    type: "characterData",
                    oldValue: r.prevValue
                }),
                    this.flushSoon()
            }
            ),
            this.onSelectionChange = this.onSelectionChange.bind(this)
    }
    flushSoon() {
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
            this.flushingSoon = -1,
                this.flush()
        }
            , 20))
    }
    forceFlush() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon),
            this.flushingSoon = -1,
            this.flush())
    }
    start() {
        this.observer && (this.observer.takeRecords(),
            this.observer.observe(this.view.dom, FF)),
            this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
            this.connectSelection()
    }
    stop() {
        if (this.observer) {
            let e = this.observer.takeRecords();
            if (e.length) {
                for (let n = 0; n < e.length; n++)
                    this.queue.push(e[n]);
                window.setTimeout(() => this.flush(), 20)
            }
            this.observer.disconnect()
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData),
            this.disconnectSelection()
    }
    connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange)
    }
    disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange)
    }
    suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = !0,
            setTimeout(() => this.suppressingSelectionUpdates = !1, 50)
    }
    onSelectionChange() {
        if (Q_(this.view)) {
            if (this.suppressingSelectionUpdates)
                return Is(this.view);
            if (Tr && Co <= 11 && !this.view.state.selection.empty) {
                let e = this.view.domSelectionRange();
                if (e.focusNode && Da(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
                    return this.flushSoon()
            }
            this.flush()
        }
    }
    setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange())
    }
    ignoreSelectionChange(e) {
        if (!e.focusNode)
            return !0;
        let n = new Set, r;
        for (let s = e.focusNode; s; s = jc(s))
            n.add(s);
        for (let s = e.anchorNode; s; s = jc(s))
            if (n.has(s)) {
                r = s;
                break
            }
        let i = r && this.view.docView.nearestDesc(r);
        if (i && i.ignoreMutation({
            type: "selection",
            target: r.nodeType == 3 ? r.parentNode : r
        }))
            return this.setCurSelection(),
                !0
    }
    pendingRecords() {
        if (this.observer)
            for (let e of this.observer.takeRecords())
                this.queue.push(e);
        return this.queue
    }
    selectionChanged(e) {
        return !this.suppressingSelectionUpdates && !this.currentSelection.eq(e) && Q_(this.view) && !this.ignoreSelectionChange(e)
    }
    flush() {
        let { view: e } = this;
        if (!e.docView || this.flushingSoon > -1)
            return;
        let n = this.pendingRecords();
        n.length && (this.queue = []);
        let r = e.domSelectionRange()
            , i = this.selectionChanged(r)
            , s = -1
            , o = -1
            , a = !1
            , l = [];
        if (e.editable)
            for (let d = 0; d < n.length; d++) {
                let h = this.registerMutation(n[d], l);
                h && (s = s < 0 ? h.from : Math.min(h.from, s),
                    o = o < 0 ? h.to : Math.max(h.to, o),
                    h.typeOver && (a = !0))
            }
        if (Oi && l.length) {
            let d = l.filter(h => h.nodeName == "BR");
            if (d.length == 2) {
                let [h, p] = d;
                h.parentNode && h.parentNode.parentNode == p.parentNode ? p.remove() : h.remove()
            } else {
                let { focusNode: h } = this.currentSelection;
                for (let p of d) {
                    let g = p.parentNode;
                    g && g.nodeName == "LI" && (!h || qF(e, h) != g) && p.remove()
                }
            }
        }
        let c = null;
        s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && xm(r) && (c = _v(e)) && c.eq(Ve.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0,
            Is(e),
            this.currentSelection.set(r),
            e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o),
                UF(e)),
                this.handleDOMChange(s, o, a, l),
                e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Is(e),
                this.currentSelection.set(r))
    }
    registerMutation(e, n) {
        if (n.indexOf(e.target) > -1)
            return null;
        let r = this.view.docView.nearestDesc(e.target);
        if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
            return null;
        if (e.type == "childList") {
            for (let d = 0; d < e.addedNodes.length; d++) {
                let h = e.addedNodes[d];
                n.push(h),
                    h.nodeType == 3 && (this.lastChangedTextNode = h)
            }
            if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
                return {
                    from: r.posBefore,
                    to: r.posAfter
                };
            let i = e.previousSibling
                , s = e.nextSibling;
            if (Tr && Co <= 11 && e.addedNodes.length)
                for (let d = 0; d < e.addedNodes.length; d++) {
                    let { previousSibling: h, nextSibling: p } = e.addedNodes[d];
                    (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h),
                        (!p || Array.prototype.indexOf.call(e.addedNodes, p) < 0) && (s = p)
                }
            let o = i && i.parentNode == e.target ? Bn(i) + 1 : 0
                , a = r.localPosFromDOM(e.target, o, -1)
                , l = s && s.parentNode == e.target ? Bn(s) : e.target.childNodes.length
                , c = r.localPosFromDOM(e.target, l, 1);
            return {
                from: a,
                to: c
            }
        } else
            return e.type == "attributes" ? {
                from: r.posAtStart - r.border,
                to: r.posAtEnd + r.border
            } : (this.lastChangedTextNode = e.target,
            {
                from: r.posAtStart,
                to: r.posAtEnd,
                typeOver: e.target.nodeValue == e.oldValue
            })
    }
}
let l3 = new WeakMap
    , u3 = !1;
function UF(t) {
    if (!l3.has(t) && (l3.set(t, null),
        ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
        if (t.requiresGeckoHackNode = Oi,
            u3)
            return;
        console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."),
            u3 = !0
    }
}
function c3(t, e) {
    let n = e.startContainer
        , r = e.startOffset
        , i = e.endContainer
        , s = e.endOffset
        , o = t.domAtPos(t.state.selection.anchor);
    return Da(o.node, o.offset, i, s) && ([n, r, i, s] = [i, s, n, r]),
    {
        anchorNode: n,
        anchorOffset: r,
        focusNode: i,
        focusOffset: s
    }
}
function KF(t, e) {
    if (e.getComposedRanges) {
        let i = e.getComposedRanges(t.root)[0];
        if (i)
            return c3(t, i)
    }
    let n;
    function r(i) {
        i.preventDefault(),
            i.stopImmediatePropagation(),
            n = i.getTargetRanges()[0]
    }
    return t.dom.addEventListener("beforeinput", r, !0),
        document.execCommand("indent"),
        t.dom.removeEventListener("beforeinput", r, !0),
        n ? c3(t, n) : null
}
function qF(t, e) {
    for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
        let r = t.docView.nearestDesc(n, !0);
        if (r && r.node.isBlock)
            return n
    }
    return null
}
function GF(t, e, n) {
    let { node: r, fromOffset: i, toOffset: s, from: o, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c, d = l.anchorNode;
    if (d && t.dom.contains(d.nodeType == 1 ? d : d.parentNode) && (c = [{
        node: d,
        offset: l.anchorOffset
    }],
        xm(l) || c.push({
            node: l.focusNode,
            offset: l.focusOffset
        })),
        Yn && t.input.lastKeyCode === 8)
        for (let S = s; S > i; S--) {
            let k = r.childNodes[S - 1]
                , A = k.pmViewDesc;
            if (k.nodeName == "BR" && !A) {
                s = S;
                break
            }
            if (!A || A.size)
                break
        }
    let h = t.state.doc
        , p = t.someProp("domParser") || hc.fromSchema(t.state.schema)
        , g = h.resolve(o)
        , y = null
        , x = p.parse(r, {
            topNode: g.parent,
            topMatch: g.parent.contentMatchAt(g.index()),
            topOpen: !0,
            from: i,
            to: s,
            preserveWhitespace: g.parent.type.whitespace == "pre" ? "full" : !0,
            findPositions: c,
            ruleFromNode: JF,
            context: g
        });
    if (c && c[0].pos != null) {
        let S = c[0].pos
            , k = c[1] && c[1].pos;
        k == null && (k = S),
            y = {
                anchor: S + o,
                head: k + o
            }
    }
    return {
        doc: x,
        sel: y,
        from: o,
        to: a
    }
}
function JF(t) {
    let e = t.pmViewDesc;
    if (e)
        return e.parseRule();
    if (t.nodeName == "BR" && t.parentNode) {
        if (dr && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
            let n = document.createElement("div");
            return n.appendChild(document.createElement("li")),
            {
                skip: n
            }
        } else if (t.parentNode.lastChild == t || dr && /^(tr|table)$/i.test(t.parentNode.nodeName))
            return {
                ignore: !0
            }
    } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
        return {
            ignore: !0
        };
    return null
}
const ZF = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function YF(t, e, n, r, i) {
    let s = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
    if (t.input.compositionPendingChanges = 0,
        e < 0) {
        let M = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null
            , E = _v(t, M);
        if (E && !t.state.selection.eq(E)) {
            if (Yn && yi && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", j => j(t, ca(13, "Enter"))))
                return;
            let N = t.state.tr.setSelection(E);
            M == "pointer" ? N.setMeta("pointer", !0) : M == "key" && N.scrollIntoView(),
                s && N.setMeta("composition", s),
                t.dispatch(N)
        }
        return
    }
    let o = t.state.doc.resolve(e)
        , a = o.sharedDepth(n);
    e = o.before(a + 1),
        n = t.state.doc.resolve(n).after(a + 1);
    let l = t.state.selection, c = GF(t, e, n), d = t.state.doc, h = d.slice(c.from, c.to), p, g;
    t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (p = t.state.selection.to,
        g = "end") : (p = t.state.selection.from,
            g = "start"),
        t.input.lastKeyCode = null;
    let y = eH(h.content, c.doc.content, c.from, p, g);
    if (y && t.input.domChangeCount++,
        (ru && t.input.lastIOSEnter > Date.now() - 225 || yi) && i.some(M => M.nodeType == 1 && !ZF.test(M.nodeName)) && (!y || y.endA >= y.endB) && t.someProp("handleKeyDown", M => M(t, ca(13, "Enter")))) {
        t.input.lastIOSEnter = 0;
        return
    }
    if (!y)
        if (r && l instanceof De && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
            y = {
                start: l.from,
                endA: l.to,
                endB: l.to
            };
        else {
            if (c.sel) {
                let M = d3(t, t.state.doc, c.sel);
                if (M && !M.eq(t.state.selection)) {
                    let E = t.state.tr.setSelection(M);
                    s && E.setMeta("composition", s),
                        t.dispatch(E)
                }
            }
            return
        }
    t.state.selection.from < t.state.selection.to && y.start == y.endB && t.state.selection instanceof De && (y.start > t.state.selection.from && y.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? y.start = t.state.selection.from : y.endA < t.state.selection.to && y.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (y.endB += t.state.selection.to - y.endA,
        y.endA = t.state.selection.to)),
        Tr && Co <= 11 && y.endB == y.start + 1 && y.endA == y.start && y.start > c.from && c.doc.textBetween(y.start - c.from - 1, y.start - c.from + 1) == " " && (y.start--,
            y.endA--,
            y.endB--);
    let x = c.doc.resolveNoCache(y.start - c.from), S = c.doc.resolveNoCache(y.endB - c.from), k = d.resolve(y.start), A = x.sameParent(S) && x.parent.inlineContent && k.end() >= y.endA, C;
    if ((ru && t.input.lastIOSEnter > Date.now() - 225 && (!A || i.some(M => M.nodeName == "DIV" || M.nodeName == "P")) || !A && x.pos < c.doc.content.size && !x.sameParent(S) && (C = Ve.findFrom(c.doc.resolve(x.pos + 1), 1, !0)) && C.head == S.pos) && t.someProp("handleKeyDown", M => M(t, ca(13, "Enter")))) {
        t.input.lastIOSEnter = 0;
        return
    }
    if (t.state.selection.anchor > y.start && QF(d, y.start, y.endA, x, S) && t.someProp("handleKeyDown", M => M(t, ca(8, "Backspace")))) {
        yi && Yn && t.domObserver.suppressSelectionUpdates();
        return
    }
    Yn && yi && y.endB == y.start && (t.input.lastAndroidDelete = Date.now()),
        yi && !A && x.start() != S.start() && S.parentOffset == 0 && x.depth == S.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == y.endA && (y.endB -= 2,
            S = c.doc.resolveNoCache(y.endB - c.from),
            setTimeout(() => {
                t.someProp("handleKeyDown", function (M) {
                    return M(t, ca(13, "Enter"))
                })
            }
                , 20));
    let m = y.start, b = y.endA, w, T, O;
    if (A) {
        if (x.pos == S.pos)
            Tr && Co <= 11 && x.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(),
                setTimeout(() => Is(t), 20)),
                w = t.state.tr.delete(m, b),
                T = d.resolve(y.start).marksAcross(d.resolve(y.endA));
        else if (y.endA == y.endB && (O = XF(x.parent.content.cut(x.parentOffset, S.parentOffset), k.parent.content.cut(k.parentOffset, y.endA - k.start()))))
            w = t.state.tr,
                O.type == "add" ? w.addMark(m, b, O.mark) : w.removeMark(m, b, O.mark);
        else if (x.parent.child(x.index()).isText && x.index() == S.index() - (S.textOffset ? 0 : 1)) {
            let M = x.parent.textBetween(x.parentOffset, S.parentOffset);
            if (t.someProp("handleTextInput", E => E(t, m, b, M)))
                return;
            w = t.state.tr.insertText(M, m, b)
        }
    }
    if (w || (w = t.state.tr.replace(m, b, c.doc.slice(y.start - c.from, y.endB - c.from))),
        c.sel) {
        let M = d3(t, w.doc, c.sel);
        M && !(Yn && yi && t.composing && M.empty && (y.start != y.endB || t.input.lastAndroidDelete < Date.now() - 100) && (M.head == m || M.head == w.mapping.map(b) - 1) || Tr && M.empty && M.head == m) && w.setSelection(M)
    }
    T && w.ensureMarks(T),
        s && w.setMeta("composition", s),
        t.dispatch(w.scrollIntoView())
}
function d3(t, e, n) {
    return Math.max(n.anchor, n.head) > e.content.size ? null : Sv(t, e.resolve(n.anchor), e.resolve(n.head))
}
function XF(t, e) {
    let n = t.firstChild.marks, r = e.firstChild.marks, i = n, s = r, o, a, l;
    for (let d = 0; d < r.length; d++)
        i = r[d].removeFromSet(i);
    for (let d = 0; d < n.length; d++)
        s = n[d].removeFromSet(s);
    if (i.length == 1 && s.length == 0)
        a = i[0],
            o = "add",
            l = d => d.mark(a.addToSet(d.marks));
    else if (i.length == 0 && s.length == 1)
        a = s[0],
            o = "remove",
            l = d => d.mark(a.removeFromSet(d.marks));
    else
        return null;
    let c = [];
    for (let d = 0; d < e.childCount; d++)
        c.push(l(e.child(d)));
    if (se.from(c).eq(t))
        return {
            mark: a,
            type: o
        }
}
function QF(t, e, n, r, i) {
    if (n - e <= i.pos - r.pos || R0(r, !0, !1) < i.pos)
        return !1;
    let s = t.resolve(e);
    if (!r.parent.isTextblock) {
        let a = s.nodeAfter;
        return a != null && n == e + a.nodeSize
    }
    if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
        return !1;
    let o = t.resolve(R0(s, !0, !0));
    return !o.parent.isTextblock || o.pos > n || R0(o, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content)
}
function R0(t, e, n) {
    let r = t.depth
        , i = e ? t.end() : t.pos;
    for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount);)
        r--,
            i++,
            e = !1;
    if (n) {
        let s = t.node(r).maybeChild(t.indexAfter(r));
        for (; s && !s.isLeaf;)
            s = s.firstChild,
                i++
    }
    return i
}
function eH(t, e, n, r, i) {
    let s = t.findDiffStart(e, n);
    if (s == null)
        return null;
    let { a: o, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
    if (i == "end") {
        let l = Math.max(0, s - Math.min(o, a));
        r -= o + l - s
    }
    if (o < s && t.size < e.size) {
        let l = r <= s && r >= o ? s - r : 0;
        s -= l,
            s && s < e.size && f3(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1),
            a = s + (a - o),
            o = s
    } else if (a < s) {
        let l = r <= s && r >= a ? s - r : 0;
        s -= l,
            s && s < t.size && f3(t.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1),
            o = s + (o - a),
            a = s
    }
    return {
        start: s,
        endA: o,
        endB: a
    }
}
function f3(t) {
    if (t.length != 2)
        return !1;
    let e = t.charCodeAt(0)
        , n = t.charCodeAt(1);
    return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319
}
class tH {
    constructor(e, n) {
        this._root = null,
            this.focused = !1,
            this.trackWrites = null,
            this.mounted = !1,
            this.markCursor = null,
            this.cursorWrapper = null,
            this.lastSelectedViewDesc = void 0,
            this.input = new wF,
            this.prevDirectPlugins = [],
            this.pluginViews = [],
            this.requiresGeckoHackNode = !1,
            this.dragging = null,
            this._props = n,
            this.state = n.state,
            this.directPlugins = n.plugins || [],
            this.directPlugins.forEach(y3),
            this.dispatch = this.dispatch.bind(this),
            this.dom = e && e.mount || document.createElement("div"),
            e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)),
            this.editable = m3(this),
            p3(this),
            this.nodeViews = g3(this),
            this.docView = q_(this.state.doc, h3(this), M0(this), this.dom, this),
            this.domObserver = new WF(this, (r, i, s, o) => YF(this, r, i, s, o)),
            this.domObserver.start(),
            xF(this),
            this.updatePluginViews()
    }
    get composing() {
        return this.input.composing
    }
    get props() {
        if (this._props.state != this.state) {
            let e = this._props;
            this._props = {};
            for (let n in e)
                this._props[n] = e[n];
            this._props.state = this.state
        }
        return this._props
    }
    update(e) {
        e.handleDOMEvents != this._props.handleDOMEvents && K1(this);
        let n = this._props;
        this._props = e,
            e.plugins && (e.plugins.forEach(y3),
                this.directPlugins = e.plugins),
            this.updateStateInner(e.state, n)
    }
    setProps(e) {
        let n = {};
        for (let r in this._props)
            n[r] = this._props[r];
        n.state = this.state;
        for (let r in e)
            n[r] = e[r];
        this.update(n)
    }
    updateState(e) {
        this.updateStateInner(e, this._props)
    }
    updateStateInner(e, n) {
        var r;
        let i = this.state
            , s = !1
            , o = !1;
        e.storedMarks && this.composing && (MT(this),
            o = !0),
            this.state = e;
        let a = i.plugins != e.plugins || this._props.plugins != n.plugins;
        if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
            let g = g3(this);
            rH(g, this.nodeViews) && (this.nodeViews = g,
                s = !0)
        }
        (a || n.handleDOMEvents != this._props.handleDOMEvents) && K1(this),
            this.editable = m3(this),
            p3(this);
        let l = M0(this)
            , c = h3(this)
            , d = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve"
            , h = s || !this.docView.matchesNode(e.doc, c, l);
        (h || !e.selection.eq(i.selection)) && (o = !0);
        let p = d == "preserve" && o && this.dom.style.overflowAnchor == null && Lz(this);
        if (o) {
            this.domObserver.stop();
            let g = h && (Tr || Yn) && !this.composing && !i.selection.empty && !e.selection.empty && nH(i.selection, e.selection);
            if (h) {
                let y = Yn ? this.trackWrites = this.domSelectionRange().focusNode : null;
                this.composing && (this.input.compositionNode = IF(this)),
                    (s || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c),
                        this.docView.destroy(),
                        this.docView = q_(e.doc, c, l, this.dom, this)),
                    y && !this.trackWrites && (g = !0)
            }
            g || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && sF(this)) ? Is(this, g) : (yT(this, e.selection),
                this.domObserver.setCurSelection()),
                this.domObserver.start()
        }
        this.updatePluginViews(i),
            !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i),
            d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : p && Dz(p)
    }
    scrollToSelection() {
        let e = this.domSelectionRange().focusNode;
        if (!this.someProp("handleScrollToSelection", n => n(this)))
            if (this.state.selection instanceof Le) {
                let n = this.docView.domAfterPos(this.state.selection.from);
                n.nodeType == 1 && F_(this, n.getBoundingClientRect(), e)
            } else
                F_(this, this.coordsAtPos(this.state.selection.head, 1), e)
    }
    destroyPluginViews() {
        let e;
        for (; e = this.pluginViews.pop();)
            e.destroy && e.destroy()
    }
    updatePluginViews(e) {
        if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins,
                this.destroyPluginViews();
            for (let n = 0; n < this.directPlugins.length; n++) {
                let r = this.directPlugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
            for (let n = 0; n < this.state.plugins.length; n++) {
                let r = this.state.plugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
        } else
            for (let n = 0; n < this.pluginViews.length; n++) {
                let r = this.pluginViews[n];
                r.update && r.update(this, e)
            }
    }
    updateDraggedNode(e, n) {
        let r = e.node
            , i = -1;
        if (this.state.doc.nodeAt(r.from) == r.node)
            i = r.from;
        else {
            let s = r.from + (this.state.doc.content.size - n.doc.content.size);
            (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s)
        }
        this.dragging = new PT(e.slice, e.move, i < 0 ? void 0 : Le.create(this.state.doc, i))
    }
    someProp(e, n) {
        let r = this._props && this._props[e], i;
        if (r != null && (i = n ? n(r) : r))
            return i;
        for (let o = 0; o < this.directPlugins.length; o++) {
            let a = this.directPlugins[o].props[e];
            if (a != null && (i = n ? n(a) : a))
                return i
        }
        let s = this.state.plugins;
        if (s)
            for (let o = 0; o < s.length; o++) {
                let a = s[o].props[e];
                if (a != null && (i = n ? n(a) : a))
                    return i
            }
    }
    hasFocus() {
        if (Tr) {
            let e = this.root.activeElement;
            if (e == this.dom)
                return !0;
            if (!e || !this.dom.contains(e))
                return !1;
            for (; e && this.dom != e && this.dom.contains(e);) {
                if (e.contentEditable == "false")
                    return !1;
                e = e.parentElement
            }
            return !0
        }
        return this.root.activeElement == this.dom
    }
    focus() {
        this.domObserver.stop(),
            this.editable && jz(this.dom),
            Is(this),
            this.domObserver.start()
    }
    get root() {
        let e = this._root;
        if (e == null) {
            for (let n = this.dom.parentNode; n; n = n.parentNode)
                if (n.nodeType == 9 || n.nodeType == 11 && n.host)
                    return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()),
                        this._root = n
        }
        return e || document
    }
    updateRoot() {
        this._root = null
    }
    posAtCoords(e) {
        return Hz(this, e)
    }
    coordsAtPos(e, n = 1) {
        return uT(this, e, n)
    }
    domAtPos(e, n = 0) {
        return this.docView.domFromPos(e, n)
    }
    nodeDOM(e) {
        let n = this.docView.descAt(e);
        return n ? n.nodeDOM : null
    }
    posAtDOM(e, n, r = -1) {
        let i = this.docView.posFromDOM(e, n, r);
        if (i == null)
            throw new RangeError("DOM position not inside the editor");
        return i
    }
    endOfTextblock(e, n) {
        return qz(this, n || this.state, e)
    }
    pasteHTML(e, n) {
        return $c(this, "", e, !1, n || new ClipboardEvent("paste"))
    }
    pasteText(e, n) {
        return $c(this, e, null, !0, n || new ClipboardEvent("paste"))
    }
    destroy() {
        this.docView && (_F(this),
            this.destroyPluginViews(),
            this.mounted ? (this.docView.update(this.state.doc, [], M0(this), this),
                this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
            this.docView.destroy(),
            this.docView = null,
            kz())
    }
    get isDestroyed() {
        return this.docView == null
    }
    dispatchEvent(e) {
        return kF(this, e)
    }
    dispatch(e) {
        let n = this._props.dispatchTransaction;
        n ? n.call(this, e) : this.updateState(this.state.apply(e))
    }
    domSelectionRange() {
        let e = this.domSelection();
        return e ? dr && this.root.nodeType === 11 && Oz(this.dom.ownerDocument) == this.dom && KF(this, e) || e : {
            focusNode: null,
            focusOffset: 0,
            anchorNode: null,
            anchorOffset: 0
        }
    }
    domSelection() {
        return this.root.getSelection()
    }
}
function h3(t) {
    let e = Object.create(null);
    return e.class = "ProseMirror",
        e.contenteditable = String(t.editable),
        t.someProp("attributes", n => {
            if (typeof n == "function" && (n = n(t.state)),
                n)
                for (let r in n)
                    r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]))
        }
        ),
        e.translate || (e.translate = "no"),
        [Xn.node(0, t.state.doc.content.size, e)]
}
function p3(t) {
    if (t.markCursor) {
        let e = document.createElement("img");
        e.className = "ProseMirror-separator",
            e.setAttribute("mark-placeholder", "true"),
            e.setAttribute("alt", ""),
            t.cursorWrapper = {
                dom: e,
                deco: Xn.widget(t.state.selection.from, e, {
                    raw: !0,
                    marks: t.markCursor
                })
            }
    } else
        t.cursorWrapper = null
}
function m3(t) {
    return !t.someProp("editable", e => e(t.state) === !1)
}
function nH(t, e) {
    let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
    return t.$anchor.start(n) != e.$anchor.start(n)
}
function g3(t) {
    let e = Object.create(null);
    function n(r) {
        for (let i in r)
            Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i])
    }
    return t.someProp("nodeViews", n),
        t.someProp("markViews", n),
        e
}
function rH(t, e) {
    let n = 0
        , r = 0;
    for (let i in t) {
        if (t[i] != e[i])
            return !0;
        n++
    }
    for (let i in e)
        r++;
    return n != r
}
function y3(t) {
    if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component")
}
var No = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
}
    , np = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"'
    }
    , iH = typeof navigator < "u" && /Mac/.test(navigator.platform)
    , sH = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var $n = 0; $n < 10; $n++)
    No[48 + $n] = No[96 + $n] = String($n);
for (var $n = 1; $n <= 24; $n++)
    No[$n + 111] = "F" + $n;
for (var $n = 65; $n <= 90; $n++)
    No[$n] = String.fromCharCode($n + 32),
        np[$n] = String.fromCharCode($n);
for (var P0 in No)
    np.hasOwnProperty(P0) || (np[P0] = No[P0]);
function oH(t) {
    var e = iH && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || sH && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified"
        , n = !e && t.key || (t.shiftKey ? np : No)[t.keyCode] || t.key || "Unidentified";
    return n == "Esc" && (n = "Escape"),
        n == "Del" && (n = "Delete"),
        n == "Left" && (n = "ArrowLeft"),
        n == "Up" && (n = "ArrowUp"),
        n == "Right" && (n = "ArrowRight"),
        n == "Down" && (n = "ArrowDown"),
        n
}
const aH = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function lH(t) {
    let e = t.split(/-(?!$)/)
        , n = e[e.length - 1];
    n == "Space" && (n = " ");
    let r, i, s, o;
    for (let a = 0; a < e.length - 1; a++) {
        let l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
            o = !0;
        else if (/^a(lt)?$/i.test(l))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(l))
            i = !0;
        else if (/^s(hift)?$/i.test(l))
            s = !0;
        else if (/^mod$/i.test(l))
            aH ? o = !0 : i = !0;
        else
            throw new Error("Unrecognized modifier name: " + l)
    }
    return r && (n = "Alt-" + n),
        i && (n = "Ctrl-" + n),
        o && (n = "Meta-" + n),
        s && (n = "Shift-" + n),
        n
}
function uH(t) {
    let e = Object.create(null);
    for (let n in t)
        e[lH(n)] = t[n];
    return e
}
function N0(t, e, n = !0) {
    return e.altKey && (t = "Alt-" + t),
        e.ctrlKey && (t = "Ctrl-" + t),
        e.metaKey && (t = "Meta-" + t),
        n && e.shiftKey && (t = "Shift-" + t),
        t
}
function cH(t) {
    return new sn({
        props: {
            handleKeyDown: Ov(t)
        }
    })
}
function Ov(t) {
    let e = uH(t);
    return function (n, r) {
        let i = oH(r), s, o = e[N0(i, r)];
        if (o && o(n.state, n.dispatch, n))
            return !0;
        if (i.length == 1 && i != " ") {
            if (r.shiftKey) {
                let a = e[N0(i, r, !1)];
                if (a && a(n.state, n.dispatch, n))
                    return !0
            }
            if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (s = No[r.keyCode]) && s != i) {
                let a = e[N0(s, r)];
                if (a && a(n.state, n.dispatch, n))
                    return !0
            }
        }
        return !1
    }
}
const dH = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()),
    !0);
function jT(t, e) {
    let { $cursor: n } = t.selection;
    return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n
}
const fH = (t, e, n) => {
    let r = jT(t, n);
    if (!r)
        return !1;
    let i = Mv(r);
    if (!i) {
        let o = r.blockRange()
            , a = o && pu(o);
        return a == null ? !1 : (e && e(t.tr.lift(o, a).scrollIntoView()),
            !0)
    }
    let s = i.nodeBefore;
    if (FT(t, i, e, -1))
        return !0;
    if (r.parent.content.size == 0 && (iu(s, "end") || Le.isSelectable(s)))
        for (let o = r.depth; ; o--) {
            let a = bm(t.doc, r.before(o), r.after(o), ve.empty);
            if (a && a.slice.size < a.to - a.from) {
                if (e) {
                    let l = t.tr.step(a);
                    l.setSelection(iu(s, "end") ? Ve.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : Le.create(l.doc, i.pos - s.nodeSize)),
                        e(l.scrollIntoView())
                }
                return !0
            }
            if (o == 1 || r.node(o - 1).childCount > 1)
                break
        }
    return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()),
        !0) : !1
}
    , hH = (t, e, n) => {
        let r = jT(t, n);
        if (!r)
            return !1;
        let i = Mv(r);
        return i ? BT(t, i, e) : !1
    }
    , pH = (t, e, n) => {
        let r = $T(t, n);
        if (!r)
            return !1;
        let i = Rv(r);
        return i ? BT(t, i, e) : !1
    }
    ;
function BT(t, e, n) {
    let r = e.nodeBefore
        , i = r
        , s = e.pos - 1;
    for (; !i.isTextblock; s--) {
        if (i.type.spec.isolating)
            return !1;
        let d = i.lastChild;
        if (!d)
            return !1;
        i = d
    }
    let o = e.nodeAfter
        , a = o
        , l = e.pos + 1;
    for (; !a.isTextblock; l++) {
        if (a.type.spec.isolating)
            return !1;
        let d = a.firstChild;
        if (!d)
            return !1;
        a = d
    }
    let c = bm(t.doc, s, l, ve.empty);
    if (!c || c.from != s || c instanceof En && c.slice.size >= l - s)
        return !1;
    if (n) {
        let d = t.tr.step(c);
        d.setSelection(De.create(d.doc, s)),
            n(d.scrollIntoView())
    }
    return !0
}
function iu(t, e, n = !1) {
    for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
        if (r.isTextblock)
            return !0;
        if (n && r.childCount != 1)
            return !1
    }
    return !1
}
const mH = (t, e, n) => {
    let { $head: r, empty: i } = t.selection
        , s = r;
    if (!i)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
            return !1;
        s = Mv(r)
    }
    let o = s && s.nodeBefore;
    return !o || !Le.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(Le.create(t.doc, s.pos - o.nodeSize)).scrollIntoView()),
        !0)
}
    ;
function Mv(t) {
    if (!t.parent.type.spec.isolating)
        for (let e = t.depth - 1; e >= 0; e--) {
            if (t.index(e) > 0)
                return t.doc.resolve(t.before(e + 1));
            if (t.node(e).type.spec.isolating)
                break
        }
    return null
}
function $T(t, e) {
    let { $cursor: n } = t.selection;
    return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n
}
const gH = (t, e, n) => {
    let r = $T(t, n);
    if (!r)
        return !1;
    let i = Rv(r);
    if (!i)
        return !1;
    let s = i.nodeAfter;
    if (FT(t, i, e, 1))
        return !0;
    if (r.parent.content.size == 0 && (iu(s, "start") || Le.isSelectable(s))) {
        let o = bm(t.doc, r.before(), r.after(), ve.empty);
        if (o && o.slice.size < o.to - o.from) {
            if (e) {
                let a = t.tr.step(o);
                a.setSelection(iu(s, "start") ? Ve.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : Le.create(a.doc, a.mapping.map(i.pos))),
                    e(a.scrollIntoView())
            }
            return !0
        }
    }
    return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()),
        !0) : !1
}
    , yH = (t, e, n) => {
        let { $head: r, empty: i } = t.selection
            , s = r;
        if (!i)
            return !1;
        if (r.parent.isTextblock) {
            if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
                return !1;
            s = Rv(r)
        }
        let o = s && s.nodeAfter;
        return !o || !Le.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(Le.create(t.doc, s.pos)).scrollIntoView()),
            !0)
    }
    ;
function Rv(t) {
    if (!t.parent.type.spec.isolating)
        for (let e = t.depth - 1; e >= 0; e--) {
            let n = t.node(e);
            if (t.index(e) + 1 < n.childCount)
                return t.doc.resolve(t.after(e + 1));
            if (n.type.spec.isolating)
                break
        }
    return null
}
const vH = (t, e) => {
    let n = t.selection, r = n instanceof Le, i;
    if (r) {
        if (n.node.isTextblock || !qo(t.doc, n.from))
            return !1;
        i = n.from
    } else if (i = vm(t.doc, n.from, -1),
        i == null)
        return !1;
    if (e) {
        let s = t.tr.join(i);
        r && s.setSelection(Le.create(s.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)),
            e(s.scrollIntoView())
    }
    return !0
}
    , bH = (t, e) => {
        let n = t.selection, r;
        if (n instanceof Le) {
            if (n.node.isTextblock || !qo(t.doc, n.to))
                return !1;
            r = n.to
        } else if (r = vm(t.doc, n.to, 1),
            r == null)
            return !1;
        return e && e(t.tr.join(r).scrollIntoView()),
            !0
    }
    , wH = (t, e) => {
        let { $from: n, $to: r } = t.selection
            , i = n.blockRange(r)
            , s = i && pu(i);
        return s == null ? !1 : (e && e(t.tr.lift(i, s).scrollIntoView()),
            !0)
    }
    , xH = (t, e) => {
        let { $head: n, $anchor: r } = t.selection;
        return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()),
            !0)
    }
    ;
function zT(t) {
    for (let e = 0; e < t.edgeCount; e++) {
        let { type: n } = t.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
const _H = (t, e) => {
    let { $head: n, $anchor: r } = t.selection;
    if (!n.parent.type.spec.code || !n.sameParent(r))
        return !1;
    let i = n.node(-1)
        , s = n.indexAfter(-1)
        , o = zT(i.contentMatchAt(s));
    if (!o || !i.canReplaceWith(s, s, o))
        return !1;
    if (e) {
        let a = n.after()
            , l = t.tr.replaceWith(a, a, o.createAndFill());
        l.setSelection(Ve.near(l.doc.resolve(a), 1)),
            e(l.scrollIntoView())
    }
    return !0
}
    , SH = (t, e) => {
        let n = t.selection
            , { $from: r, $to: i } = n;
        if (n instanceof Ci || r.parent.inlineContent || i.parent.inlineContent)
            return !1;
        let s = zT(i.parent.contentMatchAt(i.indexAfter()));
        if (!s || !s.isTextblock)
            return !1;
        if (e) {
            let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos
                , a = t.tr.insert(o, s.createAndFill());
            a.setSelection(De.create(a.doc, o + 1)),
                e(a.scrollIntoView())
        }
        return !0
    }
    , kH = (t, e) => {
        let { $cursor: n } = t.selection;
        if (!n || n.parent.content.size)
            return !1;
        if (n.depth > 1 && n.after() != n.end(-1)) {
            let s = n.before();
            if (zl(t.doc, s))
                return e && e(t.tr.split(s).scrollIntoView()),
                    !0
        }
        let r = n.blockRange()
            , i = r && pu(r);
        return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()),
            !0)
    }
    , CH = (t, e) => {
        let { $from: n, to: r } = t.selection, i, s = n.sharedDepth(r);
        return s == 0 ? !1 : (i = n.before(s),
            e && e(t.tr.setSelection(Le.create(t.doc, i))),
            !0)
    }
    ;
function EH(t, e, n) {
    let r = e.nodeBefore
        , i = e.nodeAfter
        , s = e.index();
    return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()),
        !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || qo(t.doc, e.pos)) ? !1 : (n && n(t.tr.clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()),
            !0)
}
function FT(t, e, n, r) {
    let i = e.nodeBefore, s = e.nodeAfter, o, a, l = i.type.spec.isolating || s.type.spec.isolating;
    if (!l && EH(t, e, n))
        return !0;
    let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
    if (c && (o = (a = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && a.matchType(o[0] || s.type).validEnd) {
        if (n) {
            let g = e.pos + s.nodeSize
                , y = se.empty;
            for (let k = o.length - 1; k >= 0; k--)
                y = se.from(o[k].create(null, y));
            y = se.from(i.copy(y));
            let x = t.tr.step(new Tn(e.pos - 1, g, e.pos, g, new ve(y, 1, 0), o.length, !0))
                , S = g + 2 * o.length;
            qo(x.doc, S) && x.join(S),
                n(x.scrollIntoView())
        }
        return !0
    }
    let d = s.type.spec.isolating || r > 0 && l ? null : Ve.findFrom(e, 1)
        , h = d && d.$from.blockRange(d.$to)
        , p = h && pu(h);
    if (p != null && p >= e.depth)
        return n && n(t.tr.lift(h, p).scrollIntoView()),
            !0;
    if (c && iu(s, "start", !0) && iu(i, "end")) {
        let g = i
            , y = [];
        for (; y.push(g),
            !g.isTextblock;)
            g = g.lastChild;
        let x = s
            , S = 1;
        for (; !x.isTextblock; x = x.firstChild)
            S++;
        if (g.canReplace(g.childCount, g.childCount, x.content)) {
            if (n) {
                let k = se.empty;
                for (let C = y.length - 1; C >= 0; C--)
                    k = se.from(y[C].copy(k));
                let A = t.tr.step(new Tn(e.pos - y.length, e.pos + s.nodeSize, e.pos + S, e.pos + s.nodeSize - S, new ve(k, y.length, 0), 0, !0));
                n(A.scrollIntoView())
            }
            return !0
        }
    }
    return !1
}
function HT(t) {
    return function (e, n) {
        let r = e.selection
            , i = t < 0 ? r.$from : r.$to
            , s = i.depth;
        for (; i.node(s).isInline;) {
            if (!s)
                return !1;
            s--
        }
        return i.node(s).isTextblock ? (n && n(e.tr.setSelection(De.create(e.doc, t < 0 ? i.start(s) : i.end(s)))),
            !0) : !1
    }
}
const TH = HT(-1)
    , AH = HT(1);
function OH(t, e = null) {
    return function (n, r) {
        let { $from: i, $to: s } = n.selection
            , o = i.blockRange(s)
            , a = o && vv(o, t, e);
        return a ? (r && r(n.tr.wrap(o, a).scrollIntoView()),
            !0) : !1
    }
}
function v3(t, e = null) {
    return function (n, r) {
        let i = !1;
        for (let s = 0; s < n.selection.ranges.length && !i; s++) {
            let { $from: { pos: o }, $to: { pos: a } } = n.selection.ranges[s];
            n.doc.nodesBetween(o, a, (l, c) => {
                if (i)
                    return !1;
                if (!(!l.isTextblock || l.hasMarkup(t, e)))
                    if (l.type == t)
                        i = !0;
                    else {
                        let d = n.doc.resolve(c)
                            , h = d.index();
                        i = d.parent.canReplaceWith(h, h + 1, t)
                    }
            }
            )
        }
        if (!i)
            return !1;
        if (r) {
            let s = n.tr;
            for (let o = 0; o < n.selection.ranges.length; o++) {
                let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[o];
                s.setBlockType(a, l, t, e)
            }
            r(s.scrollIntoView())
        }
        return !0
    }
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function MH(t, e = null) {
    return function (n, r) {
        let { $from: i, $to: s } = n.selection
            , o = i.blockRange(s)
            , a = !1
            , l = o;
        if (!o)
            return !1;
        if (o.depth >= 2 && i.node(o.depth - 1).type.compatibleContent(t) && o.startIndex == 0) {
            if (i.index(o.depth - 1) == 0)
                return !1;
            let d = n.doc.resolve(o.start - 2);
            l = new qh(d, d, o.depth),
                o.endIndex < o.parent.childCount && (o = new qh(i, n.doc.resolve(s.end(o.depth)), o.depth)),
                a = !0
        }
        let c = vv(l, t, e, o);
        return c ? (r && r(RH(n.tr, o, c, a, t).scrollIntoView()),
            !0) : !1
    }
}
function RH(t, e, n, r, i) {
    let s = se.empty;
    for (let d = n.length - 1; d >= 0; d--)
        s = se.from(n[d].type.create(n[d].attrs, s));
    t.step(new Tn(e.start - (r ? 2 : 0), e.end, e.start, e.end, new ve(s, 0, 0), n.length, !0));
    let o = 0;
    for (let d = 0; d < n.length; d++)
        n[d].type == i && (o = d + 1);
    let a = n.length - o
        , l = e.start + n.length - (r ? 2 : 0)
        , c = e.parent;
    for (let d = e.startIndex, h = e.endIndex, p = !0; d < h; d++,
        p = !1)
        !p && zl(t.doc, l, a) && (t.split(l, a),
            l += 2 * a),
            l += c.child(d).nodeSize;
    return t
}
function PH(t) {
    return function (e, n) {
        let { $from: r, $to: i } = e.selection
            , s = r.blockRange(i, o => o.childCount > 0 && o.firstChild.type == t);
        return s ? n ? r.node(s.depth - 1).type == t ? NH(e, n, t, s) : IH(e, n, s) : !0 : !1
    }
}
function NH(t, e, n, r) {
    let i = t.tr
        , s = r.end
        , o = r.$to.end(r.depth);
    s < o && (i.step(new Tn(s - 1, o, s, o, new ve(se.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)),
        r = new qh(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
    const a = pu(r);
    if (a == null)
        return !1;
    i.lift(r, a);
    let l = i.mapping.map(s, -1) - 1;
    return qo(i.doc, l) && i.join(l),
        e(i.scrollIntoView()),
        !0
}
function IH(t, e, n) {
    let r = t.tr
        , i = n.parent;
    for (let g = n.end, y = n.endIndex - 1, x = n.startIndex; y > x; y--)
        g -= i.child(y).nodeSize,
            r.delete(g - 1, g + 1);
    let s = r.doc.resolve(n.start)
        , o = s.nodeAfter;
    if (r.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize)
        return !1;
    let a = n.startIndex == 0
        , l = n.endIndex == i.childCount
        , c = s.node(-1)
        , d = s.index(-1);
    if (!c.canReplace(d + (a ? 0 : 1), d + 1, o.content.append(l ? se.empty : se.from(i))))
        return !1;
    let h = s.pos
        , p = h + o.nodeSize;
    return r.step(new Tn(h - (a ? 1 : 0), p + (l ? 1 : 0), h + 1, p - 1, new ve((a ? se.empty : se.from(i.copy(se.empty))).append(l ? se.empty : se.from(i.copy(se.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)),
        e(r.scrollIntoView()),
        !0
}
function LH(t) {
    return function (e, n) {
        let { $from: r, $to: i } = e.selection
            , s = r.blockRange(i, c => c.childCount > 0 && c.firstChild.type == t);
        if (!s)
            return !1;
        let o = s.startIndex;
        if (o == 0)
            return !1;
        let a = s.parent
            , l = a.child(o - 1);
        if (l.type != t)
            return !1;
        if (n) {
            let c = l.lastChild && l.lastChild.type == a.type
                , d = se.from(c ? t.create() : null)
                , h = new ve(se.from(t.create(null, se.from(a.type.create(null, d)))), c ? 3 : 1, 0)
                , p = s.start
                , g = s.end;
            n(e.tr.step(new Tn(p - (c ? 3 : 1), g, p, g, h, 1, !0)).scrollIntoView())
        }
        return !0
    }
}
function km(t) {
    const { state: e, transaction: n } = t;
    let { selection: r } = n
        , { doc: i } = n
        , { storedMarks: s } = n;
    return {
        ...e,
        apply: e.apply.bind(e),
        applyTransaction: e.applyTransaction.bind(e),
        plugins: e.plugins,
        schema: e.schema,
        reconfigure: e.reconfigure.bind(e),
        toJSON: e.toJSON.bind(e),
        get storedMarks() {
            return s
        },
        get selection() {
            return r
        },
        get doc() {
            return i
        },
        get tr() {
            return r = n.selection,
                i = n.doc,
                s = n.storedMarks,
                n
        }
    }
}
class Cm {
    constructor(e) {
        this.editor = e.editor,
            this.rawCommands = this.editor.extensionManager.commands,
            this.customState = e.state
    }
    get hasCustomState() {
        return !!this.customState
    }
    get state() {
        return this.customState || this.editor.state
    }
    get commands() {
        const { rawCommands: e, editor: n, state: r } = this
            , { view: i } = n
            , { tr: s } = r
            , o = this.buildProps(s);
        return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...d) => {
            const h = l(...d)(o);
            return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s),
                h
        }
        ]))
    }
    get chain() {
        return () => this.createChain()
    }
    get can() {
        return () => this.createCan()
    }
    createChain(e, n = !0) {
        const { rawCommands: r, editor: i, state: s } = this
            , { view: o } = i
            , a = []
            , l = !!e
            , c = e || s.tr
            , d = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c),
                a.every(p => p === !0))
            , h = {
                ...Object.fromEntries(Object.entries(r).map(([p, g]) => [p, (...x) => {
                    const S = this.buildProps(c, n)
                        , k = g(...x)(S);
                    return a.push(k),
                        h
                }
                ])),
                run: d
            };
        return h
    }
    createCan(e) {
        const { rawCommands: n, state: r } = this
            , i = !1
            , s = e || r.tr
            , o = this.buildProps(s, i);
        return {
            ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...d) => c(...d)({
                ...o,
                dispatch: void 0
            })])),
            chain: () => this.createChain(s, i)
        }
    }
    buildProps(e, n = !0) {
        const { rawCommands: r, editor: i, state: s } = this
            , { view: o } = i
            , a = {
                tr: e,
                editor: i,
                view: o,
                state: km({
                    state: s,
                    transaction: e
                }),
                dispatch: n ? () => { }
                    : void 0,
                chain: () => this.createChain(e, n),
                can: () => this.createCan(e),
                get commands() {
                    return Object.fromEntries(Object.entries(r).map(([l, c]) => [l, (...d) => c(...d)(a)]))
                }
            };
        return a
    }
}
class DH {
    constructor() {
        this.callbacks = {}
    }
    on(e, n) {
        return this.callbacks[e] || (this.callbacks[e] = []),
            this.callbacks[e].push(n),
            this
    }
    emit(e, ...n) {
        const r = this.callbacks[e];
        return r && r.forEach(i => i.apply(this, n)),
            this
    }
    off(e, n) {
        const r = this.callbacks[e];
        return r && (n ? this.callbacks[e] = r.filter(i => i !== n) : delete this.callbacks[e]),
            this
    }
    removeAllListeners() {
        this.callbacks = {}
    }
}
function Me(t, e, n) {
    return t.config[e] === void 0 && t.parent ? Me(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
        ...n,
        parent: t.parent ? Me(t.parent, e, n) : null
    }) : t.config[e]
}
function Em(t) {
    const e = t.filter(i => i.type === "extension")
        , n = t.filter(i => i.type === "node")
        , r = t.filter(i => i.type === "mark");
    return {
        baseExtensions: e,
        nodeExtensions: n,
        markExtensions: r
    }
}
function VT(t) {
    const e = []
        , { nodeExtensions: n, markExtensions: r } = Em(t)
        , i = [...n, ...r]
        , s = {
            default: null,
            rendered: !0,
            renderHTML: null,
            parseHTML: null,
            keepOnSplit: !0,
            isRequired: !1
        };
    return t.forEach(o => {
        const a = {
            name: o.name,
            options: o.options,
            storage: o.storage,
            extensions: i
        }
            , l = Me(o, "addGlobalAttributes", a);
        if (!l)
            return;
        l().forEach(d => {
            d.types.forEach(h => {
                Object.entries(d.attributes).forEach(([p, g]) => {
                    e.push({
                        type: h,
                        name: p,
                        attribute: {
                            ...s,
                            ...g
                        }
                    })
                }
                )
            }
            )
        }
        )
    }
    ),
        i.forEach(o => {
            const a = {
                name: o.name,
                options: o.options,
                storage: o.storage
            }
                , l = Me(o, "addAttributes", a);
            if (!l)
                return;
            const c = l();
            Object.entries(c).forEach(([d, h]) => {
                const p = {
                    ...s,
                    ...h
                };
                typeof p?.default == "function" && (p.default = p.default()),
                    p?.isRequired && p?.default === void 0 && delete p.default,
                    e.push({
                        type: o.name,
                        name: d,
                        attribute: p
                    })
            }
            )
        }
        ),
        e
}
function On(t, e) {
    if (typeof t == "string") {
        if (!e.nodes[t])
            throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
        return e.nodes[t]
    }
    return t
}
function Tt(...t) {
    return t.filter(e => !!e).reduce((e, n) => {
        const r = {
            ...e
        };
        return Object.entries(n).forEach(([i, s]) => {
            if (!r[i]) {
                r[i] = s;
                return
            }
            if (i === "class") {
                const a = s ? s.split(" ") : []
                    , l = r[i] ? r[i].split(" ") : []
                    , c = a.filter(d => !l.includes(d));
                r[i] = [...l, ...c].join(" ")
            } else if (i === "style") {
                const a = s ? s.split(";").map(d => d.trim()).filter(Boolean) : []
                    , l = r[i] ? r[i].split(";").map(d => d.trim()).filter(Boolean) : []
                    , c = new Map;
                l.forEach(d => {
                    const [h, p] = d.split(":").map(g => g.trim());
                    c.set(h, p)
                }
                ),
                    a.forEach(d => {
                        const [h, p] = d.split(":").map(g => g.trim());
                        c.set(h, p)
                    }
                    ),
                    r[i] = Array.from(c.entries()).map(([d, h]) => `${d}: ${h}`).join("; ")
            } else
                r[i] = s
        }
        ),
            r
    }
        , {})
}
function q1(t, e) {
    return e.filter(n => n.attribute.rendered).map(n => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
        [n.name]: t.attrs[n.name]
    }).reduce((n, r) => Tt(n, r), {})
}
function WT(t) {
    return typeof t == "function"
}
function ht(t, e = void 0, ...n) {
    return WT(t) ? e ? t.bind(e)(...n) : t(...n) : t
}
function jH(t = {}) {
    return Object.keys(t).length === 0 && t.constructor === Object
}
function BH(t) {
    return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t
}
function b3(t, e) {
    return "style" in t ? t : {
        ...t,
        getAttrs: n => {
            const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
            if (r === !1)
                return !1;
            const i = e.reduce((s, o) => {
                const a = o.attribute.parseHTML ? o.attribute.parseHTML(n) : BH(n.getAttribute(o.name));
                return a == null ? s : {
                    ...s,
                    [o.name]: a
                }
            }
                , {});
            return {
                ...r,
                ...i
            }
        }
    }
}
function w3(t) {
    return Object.fromEntries(Object.entries(t).filter(([e, n]) => e === "attrs" && jH(n) ? !1 : n != null))
}
function $H(t, e) {
    var n;
    const r = VT(t)
        , { nodeExtensions: i, markExtensions: s } = Em(t)
        , o = (n = i.find(c => Me(c, "topNode"))) === null || n === void 0 ? void 0 : n.name
        , a = Object.fromEntries(i.map(c => {
            const d = r.filter(k => k.type === c.name)
                , h = {
                    name: c.name,
                    options: c.options,
                    storage: c.storage,
                    editor: e
                }
                , p = t.reduce((k, A) => {
                    const C = Me(A, "extendNodeSchema", h);
                    return {
                        ...k,
                        ...C ? C(c) : {}
                    }
                }
                    , {})
                , g = w3({
                    ...p,
                    content: ht(Me(c, "content", h)),
                    marks: ht(Me(c, "marks", h)),
                    group: ht(Me(c, "group", h)),
                    inline: ht(Me(c, "inline", h)),
                    atom: ht(Me(c, "atom", h)),
                    selectable: ht(Me(c, "selectable", h)),
                    draggable: ht(Me(c, "draggable", h)),
                    code: ht(Me(c, "code", h)),
                    whitespace: ht(Me(c, "whitespace", h)),
                    defining: ht(Me(c, "defining", h)),
                    isolating: ht(Me(c, "isolating", h)),
                    attrs: Object.fromEntries(d.map(k => {
                        var A;
                        return [k.name, {
                            default: (A = k?.attribute) === null || A === void 0 ? void 0 : A.default
                        }]
                    }
                    ))
                })
                , y = ht(Me(c, "parseHTML", h));
            y && (g.parseDOM = y.map(k => b3(k, d)));
            const x = Me(c, "renderHTML", h);
            x && (g.toDOM = k => x({
                node: k,
                HTMLAttributes: q1(k, d)
            }));
            const S = Me(c, "renderText", h);
            return S && (g.toText = S),
                [c.name, g]
        }
        ))
        , l = Object.fromEntries(s.map(c => {
            const d = r.filter(S => S.type === c.name)
                , h = {
                    name: c.name,
                    options: c.options,
                    storage: c.storage,
                    editor: e
                }
                , p = t.reduce((S, k) => {
                    const A = Me(k, "extendMarkSchema", h);
                    return {
                        ...S,
                        ...A ? A(c) : {}
                    }
                }
                    , {})
                , g = w3({
                    ...p,
                    inclusive: ht(Me(c, "inclusive", h)),
                    excludes: ht(Me(c, "excludes", h)),
                    group: ht(Me(c, "group", h)),
                    spanning: ht(Me(c, "spanning", h)),
                    code: ht(Me(c, "code", h)),
                    attrs: Object.fromEntries(d.map(S => {
                        var k;
                        return [S.name, {
                            default: (k = S?.attribute) === null || k === void 0 ? void 0 : k.default
                        }]
                    }
                    ))
                })
                , y = ht(Me(c, "parseHTML", h));
            y && (g.parseDOM = y.map(S => b3(S, d)));
            const x = Me(c, "renderHTML", h);
            return x && (g.toDOM = S => x({
                mark: S,
                HTMLAttributes: q1(S, d)
            })),
                [c.name, g]
        }
        ));
    return new $E({
        topNode: o,
        nodes: a,
        marks: l
    })
}
function I0(t, e) {
    return e.nodes[t] || e.marks[t] || null
}
function x3(t, e) {
    return Array.isArray(e) ? e.some(n => (typeof n == "string" ? n : n.name) === t.name) : e
}
const zH = (t, e = 500) => {
    let n = "";
    const r = t.parentOffset;
    return t.parent.nodesBetween(Math.max(0, r - e), r, (i, s, o, a) => {
        var l, c;
        const d = ((c = (l = i.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
            node: i,
            pos: s,
            parent: o,
            index: a
        })) || i.textContent || "%leaf%";
        n += i.isAtom && !i.isText ? d : d.slice(0, Math.max(0, r - s))
    }
    ),
        n
}
    ;
function Pv(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]"
}
class kd {
    constructor(e) {
        this.find = e.find,
            this.handler = e.handler
    }
}
const FH = (t, e) => {
    if (Pv(e))
        return e.exec(t);
    const n = e(t);
    if (!n)
        return null;
    const r = [n.text];
    return r.index = n.index,
        r.input = t,
        r.data = n.data,
        n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'),
            r.push(n.replaceWith)),
        r
}
    ;
function Hf(t) {
    var e;
    const { editor: n, from: r, to: i, text: s, rules: o, plugin: a } = t
        , { view: l } = n;
    if (l.composing)
        return !1;
    const c = l.state.doc.resolve(r);
    if (c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find(p => p.type.spec.code))
        return !1;
    let d = !1;
    const h = zH(c) + s;
    return o.forEach(p => {
        if (d)
            return;
        const g = FH(h, p.find);
        if (!g)
            return;
        const y = l.state.tr
            , x = km({
                state: l.state,
                transaction: y
            })
            , S = {
                from: r - (g[0].length - s.length),
                to: i
            }
            , { commands: k, chain: A, can: C } = new Cm({
                editor: n,
                state: x
            });
        p.handler({
            state: x,
            range: S,
            match: g,
            commands: k,
            chain: A,
            can: C
        }) === null || !y.steps.length || (y.setMeta(a, {
            transform: y,
            from: r,
            to: i,
            text: s
        }),
            l.dispatch(y),
            d = !0)
    }
    ),
        d
}
function HH(t) {
    const { editor: e, rules: n } = t
        , r = new sn({
            state: {
                init() {
                    return null
                },
                apply(i, s) {
                    const o = i.getMeta(r);
                    if (o)
                        return o;
                    const a = i.getMeta("applyInputRules");
                    return !!a && setTimeout(() => {
                        const { from: c, text: d } = a
                            , h = c + d.length;
                        Hf({
                            editor: e,
                            from: c,
                            to: h,
                            text: d,
                            rules: n,
                            plugin: r
                        })
                    }
                    ),
                        i.selectionSet || i.docChanged ? null : s
                }
            },
            props: {
                handleTextInput(i, s, o, a) {
                    return Hf({
                        editor: e,
                        from: s,
                        to: o,
                        text: a,
                        rules: n,
                        plugin: r
                    })
                },
                handleDOMEvents: {
                    compositionend: i => (setTimeout(() => {
                        const { $cursor: s } = i.state.selection;
                        s && Hf({
                            editor: e,
                            from: s.pos,
                            to: s.pos,
                            text: "",
                            rules: n,
                            plugin: r
                        })
                    }
                    ),
                        !1)
                },
                handleKeyDown(i, s) {
                    if (s.key !== "Enter")
                        return !1;
                    const { $cursor: o } = i.state.selection;
                    return o ? Hf({
                        editor: e,
                        from: o.pos,
                        to: o.pos,
                        text: `
`,
                        rules: n,
                        plugin: r
                    }) : !1
                }
            },
            isInputRules: !0
        });
    return r
}
function VH(t) {
    return typeof t == "number"
}
class WH {
    constructor(e) {
        this.find = e.find,
            this.handler = e.handler
    }
}
const UH = (t, e, n) => {
    if (Pv(e))
        return [...t.matchAll(e)];
    const r = e(t, n);
    return r ? r.map(i => {
        const s = [i.text];
        return s.index = i.index,
            s.input = t,
            s.data = i.data,
            i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'),
                s.push(i.replaceWith)),
            s
    }
    ) : []
}
    ;
function KH(t) {
    const { editor: e, state: n, from: r, to: i, rule: s, pasteEvent: o, dropEvent: a } = t
        , { commands: l, chain: c, can: d } = new Cm({
            editor: e,
            state: n
        })
        , h = [];
    return n.doc.nodesBetween(r, i, (g, y) => {
        if (!g.isTextblock || g.type.spec.code)
            return;
        const x = Math.max(r, y)
            , S = Math.min(i, y + g.content.size)
            , k = g.textBetween(x - y, S - y, void 0, "");
        UH(k, s.find, o).forEach(C => {
            if (C.index === void 0)
                return;
            const m = x + C.index + 1
                , b = m + C[0].length
                , w = {
                    from: n.tr.mapping.map(m),
                    to: n.tr.mapping.map(b)
                }
                , T = s.handler({
                    state: n,
                    range: w,
                    match: C,
                    commands: l,
                    chain: c,
                    can: d,
                    pasteEvent: o,
                    dropEvent: a
                });
            h.push(T)
        }
        )
    }
    ),
        h.every(g => g !== null)
}
const qH = t => {
    var e;
    const n = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer
    });
    return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t),
        n
}
    ;
function GH(t) {
    const { editor: e, rules: n } = t;
    let r = null
        , i = !1
        , s = !1
        , o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null
        , a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
    const l = ({ state: d, from: h, to: p, rule: g, pasteEvt: y }) => {
        const x = d.tr
            , S = km({
                state: d,
                transaction: x
            });
        if (!(!KH({
            editor: e,
            state: S,
            from: Math.max(h - 1, 0),
            to: p.b - 1,
            rule: g,
            pasteEvent: y,
            dropEvent: a
        }) || !x.steps.length))
            return a = typeof DragEvent < "u" ? new DragEvent("drop") : null,
                o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null,
                x
    }
        ;
    return n.map(d => new sn({
        view(h) {
            const p = g => {
                var y;
                r = !((y = h.dom.parentElement) === null || y === void 0) && y.contains(g.target) ? h.dom.parentElement : null
            }
                ;
            return window.addEventListener("dragstart", p),
            {
                destroy() {
                    window.removeEventListener("dragstart", p)
                }
            }
        },
        props: {
            handleDOMEvents: {
                drop: (h, p) => (s = r === h.dom.parentElement,
                    a = p,
                    !1),
                paste: (h, p) => {
                    var g;
                    const y = (g = p.clipboardData) === null || g === void 0 ? void 0 : g.getData("text/html");
                    return o = p,
                        i = !!y?.includes("data-pm-slice"),
                        !1
                }
            }
        },
        appendTransaction: (h, p, g) => {
            const y = h[0]
                , x = y.getMeta("uiEvent") === "paste" && !i
                , S = y.getMeta("uiEvent") === "drop" && !s
                , k = y.getMeta("applyPasteRules")
                , A = !!k;
            if (!x && !S && !A)
                return;
            if (A) {
                const { from: b, text: w } = k
                    , T = b + w.length
                    , O = qH(w);
                return l({
                    rule: d,
                    state: g,
                    from: b,
                    to: {
                        b: T
                    },
                    pasteEvt: O
                })
            }
            const C = p.doc.content.findDiffStart(g.doc.content)
                , m = p.doc.content.findDiffEnd(g.doc.content);
            if (!(!VH(C) || !m || C === m.b))
                return l({
                    rule: d,
                    state: g,
                    from: C,
                    to: m,
                    pasteEvt: o
                })
        }
    }))
}
function JH(t) {
    const e = t.filter((n, r) => t.indexOf(n) !== r);
    return Array.from(new Set(e))
}
class Ml {
    constructor(e, n) {
        this.splittableMarks = [],
            this.editor = n,
            this.extensions = Ml.resolve(e),
            this.schema = $H(this.extensions, n),
            this.setupExtensions()
    }
    static resolve(e) {
        const n = Ml.sort(Ml.flatten(e))
            , r = JH(n.map(i => i.name));
        return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map(i => `'${i}'`).join(", ")}]. This can lead to issues.`),
            n
    }
    static flatten(e) {
        return e.map(n => {
            const r = {
                name: n.name,
                options: n.options,
                storage: n.storage
            }
                , i = Me(n, "addExtensions", r);
            return i ? [n, ...this.flatten(i())] : n
        }
        ).flat(10)
    }
    static sort(e) {
        return e.sort((r, i) => {
            const s = Me(r, "priority") || 100
                , o = Me(i, "priority") || 100;
            return s > o ? -1 : s < o ? 1 : 0
        }
        )
    }
    get commands() {
        return this.extensions.reduce((e, n) => {
            const r = {
                name: n.name,
                options: n.options,
                storage: n.storage,
                editor: this.editor,
                type: I0(n.name, this.schema)
            }
                , i = Me(n, "addCommands", r);
            return i ? {
                ...e,
                ...i()
            } : e
        }
            , {})
    }
    get plugins() {
        const { editor: e } = this
            , n = Ml.sort([...this.extensions].reverse())
            , r = []
            , i = []
            , s = n.map(o => {
                const a = {
                    name: o.name,
                    options: o.options,
                    storage: o.storage,
                    editor: e,
                    type: I0(o.name, this.schema)
                }
                    , l = []
                    , c = Me(o, "addKeyboardShortcuts", a);
                let d = {};
                if (o.type === "mark" && Me(o, "exitable", a) && (d.ArrowRight = () => Fr.handleExit({
                    editor: e,
                    mark: o
                })),
                    c) {
                    const x = Object.fromEntries(Object.entries(c()).map(([S, k]) => [S, () => k({
                        editor: e
                    })]));
                    d = {
                        ...d,
                        ...x
                    }
                }
                const h = cH(d);
                l.push(h);
                const p = Me(o, "addInputRules", a);
                x3(o, e.options.enableInputRules) && p && r.push(...p());
                const g = Me(o, "addPasteRules", a);
                x3(o, e.options.enablePasteRules) && g && i.push(...g());
                const y = Me(o, "addProseMirrorPlugins", a);
                if (y) {
                    const x = y();
                    l.push(...x)
                }
                return l
            }
            ).flat();
        return [HH({
            editor: e,
            rules: r
        }), ...GH({
            editor: e,
            rules: i
        }), ...s]
    }
    get attributes() {
        return VT(this.extensions)
    }
    get nodeViews() {
        const { editor: e } = this
            , { nodeExtensions: n } = Em(this.extensions);
        return Object.fromEntries(n.filter(r => !!Me(r, "addNodeView")).map(r => {
            const i = this.attributes.filter(l => l.type === r.name)
                , s = {
                    name: r.name,
                    options: r.options,
                    storage: r.storage,
                    editor: e,
                    type: On(r.name, this.schema)
                }
                , o = Me(r, "addNodeView", s);
            if (!o)
                return [];
            const a = (l, c, d, h, p) => {
                const g = q1(l, i);
                return o()({
                    node: l,
                    view: c,
                    getPos: d,
                    decorations: h,
                    innerDecorations: p,
                    editor: e,
                    extension: r,
                    HTMLAttributes: g
                })
            }
                ;
            return [r.name, a]
        }
        ))
    }
    setupExtensions() {
        this.extensions.forEach(e => {
            var n;
            this.editor.extensionStorage[e.name] = e.storage;
            const r = {
                name: e.name,
                options: e.options,
                storage: e.storage,
                editor: this.editor,
                type: I0(e.name, this.schema)
            };
            e.type === "mark" && (!((n = ht(Me(e, "keepOnSplit", r))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
            const i = Me(e, "onBeforeCreate", r)
                , s = Me(e, "onCreate", r)
                , o = Me(e, "onUpdate", r)
                , a = Me(e, "onSelectionUpdate", r)
                , l = Me(e, "onTransaction", r)
                , c = Me(e, "onFocus", r)
                , d = Me(e, "onBlur", r)
                , h = Me(e, "onDestroy", r);
            i && this.editor.on("beforeCreate", i),
                s && this.editor.on("create", s),
                o && this.editor.on("update", o),
                a && this.editor.on("selectionUpdate", a),
                l && this.editor.on("transaction", l),
                c && this.editor.on("focus", c),
                d && this.editor.on("blur", d),
                h && this.editor.on("destroy", h)
        }
        )
    }
}
function ZH(t) {
    return Object.prototype.toString.call(t).slice(8, -1)
}
function Vf(t) {
    return ZH(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype
}
function Tm(t, e) {
    const n = {
        ...t
    };
    return Vf(t) && Vf(e) && Object.keys(e).forEach(r => {
        Vf(e[r]) && Vf(t[r]) ? n[r] = Tm(t[r], e[r]) : n[r] = e[r]
    }
    ),
        n
}
class Vn {
    constructor(e = {}) {
        this.type = "extension",
            this.name = "extension",
            this.parent = null,
            this.child = null,
            this.config = {
                name: this.name,
                defaultOptions: {}
            },
            this.config = {
                ...this.config,
                ...e
            },
            this.name = this.config.name,
            e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
            this.options = this.config.defaultOptions,
            this.config.addOptions && (this.options = ht(Me(this, "addOptions", {
                name: this.name
            }))),
            this.storage = ht(Me(this, "addStorage", {
                name: this.name,
                options: this.options
            })) || {}
    }
    static create(e = {}) {
        return new Vn(e)
    }
    configure(e = {}) {
        const n = this.extend({
            ...this.config,
            addOptions: () => Tm(this.options, e)
        });
        return n.name = this.name,
            n.parent = this.parent,
            n
    }
    extend(e = {}) {
        const n = new Vn({
            ...this.config,
            ...e
        });
        return n.parent = this,
            this.child = n,
            n.name = e.name ? e.name : n.parent.name,
            e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
            n.options = ht(Me(n, "addOptions", {
                name: n.name
            })),
            n.storage = ht(Me(n, "addStorage", {
                name: n.name,
                options: n.options
            })),
            n
    }
}
function UT(t, e, n) {
    const { from: r, to: i } = e
        , { blockSeparator: s = `

`, textSerializers: o = {} } = n || {};
    let a = "";
    return t.nodesBetween(r, i, (l, c, d, h) => {
        var p;
        l.isBlock && c > r && (a += s);
        const g = o?.[l.type.name];
        if (g)
            return d && (a += g({
                node: l,
                pos: c,
                parent: d,
                index: h,
                range: e
            })),
                !1;
        l.isText && (a += (p = l?.text) === null || p === void 0 ? void 0 : p.slice(Math.max(r, c) - c, i - c))
    }
    ),
        a
}
function KT(t) {
    return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]))
}
const YH = Vn.create({
    name: "clipboardTextSerializer",
    addOptions() {
        return {
            blockSeparator: void 0
        }
    },
    addProseMirrorPlugins() {
        return [new sn({
            key: new _n("clipboardTextSerializer"),
            props: {
                clipboardTextSerializer: () => {
                    const { editor: t } = this
                        , { state: e, schema: n } = t
                        , { doc: r, selection: i } = e
                        , { ranges: s } = i
                        , o = Math.min(...s.map(d => d.$from.pos))
                        , a = Math.max(...s.map(d => d.$to.pos))
                        , l = KT(n);
                    return UT(r, {
                        from: o,
                        to: a
                    }, {
                        ...this.options.blockSeparator !== void 0 ? {
                            blockSeparator: this.options.blockSeparator
                        } : {},
                        textSerializers: l
                    })
                }
            }
        })]
    }
})
    , XH = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
        var n;
        t.isDestroyed || (e.dom.blur(),
            (n = window?.getSelection()) === null || n === void 0 || n.removeAllRanges())
    }
    ),
        !0)
    , QH = (t = !1) => ({ commands: e }) => e.setContent("", t)
    , eV = () => ({ state: t, tr: e, dispatch: n }) => {
        const { selection: r } = e
            , { ranges: i } = r;
        return n && i.forEach(({ $from: s, $to: o }) => {
            t.doc.nodesBetween(s.pos, o.pos, (a, l) => {
                if (a.type.isText)
                    return;
                const { doc: c, mapping: d } = e
                    , h = c.resolve(d.map(l))
                    , p = c.resolve(d.map(l + a.nodeSize))
                    , g = h.blockRange(p);
                if (!g)
                    return;
                const y = pu(g);
                if (a.type.isTextblock) {
                    const { defaultType: x } = h.parent.contentMatchAt(h.index());
                    e.setNodeMarkup(g.start, x)
                }
                (y || y === 0) && e.lift(g, y)
            }
            )
        }
        ),
            !0
    }
    , tV = t => e => t(e)
    , nV = () => ({ state: t, dispatch: e }) => SH(t, e)
    , rV = (t, e) => ({ editor: n, tr: r }) => {
        const { state: i } = n
            , s = i.doc.slice(t.from, t.to);
        r.deleteRange(t.from, t.to);
        const o = r.mapping.map(e);
        return r.insert(o, s.content),
            r.setSelection(new De(r.doc.resolve(o - 1))),
            !0
    }
    , iV = () => ({ tr: t, dispatch: e }) => {
        const { selection: n } = t
            , r = n.$anchor.node();
        if (r.content.size > 0)
            return !1;
        const i = t.selection.$anchor;
        for (let s = i.depth; s > 0; s -= 1)
            if (i.node(s).type === r.type) {
                if (e) {
                    const a = i.before(s)
                        , l = i.after(s);
                    t.delete(a, l).scrollIntoView()
                }
                return !0
            }
        return !1
    }
    , sV = t => ({ tr: e, state: n, dispatch: r }) => {
        const i = On(t, n.schema)
            , s = e.selection.$anchor;
        for (let o = s.depth; o > 0; o -= 1)
            if (s.node(o).type === i) {
                if (r) {
                    const l = s.before(o)
                        , c = s.after(o);
                    e.delete(l, c).scrollIntoView()
                }
                return !0
            }
        return !1
    }
    , oV = t => ({ tr: e, dispatch: n }) => {
        const { from: r, to: i } = t;
        return n && e.delete(r, i),
            !0
    }
    , aV = () => ({ state: t, dispatch: e }) => dH(t, e)
    , lV = () => ({ commands: t }) => t.keyboardShortcut("Enter")
    , uV = () => ({ state: t, dispatch: e }) => _H(t, e);
function rp(t, e, n = {
    strict: !0
}) {
    const r = Object.keys(e);
    return r.length ? r.every(i => n.strict ? e[i] === t[i] : Pv(e[i]) ? e[i].test(t[i]) : e[i] === t[i]) : !0
}
function G1(t, e, n = {}) {
    return t.find(r => r.type === e && rp(r.attrs, n))
}
function cV(t, e, n = {}) {
    return !!G1(t, e, n)
}
function Nv(t, e, n = {}) {
    if (!t || !e)
        return;
    let r = t.parent.childAfter(t.parentOffset);
    if (t.parentOffset === r.offset && r.offset !== 0 && (r = t.parent.childBefore(t.parentOffset)),
        !r.node)
        return;
    const i = G1([...r.node.marks], e, n);
    if (!i)
        return;
    let s = r.index
        , o = t.start() + r.offset
        , a = s + 1
        , l = o + r.node.nodeSize;
    for (G1([...r.node.marks], e, n); s > 0 && i.isInSet(t.parent.child(s - 1).marks);)
        s -= 1,
            o -= t.parent.child(s).nodeSize;
    for (; a < t.parent.childCount && cV([...t.parent.child(a).marks], e, n);)
        l += t.parent.child(a).nodeSize,
            a += 1;
    return {
        from: o,
        to: l
    }
}
function Jo(t, e) {
    if (typeof t == "string") {
        if (!e.marks[t])
            throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
        return e.marks[t]
    }
    return t
}
const dV = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
    const s = Jo(t, r.schema)
        , { doc: o, selection: a } = n
        , { $from: l, from: c, to: d } = a;
    if (i) {
        const h = Nv(l, s, e);
        if (h && h.from <= c && h.to >= d) {
            const p = De.create(o, h.from, h.to);
            n.setSelection(p)
        }
    }
    return !0
}
    , fV = t => e => {
        const n = typeof t == "function" ? t(e) : t;
        for (let r = 0; r < n.length; r += 1)
            if (n[r](e))
                return !0;
        return !1
    }
    ;
function qT(t) {
    return t instanceof De
}
function Ps(t = 0, e = 0, n = 0) {
    return Math.min(Math.max(t, e), n)
}
function GT(t, e = null) {
    if (!e)
        return null;
    const n = Ve.atStart(t)
        , r = Ve.atEnd(t);
    if (e === "start" || e === !0)
        return n;
    if (e === "end")
        return r;
    const i = n.from
        , s = r.to;
    return e === "all" ? De.create(t, Ps(0, i, s), Ps(t.content.size, i, s)) : De.create(t, Ps(e, i, s), Ps(e, i, s))
}
function Iv() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document
}
const hV = (t = null, e = {}) => ({ editor: n, view: r, tr: i, dispatch: s }) => {
    e = {
        scrollIntoView: !0,
        ...e
    };
    const o = () => {
        Iv() && r.dom.focus(),
            requestAnimationFrame(() => {
                n.isDestroyed || (r.focus(),
                    e?.scrollIntoView && n.commands.scrollIntoView())
            }
            )
    }
        ;
    if (r.hasFocus() && t === null || t === !1)
        return !0;
    if (s && t === null && !qT(n.state.selection))
        return o(),
            !0;
    const a = GT(i.doc, t) || n.state.selection
        , l = n.state.selection.eq(a);
    return s && (l || i.setSelection(a),
        l && i.storedMarks && i.setStoredMarks(i.storedMarks),
        o()),
        !0
}
    , pV = (t, e) => n => t.every((r, i) => e(r, {
        ...n,
        index: i
    }))
    , mV = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({
        from: n.selection.from,
        to: n.selection.to
    }, t, e)
    , JT = t => {
        const e = t.childNodes;
        for (let n = e.length - 1; n >= 0; n -= 1) {
            const r = e[n];
            r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && JT(r)
        }
        return t
    }
    ;
function Wf(t) {
    const e = `<body>${t}</body>`
        , n = new window.DOMParser().parseFromString(e, "text/html").body;
    return JT(n)
}
function ip(t, e, n) {
    n = {
        slice: !0,
        parseOptions: {},
        ...n
    };
    const r = typeof t == "object" && t !== null
        , i = typeof t == "string";
    if (r)
        try {
            if (Array.isArray(t) && t.length > 0)
                return se.fromArray(t.map(a => e.nodeFromJSON(a)));
            const o = e.nodeFromJSON(t);
            return n.errorOnInvalidContent && o.check(),
                o
        } catch (s) {
            if (n.errorOnInvalidContent)
                throw new Error("[tiptap error]: Invalid JSON content", {
                    cause: s
                });
            return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", s),
                ip("", e, n)
        }
    if (i) {
        if (n.errorOnInvalidContent) {
            let o = !1
                , a = "";
            const l = new $E({
                topNode: e.spec.topNode,
                marks: e.spec.marks,
                nodes: e.spec.nodes.append({
                    __tiptap__private__unknown__catch__all__node: {
                        content: "inline*",
                        group: "block",
                        parseDOM: [{
                            tag: "*",
                            getAttrs: c => (o = !0,
                                a = typeof c == "string" ? c : c.outerHTML,
                                null)
                        }]
                    }
                })
            });
            if (n.slice ? hc.fromSchema(l).parseSlice(Wf(t), n.parseOptions) : hc.fromSchema(l).parse(Wf(t), n.parseOptions),
                n.errorOnInvalidContent && o)
                throw new Error("[tiptap error]: Invalid HTML content", {
                    cause: new Error(`Invalid element found: ${a}`)
                })
        }
        const s = hc.fromSchema(e);
        return n.slice ? s.parseSlice(Wf(t), n.parseOptions).content : s.parse(Wf(t), n.parseOptions)
    }
    return ip("", e, n)
}
function gV(t, e, n) {
    const r = t.steps.length - 1;
    if (r < e)
        return;
    const i = t.steps[r];
    if (!(i instanceof En || i instanceof Tn))
        return;
    const s = t.mapping.maps[r];
    let o = 0;
    s.forEach((a, l, c, d) => {
        o === 0 && (o = d)
    }
    ),
        t.setSelection(Ve.near(t.doc.resolve(o), n))
}
const yV = t => !("type" in t)
    , vV = (t, e, n) => ({ tr: r, dispatch: i, editor: s }) => {
        var o;
        if (i) {
            n = {
                parseOptions: {},
                updateSelection: !0,
                applyInputRules: !1,
                applyPasteRules: !1,
                ...n
            };
            let a;
            try {
                a = ip(e, s.schema, {
                    parseOptions: {
                        preserveWhitespace: "full",
                        ...n.parseOptions
                    },
                    errorOnInvalidContent: (o = n.errorOnInvalidContent) !== null && o !== void 0 ? o : s.options.enableContentCheck
                })
            } catch (y) {
                return s.emit("contentError", {
                    editor: s,
                    error: y,
                    disableCollaboration: () => {
                        console.error("[tiptap error]: Unable to disable collaboration at this point in time")
                    }
                }),
                    !1
            }
            let { from: l, to: c } = typeof t == "number" ? {
                from: t,
                to: t
            } : {
                from: t.from,
                to: t.to
            }
                , d = !0
                , h = !0;
            if ((yV(a) ? a : [a]).forEach(y => {
                y.check(),
                    d = d ? y.isText && y.marks.length === 0 : !1,
                    h = h ? y.isBlock : !1
            }
            ),
                l === c && h) {
                const { parent: y } = r.doc.resolve(l);
                y.isTextblock && !y.type.spec.code && !y.childCount && (l -= 1,
                    c += 1)
            }
            let g;
            d ? (Array.isArray(e) ? g = e.map(y => y.text || "").join("") : typeof e == "object" && e && e.text ? g = e.text : g = e,
                r.insertText(g, l, c)) : (g = a,
                    r.replaceWith(l, c, g)),
                n.updateSelection && gV(r, r.steps.length - 1, -1),
                n.applyInputRules && r.setMeta("applyInputRules", {
                    from: l,
                    text: g
                }),
                n.applyPasteRules && r.setMeta("applyPasteRules", {
                    from: l,
                    text: g
                })
        }
        return !0
    }
    , bV = () => ({ state: t, dispatch: e }) => vH(t, e)
    , wV = () => ({ state: t, dispatch: e }) => bH(t, e)
    , xV = () => ({ state: t, dispatch: e }) => fH(t, e)
    , _V = () => ({ state: t, dispatch: e }) => gH(t, e)
    , SV = () => ({ state: t, dispatch: e, tr: n }) => {
        try {
            const r = vm(t.doc, t.selection.$from.pos, -1);
            return r == null ? !1 : (n.join(r, 2),
                e && e(n),
                !0)
        } catch {
            return !1
        }
    }
    , kV = () => ({ state: t, dispatch: e, tr: n }) => {
        try {
            const r = vm(t.doc, t.selection.$from.pos, 1);
            return r == null ? !1 : (n.join(r, 2),
                e && e(n),
                !0)
        } catch {
            return !1
        }
    }
    , CV = () => ({ state: t, dispatch: e }) => hH(t, e)
    , EV = () => ({ state: t, dispatch: e }) => pH(t, e);
function ZT() {
    return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1
}
function TV(t) {
    const e = t.split(/-(?!$)/);
    let n = e[e.length - 1];
    n === "Space" && (n = " ");
    let r, i, s, o;
    for (let a = 0; a < e.length - 1; a += 1) {
        const l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
            o = !0;
        else if (/^a(lt)?$/i.test(l))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(l))
            i = !0;
        else if (/^s(hift)?$/i.test(l))
            s = !0;
        else if (/^mod$/i.test(l))
            Iv() || ZT() ? o = !0 : i = !0;
        else
            throw new Error(`Unrecognized modifier name: ${l}`)
    }
    return r && (n = `Alt-${n}`),
        i && (n = `Ctrl-${n}`),
        o && (n = `Meta-${n}`),
        s && (n = `Shift-${n}`),
        n
}
const AV = t => ({ editor: e, view: n, tr: r, dispatch: i }) => {
    const s = TV(t).split(/-(?!$)/)
        , o = s.find(c => !["Alt", "Ctrl", "Meta", "Shift"].includes(c))
        , a = new KeyboardEvent("keydown", {
            key: o === "Space" ? " " : o,
            altKey: s.includes("Alt"),
            ctrlKey: s.includes("Ctrl"),
            metaKey: s.includes("Meta"),
            shiftKey: s.includes("Shift"),
            bubbles: !0,
            cancelable: !0
        })
        , l = e.captureTransaction(() => {
            n.someProp("handleKeyDown", c => c(n, a))
        }
        );
    return l?.steps.forEach(c => {
        const d = c.map(r.mapping);
        d && i && r.maybeStep(d)
    }
    ),
        !0
}
    ;
function Fc(t, e, n = {}) {
    const { from: r, to: i, empty: s } = t.selection
        , o = e ? On(e, t.schema) : null
        , a = [];
    t.doc.nodesBetween(r, i, (h, p) => {
        if (h.isText)
            return;
        const g = Math.max(r, p)
            , y = Math.min(i, p + h.nodeSize);
        a.push({
            node: h,
            from: g,
            to: y
        })
    }
    );
    const l = i - r
        , c = a.filter(h => o ? o.name === h.node.type.name : !0).filter(h => rp(h.node.attrs, n, {
            strict: !1
        }));
    return s ? !!c.length : c.reduce((h, p) => h + p.to - p.from, 0) >= l
}
const OV = (t, e = {}) => ({ state: n, dispatch: r }) => {
    const i = On(t, n.schema);
    return Fc(n, i, e) ? wH(n, r) : !1
}
    , MV = () => ({ state: t, dispatch: e }) => kH(t, e)
    , RV = t => ({ state: e, dispatch: n }) => {
        const r = On(t, e.schema);
        return PH(r)(e, n)
    }
    , PV = () => ({ state: t, dispatch: e }) => xH(t, e);
function Am(t, e) {
    return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null
}
function _3(t, e) {
    const n = typeof e == "string" ? [e] : e;
    return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]),
        r), {})
}
const NV = (t, e) => ({ tr: n, state: r, dispatch: i }) => {
    let s = null
        , o = null;
    const a = Am(typeof t == "string" ? t : t.name, r.schema);
    return a ? (a === "node" && (s = On(t, r.schema)),
        a === "mark" && (o = Jo(t, r.schema)),
        i && n.selection.ranges.forEach(l => {
            r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, d) => {
                s && s === c.type && n.setNodeMarkup(d, void 0, _3(c.attrs, e)),
                    o && c.marks.length && c.marks.forEach(h => {
                        o === h.type && n.addMark(d, d + c.nodeSize, o.create(_3(h.attrs, e)))
                    }
                    )
            }
            )
        }
        ),
        !0) : !1
}
    , IV = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(),
        !0)
    , LV = () => ({ tr: t, commands: e }) => e.setTextSelection({
        from: 0,
        to: t.doc.content.size
    })
    , DV = () => ({ state: t, dispatch: e }) => mH(t, e)
    , jV = () => ({ state: t, dispatch: e }) => yH(t, e)
    , BV = () => ({ state: t, dispatch: e }) => CH(t, e)
    , $V = () => ({ state: t, dispatch: e }) => AH(t, e)
    , zV = () => ({ state: t, dispatch: e }) => TH(t, e);
function J1(t, e, n = {}, r = {}) {
    return ip(t, e, {
        slice: !1,
        parseOptions: n,
        errorOnInvalidContent: r.errorOnInvalidContent
    })
}
const FV = (t, e = !1, n = {}, r = {}) => ({ editor: i, tr: s, dispatch: o, commands: a }) => {
    var l, c;
    const { doc: d } = s;
    if (n.preserveWhitespace !== "full") {
        const h = J1(t, i.schema, n, {
            errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
        });
        return o && s.replaceWith(0, d.content.size, h).setMeta("preventUpdate", !e),
            !0
    }
    return o && s.setMeta("preventUpdate", !e),
        a.insertContentAt({
            from: 0,
            to: d.content.size
        }, t, {
            parseOptions: n,
            errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : i.options.enableContentCheck
        })
}
    ;
function Cd(t, e) {
    const n = Jo(e, t.schema)
        , { from: r, to: i, empty: s } = t.selection
        , o = [];
    s ? (t.storedMarks && o.push(...t.storedMarks),
        o.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, i, l => {
            o.push(...l.marks)
        }
        );
    const a = o.find(l => l.type.name === n.name);
    return a ? {
        ...a.attrs
    } : {}
}
function HV(t, e) {
    const n = new bv(t);
    return e.forEach(r => {
        r.steps.forEach(i => {
            n.step(i)
        }
        )
    }
    ),
        n
}
function VV(t) {
    for (let e = 0; e < t.edgeCount; e += 1) {
        const { type: n } = t.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
function WV(t, e, n) {
    const r = [];
    return t.nodesBetween(e.from, e.to, (i, s) => {
        n(i) && r.push({
            node: i,
            pos: s
        })
    }
    ),
        r
}
function YT(t, e) {
    for (let n = t.depth; n > 0; n -= 1) {
        const r = t.node(n);
        if (e(r))
            return {
                pos: n > 0 ? t.before(n) : 0,
                start: t.start(n),
                depth: n,
                node: r
            }
    }
}
function Lv(t) {
    return e => YT(e.$from, t)
}
function UV(t, e) {
    const n = Ka.fromSchema(e).serializeFragment(t)
        , i = document.implementation.createHTMLDocument().createElement("div");
    return i.appendChild(n),
        i.innerHTML
}
function KV(t, e) {
    const n = {
        from: 0,
        to: t.content.size
    };
    return UT(t, n, e)
}
function qV(t, e) {
    const n = On(e, t.schema)
        , { from: r, to: i } = t.selection
        , s = [];
    t.doc.nodesBetween(r, i, a => {
        s.push(a)
    }
    );
    const o = s.reverse().find(a => a.type.name === n.name);
    return o ? {
        ...o.attrs
    } : {}
}
function XT(t, e) {
    const n = Am(typeof e == "string" ? e : e.name, t.schema);
    return n === "node" ? qV(t, e) : n === "mark" ? Cd(t, e) : {}
}
function GV(t, e = JSON.stringify) {
    const n = {};
    return t.filter(r => {
        const i = e(r);
        return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0
    }
    )
}
function JV(t) {
    const e = GV(t);
    return e.length === 1 ? e : e.filter((n, r) => !e.filter((s, o) => o !== r).some(s => n.oldRange.from >= s.oldRange.from && n.oldRange.to <= s.oldRange.to && n.newRange.from >= s.newRange.from && n.newRange.to <= s.newRange.to))
}
function ZV(t) {
    const { mapping: e, steps: n } = t
        , r = [];
    return e.maps.forEach((i, s) => {
        const o = [];
        if (i.ranges.length)
            i.forEach((a, l) => {
                o.push({
                    from: a,
                    to: l
                })
            }
            );
        else {
            const { from: a, to: l } = n[s];
            if (a === void 0 || l === void 0)
                return;
            o.push({
                from: a,
                to: l
            })
        }
        o.forEach(({ from: a, to: l }) => {
            const c = e.slice(s).map(a, -1)
                , d = e.slice(s).map(l)
                , h = e.invert().map(c, -1)
                , p = e.invert().map(d);
            r.push({
                oldRange: {
                    from: h,
                    to: p
                },
                newRange: {
                    from: c,
                    to: d
                }
            })
        }
        )
    }
    ),
        JV(r)
}
function Dv(t, e, n) {
    const r = [];
    return t === e ? n.resolve(t).marks().forEach(i => {
        const s = n.resolve(t)
            , o = Nv(s, i.type);
        o && r.push({
            mark: i,
            ...o
        })
    }
    ) : n.nodesBetween(t, e, (i, s) => {
        !i || i?.nodeSize === void 0 || r.push(...i.marks.map(o => ({
            from: s,
            to: s + i.nodeSize,
            mark: o
        })))
    }
    ),
        r
}
function hh(t, e, n) {
    return Object.fromEntries(Object.entries(n).filter(([r]) => {
        const i = t.find(s => s.type === e && s.name === r);
        return i ? i.attribute.keepOnSplit : !1
    }
    ))
}
function Z1(t, e, n = {}) {
    const { empty: r, ranges: i } = t.selection
        , s = e ? Jo(e, t.schema) : null;
    if (r)
        return !!(t.storedMarks || t.selection.$from.marks()).filter(h => s ? s.name === h.type.name : !0).find(h => rp(h.attrs, n, {
            strict: !1
        }));
    let o = 0;
    const a = [];
    if (i.forEach(({ $from: h, $to: p }) => {
        const g = h.pos
            , y = p.pos;
        t.doc.nodesBetween(g, y, (x, S) => {
            if (!x.isText && !x.marks.length)
                return;
            const k = Math.max(g, S)
                , A = Math.min(y, S + x.nodeSize)
                , C = A - k;
            o += C,
                a.push(...x.marks.map(m => ({
                    mark: m,
                    from: k,
                    to: A
                })))
        }
        )
    }
    ),
        o === 0)
        return !1;
    const l = a.filter(h => s ? s.name === h.mark.type.name : !0).filter(h => rp(h.mark.attrs, n, {
        strict: !1
    })).reduce((h, p) => h + p.to - p.from, 0)
        , c = a.filter(h => s ? h.mark.type !== s && h.mark.type.excludes(s) : !0).reduce((h, p) => h + p.to - p.from, 0);
    return (l > 0 ? l + c : l) >= o
}
function YV(t, e, n = {}) {
    if (!e)
        return Fc(t, null, n) || Z1(t, null, n);
    const r = Am(e, t.schema);
    return r === "node" ? Fc(t, e, n) : r === "mark" ? Z1(t, e, n) : !1
}
function S3(t, e) {
    const { nodeExtensions: n } = Em(e)
        , r = n.find(o => o.name === t);
    if (!r)
        return !1;
    const i = {
        name: r.name,
        options: r.options,
        storage: r.storage
    }
        , s = ht(Me(r, "group", i));
    return typeof s != "string" ? !1 : s.split(" ").includes("list")
}
function Om(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
    var r;
    if (n) {
        if (t.type.name === "hardBreak")
            return !0;
        if (t.isText)
            return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "")
    }
    if (t.isText)
        return !t.text;
    if (t.isAtom || t.isLeaf)
        return !1;
    if (t.content.childCount === 0)
        return !0;
    if (e) {
        let i = !0;
        return t.content.forEach(s => {
            i !== !1 && (Om(s, {
                ignoreWhitespace: n,
                checkChildren: e
            }) || (i = !1))
        }
        ),
            i
    }
    return !1
}
function XV(t) {
    return t instanceof Le
}
function iee(t, e, n) {
    const i = t.state.doc.content.size
        , s = Ps(e, 0, i)
        , o = Ps(n, 0, i)
        , a = t.coordsAtPos(s)
        , l = t.coordsAtPos(o, -1)
        , c = Math.min(a.top, l.top)
        , d = Math.max(a.bottom, l.bottom)
        , h = Math.min(a.left, l.left)
        , p = Math.max(a.right, l.right)
        , g = p - h
        , y = d - c
        , k = {
            top: c,
            bottom: d,
            left: h,
            right: p,
            width: g,
            height: y,
            x: h,
            y: c
        };
    return {
        ...k,
        toJSON: () => k
    }
}
function QV(t, e, n) {
    var r;
    const { selection: i } = e;
    let s = null;
    if (qT(i) && (s = i.$cursor),
        s) {
        const a = (r = t.storedMarks) !== null && r !== void 0 ? r : s.marks();
        return !!n.isInSet(a) || !a.some(l => l.type.excludes(n))
    }
    const { ranges: o } = i;
    return o.some(({ $from: a, $to: l }) => {
        let c = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
        return t.doc.nodesBetween(a.pos, l.pos, (d, h, p) => {
            if (c)
                return !1;
            if (d.isInline) {
                const g = !p || p.type.allowsMarkType(n)
                    , y = !!n.isInSet(d.marks) || !d.marks.some(x => x.type.excludes(n));
                c = g && y
            }
            return !c
        }
        ),
            c
    }
    )
}
const eW = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
    const { selection: s } = n
        , { empty: o, ranges: a } = s
        , l = Jo(t, r.schema);
    if (i)
        if (o) {
            const c = Cd(r, l);
            n.addStoredMark(l.create({
                ...c,
                ...e
            }))
        } else
            a.forEach(c => {
                const d = c.$from.pos
                    , h = c.$to.pos;
                r.doc.nodesBetween(d, h, (p, g) => {
                    const y = Math.max(g, d)
                        , x = Math.min(g + p.nodeSize, h);
                    p.marks.find(k => k.type === l) ? p.marks.forEach(k => {
                        l === k.type && n.addMark(y, x, l.create({
                            ...k.attrs,
                            ...e
                        }))
                    }
                    ) : n.addMark(y, x, l.create(e))
                }
                )
            }
            );
    return QV(r, n, l)
}
    , tW = (t, e) => ({ tr: n }) => (n.setMeta(t, e),
        !0)
    , nW = (t, e = {}) => ({ state: n, dispatch: r, chain: i }) => {
        const s = On(t, n.schema);
        return s.isTextblock ? i().command(({ commands: o }) => v3(s, e)(n) ? !0 : o.clearNodes()).command(({ state: o }) => v3(s, e)(o, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'),
            !1)
    }
    , rW = t => ({ tr: e, dispatch: n }) => {
        if (n) {
            const { doc: r } = e
                , i = Ps(t, 0, r.content.size)
                , s = Le.create(r, i);
            e.setSelection(s)
        }
        return !0
    }
    , iW = t => ({ tr: e, dispatch: n }) => {
        if (n) {
            const { doc: r } = e
                , { from: i, to: s } = typeof t == "number" ? {
                    from: t,
                    to: t
                } : t
                , o = De.atStart(r).from
                , a = De.atEnd(r).to
                , l = Ps(i, o, a)
                , c = Ps(s, o, a)
                , d = De.create(r, l, c);
            e.setSelection(d)
        }
        return !0
    }
    , sW = t => ({ state: e, dispatch: n }) => {
        const r = On(t, e.schema);
        return LH(r)(e, n)
    }
    ;
function k3(t, e) {
    const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
    if (n) {
        const r = n.filter(i => e?.includes(i.type.name));
        t.tr.ensureMarks(r)
    }
}
const oW = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: i }) => {
    const { selection: s, doc: o } = e
        , { $from: a, $to: l } = s
        , c = i.extensionManager.attributes
        , d = hh(c, a.node().type.name, a.node().attrs);
    if (s instanceof Le && s.node.isBlock)
        return !a.parentOffset || !zl(o, a.pos) ? !1 : (r && (t && k3(n, i.extensionManager.splittableMarks),
            e.split(a.pos).scrollIntoView()),
            !0);
    if (!a.parent.isBlock)
        return !1;
    const h = l.parentOffset === l.parent.content.size
        , p = a.depth === 0 ? void 0 : VV(a.node(-1).contentMatchAt(a.indexAfter(-1)));
    let g = h && p ? [{
        type: p,
        attrs: d
    }] : void 0
        , y = zl(e.doc, e.mapping.map(a.pos), 1, g);
    if (!g && !y && zl(e.doc, e.mapping.map(a.pos), 1, p ? [{
        type: p
    }] : void 0) && (y = !0,
        g = p ? [{
            type: p,
            attrs: d
        }] : void 0),
        r) {
        if (y && (s instanceof De && e.deleteSelection(),
            e.split(e.mapping.map(a.pos), 1, g),
            p && !h && !a.parentOffset && a.parent.type !== p)) {
            const x = e.mapping.map(a.before())
                , S = e.doc.resolve(x);
            a.node(-1).canReplaceWith(S.index(), S.index() + 1, p) && e.setNodeMarkup(e.mapping.map(a.before()), p)
        }
        t && k3(n, i.extensionManager.splittableMarks),
            e.scrollIntoView()
    }
    return y
}
    , aW = (t, e = {}) => ({ tr: n, state: r, dispatch: i, editor: s }) => {
        var o;
        const a = On(t, r.schema)
            , { $from: l, $to: c } = r.selection
            , d = r.selection.node;
        if (d && d.isBlock || l.depth < 2 || !l.sameParent(c))
            return !1;
        const h = l.node(-1);
        if (h.type !== a)
            return !1;
        const p = s.extensionManager.attributes;
        if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
            if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
                return !1;
            if (i) {
                let k = se.empty;
                const A = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
                for (let O = l.depth - A; O >= l.depth - 3; O -= 1)
                    k = se.from(l.node(O).copy(k));
                const C = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3
                    , m = {
                        ...hh(p, l.node().type.name, l.node().attrs),
                        ...e
                    }
                    , b = ((o = a.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(m)) || void 0;
                k = k.append(se.from(a.createAndFill(null, b) || void 0));
                const w = l.before(l.depth - (A - 1));
                n.replace(w, l.after(-C), new ve(k, 4 - A, 0));
                let T = -1;
                n.doc.nodesBetween(w, n.doc.content.size, (O, M) => {
                    if (T > -1)
                        return !1;
                    O.isTextblock && O.content.size === 0 && (T = M + 1)
                }
                ),
                    T > -1 && n.setSelection(De.near(n.doc.resolve(T))),
                    n.scrollIntoView()
            }
            return !0
        }
        const g = c.pos === l.end() ? h.contentMatchAt(0).defaultType : null
            , y = {
                ...hh(p, h.type.name, h.attrs),
                ...e
            }
            , x = {
                ...hh(p, l.node().type.name, l.node().attrs),
                ...e
            };
        n.delete(l.pos, c.pos);
        const S = g ? [{
            type: a,
            attrs: y
        }, {
            type: g,
            attrs: x
        }] : [{
            type: a,
            attrs: y
        }];
        if (!zl(n.doc, l.pos, 2))
            return !1;
        if (i) {
            const { selection: k, storedMarks: A } = r
                , { splittableMarks: C } = s.extensionManager
                , m = A || k.$to.parentOffset && k.$from.marks();
            if (n.split(l.pos, 2, S).scrollIntoView(),
                !m || !i)
                return !0;
            const b = m.filter(w => C.includes(w.type.name));
            n.ensureMarks(b)
        }
        return !0
    }
    , L0 = (t, e) => {
        const n = Lv(o => o.type === e)(t.selection);
        if (!n)
            return !0;
        const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
        if (r === void 0)
            return !0;
        const i = t.doc.nodeAt(r);
        return n.node.type === i?.type && qo(t.doc, n.pos) && t.join(n.pos),
            !0
    }
    , D0 = (t, e) => {
        const n = Lv(o => o.type === e)(t.selection);
        if (!n)
            return !0;
        const r = t.doc.resolve(n.start).after(n.depth);
        if (r === void 0)
            return !0;
        const i = t.doc.nodeAt(r);
        return n.node.type === i?.type && qo(t.doc, r) && t.join(r),
            !0
    }
    , lW = (t, e, n, r = {}) => ({ editor: i, tr: s, state: o, dispatch: a, chain: l, commands: c, can: d }) => {
        const { extensions: h, splittableMarks: p } = i.extensionManager
            , g = On(t, o.schema)
            , y = On(e, o.schema)
            , { selection: x, storedMarks: S } = o
            , { $from: k, $to: A } = x
            , C = k.blockRange(A)
            , m = S || x.$to.parentOffset && x.$from.marks();
        if (!C)
            return !1;
        const b = Lv(w => S3(w.type.name, h))(x);
        if (C.depth >= 1 && b && C.depth - b.depth <= 1) {
            if (b.node.type === g)
                return c.liftListItem(y);
            if (S3(b.node.type.name, h) && g.validContent(b.node.content) && a)
                return l().command(() => (s.setNodeMarkup(b.pos, g),
                    !0)).command(() => L0(s, g)).command(() => D0(s, g)).run()
        }
        return !n || !m || !a ? l().command(() => d().wrapInList(g, r) ? !0 : c.clearNodes()).wrapInList(g, r).command(() => L0(s, g)).command(() => D0(s, g)).run() : l().command(() => {
            const w = d().wrapInList(g, r)
                , T = m.filter(O => p.includes(O.type.name));
            return s.ensureMarks(T),
                w ? !0 : c.clearNodes()
        }
        ).wrapInList(g, r).command(() => L0(s, g)).command(() => D0(s, g)).run()
    }
    , uW = (t, e = {}, n = {}) => ({ state: r, commands: i }) => {
        const { extendEmptyMarkRange: s = !1 } = n
            , o = Jo(t, r.schema);
        return Z1(r, o, e) ? i.unsetMark(o, {
            extendEmptyMarkRange: s
        }) : i.setMark(o, e)
    }
    , cW = (t, e, n = {}) => ({ state: r, commands: i }) => {
        const s = On(t, r.schema)
            , o = On(e, r.schema)
            , a = Fc(r, s, n);
        let l;
        return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs),
            a ? i.setNode(o, l) : i.setNode(s, {
                ...l,
                ...n
            })
    }
    , dW = (t, e = {}) => ({ state: n, commands: r }) => {
        const i = On(t, n.schema);
        return Fc(n, i, e) ? r.lift(i) : r.wrapIn(i, e)
    }
    , fW = () => ({ state: t, dispatch: e }) => {
        const n = t.plugins;
        for (let r = 0; r < n.length; r += 1) {
            const i = n[r];
            let s;
            if (i.spec.isInputRules && (s = i.getState(t))) {
                if (e) {
                    const o = t.tr
                        , a = s.transform;
                    for (let l = a.steps.length - 1; l >= 0; l -= 1)
                        o.step(a.steps[l].invert(a.docs[l]));
                    if (s.text) {
                        const l = o.doc.resolve(s.from).marks();
                        o.replaceWith(s.from, s.to, t.schema.text(s.text, l))
                    } else
                        o.delete(s.from, s.to)
                }
                return !0
            }
        }
        return !1
    }
    , hW = () => ({ tr: t, dispatch: e }) => {
        const { selection: n } = t
            , { empty: r, ranges: i } = n;
        return r || e && i.forEach(s => {
            t.removeMark(s.$from.pos, s.$to.pos)
        }
        ),
            !0
    }
    , pW = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
        var s;
        const { extendEmptyMarkRange: o = !1 } = e
            , { selection: a } = n
            , l = Jo(t, r.schema)
            , { $from: c, empty: d, ranges: h } = a;
        if (!i)
            return !0;
        if (d && o) {
            let { from: p, to: g } = a;
            const y = (s = c.marks().find(S => S.type === l)) === null || s === void 0 ? void 0 : s.attrs
                , x = Nv(c, l, y);
            x && (p = x.from,
                g = x.to),
                n.removeMark(p, g, l)
        } else
            h.forEach(p => {
                n.removeMark(p.$from.pos, p.$to.pos, l)
            }
            );
        return n.removeStoredMark(l),
            !0
    }
    , mW = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
        let s = null
            , o = null;
        const a = Am(typeof t == "string" ? t : t.name, r.schema);
        return a ? (a === "node" && (s = On(t, r.schema)),
            a === "mark" && (o = Jo(t, r.schema)),
            i && n.selection.ranges.forEach(l => {
                const c = l.$from.pos
                    , d = l.$to.pos;
                r.doc.nodesBetween(c, d, (h, p) => {
                    s && s === h.type && n.setNodeMarkup(p, void 0, {
                        ...h.attrs,
                        ...e
                    }),
                        o && h.marks.length && h.marks.forEach(g => {
                            if (o === g.type) {
                                const y = Math.max(p, c)
                                    , x = Math.min(p + h.nodeSize, d);
                                n.addMark(y, x, o.create({
                                    ...g.attrs,
                                    ...e
                                }))
                            }
                        }
                        )
                }
                )
            }
            ),
            !0) : !1
    }
    , gW = (t, e = {}) => ({ state: n, dispatch: r }) => {
        const i = On(t, n.schema);
        return OH(i, e)(n, r)
    }
    , yW = (t, e = {}) => ({ state: n, dispatch: r }) => {
        const i = On(t, n.schema);
        return MH(i, e)(n, r)
    }
    ;
var vW = Object.freeze({
    __proto__: null,
    blur: XH,
    clearContent: QH,
    clearNodes: eV,
    command: tV,
    createParagraphNear: nV,
    cut: rV,
    deleteCurrentNode: iV,
    deleteNode: sV,
    deleteRange: oV,
    deleteSelection: aV,
    enter: lV,
    exitCode: uV,
    extendMarkRange: dV,
    first: fV,
    focus: hV,
    forEach: pV,
    insertContent: mV,
    insertContentAt: vV,
    joinBackward: xV,
    joinDown: wV,
    joinForward: _V,
    joinItemBackward: SV,
    joinItemForward: kV,
    joinTextblockBackward: CV,
    joinTextblockForward: EV,
    joinUp: bV,
    keyboardShortcut: AV,
    lift: OV,
    liftEmptyBlock: MV,
    liftListItem: RV,
    newlineInCode: PV,
    resetAttributes: NV,
    scrollIntoView: IV,
    selectAll: LV,
    selectNodeBackward: DV,
    selectNodeForward: jV,
    selectParentNode: BV,
    selectTextblockEnd: $V,
    selectTextblockStart: zV,
    setContent: FV,
    setMark: eW,
    setMeta: tW,
    setNode: nW,
    setNodeSelection: rW,
    setTextSelection: iW,
    sinkListItem: sW,
    splitBlock: oW,
    splitListItem: aW,
    toggleList: lW,
    toggleMark: uW,
    toggleNode: cW,
    toggleWrap: dW,
    undoInputRule: fW,
    unsetAllMarks: hW,
    unsetMark: pW,
    updateAttributes: mW,
    wrapIn: gW,
    wrapInList: yW
});
const bW = Vn.create({
    name: "commands",
    addCommands() {
        return {
            ...vW
        }
    }
})
    , wW = Vn.create({
        name: "editable",
        addProseMirrorPlugins() {
            return [new sn({
                key: new _n("editable"),
                props: {
                    editable: () => this.editor.options.editable
                }
            })]
        }
    })
    , xW = Vn.create({
        name: "focusEvents",
        addProseMirrorPlugins() {
            const { editor: t } = this;
            return [new sn({
                key: new _n("focusEvents"),
                props: {
                    handleDOMEvents: {
                        focus: (e, n) => {
                            t.isFocused = !0;
                            const r = t.state.tr.setMeta("focus", {
                                event: n
                            }).setMeta("addToHistory", !1);
                            return e.dispatch(r),
                                !1
                        }
                        ,
                        blur: (e, n) => {
                            t.isFocused = !1;
                            const r = t.state.tr.setMeta("blur", {
                                event: n
                            }).setMeta("addToHistory", !1);
                            return e.dispatch(r),
                                !1
                        }
                    }
                }
            })]
        }
    })
    , _W = Vn.create({
        name: "keymap",
        addKeyboardShortcuts() {
            const t = () => this.editor.commands.first(({ commands: o }) => [() => o.undoInputRule(), () => o.command(({ tr: a }) => {
                const { selection: l, doc: c } = a
                    , { empty: d, $anchor: h } = l
                    , { pos: p, parent: g } = h
                    , y = h.parent.isTextblock && p > 0 ? a.doc.resolve(p - 1) : h
                    , x = y.parent.type.spec.isolating
                    , S = h.pos - h.parentOffset
                    , k = x && y.parent.childCount === 1 ? S === h.pos : Ve.atStart(c).from === p;
                return !d || !g.type.isTextblock || g.textContent.length || !k || k && h.parent.type.name === "paragraph" ? !1 : o.clearNodes()
            }
            ), () => o.deleteSelection(), () => o.joinBackward(), () => o.selectNodeBackward()])
                , e = () => this.editor.commands.first(({ commands: o }) => [() => o.deleteSelection(), () => o.deleteCurrentNode(), () => o.joinForward(), () => o.selectNodeForward()])
                , r = {
                    Enter: () => this.editor.commands.first(({ commands: o }) => [() => o.newlineInCode(), () => o.createParagraphNear(), () => o.liftEmptyBlock(), () => o.splitBlock()]),
                    "Mod-Enter": () => this.editor.commands.exitCode(),
                    Backspace: t,
                    "Mod-Backspace": t,
                    "Shift-Backspace": t,
                    Delete: e,
                    "Mod-Delete": e,
                    "Mod-a": () => this.editor.commands.selectAll()
                }
                , i = {
                    ...r
                }
                , s = {
                    ...r,
                    "Ctrl-h": t,
                    "Alt-Backspace": t,
                    "Ctrl-d": e,
                    "Ctrl-Alt-Backspace": e,
                    "Alt-Delete": e,
                    "Alt-d": e,
                    "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
                    "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
                };
            return Iv() || ZT() ? s : i
        },
        addProseMirrorPlugins() {
            return [new sn({
                key: new _n("clearDocument"),
                appendTransaction: (t, e, n) => {
                    const r = t.some(x => x.docChanged) && !e.doc.eq(n.doc)
                        , i = t.some(x => x.getMeta("preventClearDocument"));
                    if (!r || i)
                        return;
                    const { empty: s, from: o, to: a } = e.selection
                        , l = Ve.atStart(e.doc).from
                        , c = Ve.atEnd(e.doc).to;
                    if (s || !(o === l && a === c) || !Om(n.doc))
                        return;
                    const p = n.tr
                        , g = km({
                            state: n,
                            transaction: p
                        })
                        , { commands: y } = new Cm({
                            editor: this.editor,
                            state: g
                        });
                    if (y.clearNodes(),
                        !!p.steps.length)
                        return p
                }
            })]
        }
    })
    , SW = Vn.create({
        name: "tabindex",
        addProseMirrorPlugins() {
            return [new sn({
                key: new _n("tabindex"),
                props: {
                    attributes: () => this.editor.isEditable ? {
                        tabindex: "0"
                    } : {}
                }
            })]
        }
    });
class da {
    get name() {
        return this.node.type.name
    }
    constructor(e, n, r = !1, i = null) {
        this.currentNode = null,
            this.actualDepth = null,
            this.isBlock = r,
            this.resolvedPos = e,
            this.editor = n,
            this.currentNode = i
    }
    get node() {
        return this.currentNode || this.resolvedPos.node()
    }
    get element() {
        return this.editor.view.domAtPos(this.pos).node
    }
    get depth() {
        var e;
        return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth
    }
    get pos() {
        return this.resolvedPos.pos
    }
    get content() {
        return this.node.content
    }
    set content(e) {
        let n = this.from
            , r = this.to;
        if (this.isBlock) {
            if (this.content.size === 0) {
                console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
                return
            }
            n = this.from + 1,
                r = this.to - 1
        }
        this.editor.commands.insertContentAt({
            from: n,
            to: r
        }, e)
    }
    get attributes() {
        return this.node.attrs
    }
    get textContent() {
        return this.node.textContent
    }
    get size() {
        return this.node.nodeSize
    }
    get from() {
        return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth)
    }
    get range() {
        return {
            from: this.from,
            to: this.to
        }
    }
    get to() {
        return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1)
    }
    get parent() {
        if (this.depth === 0)
            return null;
        const e = this.resolvedPos.start(this.resolvedPos.depth - 1)
            , n = this.resolvedPos.doc.resolve(e);
        return new da(n, this.editor)
    }
    get before() {
        let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)),
            new da(e, this.editor)
    }
    get after() {
        let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)),
            new da(e, this.editor)
    }
    get children() {
        const e = [];
        return this.node.content.forEach((n, r) => {
            const i = n.isBlock && !n.isTextblock
                , s = this.pos + r + 1
                , o = this.resolvedPos.doc.resolve(s);
            if (!i && o.depth <= this.depth)
                return;
            const a = new da(o, this.editor, i, i ? n : null);
            i && (a.actualDepth = this.depth + 1),
                e.push(new da(o, this.editor, i, i ? n : null))
        }
        ),
            e
    }
    get firstChild() {
        return this.children[0] || null
    }
    get lastChild() {
        const e = this.children;
        return e[e.length - 1] || null
    }
    closest(e, n = {}) {
        let r = null
            , i = this.parent;
        for (; i && !r;) {
            if (i.node.type.name === e)
                if (Object.keys(n).length > 0) {
                    const s = i.node.attrs
                        , o = Object.keys(n);
                    for (let a = 0; a < o.length; a += 1) {
                        const l = o[a];
                        if (s[l] !== n[l])
                            break
                    }
                } else
                    r = i;
            i = i.parent
        }
        return r
    }
    querySelector(e, n = {}) {
        return this.querySelectorAll(e, n, !0)[0] || null
    }
    querySelectorAll(e, n = {}, r = !1) {
        let i = [];
        if (!this.children || this.children.length === 0)
            return i;
        const s = Object.keys(n);
        return this.children.forEach(o => {
            r && i.length > 0 || (o.node.type.name === e && s.every(l => n[l] === o.node.attrs[l]) && i.push(o),
                !(r && i.length > 0) && (i = i.concat(o.querySelectorAll(e, n, r))))
        }
        ),
            i
    }
    setAttribute(e) {
        const n = this.editor.state.selection;
        this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, e).setTextSelection(n.from).run()
    }
}
const kW = t => new sn({
    key: new _n("tiptapDrop"),
    props: {
        handleDrop: (e, n, r, i) => {
            t(n, r, i)
        }
    }
})
    , CW = t => new sn({
        key: new _n("tiptapPaste"),
        props: {
            handlePaste: (e, n, r) => {
                t(n, r)
            }
        }
    })
    , EW = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function TW(t, e, n) {
    const r = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ""}]`);
    if (r !== null)
        return r;
    const i = document.createElement("style");
    return e && i.setAttribute("nonce", e),
        i.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""),
        i.innerHTML = t,
        document.getElementsByTagName("head")[0].appendChild(i),
        i
}
let see = class extends DH {
    constructor(e = {}) {
        super(),
            this.isFocused = !1,
            this.isInitialized = !1,
            this.extensionStorage = {},
            this.options = {
                element: document.createElement("div"),
                content: "",
                injectCSS: !0,
                injectNonce: void 0,
                extensions: [],
                autofocus: !1,
                editable: !0,
                editorProps: {},
                parseOptions: {},
                coreExtensionOptions: {},
                enableInputRules: !0,
                enablePasteRules: !0,
                enableCoreExtensions: !0,
                enableContentCheck: !1,
                onBeforeCreate: () => null,
                onCreate: () => null,
                onUpdate: () => null,
                onSelectionUpdate: () => null,
                onTransaction: () => null,
                onFocus: () => null,
                onBlur: () => null,
                onDestroy: () => null,
                onContentError: ({ error: n }) => {
                    throw n
                }
                ,
                onPaste: () => null,
                onDrop: () => null
            },
            this.isCapturingTransaction = !1,
            this.capturedTransaction = null,
            this.setOptions(e),
            this.createExtensionManager(),
            this.createCommandManager(),
            this.createSchema(),
            this.on("beforeCreate", this.options.onBeforeCreate),
            this.emit("beforeCreate", {
                editor: this
            }),
            this.on("contentError", this.options.onContentError),
            this.createView(),
            this.injectCSS(),
            this.on("create", this.options.onCreate),
            this.on("update", this.options.onUpdate),
            this.on("selectionUpdate", this.options.onSelectionUpdate),
            this.on("transaction", this.options.onTransaction),
            this.on("focus", this.options.onFocus),
            this.on("blur", this.options.onBlur),
            this.on("destroy", this.options.onDestroy),
            this.options.onPaste && this.registerPlugin(CW(this.options.onPaste)),
            this.options.onDrop && this.registerPlugin(kW(this.options.onDrop)),
            window.setTimeout(() => {
                this.isDestroyed || (this.commands.focus(this.options.autofocus),
                    this.emit("create", {
                        editor: this
                    }),
                    this.isInitialized = !0)
            }
                , 0)
    }
    get storage() {
        return this.extensionStorage
    }
    get commands() {
        return this.commandManager.commands
    }
    chain() {
        return this.commandManager.chain()
    }
    can() {
        return this.commandManager.can()
    }
    injectCSS() {
        this.options.injectCSS && document && (this.css = TW(EW, this.options.injectNonce))
    }
    setOptions(e = {}) {
        this.options = {
            ...this.options,
            ...e
        },
            !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps),
                this.view.updateState(this.state))
    }
    setEditable(e, n = !0) {
        this.setOptions({
            editable: e
        }),
            n && this.emit("update", {
                editor: this,
                transaction: this.state.tr
            })
    }
    get isEditable() {
        return this.options.editable && this.view && this.view.editable
    }
    get state() {
        return this.view.state
    }
    registerPlugin(e, n) {
        const r = WT(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e]
            , i = this.state.reconfigure({
                plugins: r
            });
        return this.view.updateState(i),
            i
    }
    unregisterPlugin(e) {
        if (this.isDestroyed)
            return;
        const n = typeof e == "string" ? `${e}$` : e.key
            , r = this.state.reconfigure({
                plugins: this.state.plugins.filter(i => !i.key.startsWith(n))
            });
        return this.view.updateState(r),
            r
    }
    createExtensionManager() {
        var e, n;
        const i = [...this.options.enableCoreExtensions ? [wW, YH.configure({
            blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
        }), bW, xW, _W, SW].filter(s => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== !1 : !0) : [], ...this.options.extensions].filter(s => ["extension", "node", "mark"].includes(s?.type));
        this.extensionManager = new Ml(i, this)
    }
    createCommandManager() {
        this.commandManager = new Cm({
            editor: this
        })
    }
    createSchema() {
        this.schema = this.extensionManager.schema
    }
    createView() {
        let e;
        try {
            e = J1(this.options.content, this.schema, this.options.parseOptions, {
                errorOnInvalidContent: this.options.enableContentCheck
            })
        } catch (s) {
            if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
                throw s;
            this.emit("contentError", {
                editor: this,
                error: s,
                disableCollaboration: () => {
                    this.options.extensions = this.options.extensions.filter(o => o.name !== "collaboration"),
                        this.createExtensionManager()
                }
            }),
                e = J1(this.options.content, this.schema, this.options.parseOptions, {
                    errorOnInvalidContent: !1
                })
        }
        const n = GT(e, this.options.autofocus);
        this.view = new tH(this.options.element, {
            ...this.options.editorProps,
            dispatchTransaction: this.dispatchTransaction.bind(this),
            state: Ol.create({
                doc: e,
                selection: n || void 0
            })
        });
        const r = this.state.reconfigure({
            plugins: this.extensionManager.plugins
        });
        this.view.updateState(r),
            this.createNodeViews(),
            this.prependClass();
        const i = this.view.dom;
        i.editor = this
    }
    createNodeViews() {
        this.view.isDestroyed || this.view.setProps({
            nodeViews: this.extensionManager.nodeViews
        })
    }
    prependClass() {
        this.view.dom.className = `tiptap ${this.view.dom.className}`
    }
    captureTransaction(e) {
        this.isCapturingTransaction = !0,
            e(),
            this.isCapturingTransaction = !1;
        const n = this.capturedTransaction;
        return this.capturedTransaction = null,
            n
    }
    dispatchTransaction(e) {
        if (this.view.isDestroyed)
            return;
        if (this.isCapturingTransaction) {
            if (!this.capturedTransaction) {
                this.capturedTransaction = e;
                return
            }
            e.steps.forEach(o => {
                var a;
                return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(o)
            }
            );
            return
        }
        const n = this.state.apply(e)
            , r = !this.state.selection.eq(n.selection);
        this.emit("beforeTransaction", {
            editor: this,
            transaction: e,
            nextState: n
        }),
            this.view.updateState(n),
            this.emit("transaction", {
                editor: this,
                transaction: e
            }),
            r && this.emit("selectionUpdate", {
                editor: this,
                transaction: e
            });
        const i = e.getMeta("focus")
            , s = e.getMeta("blur");
        i && this.emit("focus", {
            editor: this,
            event: i.event,
            transaction: e
        }),
            s && this.emit("blur", {
                editor: this,
                event: s.event,
                transaction: e
            }),
            !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
                editor: this,
                transaction: e
            })
    }
    getAttributes(e) {
        return XT(this.state, e)
    }
    isActive(e, n) {
        const r = typeof e == "string" ? e : null
            , i = typeof e == "string" ? n : e;
        return YV(this.state, r, i)
    }
    getJSON() {
        return this.state.doc.toJSON()
    }
    getHTML() {
        return UV(this.state.doc.content, this.schema)
    }
    getText(e) {
        const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {};
        return KV(this.state.doc, {
            blockSeparator: n,
            textSerializers: {
                ...KT(this.schema),
                ...r
            }
        })
    }
    get isEmpty() {
        return Om(this.state.doc)
    }
    getCharacterCount() {
        return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'),
            this.state.doc.content.size - 2
    }
    destroy() {
        this.emit("destroy"),
            this.view && this.view.destroy(),
            this.removeAllListeners()
    }
    get isDestroyed() {
        var e;
        return !(!((e = this.view) === null || e === void 0) && e.docView)
    }
    $node(e, n) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null
    }
    $nodes(e, n) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null
    }
    $pos(e) {
        const n = this.state.doc.resolve(e);
        return new da(n, this)
    }
    get $doc() {
        return this.$pos(0)
    }
}
    ;
function Ba(t) {
    return new kd({
        find: t.find,
        handler: ({ state: e, range: n, match: r }) => {
            const i = ht(t.getAttributes, void 0, r);
            if (i === !1 || i === null)
                return null;
            const { tr: s } = e
                , o = r[r.length - 1]
                , a = r[0];
            if (o) {
                const l = a.search(/\S/)
                    , c = n.from + a.indexOf(o)
                    , d = c + o.length;
                if (Dv(n.from, n.to, e.doc).filter(g => g.mark.type.excluded.find(x => x === t.type && x !== g.mark.type)).filter(g => g.to > c).length)
                    return null;
                d < n.to && s.delete(d, n.to),
                    c > n.from && s.delete(n.from + l, c);
                const p = n.from + l + o.length;
                s.addMark(n.from + l, p, t.type.create(i || {})),
                    s.removeStoredMark(t.type)
            }
        }
    })
}
function QT(t) {
    return new kd({
        find: t.find,
        handler: ({ state: e, range: n, match: r }) => {
            const i = ht(t.getAttributes, void 0, r) || {}
                , { tr: s } = e
                , o = n.from;
            let a = n.to;
            const l = t.type.create(i);
            if (r[1]) {
                const c = r[0].lastIndexOf(r[1]);
                let d = o + c;
                d > a ? d = a : a = d + r[1].length;
                const h = r[0][r[0].length - 1];
                s.insertText(h, o + r[0].length - 1),
                    s.replaceWith(d, a, l)
            } else if (r[0]) {
                const c = t.type.isInline ? o : o - 1;
                s.insert(c, t.type.create(i)).delete(s.mapping.map(o), s.mapping.map(a))
            }
            s.scrollIntoView()
        }
    })
}
function Y1(t) {
    return new kd({
        find: t.find,
        handler: ({ state: e, range: n, match: r }) => {
            const i = e.doc.resolve(n.from)
                , s = ht(t.getAttributes, void 0, r) || {};
            if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type))
                return null;
            e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, s)
        }
    })
}
function on(t) {
    return new kd({
        find: t.find,
        handler: ({ state: e, range: n, match: r }) => {
            let i = t.replace
                , s = n.from;
            const o = n.to;
            if (r[1]) {
                const a = r[0].lastIndexOf(r[1]);
                i += r[0].slice(a + r[1].length),
                    s += a;
                const l = s - o;
                l > 0 && (i = r[0].slice(a - l, a) + i,
                    s = o)
            }
            e.tr.insertText(i, s, o)
        }
    })
}
function Hc(t) {
    return new kd({
        find: t.find,
        handler: ({ state: e, range: n, match: r, chain: i }) => {
            const s = ht(t.getAttributes, void 0, r) || {}
                , o = e.tr.delete(n.from, n.to)
                , l = o.doc.resolve(n.from).blockRange()
                , c = l && vv(l, t.type, s);
            if (!c)
                return null;
            if (o.wrap(l, c),
                t.keepMarks && t.editor) {
                const { selection: h, storedMarks: p } = e
                    , { splittableMarks: g } = t.editor.extensionManager
                    , y = p || h.$to.parentOffset && h.$from.marks();
                if (y) {
                    const x = y.filter(S => g.includes(S.type.name));
                    o.ensureMarks(x)
                }
            }
            if (t.keepAttributes) {
                const h = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
                i().updateAttributes(h, s).run()
            }
            const d = o.doc.resolve(n.from - 1).nodeBefore;
            d && d.type === t.type && qo(o.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, d)) && o.join(n.from - 1)
        }
    })
}
class Fr {
    constructor(e = {}) {
        this.type = "mark",
            this.name = "mark",
            this.parent = null,
            this.child = null,
            this.config = {
                name: this.name,
                defaultOptions: {}
            },
            this.config = {
                ...this.config,
                ...e
            },
            this.name = this.config.name,
            e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
            this.options = this.config.defaultOptions,
            this.config.addOptions && (this.options = ht(Me(this, "addOptions", {
                name: this.name
            }))),
            this.storage = ht(Me(this, "addStorage", {
                name: this.name,
                options: this.options
            })) || {}
    }
    static create(e = {}) {
        return new Fr(e)
    }
    configure(e = {}) {
        const n = this.extend({
            ...this.config,
            addOptions: () => Tm(this.options, e)
        });
        return n.name = this.name,
            n.parent = this.parent,
            n
    }
    extend(e = {}) {
        const n = new Fr(e);
        return n.parent = this,
            this.child = n,
            n.name = e.name ? e.name : n.parent.name,
            e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
            n.options = ht(Me(n, "addOptions", {
                name: n.name
            })),
            n.storage = ht(Me(n, "addStorage", {
                name: n.name,
                options: n.options
            })),
            n
    }
    static handleExit({ editor: e, mark: n }) {
        const { tr: r } = e.state
            , i = e.state.selection.$from;
        if (i.pos === i.end()) {
            const o = i.marks();
            if (!!!o.find(c => c?.type.name === n.name))
                return !1;
            const l = o.find(c => c?.type.name === n.name);
            return l && r.removeStoredMark(l),
                r.insertText(" ", i.pos),
                e.view.dispatch(r),
                !0
        }
        return !1
    }
}
let mn = class X1 {
    constructor(e = {}) {
        this.type = "node",
            this.name = "node",
            this.parent = null,
            this.child = null,
            this.config = {
                name: this.name,
                defaultOptions: {}
            },
            this.config = {
                ...this.config,
                ...e
            },
            this.name = this.config.name,
            e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
            this.options = this.config.defaultOptions,
            this.config.addOptions && (this.options = ht(Me(this, "addOptions", {
                name: this.name
            }))),
            this.storage = ht(Me(this, "addStorage", {
                name: this.name,
                options: this.options
            })) || {}
    }
    static create(e = {}) {
        return new X1(e)
    }
    configure(e = {}) {
        const n = this.extend({
            ...this.config,
            addOptions: () => Tm(this.options, e)
        });
        return n.name = this.name,
            n.parent = this.parent,
            n
    }
    extend(e = {}) {
        const n = new X1(e);
        return n.parent = this,
            this.child = n,
            n.name = e.name ? e.name : n.parent.name,
            e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
            n.options = ht(Me(n, "addOptions", {
                name: n.name
            })),
            n.storage = ht(Me(n, "addStorage", {
                name: n.name,
                options: n.options
            })),
            n
    }
}
    ;
function Io(t) {
    return new WH({
        find: t.find,
        handler: ({ state: e, range: n, match: r, pasteEvent: i }) => {
            const s = ht(t.getAttributes, void 0, r, i);
            if (s === !1 || s === null)
                return null;
            const { tr: o } = e
                , a = r[r.length - 1]
                , l = r[0];
            let c = n.to;
            if (a) {
                const d = l.search(/\S/)
                    , h = n.from + l.indexOf(a)
                    , p = h + a.length;
                if (Dv(n.from, n.to, e.doc).filter(y => y.mark.type.excluded.find(S => S === t.type && S !== y.mark.type)).filter(y => y.to > h).length)
                    return null;
                p < n.to && o.delete(p, n.to),
                    h > n.from && o.delete(n.from + d, h),
                    c = n.from + d + a.length,
                    o.addMark(n.from + d, c, t.type.create(s || {})),
                    o.removeStoredMark(t.type)
            }
        }
    })
}
function AW(t) {
    return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")
}
const OW = /^\s*>\s$/
    , MW = mn.create({
        name: "blockquote",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        content: "block+",
        group: "block",
        defining: !0,
        parseHTML() {
            return [{
                tag: "blockquote"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["blockquote", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
                toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
                unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
            }
        },
        addInputRules() {
            return [Hc({
                find: OW,
                type: this.type
            })]
        }
    })
    , RW = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/
    , PW = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g
    , NW = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/
    , IW = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g
    , LW = Fr.create({
        name: "bold",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        parseHTML() {
            return [{
                tag: "strong"
            }, {
                tag: "b",
                getAttrs: t => t.style.fontWeight !== "normal" && null
            }, {
                style: "font-weight",
                getAttrs: t => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["strong", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                setBold: () => ({ commands: t }) => t.setMark(this.name),
                toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
                unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-b": () => this.editor.commands.toggleBold(),
                "Mod-B": () => this.editor.commands.toggleBold()
            }
        },
        addInputRules() {
            return [Ba({
                find: RW,
                type: this.type
            }), Ba({
                find: NW,
                type: this.type
            })]
        },
        addPasteRules() {
            return [Io({
                find: PW,
                type: this.type
            }), Io({
                find: IW,
                type: this.type
            })]
        }
    })
    , DW = mn.create({
        name: "listItem",
        addOptions() {
            return {
                HTMLAttributes: {},
                bulletListTypeName: "bulletList",
                orderedListTypeName: "orderedList"
            }
        },
        content: "paragraph block*",
        defining: !0,
        parseHTML() {
            return [{
                tag: "li"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["li", Tt(this.options.HTMLAttributes, t), 0]
        },
        addKeyboardShortcuts() {
            return {
                Enter: () => this.editor.commands.splitListItem(this.name),
                Tab: () => this.editor.commands.sinkListItem(this.name),
                "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
            }
        }
    })
    , C3 = Fr.create({
        name: "textStyle",
        priority: 101,
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        parseHTML() {
            return [{
                tag: "span",
                getAttrs: t => t.hasAttribute("style") ? {} : !1
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["span", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
                    const n = Cd(t, this.type);
                    return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name)
                }
            }
        }
    })
    , E3 = /^\s*([-+*])\s$/
    , jW = mn.create({
        name: "bulletList",
        addOptions() {
            return {
                itemTypeName: "listItem",
                HTMLAttributes: {},
                keepMarks: !1,
                keepAttributes: !1
            }
        },
        group: "block list",
        content() {
            return `${this.options.itemTypeName}+`
        },
        parseHTML() {
            return [{
                tag: "ul"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["ul", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(DW.name, this.editor.getAttributes(C3.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
            }
        },
        addInputRules() {
            let t = Hc({
                find: E3,
                type: this.type
            });
            return (this.options.keepMarks || this.options.keepAttributes) && (t = Hc({
                find: E3,
                type: this.type,
                keepMarks: this.options.keepMarks,
                keepAttributes: this.options.keepAttributes,
                getAttributes: () => this.editor.getAttributes(C3.name),
                editor: this.editor
            })),
                [t]
        }
    })
    , BW = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/
    , $W = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g
    , zW = Fr.create({
        name: "code",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        excludes: "_",
        code: !0,
        exitable: !0,
        parseHTML() {
            return [{
                tag: "code"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["code", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                setCode: () => ({ commands: t }) => t.setMark(this.name),
                toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
                unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-e": () => this.editor.commands.toggleCode()
            }
        },
        addInputRules() {
            return [Ba({
                find: BW,
                type: this.type
            })]
        },
        addPasteRules() {
            return [Io({
                find: $W,
                type: this.type
            })]
        }
    })
    , FW = /^```([a-z]+)?[\s\n]$/
    , HW = /^~~~([a-z]+)?[\s\n]$/
    , VW = mn.create({
        name: "codeBlock",
        addOptions() {
            return {
                languageClassPrefix: "language-",
                exitOnTripleEnter: !0,
                exitOnArrowDown: !0,
                defaultLanguage: null,
                HTMLAttributes: {}
            }
        },
        content: "text*",
        marks: "",
        group: "block",
        code: !0,
        defining: !0,
        addAttributes() {
            return {
                language: {
                    default: this.options.defaultLanguage,
                    parseHTML: t => {
                        var e;
                        const { languageClassPrefix: n } = this.options
                            , s = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter(o => o.startsWith(n)).map(o => o.replace(n, ""))[0];
                        return s || null
                    }
                    ,
                    rendered: !1
                }
            }
        },
        parseHTML() {
            return [{
                tag: "pre",
                preserveWhitespace: "full"
            }]
        },
        renderHTML({ node: t, HTMLAttributes: e }) {
            return ["pre", Tt(this.options.HTMLAttributes, e), ["code", {
                class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
            }, 0]]
        },
        addCommands() {
            return {
                setCodeBlock: t => ({ commands: e }) => e.setNode(this.name, t),
                toggleCodeBlock: t => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
                Backspace: () => {
                    const { empty: t, $anchor: e } = this.editor.state.selection
                        , n = e.pos === 1;
                    return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1
                }
                ,
                Enter: ({ editor: t }) => {
                    if (!this.options.exitOnTripleEnter)
                        return !1;
                    const { state: e } = t
                        , { selection: n } = e
                        , { $from: r, empty: i } = n;
                    if (!i || r.parent.type !== this.type)
                        return !1;
                    const s = r.parentOffset === r.parent.nodeSize - 2
                        , o = r.parent.textContent.endsWith(`

`);
                    return !s || !o ? !1 : t.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos),
                        !0)).exitCode().run()
                }
                ,
                ArrowDown: ({ editor: t }) => {
                    if (!this.options.exitOnArrowDown)
                        return !1;
                    const { state: e } = t
                        , { selection: n, doc: r } = e
                        , { $from: i, empty: s } = n;
                    if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
                        return !1;
                    const a = i.after();
                    return a === void 0 ? !1 : r.nodeAt(a) ? t.commands.command(({ tr: c }) => (c.setSelection(Ve.near(r.resolve(a))),
                        !0)) : t.commands.exitCode()
                }
            }
        },
        addInputRules() {
            return [Y1({
                find: FW,
                type: this.type,
                getAttributes: t => ({
                    language: t[1]
                })
            }), Y1({
                find: HW,
                type: this.type,
                getAttributes: t => ({
                    language: t[1]
                })
            })]
        },
        addProseMirrorPlugins() {
            return [new sn({
                key: new _n("codeBlockVSCodeHandler"),
                props: {
                    handlePaste: (t, e) => {
                        if (!e.clipboardData || this.editor.isActive(this.type.name))
                            return !1;
                        const n = e.clipboardData.getData("text/plain")
                            , r = e.clipboardData.getData("vscode-editor-data")
                            , i = r ? JSON.parse(r) : void 0
                            , s = i?.mode;
                        if (!n || !s)
                            return !1;
                        const { tr: o, schema: a } = t.state
                            , l = a.text(n.replace(/\r\n?/g, `
`));
                        return o.replaceSelectionWith(this.type.create({
                            language: s
                        }, l)),
                            o.selection.$from.parent.type !== this.type && o.setSelection(De.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))),
                            o.setMeta("paste", !0),
                            t.dispatch(o),
                            !0
                    }
                }
            })]
        }
    })
    , WW = mn.create({
        name: "doc",
        topNode: !0,
        content: "block+"
    });
function UW(t = {}) {
    return new sn({
        view(e) {
            return new KW(e, t)
        }
    })
}
class KW {
    constructor(e, n) {
        var r;
        this.editorView = e,
            this.cursorPos = null,
            this.element = null,
            this.timeout = -1,
            this.width = (r = n.width) !== null && r !== void 0 ? r : 1,
            this.color = n.color === !1 ? void 0 : n.color || "black",
            this.class = n.class,
            this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(i => {
                let s = o => {
                    this[i](o)
                }
                    ;
                return e.dom.addEventListener(i, s),
                {
                    name: i,
                    handler: s
                }
            }
            )
    }
    destroy() {
        this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n))
    }
    update(e, n) {
        this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay())
    }
    setCursor(e) {
        e != this.cursorPos && (this.cursorPos = e,
            e == null ? (this.element.parentNode.removeChild(this.element),
                this.element = null) : this.updateOverlay())
    }
    updateOverlay() {
        let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r;
        if (n) {
            let a = e.nodeBefore
                , l = e.nodeAfter;
            if (a || l) {
                let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
                if (c) {
                    let d = c.getBoundingClientRect()
                        , h = a ? d.bottom : d.top;
                    a && l && (h = (h + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2),
                        r = {
                            left: d.left,
                            right: d.right,
                            top: h - this.width / 2,
                            bottom: h + this.width / 2
                        }
                }
            }
        }
        if (!r) {
            let a = this.editorView.coordsAtPos(this.cursorPos);
            r = {
                left: a.left - this.width / 2,
                right: a.left + this.width / 2,
                top: a.top,
                bottom: a.bottom
            }
        }
        let i = this.editorView.dom.offsetParent;
        this.element || (this.element = i.appendChild(document.createElement("div")),
            this.class && (this.element.className = this.class),
            this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;",
            this.color && (this.element.style.backgroundColor = this.color)),
            this.element.classList.toggle("prosemirror-dropcursor-block", n),
            this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
        let s, o;
        if (!i || i == document.body && getComputedStyle(i).position == "static")
            s = -pageXOffset,
                o = -pageYOffset;
        else {
            let a = i.getBoundingClientRect();
            s = a.left - i.scrollLeft,
                o = a.top - i.scrollTop
        }
        this.element.style.left = r.left - s + "px",
            this.element.style.top = r.top - o + "px",
            this.element.style.width = r.right - r.left + "px",
            this.element.style.height = r.bottom - r.top + "px"
    }
    scheduleRemoval(e) {
        clearTimeout(this.timeout),
            this.timeout = setTimeout(() => this.setCursor(null), e)
    }
    dragover(e) {
        if (!this.editorView.editable)
            return;
        let n = this.editorView.posAtCoords({
            left: e.clientX,
            top: e.clientY
        })
            , r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside)
            , i = r && r.type.spec.disableDropCursor
            , s = typeof i == "function" ? i(this.editorView, n, e) : i;
        if (n && !s) {
            let o = n.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
                let a = JE(this.editorView.state.doc, o, this.editorView.dragging.slice);
                a != null && (o = a)
            }
            this.setCursor(o),
                this.scheduleRemoval(5e3)
        }
    }
    dragend() {
        this.scheduleRemoval(20)
    }
    drop() {
        this.scheduleRemoval(20)
    }
    dragleave(e) {
        (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null)
    }
}
const qW = Vn.create({
    name: "dropCursor",
    addOptions() {
        return {
            color: "currentColor",
            width: 1,
            class: void 0
        }
    },
    addProseMirrorPlugins() {
        return [UW(this.options)]
    }
});
class nn extends Ve {
    constructor(e) {
        super(e, e)
    }
    map(e, n) {
        let r = e.resolve(n.map(this.head));
        return nn.valid(r) ? new nn(r) : Ve.near(r)
    }
    content() {
        return ve.empty
    }
    eq(e) {
        return e instanceof nn && e.head == this.head
    }
    toJSON() {
        return {
            type: "gapcursor",
            pos: this.head
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new nn(e.resolve(n.pos))
    }
    getBookmark() {
        return new jv(this.anchor)
    }
    static valid(e) {
        let n = e.parent;
        if (n.isTextblock || !GW(e) || !JW(e))
            return !1;
        let r = n.type.spec.allowGapCursor;
        if (r != null)
            return r;
        let i = n.contentMatchAt(e.index()).defaultType;
        return i && i.isTextblock
    }
    static findGapCursorFrom(e, n, r = !1) {
        e: for (; ;) {
            if (!r && nn.valid(e))
                return e;
            let i = e.pos
                , s = null;
            for (let o = e.depth; ; o--) {
                let a = e.node(o);
                if (n > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
                    s = a.child(n > 0 ? e.indexAfter(o) : e.index(o) - 1);
                    break
                } else if (o == 0)
                    return null;
                i += n;
                let l = e.doc.resolve(i);
                if (nn.valid(l))
                    return l
            }
            for (; ;) {
                let o = n > 0 ? s.firstChild : s.lastChild;
                if (!o) {
                    if (s.isAtom && !s.isText && !Le.isSelectable(s)) {
                        e = e.doc.resolve(i + s.nodeSize * n),
                            r = !1;
                        continue e
                    }
                    break
                }
                s = o,
                    i += n;
                let a = e.doc.resolve(i);
                if (nn.valid(a))
                    return a
            }
            return null
        }
    }
}
nn.prototype.visible = !1;
nn.findFrom = nn.findGapCursorFrom;
Ve.jsonID("gapcursor", nn);
class jv {
    constructor(e) {
        this.pos = e
    }
    map(e) {
        return new jv(e.map(this.pos))
    }
    resolve(e) {
        let n = e.resolve(this.pos);
        return nn.valid(n) ? new nn(n) : Ve.near(n)
    }
}
function GW(t) {
    for (let e = t.depth; e >= 0; e--) {
        let n = t.index(e)
            , r = t.node(e);
        if (n == 0) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let i = r.child(n - 1); ; i = i.lastChild) {
            if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
                return !0;
            if (i.inlineContent)
                return !1
        }
    }
    return !0
}
function JW(t) {
    for (let e = t.depth; e >= 0; e--) {
        let n = t.indexAfter(e)
            , r = t.node(e);
        if (n == r.childCount) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let i = r.child(n); ; i = i.firstChild) {
            if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
                return !0;
            if (i.inlineContent)
                return !1
        }
    }
    return !0
}
function ZW() {
    return new sn({
        props: {
            decorations: eU,
            createSelectionBetween(t, e, n) {
                return e.pos == n.pos && nn.valid(n) ? new nn(n) : null
            },
            handleClick: XW,
            handleKeyDown: YW,
            handleDOMEvents: {
                beforeinput: QW
            }
        }
    })
}
const YW = Ov({
    ArrowLeft: Uf("horiz", -1),
    ArrowRight: Uf("horiz", 1),
    ArrowUp: Uf("vert", -1),
    ArrowDown: Uf("vert", 1)
});
function Uf(t, e) {
    const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
    return function (r, i, s) {
        let o = r.selection
            , a = e > 0 ? o.$to : o.$from
            , l = o.empty;
        if (o instanceof De) {
            if (!s.endOfTextblock(n) || a.depth == 0)
                return !1;
            l = !1,
                a = r.doc.resolve(e > 0 ? a.after() : a.before())
        }
        let c = nn.findGapCursorFrom(a, e, l);
        return c ? (i && i(r.tr.setSelection(new nn(c))),
            !0) : !1
    }
}
function XW(t, e, n) {
    if (!t || !t.editable)
        return !1;
    let r = t.state.doc.resolve(e);
    if (!nn.valid(r))
        return !1;
    let i = t.posAtCoords({
        left: n.clientX,
        top: n.clientY
    });
    return i && i.inside > -1 && Le.isSelectable(t.state.doc.nodeAt(i.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new nn(r))),
        !0)
}
function QW(t, e) {
    if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof nn))
        return !1;
    let { $from: n } = t.state.selection
        , r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
    if (!r)
        return !1;
    let i = se.empty;
    for (let o = r.length - 1; o >= 0; o--)
        i = se.from(r[o].createAndFill(null, i));
    let s = t.state.tr.replace(n.pos, n.pos, new ve(i, 0, 0));
    return s.setSelection(De.near(s.doc.resolve(n.pos + 1))),
        t.dispatch(s),
        !1
}
function eU(t) {
    if (!(t.selection instanceof nn))
        return null;
    let e = document.createElement("div");
    return e.className = "ProseMirror-gapcursor",
        Zt.create(t.doc, [Xn.widget(t.selection.head, e, {
            key: "gapcursor"
        })])
}
const tU = Vn.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
        return [ZW()]
    },
    extendNodeSchema(t) {
        var e;
        const n = {
            name: t.name,
            options: t.options,
            storage: t.storage
        };
        return {
            allowGapCursor: (e = ht(Me(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
        }
    }
})
    , nU = mn.create({
        name: "hardBreak",
        addOptions() {
            return {
                keepMarks: !0,
                HTMLAttributes: {}
            }
        },
        inline: !0,
        group: "inline",
        selectable: !1,
        parseHTML() {
            return [{
                tag: "br"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["br", Tt(this.options.HTMLAttributes, t)]
        },
        renderText() {
            return `
`
        },
        addCommands() {
            return {
                setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([() => t.exitCode(), () => t.command(() => {
                    const { selection: i, storedMarks: s } = n;
                    if (i.$from.parent.type.spec.isolating)
                        return !1;
                    const { keepMarks: o } = this.options
                        , { splittableMarks: a } = r.extensionManager
                        , l = s || i.$to.parentOffset && i.$from.marks();
                    return e().insertContent({
                        type: this.name
                    }).command(({ tr: c, dispatch: d }) => {
                        if (d && l && o) {
                            const h = l.filter(p => a.includes(p.type.name));
                            c.ensureMarks(h)
                        }
                        return !0
                    }
                    ).run()
                }
                )])
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Enter": () => this.editor.commands.setHardBreak(),
                "Shift-Enter": () => this.editor.commands.setHardBreak()
            }
        }
    })
    , rU = mn.create({
        name: "heading",
        addOptions() {
            return {
                levels: [1, 2, 3, 4, 5, 6],
                HTMLAttributes: {}
            }
        },
        content: "inline*",
        group: "block",
        defining: !0,
        addAttributes() {
            return {
                level: {
                    default: 1,
                    rendered: !1
                }
            }
        },
        parseHTML() {
            return this.options.levels.map(t => ({
                tag: `h${t}`,
                attrs: {
                    level: t
                }
            }))
        },
        renderHTML({ node: t, HTMLAttributes: e }) {
            return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Tt(this.options.HTMLAttributes, e), 0]
        },
        addCommands() {
            return {
                setHeading: t => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
                toggleHeading: t => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
            }
        },
        addKeyboardShortcuts() {
            return this.options.levels.reduce((t, e) => ({
                ...t,
                [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({
                    level: e
                })
            }), {})
        },
        addInputRules() {
            return this.options.levels.map(t => Y1({
                find: new RegExp(`^(#{1,${t}})\\s$`),
                type: this.type,
                getAttributes: {
                    level: t
                }
            }))
        }
    });
var sp = 200
    , An = function () { };
An.prototype.append = function (e) {
    return e.length ? (e = An.from(e),
        !this.length && e || e.length < sp && this.leafAppend(e) || this.length < sp && e.leafPrepend(this) || this.appendInner(e)) : this
}
    ;
An.prototype.prepend = function (e) {
    return e.length ? An.from(e).append(this) : this
}
    ;
An.prototype.appendInner = function (e) {
    return new iU(this, e)
}
    ;
An.prototype.slice = function (e, n) {
    return e === void 0 && (e = 0),
        n === void 0 && (n = this.length),
        e >= n ? An.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
}
    ;
An.prototype.get = function (e) {
    if (!(e < 0 || e >= this.length))
        return this.getInner(e)
}
    ;
An.prototype.forEach = function (e, n, r) {
    n === void 0 && (n = 0),
        r === void 0 && (r = this.length),
        n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0)
}
    ;
An.prototype.map = function (e, n, r) {
    n === void 0 && (n = 0),
        r === void 0 && (r = this.length);
    var i = [];
    return this.forEach(function (s, o) {
        return i.push(e(s, o))
    }, n, r),
        i
}
    ;
An.from = function (e) {
    return e instanceof An ? e : e && e.length ? new eA(e) : An.empty
}
    ;
var eA = function (t) {
    function e(r) {
        t.call(this),
            this.values = r
    }
    t && (e.__proto__ = t),
        e.prototype = Object.create(t && t.prototype),
        e.prototype.constructor = e;
    var n = {
        length: {
            configurable: !0
        },
        depth: {
            configurable: !0
        }
    };
    return e.prototype.flatten = function () {
        return this.values
    }
        ,
        e.prototype.sliceInner = function (i, s) {
            return i == 0 && s == this.length ? this : new e(this.values.slice(i, s))
        }
        ,
        e.prototype.getInner = function (i) {
            return this.values[i]
        }
        ,
        e.prototype.forEachInner = function (i, s, o, a) {
            for (var l = s; l < o; l++)
                if (i(this.values[l], a + l) === !1)
                    return !1
        }
        ,
        e.prototype.forEachInvertedInner = function (i, s, o, a) {
            for (var l = s - 1; l >= o; l--)
                if (i(this.values[l], a + l) === !1)
                    return !1
        }
        ,
        e.prototype.leafAppend = function (i) {
            if (this.length + i.length <= sp)
                return new e(this.values.concat(i.flatten()))
        }
        ,
        e.prototype.leafPrepend = function (i) {
            if (this.length + i.length <= sp)
                return new e(i.flatten().concat(this.values))
        }
        ,
        n.length.get = function () {
            return this.values.length
        }
        ,
        n.depth.get = function () {
            return 0
        }
        ,
        Object.defineProperties(e.prototype, n),
        e
}(An);
An.empty = new eA([]);
var iU = function (t) {
    function e(n, r) {
        t.call(this),
            this.left = n,
            this.right = r,
            this.length = n.length + r.length,
            this.depth = Math.max(n.depth, r.depth) + 1
    }
    return t && (e.__proto__ = t),
        e.prototype = Object.create(t && t.prototype),
        e.prototype.constructor = e,
        e.prototype.flatten = function () {
            return this.left.flatten().concat(this.right.flatten())
        }
        ,
        e.prototype.getInner = function (r) {
            return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length)
        }
        ,
        e.prototype.forEachInner = function (r, i, s, o) {
            var a = this.left.length;
            if (i < a && this.left.forEachInner(r, i, Math.min(s, a), o) === !1 || s > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, s) - a, o + a) === !1)
                return !1
        }
        ,
        e.prototype.forEachInvertedInner = function (r, i, s, o) {
            var a = this.left.length;
            if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(s, a) - a, o + a) === !1 || s < a && this.left.forEachInvertedInner(r, Math.min(i, a), s, o) === !1)
                return !1
        }
        ,
        e.prototype.sliceInner = function (r, i) {
            if (r == 0 && i == this.length)
                return this;
            var s = this.left.length;
            return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s))
        }
        ,
        e.prototype.leafAppend = function (r) {
            var i = this.right.leafAppend(r);
            if (i)
                return new e(this.left, i)
        }
        ,
        e.prototype.leafPrepend = function (r) {
            var i = this.left.leafPrepend(r);
            if (i)
                return new e(i, this.right)
        }
        ,
        e.prototype.appendInner = function (r) {
            return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r)
        }
        ,
        e
}(An);
const sU = 500;
class bi {
    constructor(e, n) {
        this.items = e,
            this.eventCount = n
    }
    popEvent(e, n) {
        if (this.eventCount == 0)
            return null;
        let r = this.items.length;
        for (; ; r--)
            if (this.items.get(r - 1).selection) {
                --r;
                break
            }
        let i, s;
        n && (i = this.remapping(r, this.items.length),
            s = i.maps.length);
        let o = e.tr, a, l, c = [], d = [];
        return this.items.forEach((h, p) => {
            if (!h.step) {
                i || (i = this.remapping(r, p + 1),
                    s = i.maps.length),
                    s--,
                    d.push(h);
                return
            }
            if (i) {
                d.push(new Bi(h.map));
                let g = h.step.map(i.slice(s)), y;
                g && o.maybeStep(g).doc && (y = o.mapping.maps[o.mapping.maps.length - 1],
                    c.push(new Bi(y, void 0, void 0, c.length + d.length))),
                    s--,
                    y && i.appendMap(y, s)
            } else
                o.maybeStep(h.step);
            if (h.selection)
                return a = i ? h.selection.map(i.slice(s)) : h.selection,
                    l = new bi(this.items.slice(0, r).append(d.reverse().concat(c)), this.eventCount - 1),
                    !1
        }
            , this.items.length, 0),
        {
            remaining: l,
            transform: o,
            selection: a
        }
    }
    addTransform(e, n, r, i) {
        let s = []
            , o = this.eventCount
            , a = this.items
            , l = !i && a.length ? a.get(a.length - 1) : null;
        for (let d = 0; d < e.steps.length; d++) {
            let h = e.steps[d].invert(e.docs[d]), p = new Bi(e.mapping.maps[d], h, n), g;
            (g = l && l.merge(p)) && (p = g,
                d ? s.pop() : a = a.slice(0, a.length - 1)),
                s.push(p),
                n && (o++,
                    n = void 0),
                i || (l = p)
        }
        let c = o - r.depth;
        return c > aU && (a = oU(a, c),
            o -= c),
            new bi(a.append(s), o)
    }
    remapping(e, n) {
        let r = new $l;
        return this.items.forEach((i, s) => {
            let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
            r.appendMap(i.map, o)
        }
            , e, n),
            r
    }
    addMaps(e) {
        return this.eventCount == 0 ? this : new bi(this.items.append(e.map(n => new Bi(n))), this.eventCount)
    }
    rebased(e, n) {
        if (!this.eventCount)
            return this;
        let r = []
            , i = Math.max(0, this.items.length - n)
            , s = e.mapping
            , o = e.steps.length
            , a = this.eventCount;
        this.items.forEach(p => {
            p.selection && a--
        }
            , i);
        let l = n;
        this.items.forEach(p => {
            let g = s.getMirror(--l);
            if (g == null)
                return;
            o = Math.min(o, g);
            let y = s.maps[g];
            if (p.step) {
                let x = e.steps[g].invert(e.docs[g])
                    , S = p.selection && p.selection.map(s.slice(l + 1, g));
                S && a++,
                    r.push(new Bi(y, x, S))
            } else
                r.push(new Bi(y))
        }
            , i);
        let c = [];
        for (let p = n; p < o; p++)
            c.push(new Bi(s.maps[p]));
        let d = this.items.slice(0, i).append(c).append(r)
            , h = new bi(d, a);
        return h.emptyItemCount() > sU && (h = h.compress(this.items.length - r.length)),
            h
    }
    emptyItemCount() {
        let e = 0;
        return this.items.forEach(n => {
            n.step || e++
        }
        ),
            e
    }
    compress(e = this.items.length) {
        let n = this.remapping(0, e)
            , r = n.maps.length
            , i = []
            , s = 0;
        return this.items.forEach((o, a) => {
            if (a >= e)
                i.push(o),
                    o.selection && s++;
            else if (o.step) {
                let l = o.step.map(n.slice(r))
                    , c = l && l.getMap();
                if (r--,
                    c && n.appendMap(c, r),
                    l) {
                    let d = o.selection && o.selection.map(n.slice(r));
                    d && s++;
                    let h = new Bi(c.invert(), l, d), p, g = i.length - 1;
                    (p = i.length && i[g].merge(h)) ? i[g] = p : i.push(h)
                }
            } else
                o.map && r--
        }
            , this.items.length, 0),
            new bi(An.from(i.reverse()), s)
    }
}
bi.empty = new bi(An.empty, 0);
function oU(t, e) {
    let n;
    return t.forEach((r, i) => {
        if (r.selection && e-- == 0)
            return n = i,
                !1
    }
    ),
        t.slice(n)
}
class Bi {
    constructor(e, n, r, i) {
        this.map = e,
            this.step = n,
            this.selection = r,
            this.mirrorOffset = i
    }
    merge(e) {
        if (this.step && e.step && !e.selection) {
            let n = e.step.merge(this.step);
            if (n)
                return new Bi(n.getMap().invert(), n, this.selection)
        }
    }
}
class uo {
    constructor(e, n, r, i, s) {
        this.done = e,
            this.undone = n,
            this.prevRanges = r,
            this.prevTime = i,
            this.prevComposition = s
    }
}
const aU = 20;
function lU(t, e, n, r) {
    let i = n.getMeta(Ca), s;
    if (i)
        return i.historyState;
    n.getMeta(dU) && (t = new uo(t.done, t.undone, null, 0, -1));
    let o = n.getMeta("appendedTransaction");
    if (n.steps.length == 0)
        return t;
    if (o && o.getMeta(Ca))
        return o.getMeta(Ca).redo ? new uo(t.done.addTransform(n, void 0, r, ph(e)), t.undone, T3(n.mapping.maps), t.prevTime, t.prevComposition) : new uo(t.done, t.undone.addTransform(n, void 0, r, ph(e)), null, t.prevTime, t.prevComposition);
    if (n.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
        let a = n.getMeta("composition")
            , l = t.prevTime == 0 || !o && t.prevComposition != a && (t.prevTime < (n.time || 0) - r.newGroupDelay || !uU(n, t.prevRanges))
            , c = o ? j0(t.prevRanges, n.mapping) : T3(n.mapping.maps);
        return new uo(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, ph(e)), bi.empty, c, n.time, a ?? t.prevComposition)
    } else
        return (s = n.getMeta("rebased")) ? new uo(t.done.rebased(n, s), t.undone.rebased(n, s), j0(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new uo(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), j0(t.prevRanges, n.mapping), t.prevTime, t.prevComposition)
}
function uU(t, e) {
    if (!e)
        return !1;
    if (!t.docChanged)
        return !0;
    let n = !1;
    return t.mapping.maps[0].forEach((r, i) => {
        for (let s = 0; s < e.length; s += 2)
            r <= e[s + 1] && i >= e[s] && (n = !0)
    }
    ),
        n
}
function T3(t) {
    let e = [];
    for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
        t[n].forEach((r, i, s, o) => e.push(s, o));
    return e
}
function j0(t, e) {
    if (!t)
        return null;
    let n = [];
    for (let r = 0; r < t.length; r += 2) {
        let i = e.map(t[r], 1)
            , s = e.map(t[r + 1], -1);
        i <= s && n.push(i, s)
    }
    return n
}
function cU(t, e, n) {
    let r = ph(e)
        , i = Ca.get(e).spec.config
        , s = (n ? t.undone : t.done).popEvent(e, r);
    if (!s)
        return null;
    let o = s.selection.resolve(s.transform.doc)
        , a = (n ? t.done : t.undone).addTransform(s.transform, e.selection.getBookmark(), i, r)
        , l = new uo(n ? a : s.remaining, n ? s.remaining : a, null, 0, -1);
    return s.transform.setSelection(o).setMeta(Ca, {
        redo: n,
        historyState: l
    })
}
let B0 = !1
    , A3 = null;
function ph(t) {
    let e = t.plugins;
    if (A3 != e) {
        B0 = !1,
            A3 = e;
        for (let n = 0; n < e.length; n++)
            if (e[n].spec.historyPreserveItems) {
                B0 = !0;
                break
            }
    }
    return B0
}
const Ca = new _n("history")
    , dU = new _n("closeHistory");
function fU(t = {}) {
    return t = {
        depth: t.depth || 100,
        newGroupDelay: t.newGroupDelay || 500
    },
        new sn({
            key: Ca,
            state: {
                init() {
                    return new uo(bi.empty, bi.empty, null, 0, -1)
                },
                apply(e, n, r) {
                    return lU(n, r, e, t)
                }
            },
            config: t,
            props: {
                handleDOMEvents: {
                    beforeinput(e, n) {
                        let r = n.inputType
                            , i = r == "historyUndo" ? nA : r == "historyRedo" ? rA : null;
                        return i ? (n.preventDefault(),
                            i(e.state, e.dispatch)) : !1
                    }
                }
            }
        })
}
function tA(t, e) {
    return (n, r) => {
        let i = Ca.getState(n);
        if (!i || (t ? i.undone : i.done).eventCount == 0)
            return !1;
        if (r) {
            let s = cU(i, n, t);
            s && r(e ? s.scrollIntoView() : s)
        }
        return !0
    }
}
const nA = tA(!1, !0)
    , rA = tA(!0, !0)
    , hU = Vn.create({
        name: "history",
        addOptions() {
            return {
                depth: 100,
                newGroupDelay: 500
            }
        },
        addCommands() {
            return {
                undo: () => ({ state: t, dispatch: e }) => nA(t, e),
                redo: () => ({ state: t, dispatch: e }) => rA(t, e)
            }
        },
        addProseMirrorPlugins() {
            return [fU(this.options)]
        },
        addKeyboardShortcuts() {
            return {
                "Mod-z": () => this.editor.commands.undo(),
                "Shift-Mod-z": () => this.editor.commands.redo(),
                "Mod-y": () => this.editor.commands.redo(),
                "Mod-": () => this.editor.commands.undo(),
                "Shift-Mod-": () => this.editor.commands.redo()
            }
        }
    })
    , pU = mn.create({
        name: "horizontalRule",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        group: "block",
        parseHTML() {
            return [{
                tag: "hr"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["hr", Tt(this.options.HTMLAttributes, t)]
        },
        addCommands() {
            return {
                setHorizontalRule: () => ({ chain: t, state: e }) => {
                    const { selection: n } = e
                        , { $from: r, $to: i } = n
                        , s = t();
                    return r.parentOffset === 0 ? s.insertContentAt({
                        from: Math.max(r.pos - 1, 0),
                        to: i.pos
                    }, {
                        type: this.name
                    }) : XV(n) ? s.insertContentAt(i.pos, {
                        type: this.name
                    }) : s.insertContent({
                        type: this.name
                    }),
                        s.command(({ tr: o, dispatch: a }) => {
                            var l;
                            if (a) {
                                const { $to: c } = o.selection
                                    , d = c.end();
                                if (c.nodeAfter)
                                    c.nodeAfter.isTextblock ? o.setSelection(De.create(o.doc, c.pos + 1)) : c.nodeAfter.isBlock ? o.setSelection(Le.create(o.doc, c.pos)) : o.setSelection(De.create(o.doc, c.pos));
                                else {
                                    const h = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
                                    h && (o.insert(d, h),
                                        o.setSelection(De.create(o.doc, d + 1)))
                                }
                                o.scrollIntoView()
                            }
                            return !0
                        }
                        ).run()
                }
            }
        },
        addInputRules() {
            return [QT({
                find: /^(?:---|-|___\s|\*\*\*\s)$/,
                type: this.type
            })]
        }
    })
    , mU = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/
    , gU = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g
    , yU = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/
    , vU = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g
    , bU = Fr.create({
        name: "italic",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        parseHTML() {
            return [{
                tag: "em"
            }, {
                tag: "i",
                getAttrs: t => t.style.fontStyle !== "normal" && null
            }, {
                style: "font-style=italic"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["em", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                setItalic: () => ({ commands: t }) => t.setMark(this.name),
                toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
                unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-i": () => this.editor.commands.toggleItalic(),
                "Mod-I": () => this.editor.commands.toggleItalic()
            }
        },
        addInputRules() {
            return [Ba({
                find: mU,
                type: this.type
            }), Ba({
                find: yU,
                type: this.type
            })]
        },
        addPasteRules() {
            return [Io({
                find: gU,
                type: this.type
            }), Io({
                find: vU,
                type: this.type
            })]
        }
    })
    , wU = mn.create({
        name: "listItem",
        addOptions() {
            return {
                HTMLAttributes: {},
                bulletListTypeName: "bulletList",
                orderedListTypeName: "orderedList"
            }
        },
        content: "paragraph block*",
        defining: !0,
        parseHTML() {
            return [{
                tag: "li"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["li", Tt(this.options.HTMLAttributes, t), 0]
        },
        addKeyboardShortcuts() {
            return {
                Enter: () => this.editor.commands.splitListItem(this.name),
                Tab: () => this.editor.commands.sinkListItem(this.name),
                "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
            }
        }
    })
    , xU = mn.create({
        name: "listItem",
        addOptions() {
            return {
                HTMLAttributes: {},
                bulletListTypeName: "bulletList",
                orderedListTypeName: "orderedList"
            }
        },
        content: "paragraph block*",
        defining: !0,
        parseHTML() {
            return [{
                tag: "li"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["li", Tt(this.options.HTMLAttributes, t), 0]
        },
        addKeyboardShortcuts() {
            return {
                Enter: () => this.editor.commands.splitListItem(this.name),
                Tab: () => this.editor.commands.sinkListItem(this.name),
                "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
            }
        }
    })
    , O3 = Fr.create({
        name: "textStyle",
        priority: 101,
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        parseHTML() {
            return [{
                tag: "span",
                getAttrs: t => t.hasAttribute("style") ? {} : !1
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["span", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
                    const n = Cd(t, this.type);
                    return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name)
                }
            }
        }
    })
    , M3 = /^(\d+)\.\s$/
    , _U = mn.create({
        name: "orderedList",
        addOptions() {
            return {
                itemTypeName: "listItem",
                HTMLAttributes: {},
                keepMarks: !1,
                keepAttributes: !1
            }
        },
        group: "block list",
        content() {
            return `${this.options.itemTypeName}+`
        },
        addAttributes() {
            return {
                start: {
                    default: 1,
                    parseHTML: t => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
                },
                type: {
                    default: void 0,
                    parseHTML: t => t.getAttribute("type")
                }
            }
        },
        parseHTML() {
            return [{
                tag: "ol"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            const { start: e, ...n } = t;
            return e === 1 ? ["ol", Tt(this.options.HTMLAttributes, n), 0] : ["ol", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(xU.name, this.editor.getAttributes(O3.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
            }
        },
        addInputRules() {
            let t = Hc({
                find: M3,
                type: this.type,
                getAttributes: e => ({
                    start: +e[1]
                }),
                joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
            });
            return (this.options.keepMarks || this.options.keepAttributes) && (t = Hc({
                find: M3,
                type: this.type,
                keepMarks: this.options.keepMarks,
                keepAttributes: this.options.keepAttributes,
                getAttributes: e => ({
                    start: +e[1],
                    ...this.editor.getAttributes(O3.name)
                }),
                joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
                editor: this.editor
            })),
                [t]
        }
    })
    , SU = mn.create({
        name: "paragraph",
        priority: 1e3,
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        group: "block",
        content: "inline*",
        parseHTML() {
            return [{
                tag: "p"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["p", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                setParagraph: () => ({ commands: t }) => t.setNode(this.name)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Alt-0": () => this.editor.commands.setParagraph()
            }
        }
    })
    , kU = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/
    , CU = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g
    , EU = Fr.create({
        name: "strike",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        parseHTML() {
            return [{
                tag: "s"
            }, {
                tag: "del"
            }, {
                tag: "strike"
            }, {
                style: "text-decoration",
                consuming: !1,
                getAttrs: t => t.includes("line-through") ? {} : !1
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["s", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                setStrike: () => ({ commands: t }) => t.setMark(this.name),
                toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
                unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Shift-s": () => this.editor.commands.toggleStrike()
            }
        },
        addInputRules() {
            return [Ba({
                find: kU,
                type: this.type
            })]
        },
        addPasteRules() {
            return [Io({
                find: CU,
                type: this.type
            })]
        }
    })
    , TU = mn.create({
        name: "text",
        group: "inline"
    })
    , aee = Vn.create({
        name: "starterKit",
        addExtensions() {
            var t, e, n, r, i, s, o, a, l, c, d, h, p, g, y, x, S, k;
            const A = [];
            return this.options.bold !== !1 && A.push(LW.configure((t = this.options) === null || t === void 0 ? void 0 : t.bold)),
                this.options.blockquote !== !1 && A.push(MW.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)),
                this.options.bulletList !== !1 && A.push(jW.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)),
                this.options.code !== !1 && A.push(zW.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)),
                this.options.codeBlock !== !1 && A.push(VW.configure((i = this.options) === null || i === void 0 ? void 0 : i.codeBlock)),
                this.options.document !== !1 && A.push(WW.configure((s = this.options) === null || s === void 0 ? void 0 : s.document)),
                this.options.dropcursor !== !1 && A.push(qW.configure((o = this.options) === null || o === void 0 ? void 0 : o.dropcursor)),
                this.options.gapcursor !== !1 && A.push(tU.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)),
                this.options.hardBreak !== !1 && A.push(nU.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)),
                this.options.heading !== !1 && A.push(rU.configure((c = this.options) === null || c === void 0 ? void 0 : c.heading)),
                this.options.history !== !1 && A.push(hU.configure((d = this.options) === null || d === void 0 ? void 0 : d.history)),
                this.options.horizontalRule !== !1 && A.push(pU.configure((h = this.options) === null || h === void 0 ? void 0 : h.horizontalRule)),
                this.options.italic !== !1 && A.push(bU.configure((p = this.options) === null || p === void 0 ? void 0 : p.italic)),
                this.options.listItem !== !1 && A.push(wU.configure((g = this.options) === null || g === void 0 ? void 0 : g.listItem)),
                this.options.orderedList !== !1 && A.push(_U.configure((y = this.options) === null || y === void 0 ? void 0 : y.orderedList)),
                this.options.paragraph !== !1 && A.push(SU.configure((x = this.options) === null || x === void 0 ? void 0 : x.paragraph)),
                this.options.strike !== !1 && A.push(EU.configure((S = this.options) === null || S === void 0 ? void 0 : S.strike)),
                this.options.text !== !1 && A.push(TU.configure((k = this.options) === null || k === void 0 ? void 0 : k.text)),
                A
        }
    })
    , lee = Vn.create({
        name: "placeholder",
        addOptions() {
            return {
                emptyEditorClass: "is-editor-empty",
                emptyNodeClass: "is-empty",
                placeholder: "Write something ",
                showOnlyWhenEditable: !0,
                showOnlyCurrent: !0,
                includeChildren: !1
            }
        },
        addProseMirrorPlugins() {
            return [new sn({
                key: new _n("placeholder"),
                props: {
                    decorations: ({ doc: t, selection: e }) => {
                        const n = this.editor.isEditable || !this.options.showOnlyWhenEditable
                            , { anchor: r } = e
                            , i = [];
                        if (!n)
                            return null;
                        const s = this.editor.isEmpty;
                        return t.descendants((o, a) => {
                            const l = r >= a && r <= a + o.nodeSize
                                , c = !o.isLeaf && Om(o);
                            if ((l || !this.options.showOnlyCurrent) && c) {
                                const d = [this.options.emptyNodeClass];
                                s && d.push(this.options.emptyEditorClass);
                                const h = Xn.node(a, a + o.nodeSize, {
                                    class: d.join(" "),
                                    "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                                        editor: this.editor,
                                        node: o,
                                        pos: a,
                                        hasAnchor: l
                                    }) : this.options.placeholder
                                });
                                i.push(h)
                            }
                            return this.options.includeChildren
                        }
                        ),
                            Zt.create(t, i)
                    }
                }
            })]
        }
    })
    , uee = Vn.create({
        name: "textAlign",
        addOptions() {
            return {
                types: [],
                alignments: ["left", "center", "right", "justify"],
                defaultAlignment: "left"
            }
        },
        addGlobalAttributes() {
            return [{
                types: this.options.types,
                attributes: {
                    textAlign: {
                        default: this.options.defaultAlignment,
                        parseHTML: t => {
                            const e = t.style.textAlign || this.options.defaultAlignment;
                            return this.options.alignments.includes(e) ? e : this.options.defaultAlignment
                        }
                        ,
                        renderHTML: t => t.textAlign === this.options.defaultAlignment ? {} : {
                            style: `text-align: ${t.textAlign}`
                        }
                    }
                }
            }]
        },
        addCommands() {
            return {
                setTextAlign: t => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map(n => e.updateAttributes(n, {
                    textAlign: t
                })).every(n => n) : !1,
                unsetTextAlign: () => ({ commands: t }) => this.options.types.map(e => t.resetAttributes(e, "textAlign")).every(e => e)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
                "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
                "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
                "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
            }
        }
    });
var Q1, ey;
if (typeof WeakMap < "u") {
    let t = new WeakMap;
    Q1 = e => t.get(e),
        ey = (e, n) => (t.set(e, n),
            n)
} else {
    const t = [];
    let n = 0;
    Q1 = r => {
        for (let i = 0; i < t.length; i += 2)
            if (t[i] == r)
                return t[i + 1]
    }
        ,
        ey = (r, i) => (n == 10 && (n = 0),
            t[n++] = r,
            t[n++] = i)
}
var rn = class {
    constructor(t, e, n, r) {
        this.width = t,
            this.height = e,
            this.map = n,
            this.problems = r
    }
    findCell(t) {
        for (let e = 0; e < this.map.length; e++) {
            const n = this.map[e];
            if (n != t)
                continue;
            const r = e % this.width
                , i = e / this.width | 0;
            let s = r + 1
                , o = i + 1;
            for (let a = 1; s < this.width && this.map[e + a] == n; a++)
                s++;
            for (let a = 1; o < this.height && this.map[e + this.width * a] == n; a++)
                o++;
            return {
                left: r,
                top: i,
                right: s,
                bottom: o
            }
        }
        throw new RangeError(`No cell with offset ${t} found`)
    }
    colCount(t) {
        for (let e = 0; e < this.map.length; e++)
            if (this.map[e] == t)
                return e % this.width;
        throw new RangeError(`No cell with offset ${t} found`)
    }
    nextCell(t, e, n) {
        const { left: r, right: i, top: s, bottom: o } = this.findCell(t);
        return e == "horiz" ? (n < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (n < 0 ? r - 1 : i)] : (n < 0 ? s == 0 : o == this.height) ? null : this.map[r + this.width * (n < 0 ? s - 1 : o)]
    }
    rectBetween(t, e) {
        const { left: n, right: r, top: i, bottom: s } = this.findCell(t)
            , { left: o, right: a, top: l, bottom: c } = this.findCell(e);
        return {
            left: Math.min(n, o),
            top: Math.min(i, l),
            right: Math.max(r, a),
            bottom: Math.max(s, c)
        }
    }
    cellsInRect(t) {
        const e = []
            , n = {};
        for (let r = t.top; r < t.bottom; r++)
            for (let i = t.left; i < t.right; i++) {
                const s = r * this.width + i
                    , o = this.map[s];
                n[o] || (n[o] = !0,
                    !(i == t.left && i && this.map[s - 1] == o || r == t.top && r && this.map[s - this.width] == o) && e.push(o))
            }
        return e
    }
    positionAt(t, e, n) {
        for (let r = 0, i = 0; ; r++) {
            const s = i + n.child(r).nodeSize;
            if (r == t) {
                let o = e + t * this.width;
                const a = (t + 1) * this.width;
                for (; o < a && this.map[o] < i;)
                    o++;
                return o == a ? s - 1 : this.map[o]
            }
            i = s
        }
    }
    static get(t) {
        return Q1(t) || ey(t, AU(t))
    }
}
    ;
function AU(t) {
    if (t.type.spec.tableRole != "table")
        throw new RangeError("Not a table node: " + t.type.name);
    const e = OU(t)
        , n = t.childCount
        , r = [];
    let i = 0
        , s = null;
    const o = [];
    for (let c = 0, d = e * n; c < d; c++)
        r[c] = 0;
    for (let c = 0, d = 0; c < n; c++) {
        const h = t.child(c);
        d++;
        for (let y = 0; ; y++) {
            for (; i < r.length && r[i] != 0;)
                i++;
            if (y == h.childCount)
                break;
            const x = h.child(y)
                , { colspan: S, rowspan: k, colwidth: A } = x.attrs;
            for (let C = 0; C < k; C++) {
                if (C + c >= n) {
                    (s || (s = [])).push({
                        type: "overlong_rowspan",
                        pos: d,
                        n: k - C
                    });
                    break
                }
                const m = i + C * e;
                for (let b = 0; b < S; b++) {
                    r[m + b] == 0 ? r[m + b] = d : (s || (s = [])).push({
                        type: "collision",
                        row: c,
                        pos: d,
                        n: S - b
                    });
                    const w = A && A[b];
                    if (w) {
                        const T = (m + b) % e * 2
                            , O = o[T];
                        O == null || O != w && o[T + 1] == 1 ? (o[T] = w,
                            o[T + 1] = 1) : O == w && o[T + 1]++
                    }
                }
            }
            i += S,
                d += x.nodeSize
        }
        const p = (c + 1) * e;
        let g = 0;
        for (; i < p;)
            r[i++] == 0 && g++;
        g && (s || (s = [])).push({
            type: "missing",
            row: c,
            n: g
        }),
            d++
    }
    const a = new rn(e, n, r, s);
    let l = !1;
    for (let c = 0; !l && c < o.length; c += 2)
        o[c] != null && o[c + 1] < n && (l = !0);
    return l && MU(a, o, t),
        a
}
function OU(t) {
    let e = -1
        , n = !1;
    for (let r = 0; r < t.childCount; r++) {
        const i = t.child(r);
        let s = 0;
        if (n)
            for (let o = 0; o < r; o++) {
                const a = t.child(o);
                for (let l = 0; l < a.childCount; l++) {
                    const c = a.child(l);
                    o + c.attrs.rowspan > r && (s += c.attrs.colspan)
                }
            }
        for (let o = 0; o < i.childCount; o++) {
            const a = i.child(o);
            s += a.attrs.colspan,
                a.attrs.rowspan > 1 && (n = !0)
        }
        e == -1 ? e = s : e != s && (e = Math.max(e, s))
    }
    return e
}
function MU(t, e, n) {
    t.problems || (t.problems = []);
    const r = {};
    for (let i = 0; i < t.map.length; i++) {
        const s = t.map[i];
        if (r[s])
            continue;
        r[s] = !0;
        const o = n.nodeAt(s);
        if (!o)
            throw new RangeError(`No cell with offset ${s} found`);
        let a = null;
        const l = o.attrs;
        for (let c = 0; c < l.colspan; c++) {
            const d = (i + c) % t.width
                , h = e[d * 2];
            h != null && (!l.colwidth || l.colwidth[c] != h) && ((a || (a = RU(l)))[c] = h)
        }
        a && t.problems.unshift({
            type: "colwidth mismatch",
            pos: s,
            colwidth: a
        })
    }
}
function RU(t) {
    if (t.colwidth)
        return t.colwidth.slice();
    const e = [];
    for (let n = 0; n < t.colspan; n++)
        e.push(0);
    return e
}
function er(t) {
    let e = t.cached.tableNodeTypes;
    if (!e) {
        e = t.cached.tableNodeTypes = {};
        for (const n in t.nodes) {
            const r = t.nodes[n]
                , i = r.spec.tableRole;
            i && (e[i] = r)
        }
    }
    return e
}
var po = new _n("selectingCells");
function mu(t) {
    for (let e = t.depth - 1; e > 0; e--)
        if (t.node(e).type.spec.tableRole == "row")
            return t.node(0).resolve(t.before(e + 1));
    return null
}
function PU(t) {
    for (let e = t.depth; e > 0; e--) {
        const n = t.node(e).type.spec.tableRole;
        if (n === "cell" || n === "header_cell")
            return t.node(e)
    }
    return null
}
function Ni(t) {
    const e = t.selection.$head;
    for (let n = e.depth; n > 0; n--)
        if (e.node(n).type.spec.tableRole == "row")
            return !0;
    return !1
}
function Mm(t) {
    const e = t.selection;
    if ("$anchorCell" in e && e.$anchorCell)
        return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
    if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
        return e.$anchor;
    const n = mu(e.$head) || NU(e.$head);
    if (n)
        return n;
    throw new RangeError(`No cell found around position ${e.head}`)
}
function NU(t) {
    for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild,
        n++) {
        const r = e.type.spec.tableRole;
        if (r == "cell" || r == "header_cell")
            return t.doc.resolve(n)
    }
    for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild,
        n--) {
        const r = e.type.spec.tableRole;
        if (r == "cell" || r == "header_cell")
            return t.doc.resolve(n - e.nodeSize)
    }
}
function ty(t) {
    return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter
}
function IU(t) {
    return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize)
}
function Bv(t, e) {
    return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1)
}
function iA(t, e, n) {
    const r = t.node(-1)
        , i = rn.get(r)
        , s = t.start(-1)
        , o = i.nextCell(t.pos - s, e, n);
    return o == null ? null : t.node(0).resolve(s + o)
}
function $a(t, e, n = 1) {
    const r = {
        ...t,
        colspan: t.colspan - n
    };
    return r.colwidth && (r.colwidth = r.colwidth.slice(),
        r.colwidth.splice(e, n),
        r.colwidth.some(i => i > 0) || (r.colwidth = null)),
        r
}
function sA(t, e, n = 1) {
    const r = {
        ...t,
        colspan: t.colspan + n
    };
    if (r.colwidth) {
        r.colwidth = r.colwidth.slice();
        for (let i = 0; i < n; i++)
            r.colwidth.splice(e, 0, 0)
    }
    return r
}
function LU(t, e, n) {
    const r = er(e.type.schema).header_cell;
    for (let i = 0; i < t.height; i++)
        if (e.nodeAt(t.map[n + i * t.width]).type != r)
            return !1;
    return !0
}
var Ut = class ks extends Ve {
    constructor(e, n = e) {
        const r = e.node(-1)
            , i = rn.get(r)
            , s = e.start(-1)
            , o = i.rectBetween(e.pos - s, n.pos - s)
            , a = e.node(0)
            , l = i.cellsInRect(o).filter(d => d != n.pos - s);
        l.unshift(n.pos - s);
        const c = l.map(d => {
            const h = r.nodeAt(d);
            if (!h)
                throw RangeError(`No cell with offset ${d} found`);
            const p = s + d + 1;
            return new eT(a.resolve(p), a.resolve(p + h.content.size))
        }
        );
        super(c[0].$from, c[0].$to, c),
            this.$anchorCell = e,
            this.$headCell = n
    }
    map(e, n) {
        const r = e.resolve(n.map(this.$anchorCell.pos))
            , i = e.resolve(n.map(this.$headCell.pos));
        if (ty(r) && ty(i) && Bv(r, i)) {
            const s = this.$anchorCell.node(-1) != r.node(-1);
            return s && this.isRowSelection() ? ks.rowSelection(r, i) : s && this.isColSelection() ? ks.colSelection(r, i) : new ks(r, i)
        }
        return De.between(r, i)
    }
    content() {
        const e = this.$anchorCell.node(-1)
            , n = rn.get(e)
            , r = this.$anchorCell.start(-1)
            , i = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r)
            , s = {}
            , o = [];
        for (let l = i.top; l < i.bottom; l++) {
            const c = [];
            for (let d = l * n.width + i.left, h = i.left; h < i.right; h++,
                d++) {
                const p = n.map[d];
                if (s[p])
                    continue;
                s[p] = !0;
                const g = n.findCell(p);
                let y = e.nodeAt(p);
                if (!y)
                    throw RangeError(`No cell with offset ${p} found`);
                const x = i.left - g.left
                    , S = g.right - i.right;
                if (x > 0 || S > 0) {
                    let k = y.attrs;
                    if (x > 0 && (k = $a(k, 0, x)),
                        S > 0 && (k = $a(k, k.colspan - S, S)),
                        g.left < i.left) {
                        if (y = y.type.createAndFill(k),
                            !y)
                            throw RangeError(`Could not create cell with attrs ${JSON.stringify(k)}`)
                    } else
                        y = y.type.create(k, y.content)
                }
                if (g.top < i.top || g.bottom > i.bottom) {
                    const k = {
                        ...y.attrs,
                        rowspan: Math.min(g.bottom, i.bottom) - Math.max(g.top, i.top)
                    };
                    g.top < i.top ? y = y.type.createAndFill(k) : y = y.type.create(k, y.content)
                }
                c.push(y)
            }
            o.push(e.child(l).copy(se.from(c)))
        }
        const a = this.isColSelection() && this.isRowSelection() ? e : o;
        return new ve(se.from(a), 1, 1)
    }
    replace(e, n = ve.empty) {
        const r = e.steps.length
            , i = this.ranges;
        for (let o = 0; o < i.length; o++) {
            const { $from: a, $to: l } = i[o]
                , c = e.mapping.slice(r);
            e.replace(c.map(a.pos), c.map(l.pos), o ? ve.empty : n)
        }
        const s = Ve.findFrom(e.doc.resolve(e.mapping.slice(r).map(this.to)), -1);
        s && e.setSelection(s)
    }
    replaceWith(e, n) {
        this.replace(e, new ve(se.from(n), 0, 0))
    }
    forEachCell(e) {
        const n = this.$anchorCell.node(-1)
            , r = rn.get(n)
            , i = this.$anchorCell.start(-1)
            , s = r.cellsInRect(r.rectBetween(this.$anchorCell.pos - i, this.$headCell.pos - i));
        for (let o = 0; o < s.length; o++)
            e(n.nodeAt(s[o]), i + s[o])
    }
    isColSelection() {
        const e = this.$anchorCell.index(-1)
            , n = this.$headCell.index(-1);
        if (Math.min(e, n) > 0)
            return !1;
        const r = e + this.$anchorCell.nodeAfter.attrs.rowspan
            , i = n + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(r, i) == this.$headCell.node(-1).childCount
    }
    static colSelection(e, n = e) {
        const r = e.node(-1)
            , i = rn.get(r)
            , s = e.start(-1)
            , o = i.findCell(e.pos - s)
            , a = i.findCell(n.pos - s)
            , l = e.node(0);
        return o.top <= a.top ? (o.top > 0 && (e = l.resolve(s + i.map[o.left])),
            a.bottom < i.height && (n = l.resolve(s + i.map[i.width * (i.height - 1) + a.right - 1]))) : (a.top > 0 && (n = l.resolve(s + i.map[a.left])),
                o.bottom < i.height && (e = l.resolve(s + i.map[i.width * (i.height - 1) + o.right - 1]))),
            new ks(e, n)
    }
    isRowSelection() {
        const e = this.$anchorCell.node(-1)
            , n = rn.get(e)
            , r = this.$anchorCell.start(-1)
            , i = n.colCount(this.$anchorCell.pos - r)
            , s = n.colCount(this.$headCell.pos - r);
        if (Math.min(i, s) > 0)
            return !1;
        const o = i + this.$anchorCell.nodeAfter.attrs.colspan
            , a = s + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(o, a) == n.width
    }
    eq(e) {
        return e instanceof ks && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos
    }
    static rowSelection(e, n = e) {
        const r = e.node(-1)
            , i = rn.get(r)
            , s = e.start(-1)
            , o = i.findCell(e.pos - s)
            , a = i.findCell(n.pos - s)
            , l = e.node(0);
        return o.left <= a.left ? (o.left > 0 && (e = l.resolve(s + i.map[o.top * i.width])),
            a.right < i.width && (n = l.resolve(s + i.map[i.width * (a.top + 1) - 1]))) : (a.left > 0 && (n = l.resolve(s + i.map[a.top * i.width])),
                o.right < i.width && (e = l.resolve(s + i.map[i.width * (o.top + 1) - 1]))),
            new ks(e, n)
    }
    toJSON() {
        return {
            type: "cell",
            anchor: this.$anchorCell.pos,
            head: this.$headCell.pos
        }
    }
    static fromJSON(e, n) {
        return new ks(e.resolve(n.anchor), e.resolve(n.head))
    }
    static create(e, n, r = n) {
        return new ks(e.resolve(n), e.resolve(r))
    }
    getBookmark() {
        return new DU(this.$anchorCell.pos, this.$headCell.pos)
    }
}
    ;
Ut.prototype.visible = !1;
Ve.jsonID("cell", Ut);
var DU = class oA {
    constructor(e, n) {
        this.anchor = e,
            this.head = n
    }
    map(e) {
        return new oA(e.map(this.anchor), e.map(this.head))
    }
    resolve(e) {
        const n = e.resolve(this.anchor)
            , r = e.resolve(this.head);
        return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && Bv(n, r) ? new Ut(n, r) : Ve.near(r, 1)
    }
}
    ;
function jU(t) {
    if (!(t.selection instanceof Ut))
        return null;
    const e = [];
    return t.selection.forEachCell((n, r) => {
        e.push(Xn.node(r, r + n.nodeSize, {
            class: "selectedCell"
        }))
    }
    ),
        Zt.create(t.doc, e)
}
function BU({ $from: t, $to: e }) {
    if (t.pos == e.pos || t.pos < t.pos - 6)
        return !1;
    let n = t.pos
        , r = e.pos
        , i = t.depth;
    for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--,
        n++)
        ;
    for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--,
        r--)
        ;
    return n == r && /row|table/.test(t.node(i).type.spec.tableRole)
}
function $U({ $from: t, $to: e }) {
    let n, r;
    for (let i = t.depth; i > 0; i--) {
        const s = t.node(i);
        if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
            n = s;
            break
        }
    }
    for (let i = e.depth; i > 0; i--) {
        const s = e.node(i);
        if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
            r = s;
            break
        }
    }
    return n !== r && e.parentOffset === 0
}
function zU(t, e, n) {
    const r = (e || t).selection
        , i = (e || t).doc;
    let s, o;
    if (r instanceof Le && (o = r.node.type.spec.tableRole)) {
        if (o == "cell" || o == "header_cell")
            s = Ut.create(i, r.from);
        else if (o == "row") {
            const a = i.resolve(r.from + 1);
            s = Ut.rowSelection(a, a)
        } else if (!n) {
            const a = rn.get(r.node)
                , l = r.from + 1
                , c = l + a.map[a.width * a.height - 1];
            s = Ut.create(i, l + 1, c)
        }
    } else
        r instanceof De && BU(r) ? s = De.create(i, r.from) : r instanceof De && $U(r) && (s = De.create(i, r.$from.start(), r.$from.end()));
    return s && (e || (e = t.tr)).setSelection(s),
        e
}
var FU = new _n("fix-tables");
function aA(t, e, n, r) {
    const i = t.childCount
        , s = e.childCount;
    e: for (let o = 0, a = 0; o < s; o++) {
        const l = e.child(o);
        for (let c = a, d = Math.min(i, o + 3); c < d; c++)
            if (t.child(c) == l) {
                a = c + 1,
                    n += l.nodeSize;
                continue e
            }
        r(l, n),
            a < i && t.child(a).sameMarkup(l) ? aA(t.child(a), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1),
            n += l.nodeSize
    }
}
function lA(t, e) {
    let n;
    const r = (i, s) => {
        i.type.spec.tableRole == "table" && (n = HU(t, i, s, n))
    }
        ;
    return e ? e.doc != t.doc && aA(e.doc, t.doc, 0, r) : t.doc.descendants(r),
        n
}
function HU(t, e, n, r) {
    const i = rn.get(e);
    if (!i.problems)
        return r;
    r || (r = t.tr);
    const s = [];
    for (let l = 0; l < i.height; l++)
        s.push(0);
    for (let l = 0; l < i.problems.length; l++) {
        const c = i.problems[l];
        if (c.type == "collision") {
            const d = e.nodeAt(c.pos);
            if (!d)
                continue;
            const h = d.attrs;
            for (let p = 0; p < h.rowspan; p++)
                s[c.row + p] += c.n;
            r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, $a(h, h.colspan - c.n, c.n))
        } else if (c.type == "missing")
            s[c.row] += c.n;
        else if (c.type == "overlong_rowspan") {
            const d = e.nodeAt(c.pos);
            if (!d)
                continue;
            r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
                ...d.attrs,
                rowspan: d.attrs.rowspan - c.n
            })
        } else if (c.type == "colwidth mismatch") {
            const d = e.nodeAt(c.pos);
            if (!d)
                continue;
            r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
                ...d.attrs,
                colwidth: c.colwidth
            })
        }
    }
    let o, a;
    for (let l = 0; l < s.length; l++)
        s[l] && (o == null && (o = l),
            a = l);
    for (let l = 0, c = n + 1; l < i.height; l++) {
        const d = e.child(l)
            , h = c + d.nodeSize
            , p = s[l];
        if (p > 0) {
            let g = "cell";
            d.firstChild && (g = d.firstChild.type.spec.tableRole);
            const y = [];
            for (let S = 0; S < p; S++) {
                const k = er(t.schema)[g].createAndFill();
                k && y.push(k)
            }
            const x = (l == 0 || o == l - 1) && a == l ? c + 1 : h - 1;
            r.insert(r.mapping.map(x), y)
        }
        c = h
    }
    return r.setMeta(FU, {
        fixTables: !0
    })
}
function as(t) {
    const e = t.selection
        , n = Mm(t)
        , r = n.node(-1)
        , i = n.start(-1)
        , s = rn.get(r);
    return {
        ...e instanceof Ut ? s.rectBetween(e.$anchorCell.pos - i, e.$headCell.pos - i) : s.findCell(n.pos - i),
        tableStart: i,
        map: s,
        table: r
    }
}
function uA(t, { map: e, tableStart: n, table: r }, i) {
    let s = i > 0 ? -1 : 0;
    LU(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0);
    for (let o = 0; o < e.height; o++) {
        const a = o * e.width + i;
        if (i > 0 && i < e.width && e.map[a - 1] == e.map[a]) {
            const l = e.map[a]
                , c = r.nodeAt(l);
            t.setNodeMarkup(t.mapping.map(n + l), null, sA(c.attrs, i - e.colCount(l))),
                o += c.attrs.rowspan - 1
        } else {
            const l = s == null ? er(r.type.schema).cell : r.nodeAt(e.map[a + s]).type
                , c = e.positionAt(o, i, r);
            t.insert(t.mapping.map(n + c), l.createAndFill())
        }
    }
    return t
}
function VU(t, e) {
    if (!Ni(t))
        return !1;
    if (e) {
        const n = as(t);
        e(uA(t.tr, n, n.left))
    }
    return !0
}
function WU(t, e) {
    if (!Ni(t))
        return !1;
    if (e) {
        const n = as(t);
        e(uA(t.tr, n, n.right))
    }
    return !0
}
function UU(t, { map: e, table: n, tableStart: r }, i) {
    const s = t.mapping.maps.length;
    for (let o = 0; o < e.height;) {
        const a = o * e.width + i
            , l = e.map[a]
            , c = n.nodeAt(l)
            , d = c.attrs;
        if (i > 0 && e.map[a - 1] == l || i < e.width - 1 && e.map[a + 1] == l)
            t.setNodeMarkup(t.mapping.slice(s).map(r + l), null, $a(d, i - e.colCount(l)));
        else {
            const h = t.mapping.slice(s).map(r + l);
            t.delete(h, h + c.nodeSize)
        }
        o += d.rowspan
    }
}
function KU(t, e) {
    if (!Ni(t))
        return !1;
    if (e) {
        const n = as(t)
            , r = t.tr;
        if (n.left == 0 && n.right == n.map.width)
            return !1;
        for (let i = n.right - 1; UU(r, n, i),
            i != n.left; i--) {
            const s = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
            if (!s)
                throw RangeError("No table found");
            n.table = s,
                n.map = rn.get(s)
        }
        e(r)
    }
    return !0
}
function qU(t, e, n) {
    var r;
    const i = er(e.type.schema).header_cell;
    for (let s = 0; s < t.width; s++)
        if (((r = e.nodeAt(t.map[s + n * t.width])) == null ? void 0 : r.type) != i)
            return !1;
    return !0
}
function cA(t, { map: e, tableStart: n, table: r }, i) {
    var s;
    let o = n;
    for (let c = 0; c < i; c++)
        o += r.child(c).nodeSize;
    const a = [];
    let l = i > 0 ? -1 : 0;
    qU(e, r, i + l) && (l = i == 0 || i == e.height ? null : 0);
    for (let c = 0, d = e.width * i; c < e.width; c++,
        d++)
        if (i > 0 && i < e.height && e.map[d] == e.map[d - e.width]) {
            const h = e.map[d]
                , p = r.nodeAt(h).attrs;
            t.setNodeMarkup(n + h, null, {
                ...p,
                rowspan: p.rowspan + 1
            }),
                c += p.colspan - 1
        } else {
            const h = l == null ? er(r.type.schema).cell : (s = r.nodeAt(e.map[d + l * e.width])) == null ? void 0 : s.type
                , p = h?.createAndFill();
            p && a.push(p)
        }
    return t.insert(o, er(r.type.schema).row.create(null, a)),
        t
}
function GU(t, e) {
    if (!Ni(t))
        return !1;
    if (e) {
        const n = as(t);
        e(cA(t.tr, n, n.top))
    }
    return !0
}
function JU(t, e) {
    if (!Ni(t))
        return !1;
    if (e) {
        const n = as(t);
        e(cA(t.tr, n, n.bottom))
    }
    return !0
}
function ZU(t, { map: e, table: n, tableStart: r }, i) {
    let s = 0;
    for (let c = 0; c < i; c++)
        s += n.child(c).nodeSize;
    const o = s + n.child(i).nodeSize
        , a = t.mapping.maps.length;
    t.delete(s + r, o + r);
    const l = new Set;
    for (let c = 0, d = i * e.width; c < e.width; c++,
        d++) {
        const h = e.map[d];
        if (!l.has(h)) {
            if (l.add(h),
                i > 0 && h == e.map[d - e.width]) {
                const p = n.nodeAt(h).attrs;
                t.setNodeMarkup(t.mapping.slice(a).map(h + r), null, {
                    ...p,
                    rowspan: p.rowspan - 1
                }),
                    c += p.colspan - 1
            } else if (i < e.height && h == e.map[d + e.width]) {
                const p = n.nodeAt(h)
                    , g = p.attrs
                    , y = p.type.create({
                        ...g,
                        rowspan: p.attrs.rowspan - 1
                    }, p.content)
                    , x = e.positionAt(i + 1, c, n);
                t.insert(t.mapping.slice(a).map(r + x), y),
                    c += g.colspan - 1
            }
        }
    }
}
function YU(t, e) {
    if (!Ni(t))
        return !1;
    if (e) {
        const n = as(t)
            , r = t.tr;
        if (n.top == 0 && n.bottom == n.map.height)
            return !1;
        for (let i = n.bottom - 1; ZU(r, n, i),
            i != n.top; i--) {
            const s = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
            if (!s)
                throw RangeError("No table found");
            n.table = s,
                n.map = rn.get(n.table)
        }
        e(r)
    }
    return !0
}
function R3(t) {
    const e = t.content;
    return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0
}
function XU({ width: t, height: e, map: n }, r) {
    let i = r.top * t + r.left
        , s = i
        , o = (r.bottom - 1) * t + r.left
        , a = i + (r.right - r.left - 1);
    for (let l = r.top; l < r.bottom; l++) {
        if (r.left > 0 && n[s] == n[s - 1] || r.right < t && n[a] == n[a + 1])
            return !0;
        s += t,
            a += t
    }
    for (let l = r.left; l < r.right; l++) {
        if (r.top > 0 && n[i] == n[i - t] || r.bottom < e && n[o] == n[o + t])
            return !0;
        i++,
            o++
    }
    return !1
}
function P3(t, e) {
    const n = t.selection;
    if (!(n instanceof Ut) || n.$anchorCell.pos == n.$headCell.pos)
        return !1;
    const r = as(t)
        , { map: i } = r;
    if (XU(i, r))
        return !1;
    if (e) {
        const s = t.tr
            , o = {};
        let a = se.empty, l, c;
        for (let d = r.top; d < r.bottom; d++)
            for (let h = r.left; h < r.right; h++) {
                const p = i.map[d * i.width + h]
                    , g = r.table.nodeAt(p);
                if (!(o[p] || !g))
                    if (o[p] = !0,
                        l == null)
                        l = p,
                            c = g;
                    else {
                        R3(g) || (a = a.append(g.content));
                        const y = s.mapping.map(p + r.tableStart);
                        s.delete(y, y + g.nodeSize)
                    }
            }
        if (l == null || c == null)
            return !0;
        if (s.setNodeMarkup(l + r.tableStart, null, {
            ...sA(c.attrs, c.attrs.colspan, r.right - r.left - c.attrs.colspan),
            rowspan: r.bottom - r.top
        }),
            a.size) {
            const d = l + 1 + c.content.size
                , h = R3(c) ? l + 1 : d;
            s.replaceWith(h + r.tableStart, d + r.tableStart, a)
        }
        s.setSelection(new Ut(s.doc.resolve(l + r.tableStart))),
            e(s)
    }
    return !0
}
function N3(t, e) {
    const n = er(t.schema);
    return QU(({ node: r }) => n[r.type.spec.tableRole])(t, e)
}
function QU(t) {
    return (e, n) => {
        var r;
        const i = e.selection;
        let s, o;
        if (i instanceof Ut) {
            if (i.$anchorCell.pos != i.$headCell.pos)
                return !1;
            s = i.$anchorCell.nodeAfter,
                o = i.$anchorCell.pos
        } else {
            if (s = PU(i.$from),
                !s)
                return !1;
            o = (r = mu(i.$from)) == null ? void 0 : r.pos
        }
        if (s == null || o == null || s.attrs.colspan == 1 && s.attrs.rowspan == 1)
            return !1;
        if (n) {
            let a = s.attrs;
            const l = []
                , c = a.colwidth;
            a.rowspan > 1 && (a = {
                ...a,
                rowspan: 1
            }),
                a.colspan > 1 && (a = {
                    ...a,
                    colspan: 1
                });
            const d = as(e)
                , h = e.tr;
            for (let g = 0; g < d.right - d.left; g++)
                l.push(c ? {
                    ...a,
                    colwidth: c && c[g] ? [c[g]] : null
                } : a);
            let p;
            for (let g = d.top; g < d.bottom; g++) {
                let y = d.map.positionAt(g, d.left, d.table);
                g == d.top && (y += s.nodeSize);
                for (let x = d.left, S = 0; x < d.right; x++,
                    S++)
                    x == d.left && g == d.top || h.insert(p = h.mapping.map(y + d.tableStart, 1), t({
                        node: s,
                        row: g,
                        col: x
                    }).createAndFill(l[S]))
            }
            h.setNodeMarkup(o, t({
                node: s,
                row: d.top,
                col: d.left
            }), l[0]),
                i instanceof Ut && h.setSelection(new Ut(h.doc.resolve(i.$anchorCell.pos), p ? h.doc.resolve(p) : void 0)),
                n(h)
        }
        return !0
    }
}
function eK(t, e) {
    return function (n, r) {
        if (!Ni(n))
            return !1;
        const i = Mm(n);
        if (i.nodeAfter.attrs[t] === e)
            return !1;
        if (r) {
            const s = n.tr;
            n.selection instanceof Ut ? n.selection.forEachCell((o, a) => {
                o.attrs[t] !== e && s.setNodeMarkup(a, null, {
                    ...o.attrs,
                    [t]: e
                })
            }
            ) : s.setNodeMarkup(i.pos, null, {
                ...i.nodeAfter.attrs,
                [t]: e
            }),
                r(s)
        }
        return !0
    }
}
function tK(t) {
    return function (e, n) {
        if (!Ni(e))
            return !1;
        if (n) {
            const r = er(e.schema)
                , i = as(e)
                , s = e.tr
                , o = i.map.cellsInRect(t == "column" ? {
                    left: i.left,
                    top: 0,
                    right: i.right,
                    bottom: i.map.height
                } : t == "row" ? {
                    left: 0,
                    top: i.top,
                    right: i.map.width,
                    bottom: i.bottom
                } : i)
                , a = o.map(l => i.table.nodeAt(l));
            for (let l = 0; l < o.length; l++)
                a[l].type == r.header_cell && s.setNodeMarkup(i.tableStart + o[l], r.cell, a[l].attrs);
            if (s.steps.length == 0)
                for (let l = 0; l < o.length; l++)
                    s.setNodeMarkup(i.tableStart + o[l], r.header_cell, a[l].attrs);
            n(s)
        }
        return !0
    }
}
function I3(t, e, n) {
    const r = e.map.cellsInRect({
        left: 0,
        top: 0,
        right: t == "row" ? e.map.width : 1,
        bottom: t == "column" ? e.map.height : 1
    });
    for (let i = 0; i < r.length; i++) {
        const s = e.table.nodeAt(r[i]);
        if (s && s.type !== n.header_cell)
            return !1
    }
    return !0
}
function Vc(t, e) {
    return e = e || {
        useDeprecatedLogic: !1
    },
        e.useDeprecatedLogic ? tK(t) : function (n, r) {
            if (!Ni(n))
                return !1;
            if (r) {
                const i = er(n.schema)
                    , s = as(n)
                    , o = n.tr
                    , a = I3("row", s, i)
                    , l = I3("column", s, i)
                    , d = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0
                    , h = t == "column" ? {
                        left: 0,
                        top: d,
                        right: 1,
                        bottom: s.map.height
                    } : t == "row" ? {
                        left: d,
                        top: 0,
                        right: s.map.width,
                        bottom: 1
                    } : s
                    , p = t == "column" ? l ? i.cell : i.header_cell : t == "row" ? a ? i.cell : i.header_cell : i.cell;
                s.map.cellsInRect(h).forEach(g => {
                    const y = g + s.tableStart
                        , x = o.doc.nodeAt(y);
                    x && o.setNodeMarkup(y, p, x.attrs)
                }
                ),
                    r(o)
            }
            return !0
        }
}
Vc("row", {
    useDeprecatedLogic: !0
});
Vc("column", {
    useDeprecatedLogic: !0
});
var nK = Vc("cell", {
    useDeprecatedLogic: !0
});
function rK(t, e) {
    if (e < 0) {
        const n = t.nodeBefore;
        if (n)
            return t.pos - n.nodeSize;
        for (let r = t.index(-1) - 1, i = t.before(); r >= 0; r--) {
            const s = t.node(-1).child(r)
                , o = s.lastChild;
            if (o)
                return i - 1 - o.nodeSize;
            i -= s.nodeSize
        }
    } else {
        if (t.index() < t.parent.childCount - 1)
            return t.pos + t.nodeAfter.nodeSize;
        const n = t.node(-1);
        for (let r = t.indexAfter(-1), i = t.after(); r < n.childCount; r++) {
            const s = n.child(r);
            if (s.childCount)
                return i + 1;
            i += s.nodeSize
        }
    }
    return null
}
function L3(t) {
    return function (e, n) {
        if (!Ni(e))
            return !1;
        const r = rK(Mm(e), t);
        if (r == null)
            return !1;
        if (n) {
            const i = e.doc.resolve(r);
            n(e.tr.setSelection(De.between(i, IU(i))).scrollIntoView())
        }
        return !0
    }
}
function iK(t, e) {
    const n = t.selection.$anchor;
    for (let r = n.depth; r > 0; r--)
        if (n.node(r).type.spec.tableRole == "table")
            return e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()),
                !0;
    return !1
}
function Kf(t, e) {
    const n = t.selection;
    if (!(n instanceof Ut))
        return !1;
    if (e) {
        const r = t.tr
            , i = er(t.schema).cell.createAndFill().content;
        n.forEachCell((s, o) => {
            s.content.eq(i) || r.replace(r.mapping.map(o + 1), r.mapping.map(o + s.nodeSize - 1), new ve(i, 0, 0))
        }
        ),
            r.docChanged && e(r)
    }
    return !0
}
function sK(t) {
    if (!t.size)
        return null;
    let { content: e, openStart: n, openEnd: r } = t;
    for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table");)
        n--,
            r--,
            e = e.child(0).content;
    const i = e.child(0)
        , s = i.type.spec.tableRole
        , o = i.type.schema
        , a = [];
    if (s == "row")
        for (let l = 0; l < e.childCount; l++) {
            let c = e.child(l).content;
            const d = l ? 0 : Math.max(0, n - 1)
                , h = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
            (d || h) && (c = ny(er(o).row, new ve(c, d, h)).content),
                a.push(c)
        }
    else if (s == "cell" || s == "header_cell")
        a.push(n || r ? ny(er(o).row, new ve(e, n, r)).content : e);
    else
        return null;
    return oK(o, a)
}
function oK(t, e) {
    const n = [];
    for (let i = 0; i < e.length; i++) {
        const s = e[i];
        for (let o = s.childCount - 1; o >= 0; o--) {
            const { rowspan: a, colspan: l } = s.child(o).attrs;
            for (let c = i; c < i + a; c++)
                n[c] = (n[c] || 0) + l
        }
    }
    let r = 0;
    for (let i = 0; i < n.length; i++)
        r = Math.max(r, n[i]);
    for (let i = 0; i < n.length; i++)
        if (i >= e.length && e.push(se.empty),
            n[i] < r) {
            const s = er(t).cell.createAndFill()
                , o = [];
            for (let a = n[i]; a < r; a++)
                o.push(s);
            e[i] = e[i].append(se.from(o))
        }
    return {
        height: e.length,
        width: r,
        rows: e
    }
}
function ny(t, e) {
    const n = t.createAndFill();
    return new bv(n).replace(0, n.content.size, e).doc
}
function aK({ width: t, height: e, rows: n }, r, i) {
    if (t != r) {
        const s = []
            , o = [];
        for (let a = 0; a < n.length; a++) {
            const l = n[a]
                , c = [];
            for (let d = s[a] || 0, h = 0; d < r; h++) {
                let p = l.child(h % l.childCount);
                d + p.attrs.colspan > r && (p = p.type.createChecked($a(p.attrs, p.attrs.colspan, d + p.attrs.colspan - r), p.content)),
                    c.push(p),
                    d += p.attrs.colspan;
                for (let g = 1; g < p.attrs.rowspan; g++)
                    s[a + g] = (s[a + g] || 0) + p.attrs.colspan
            }
            o.push(se.from(c))
        }
        n = o,
            t = r
    }
    if (e != i) {
        const s = [];
        for (let o = 0, a = 0; o < i; o++,
            a++) {
            const l = []
                , c = n[a % e];
            for (let d = 0; d < c.childCount; d++) {
                let h = c.child(d);
                o + h.attrs.rowspan > i && (h = h.type.create({
                    ...h.attrs,
                    rowspan: Math.max(1, i - h.attrs.rowspan)
                }, h.content)),
                    l.push(h)
            }
            s.push(se.from(l))
        }
        n = s,
            e = i
    }
    return {
        width: t,
        height: e,
        rows: n
    }
}
function lK(t, e, n, r, i, s, o) {
    const a = t.doc.type.schema
        , l = er(a);
    let c, d;
    if (i > e.width)
        for (let h = 0, p = 0; h < e.height; h++) {
            const g = n.child(h);
            p += g.nodeSize;
            const y = [];
            let x;
            g.lastChild == null || g.lastChild.type == l.cell ? x = c || (c = l.cell.createAndFill()) : x = d || (d = l.header_cell.createAndFill());
            for (let S = e.width; S < i; S++)
                y.push(x);
            t.insert(t.mapping.slice(o).map(p - 1 + r), y)
        }
    if (s > e.height) {
        const h = [];
        for (let y = 0, x = (e.height - 1) * e.width; y < Math.max(e.width, i); y++) {
            const S = y >= e.width ? !1 : n.nodeAt(e.map[x + y]).type == l.header_cell;
            h.push(S ? d || (d = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill()))
        }
        const p = l.row.create(null, se.from(h))
            , g = [];
        for (let y = e.height; y < s; y++)
            g.push(p);
        t.insert(t.mapping.slice(o).map(r + n.nodeSize - 2), g)
    }
    return !!(c || d)
}
function D3(t, e, n, r, i, s, o, a) {
    if (o == 0 || o == e.height)
        return !1;
    let l = !1;
    for (let c = i; c < s; c++) {
        const d = o * e.width + c
            , h = e.map[d];
        if (e.map[d - e.width] == h) {
            l = !0;
            const p = n.nodeAt(h)
                , { top: g, left: y } = e.findCell(h);
            t.setNodeMarkup(t.mapping.slice(a).map(h + r), null, {
                ...p.attrs,
                rowspan: o - g
            }),
                t.insert(t.mapping.slice(a).map(e.positionAt(o, y, n)), p.type.createAndFill({
                    ...p.attrs,
                    rowspan: g + p.attrs.rowspan - o
                })),
                c += p.attrs.colspan - 1
        }
    }
    return l
}
function j3(t, e, n, r, i, s, o, a) {
    if (o == 0 || o == e.width)
        return !1;
    let l = !1;
    for (let c = i; c < s; c++) {
        const d = c * e.width + o
            , h = e.map[d];
        if (e.map[d - 1] == h) {
            l = !0;
            const p = n.nodeAt(h)
                , g = e.colCount(h)
                , y = t.mapping.slice(a).map(h + r);
            t.setNodeMarkup(y, null, $a(p.attrs, o - g, p.attrs.colspan - (o - g))),
                t.insert(y + p.nodeSize, p.type.createAndFill($a(p.attrs, 0, o - g))),
                c += p.attrs.rowspan - 1
        }
    }
    return l
}
function B3(t, e, n, r, i) {
    let s = n ? t.doc.nodeAt(n - 1) : t.doc;
    if (!s)
        throw new Error("No table found");
    let o = rn.get(s);
    const { top: a, left: l } = r
        , c = l + i.width
        , d = a + i.height
        , h = t.tr;
    let p = 0;
    function g() {
        if (s = n ? h.doc.nodeAt(n - 1) : h.doc,
            !s)
            throw new Error("No table found");
        o = rn.get(s),
            p = h.mapping.maps.length
    }
    lK(h, o, s, n, c, d, p) && g(),
        D3(h, o, s, n, l, c, a, p) && g(),
        D3(h, o, s, n, l, c, d, p) && g(),
        j3(h, o, s, n, a, d, l, p) && g(),
        j3(h, o, s, n, a, d, c, p) && g();
    for (let y = a; y < d; y++) {
        const x = o.positionAt(y, l, s)
            , S = o.positionAt(y, c, s);
        h.replace(h.mapping.slice(p).map(x + n), h.mapping.slice(p).map(S + n), new ve(i.rows[y - a], 0, 0))
    }
    g(),
        h.setSelection(new Ut(h.doc.resolve(n + o.positionAt(a, l, s)), h.doc.resolve(n + o.positionAt(d - 1, c - 1, s)))),
        e(h)
}
var uK = Ov({
    ArrowLeft: qf("horiz", -1),
    ArrowRight: qf("horiz", 1),
    ArrowUp: qf("vert", -1),
    ArrowDown: qf("vert", 1),
    "Shift-ArrowLeft": Gf("horiz", -1),
    "Shift-ArrowRight": Gf("horiz", 1),
    "Shift-ArrowUp": Gf("vert", -1),
    "Shift-ArrowDown": Gf("vert", 1),
    Backspace: Kf,
    "Mod-Backspace": Kf,
    Delete: Kf,
    "Mod-Delete": Kf
});
function mh(t, e, n) {
    return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()),
        !0)
}
function qf(t, e) {
    return (n, r, i) => {
        if (!i)
            return !1;
        const s = n.selection;
        if (s instanceof Ut)
            return mh(n, r, Ve.near(s.$headCell, e));
        if (t != "horiz" && !s.empty)
            return !1;
        const o = dA(i, t, e);
        if (o == null)
            return !1;
        if (t == "horiz")
            return mh(n, r, Ve.near(n.doc.resolve(s.head + e), e));
        {
            const a = n.doc.resolve(o)
                , l = iA(a, t, e);
            let c;
            return l ? c = Ve.near(l, 1) : e < 0 ? c = Ve.near(n.doc.resolve(a.before(-1)), -1) : c = Ve.near(n.doc.resolve(a.after(-1)), 1),
                mh(n, r, c)
        }
    }
}
function Gf(t, e) {
    return (n, r, i) => {
        if (!i)
            return !1;
        const s = n.selection;
        let o;
        if (s instanceof Ut)
            o = s;
        else {
            const l = dA(i, t, e);
            if (l == null)
                return !1;
            o = new Ut(n.doc.resolve(l))
        }
        const a = iA(o.$headCell, t, e);
        return a ? mh(n, r, new Ut(o.$anchorCell, a)) : !1
    }
}
function cK(t, e) {
    const n = t.state.doc
        , r = mu(n.resolve(e));
    return r ? (t.dispatch(t.state.tr.setSelection(new Ut(r))),
        !0) : !1
}
function dK(t, e, n) {
    if (!Ni(t.state))
        return !1;
    let r = sK(n);
    const i = t.state.selection;
    if (i instanceof Ut) {
        r || (r = {
            width: 1,
            height: 1,
            rows: [se.from(ny(er(t.state.schema).cell, n))]
        });
        const s = i.$anchorCell.node(-1)
            , o = i.$anchorCell.start(-1)
            , a = rn.get(s).rectBetween(i.$anchorCell.pos - o, i.$headCell.pos - o);
        return r = aK(r, a.right - a.left, a.bottom - a.top),
            B3(t.state, t.dispatch, o, a, r),
            !0
    } else if (r) {
        const s = Mm(t.state)
            , o = s.start(-1);
        return B3(t.state, t.dispatch, o, rn.get(s.node(-1)).findCell(s.pos - o), r),
            !0
    } else
        return !1
}
function fK(t, e) {
    var n;
    if (e.ctrlKey || e.metaKey)
        return;
    const r = $3(t, e.target);
    let i;
    if (e.shiftKey && t.state.selection instanceof Ut)
        s(t.state.selection.$anchorCell, e),
            e.preventDefault();
    else if (e.shiftKey && r && (i = mu(t.state.selection.$anchor)) != null && ((n = $0(t, e)) == null ? void 0 : n.pos) != i.pos)
        s(i, e),
            e.preventDefault();
    else if (!r)
        return;
    function s(l, c) {
        let d = $0(t, c);
        const h = po.getState(t.state) == null;
        if (!d || !Bv(l, d))
            if (h)
                d = l;
            else
                return;
        const p = new Ut(l, d);
        if (h || !t.state.selection.eq(p)) {
            const g = t.state.tr.setSelection(p);
            h && g.setMeta(po, l.pos),
                t.dispatch(g)
        }
    }
    function o() {
        t.root.removeEventListener("mouseup", o),
            t.root.removeEventListener("dragstart", o),
            t.root.removeEventListener("mousemove", a),
            po.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(po, -1))
    }
    function a(l) {
        const c = l
            , d = po.getState(t.state);
        let h;
        if (d != null)
            h = t.state.doc.resolve(d);
        else if ($3(t, c.target) != r && (h = $0(t, e),
            !h))
            return o();
        h && s(h, c)
    }
    t.root.addEventListener("mouseup", o),
        t.root.addEventListener("dragstart", o),
        t.root.addEventListener("mousemove", a)
}
function dA(t, e, n) {
    if (!(t.state.selection instanceof De))
        return null;
    const { $head: r } = t.state.selection;
    for (let i = r.depth - 1; i >= 0; i--) {
        const s = r.node(i);
        if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : s.childCount))
            return null;
        if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
            const a = r.before(i)
                , l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
            return t.endOfTextblock(l) ? a : null
        }
    }
    return null
}
function $3(t, e) {
    for (; e && e != t.dom; e = e.parentNode)
        if (e.nodeName == "TD" || e.nodeName == "TH")
            return e;
    return null
}
function $0(t, e) {
    const n = t.posAtCoords({
        left: e.clientX,
        top: e.clientY
    });
    return n && n ? mu(t.state.doc.resolve(n.pos)) : null
}
var hK = class {
    constructor(e, n) {
        this.node = e,
            this.cellMinWidth = n,
            this.dom = document.createElement("div"),
            this.dom.className = "tableWrapper",
            this.table = this.dom.appendChild(document.createElement("table")),
            this.colgroup = this.table.appendChild(document.createElement("colgroup")),
            ry(e, this.colgroup, this.table, n),
            this.contentDOM = this.table.appendChild(document.createElement("tbody"))
    }
    update(e) {
        return e.type != this.node.type ? !1 : (this.node = e,
            ry(e, this.colgroup, this.table, this.cellMinWidth),
            !0)
    }
    ignoreMutation(e) {
        return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target))
    }
}
    ;
function ry(t, e, n, r, i, s) {
    var o;
    let a = 0
        , l = !0
        , c = e.firstChild;
    const d = t.firstChild;
    if (d) {
        for (let h = 0, p = 0; h < d.childCount; h++) {
            const { colspan: g, colwidth: y } = d.child(h).attrs;
            for (let x = 0; x < g; x++,
                p++) {
                const S = i == p ? s : y && y[x]
                    , k = S ? S + "px" : "";
                a += S || r,
                    S || (l = !1),
                    c ? (c.style.width != k && (c.style.width = k),
                        c = c.nextSibling) : e.appendChild(document.createElement("col")).style.width = k
            }
        }
        for (; c;) {
            const h = c.nextSibling;
            (o = c.parentNode) == null || o.removeChild(c),
                c = h
        }
        l ? (n.style.width = a + "px",
            n.style.minWidth = "") : (n.style.width = "",
                n.style.minWidth = a + "px")
    }
}
var ri = new _n("tableColumnResizing");
function pK({ handleWidth: t = 5, cellMinWidth: e = 25, View: n = hK, lastColumnResizable: r = !0 } = {}) {
    const i = new sn({
        key: ri,
        state: {
            init(s, o) {
                var a, l;
                const c = (l = (a = i.spec) == null ? void 0 : a.props) == null ? void 0 : l.nodeViews
                    , d = er(o.schema).table.name;
                return n && c && (c[d] = (h, p) => new n(h, e, p)),
                    new mK(-1, !1)
            },
            apply(s, o) {
                return o.apply(s)
            }
        },
        props: {
            attributes: s => {
                const o = ri.getState(s);
                return o && o.activeHandle > -1 ? {
                    class: "resize-cursor"
                } : {}
            }
            ,
            handleDOMEvents: {
                mousemove: (s, o) => {
                    gK(s, o, t, e, r)
                }
                ,
                mouseleave: s => {
                    yK(s)
                }
                ,
                mousedown: (s, o) => {
                    vK(s, o, e)
                }
            },
            decorations: s => {
                const o = ri.getState(s);
                if (o && o.activeHandle > -1)
                    return kK(s, o.activeHandle)
            }
            ,
            nodeViews: {}
        }
    });
    return i
}
var mK = class gh {
    constructor(e, n) {
        this.activeHandle = e,
            this.dragging = n
    }
    apply(e) {
        const n = this
            , r = e.getMeta(ri);
        if (r && r.setHandle != null)
            return new gh(r.setHandle, !1);
        if (r && r.setDragging !== void 0)
            return new gh(n.activeHandle, r.setDragging);
        if (n.activeHandle > -1 && e.docChanged) {
            let i = e.mapping.map(n.activeHandle, -1);
            return ty(e.doc.resolve(i)) || (i = -1),
                new gh(i, n.dragging)
        }
        return n
    }
}
    ;
function gK(t, e, n, r, i) {
    const s = ri.getState(t.state);
    if (s && !s.dragging) {
        const o = wK(e.target);
        let a = -1;
        if (o) {
            const { left: l, right: c } = o.getBoundingClientRect();
            e.clientX - l <= n ? a = z3(t, e, "left", n) : c - e.clientX <= n && (a = z3(t, e, "right", n))
        }
        if (a != s.activeHandle) {
            if (!i && a !== -1) {
                const l = t.state.doc.resolve(a)
                    , c = l.node(-1)
                    , d = rn.get(c)
                    , h = l.start(-1);
                if (d.colCount(l.pos - h) + l.nodeAfter.attrs.colspan - 1 == d.width - 1)
                    return
            }
            fA(t, a)
        }
    }
}
function yK(t) {
    const e = ri.getState(t.state);
    e && e.activeHandle > -1 && !e.dragging && fA(t, -1)
}
function vK(t, e, n) {
    var r;
    const i = (r = t.dom.ownerDocument.defaultView) != null ? r : window
        , s = ri.getState(t.state);
    if (!s || s.activeHandle == -1 || s.dragging)
        return !1;
    const o = t.state.doc.nodeAt(s.activeHandle)
        , a = bK(t, s.activeHandle, o.attrs);
    t.dispatch(t.state.tr.setMeta(ri, {
        setDragging: {
            startX: e.clientX,
            startWidth: a
        }
    }));
    function l(d) {
        i.removeEventListener("mouseup", l),
            i.removeEventListener("mousemove", c);
        const h = ri.getState(t.state);
        h?.dragging && (xK(t, h.activeHandle, F3(h.dragging, d, n)),
            t.dispatch(t.state.tr.setMeta(ri, {
                setDragging: null
            })))
    }
    function c(d) {
        if (!d.which)
            return l(d);
        const h = ri.getState(t.state);
        if (h && h.dragging) {
            const p = F3(h.dragging, d, n);
            _K(t, h.activeHandle, p, n)
        }
    }
    return i.addEventListener("mouseup", l),
        i.addEventListener("mousemove", c),
        e.preventDefault(),
        !0
}
function bK(t, e, { colspan: n, colwidth: r }) {
    const i = r && r[r.length - 1];
    if (i)
        return i;
    const s = t.domAtPos(e);
    let a = s.node.childNodes[s.offset].offsetWidth
        , l = n;
    if (r)
        for (let c = 0; c < n; c++)
            r[c] && (a -= r[c],
                l--);
    return a / l
}
function wK(t) {
    for (; t && t.nodeName != "TD" && t.nodeName != "TH";)
        t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
    return t
}
function z3(t, e, n, r) {
    const i = n == "right" ? -r : r
        , s = t.posAtCoords({
            left: e.clientX + i,
            top: e.clientY
        });
    if (!s)
        return -1;
    const { pos: o } = s
        , a = mu(t.state.doc.resolve(o));
    if (!a)
        return -1;
    if (n == "right")
        return a.pos;
    const l = rn.get(a.node(-1))
        , c = a.start(-1)
        , d = l.map.indexOf(a.pos - c);
    return d % l.width == 0 ? -1 : c + l.map[d - 1]
}
function F3(t, e, n) {
    const r = e.clientX - t.startX;
    return Math.max(n, t.startWidth + r)
}
function fA(t, e) {
    t.dispatch(t.state.tr.setMeta(ri, {
        setHandle: e
    }))
}
function xK(t, e, n) {
    const r = t.state.doc.resolve(e)
        , i = r.node(-1)
        , s = rn.get(i)
        , o = r.start(-1)
        , a = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1
        , l = t.state.tr;
    for (let c = 0; c < s.height; c++) {
        const d = c * s.width + a;
        if (c && s.map[d] == s.map[d - s.width])
            continue;
        const h = s.map[d]
            , p = i.nodeAt(h).attrs
            , g = p.colspan == 1 ? 0 : a - s.colCount(h);
        if (p.colwidth && p.colwidth[g] == n)
            continue;
        const y = p.colwidth ? p.colwidth.slice() : SK(p.colspan);
        y[g] = n,
            l.setNodeMarkup(o + h, null, {
                ...p,
                colwidth: y
            })
    }
    l.docChanged && t.dispatch(l)
}
function _K(t, e, n, r) {
    const i = t.state.doc.resolve(e)
        , s = i.node(-1)
        , o = i.start(-1)
        , a = rn.get(s).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
    let l = t.domAtPos(i.start(-1)).node;
    for (; l && l.nodeName != "TABLE";)
        l = l.parentNode;
    l && ry(s, l.firstChild, l, r, a, n)
}
function SK(t) {
    return Array(t).fill(0)
}
function kK(t, e) {
    const n = []
        , r = t.doc.resolve(e)
        , i = r.node(-1);
    if (!i)
        return Zt.empty;
    const s = rn.get(i)
        , o = r.start(-1)
        , a = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1;
    for (let l = 0; l < s.height; l++) {
        const c = a + l * s.width;
        if ((a == s.width - 1 || s.map[c] != s.map[c + 1]) && (l == 0 || s.map[c] != s.map[c - s.width])) {
            const d = s.map[c]
                , h = o + d + i.nodeAt(d).nodeSize - 1
                , p = document.createElement("div");
            p.className = "column-resize-handle",
                n.push(Xn.widget(h, p))
        }
    }
    return Zt.create(t.doc, n)
}
function CK({ allowTableNodeSelection: t = !1 } = {}) {
    return new sn({
        key: po,
        state: {
            init() {
                return null
            },
            apply(e, n) {
                const r = e.getMeta(po);
                if (r != null)
                    return r == -1 ? null : r;
                if (n == null || !e.docChanged)
                    return n;
                const { deleted: i, pos: s } = e.mapping.mapResult(n);
                return i ? null : s
            }
        },
        props: {
            decorations: jU,
            handleDOMEvents: {
                mousedown: fK
            },
            createSelectionBetween(e) {
                return po.getState(e.state) != null ? e.state.selection : null
            },
            handleTripleClick: cK,
            handleKeyDown: uK,
            handlePaste: dK
        },
        appendTransaction(e, n, r) {
            return zU(r, lA(r, n), t)
        }
    })
}
function H3(t, e, n, r, i, s) {
    let o = 0
        , a = !0
        , l = e.firstChild;
    const c = t.firstChild;
    for (let d = 0, h = 0; d < c.childCount; d += 1) {
        const { colspan: p, colwidth: g } = c.child(d).attrs;
        for (let y = 0; y < p; y += 1,
            h += 1) {
            const x = i === h ? s : g && g[y]
                , S = x ? `${x}px` : "";
            o += x || r,
                x || (a = !1),
                l ? (l.style.width !== S && (l.style.width = S),
                    l = l.nextSibling) : e.appendChild(document.createElement("col")).style.width = S
        }
    }
    for (; l;) {
        const d = l.nextSibling;
        l.parentNode.removeChild(l),
            l = d
    }
    a ? (n.style.width = `${o}px`,
        n.style.minWidth = "") : (n.style.width = "",
            n.style.minWidth = `${o}px`)
}
class EK {
    constructor(e, n) {
        this.node = e,
            this.cellMinWidth = n,
            this.dom = document.createElement("div"),
            this.dom.className = "tableWrapper",
            this.table = this.dom.appendChild(document.createElement("table")),
            this.colgroup = this.table.appendChild(document.createElement("colgroup")),
            H3(e, this.colgroup, this.table, n),
            this.contentDOM = this.table.appendChild(document.createElement("tbody"))
    }
    update(e) {
        return e.type !== this.node.type ? !1 : (this.node = e,
            H3(e, this.colgroup, this.table, this.cellMinWidth),
            !0)
    }
    ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target))
    }
}
function TK(t, e, n, r) {
    let i = 0
        , s = !0;
    const o = []
        , a = t.firstChild;
    if (!a)
        return {};
    for (let h = 0, p = 0; h < a.childCount; h += 1) {
        const { colspan: g, colwidth: y } = a.child(h).attrs;
        for (let x = 0; x < g; x += 1,
            p += 1) {
            const S = n === p ? r : y && y[x]
                , k = S ? `${S}px` : "";
            i += S || e,
                S || (s = !1),
                o.push(["col", k ? {
                    style: `width: ${k}`
                } : {}])
        }
    }
    const l = s ? `${i}px` : ""
        , c = s ? "" : `${i}px`;
    return {
        colgroup: ["colgroup", {}, ...o],
        tableWidth: l,
        tableMinWidth: c
    }
}
function V3(t, e) {
    return e ? t.createChecked(null, e) : t.createAndFill()
}
function AK(t) {
    if (t.cached.tableNodeTypes)
        return t.cached.tableNodeTypes;
    const e = {};
    return Object.keys(t.nodes).forEach(n => {
        const r = t.nodes[n];
        r.spec.tableRole && (e[r.spec.tableRole] = r)
    }
    ),
        t.cached.tableNodeTypes = e,
        e
}
function OK(t, e, n, r, i) {
    const s = AK(t)
        , o = []
        , a = [];
    for (let c = 0; c < n; c += 1) {
        const d = V3(s.cell, i);
        if (d && a.push(d),
            r) {
            const h = V3(s.header_cell, i);
            h && o.push(h)
        }
    }
    const l = [];
    for (let c = 0; c < e; c += 1)
        l.push(s.row.createChecked(null, r && c === 0 ? o : a));
    return s.table.createChecked(null, l)
}
function MK(t) {
    return t instanceof Ut
}
const Jf = ({ editor: t }) => {
    const { selection: e } = t.state;
    if (!MK(e))
        return !1;
    let n = 0;
    const r = YT(e.ranges[0].$from, s => s.type.name === "table");
    return r?.node.descendants(s => {
        if (s.type.name === "table")
            return !1;
        ["tableCell", "tableHeader"].includes(s.type.name) && (n += 1)
    }
    ),
        n === e.ranges.length ? (t.commands.deleteTable(),
            !0) : !1
}
    , dee = mn.create({
        name: "table",
        addOptions() {
            return {
                HTMLAttributes: {},
                resizable: !1,
                handleWidth: 5,
                cellMinWidth: 25,
                View: EK,
                lastColumnResizable: !0,
                allowTableNodeSelection: !1
            }
        },
        content: "tableRow+",
        tableRole: "table",
        isolating: !0,
        group: "block",
        parseHTML() {
            return [{
                tag: "table"
            }]
        },
        renderHTML({ node: t, HTMLAttributes: e }) {
            const { colgroup: n, tableWidth: r, tableMinWidth: i } = TK(t, this.options.cellMinWidth);
            return ["table", Tt(this.options.HTMLAttributes, e, {
                style: r ? `width: ${r}` : `min-width: ${i}`
            }), n, ["tbody", 0]]
        },
        addCommands() {
            return {
                insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: r, dispatch: i, editor: s }) => {
                    const o = OK(s.schema, t, e, n);
                    if (i) {
                        const a = r.selection.from + 1;
                        r.replaceSelectionWith(o).scrollIntoView().setSelection(De.near(r.doc.resolve(a)))
                    }
                    return !0
                }
                ,
                addColumnBefore: () => ({ state: t, dispatch: e }) => VU(t, e),
                addColumnAfter: () => ({ state: t, dispatch: e }) => WU(t, e),
                deleteColumn: () => ({ state: t, dispatch: e }) => KU(t, e),
                addRowBefore: () => ({ state: t, dispatch: e }) => GU(t, e),
                addRowAfter: () => ({ state: t, dispatch: e }) => JU(t, e),
                deleteRow: () => ({ state: t, dispatch: e }) => YU(t, e),
                deleteTable: () => ({ state: t, dispatch: e }) => iK(t, e),
                mergeCells: () => ({ state: t, dispatch: e }) => P3(t, e),
                splitCell: () => ({ state: t, dispatch: e }) => N3(t, e),
                toggleHeaderColumn: () => ({ state: t, dispatch: e }) => Vc("column")(t, e),
                toggleHeaderRow: () => ({ state: t, dispatch: e }) => Vc("row")(t, e),
                toggleHeaderCell: () => ({ state: t, dispatch: e }) => nK(t, e),
                mergeOrSplit: () => ({ state: t, dispatch: e }) => P3(t, e) ? !0 : N3(t, e),
                setCellAttribute: (t, e) => ({ state: n, dispatch: r }) => eK(t, e)(n, r),
                goToNextCell: () => ({ state: t, dispatch: e }) => L3(1)(t, e),
                goToPreviousCell: () => ({ state: t, dispatch: e }) => L3(-1)(t, e),
                fixTables: () => ({ state: t, dispatch: e }) => (e && lA(t),
                    !0),
                setCellSelection: t => ({ tr: e, dispatch: n }) => {
                    if (n) {
                        const r = Ut.create(e.doc, t.anchorCell, t.headCell);
                        e.setSelection(r)
                    }
                    return !0
                }
            }
        },
        addKeyboardShortcuts() {
            return {
                Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
                "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
                Backspace: Jf,
                "Mod-Backspace": Jf,
                Delete: Jf,
                "Mod-Delete": Jf
            }
        },
        addProseMirrorPlugins() {
            return [...this.options.resizable && this.editor.isEditable ? [pK({
                handleWidth: this.options.handleWidth,
                cellMinWidth: this.options.cellMinWidth,
                View: this.options.View,
                lastColumnResizable: this.options.lastColumnResizable
            })] : [], CK({
                allowTableNodeSelection: this.options.allowTableNodeSelection
            })]
        },
        extendNodeSchema(t) {
            const e = {
                name: t.name,
                options: t.options,
                storage: t.storage
            };
            return {
                tableRole: ht(Me(t, "tableRole", e))
            }
        }
    })
    , fee = mn.create({
        name: "tableCell",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        content: "block+",
        addAttributes() {
            return {
                colspan: {
                    default: 1
                },
                rowspan: {
                    default: 1
                },
                colwidth: {
                    default: null,
                    parseHTML: t => {
                        const e = t.getAttribute("colwidth");
                        return e ? [parseInt(e, 10)] : null
                    }
                }
            }
        },
        tableRole: "cell",
        isolating: !0,
        parseHTML() {
            return [{
                tag: "td"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["td", Tt(this.options.HTMLAttributes, t), 0]
        }
    })
    , hee = mn.create({
        name: "tableHeader",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        content: "block+",
        addAttributes() {
            return {
                colspan: {
                    default: 1
                },
                rowspan: {
                    default: 1
                },
                colwidth: {
                    default: null,
                    parseHTML: t => {
                        const e = t.getAttribute("colwidth");
                        return e ? [parseInt(e, 10)] : null
                    }
                }
            }
        },
        tableRole: "header_cell",
        isolating: !0,
        parseHTML() {
            return [{
                tag: "th"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["th", Tt(this.options.HTMLAttributes, t), 0]
        }
    })
    , pee = mn.create({
        name: "tableRow",
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        content: "(tableCell | tableHeader)*",
        tableRole: "row",
        parseHTML() {
            return [{
                tag: "tr"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["tr", Tt(this.options.HTMLAttributes, t), 0]
        }
    })
    , W3 = t => new Promise(e => {
        let n = new FileReader;
        n.onloadend = () => {
            e(n.result)
        }
            ,
            n.readAsDataURL(t)
    }
    )
    , RK = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/
    , mee = mn.create({
        name: "image",
        addOptions() {
            return {
                inline: !1,
                HTMLAttributes: {}
            }
        },
        inline() {
            return this.options.inline
        },
        group() {
            return this.options.inline ? "inline" : "block"
        },
        draggable: !0,
        addAttributes() {
            return {
                src: {
                    default: null
                },
                alt: {
                    default: null
                },
                title: {
                    default: null
                }
            }
        },
        parseHTML() {
            return [{
                tag: "img[src]"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["img", Tt(this.options.HTMLAttributes, t)]
        },
        addCommands() {
            return {
                setImage: t => ({ commands: e }) => e.insertContent({
                    type: this.name,
                    attrs: t
                })
            }
        },
        addInputRules() {
            return [QT({
                find: RK,
                type: this.type,
                getAttributes: t => {
                    const [, , e, n, r] = t;
                    return {
                        src: n,
                        alt: e,
                        title: r
                    }
                }
            })]
        },
        addProseMirrorPlugins() {
            return [PK()]
        }
    })
    , PK = () => new sn({
        props: {
            handlePaste(t, e, n) {
                const r = Array.from(e.clipboardData?.items || [])
                    , { schema: i } = t.state;
                return r.forEach(s => {
                    const o = s.getAsFile();
                    o && s.type.indexOf("image") === 0 && (e.preventDefault(),
                        W3(o).then(a => {
                            const l = i.nodes.image.create({
                                src: a
                            })
                                , c = t.state.tr.replaceSelectionWith(l);
                            t.dispatch(c)
                        }
                        ))
                }
                ),
                    !1
            },
            handleDOMEvents: {
                drop: (t, e) => {
                    if (!(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length))
                        return !1;
                    const r = Array.from(e.dataTransfer?.files ?? []).filter(o => /image/i.test(o.type));
                    if (r.length === 0)
                        return !1;
                    e.preventDefault();
                    const { schema: i } = t.state
                        , s = t.posAtCoords({
                            left: e.clientX,
                            top: e.clientY
                        });
                    return s ? (r.forEach(async o => {
                        W3(o).then(a => {
                            const l = i.nodes.image.create({
                                src: a
                            })
                                , c = t.state.tr.insert(s.pos, l);
                            t.dispatch(c)
                        }
                        )
                    }
                    ),
                        !0) : !1
                }
            }
        }
    })
    , gee = mn.create({
        name: "video",
        group: "block",
        selectable: !0,
        draggable: !0,
        atom: !0,
        addAttributes() {
            return {
                src: {
                    default: null
                }
            }
        },
        parseHTML() {
            return [{
                tag: "video"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["video", Tt(t)]
        },
        addNodeView() {
            return ({ editor: t, node: e }) => {
                const n = document.createElement("div");
                n.className = "relative aspect-w-16 aspect-h-9" + (t.isEditable ? " cursor-pointer" : "");
                const r = document.createElement("video");
                if (t.isEditable && (r.className = "pointer-events-none"),
                    r.src = e.attrs.src,
                    !t.isEditable)
                    r.setAttribute("controls", "");
                else {
                    let i = document.createElement("div");
                    i.className = "absolute top-0 right-0 text-xs m-2 bg-gray-800 text-white px-2 py-1 rounded-md",
                        i.innerHTML = "Video",
                        n.append(i)
                }
                return n.append(r),
                {
                    dom: n
                }
            }
        }
    })
    , NK = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2"
    , IK = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222"
    , su = (t, e) => {
        for (const n in e)
            t[n] = e[n];
        return t
    }
    , iy = "numeric"
    , sy = "ascii"
    , oy = "alpha"
    , yh = "asciinumeric"
    , Zf = "alphanumeric"
    , ay = "domain"
    , hA = "emoji"
    , LK = "scheme"
    , DK = "slashscheme"
    , U3 = "whitespace";
function jK(t, e) {
    return t in e || (e[t] = []),
        e[t]
}
function ma(t, e, n) {
    e[iy] && (e[yh] = !0,
        e[Zf] = !0),
        e[sy] && (e[yh] = !0,
            e[oy] = !0),
        e[yh] && (e[Zf] = !0),
        e[oy] && (e[Zf] = !0),
        e[Zf] && (e[ay] = !0),
        e[hA] && (e[ay] = !0);
    for (const r in e) {
        const i = jK(r, n);
        i.indexOf(t) < 0 && i.push(t)
    }
}
function BK(t, e) {
    const n = {};
    for (const r in e)
        e[r].indexOf(t) >= 0 && (n[r] = !0);
    return n
}
function Sr(t) {
    t === void 0 && (t = null),
        this.j = {},
        this.jr = [],
        this.jd = null,
        this.t = t
}
Sr.groups = {};
Sr.prototype = {
    accepts() {
        return !!this.t
    },
    go(t) {
        const e = this
            , n = e.j[t];
        if (n)
            return n;
        for (let r = 0; r < e.jr.length; r++) {
            const i = e.jr[r][0]
                , s = e.jr[r][1];
            if (s && i.test(t))
                return s
        }
        return e.jd
    },
    has(t, e) {
        return e === void 0 && (e = !1),
            e ? t in this.j : !!this.go(t)
    },
    ta(t, e, n, r) {
        for (let i = 0; i < t.length; i++)
            this.tt(t[i], e, n, r)
    },
    tr(t, e, n, r) {
        r = r || Sr.groups;
        let i;
        return e && e.j ? i = e : (i = new Sr(e),
            n && r && ma(e, n, r)),
            this.jr.push([t, i]),
            i
    },
    ts(t, e, n, r) {
        let i = this;
        const s = t.length;
        if (!s)
            return i;
        for (let o = 0; o < s - 1; o++)
            i = i.tt(t[o]);
        return i.tt(t[s - 1], e, n, r)
    },
    tt(t, e, n, r) {
        r = r || Sr.groups;
        const i = this;
        if (e && e.j)
            return i.j[t] = e,
                e;
        const s = e;
        let o, a = i.go(t);
        if (a ? (o = new Sr,
            su(o.j, a.j),
            o.jr.push.apply(o.jr, a.jr),
            o.jd = a.jd,
            o.t = a.t) : o = new Sr,
            s) {
            if (r)
                if (o.t && typeof o.t == "string") {
                    const l = su(BK(o.t, r), n);
                    ma(s, l, r)
                } else
                    n && ma(s, n, r);
            o.t = s
        }
        return i.j[t] = o,
            o
    }
};
const ct = (t, e, n, r, i) => t.ta(e, n, r, i)
    , Xr = (t, e, n, r, i) => t.tr(e, n, r, i)
    , K3 = (t, e, n, r, i) => t.ts(e, n, r, i)
    , ye = (t, e, n, r, i) => t.tt(e, n, r, i)
    , Cs = "WORD"
    , ly = "UWORD"
    , Wc = "LOCALHOST"
    , uy = "TLD"
    , cy = "UTLD"
    , vh = "SCHEME"
    , kl = "SLASH_SCHEME"
    , $v = "NUM"
    , pA = "WS"
    , zv = "NL"
    , yc = "OPENBRACE"
    , vc = "CLOSEBRACE"
    , op = "OPENBRACKET"
    , ap = "CLOSEBRACKET"
    , lp = "OPENPAREN"
    , up = "CLOSEPAREN"
    , cp = "OPENANGLEBRACKET"
    , dp = "CLOSEANGLEBRACKET"
    , fp = "FULLWIDTHLEFTPAREN"
    , hp = "FULLWIDTHRIGHTPAREN"
    , pp = "LEFTCORNERBRACKET"
    , mp = "RIGHTCORNERBRACKET"
    , gp = "LEFTWHITECORNERBRACKET"
    , yp = "RIGHTWHITECORNERBRACKET"
    , vp = "FULLWIDTHLESSTHAN"
    , bp = "FULLWIDTHGREATERTHAN"
    , wp = "AMPERSAND"
    , xp = "APOSTROPHE"
    , _p = "ASTERISK"
    , co = "AT"
    , Sp = "BACKSLASH"
    , kp = "BACKTICK"
    , Cp = "CARET"
    , mo = "COLON"
    , Fv = "COMMA"
    , Ep = "DOLLAR"
    , $i = "DOT"
    , Tp = "EQUALS"
    , Hv = "EXCLAMATION"
    , zi = "HYPHEN"
    , Ap = "PERCENT"
    , Op = "PIPE"
    , Mp = "PLUS"
    , Rp = "POUND"
    , Pp = "QUERY"
    , Vv = "QUOTE"
    , Wv = "SEMI"
    , Fi = "SLASH"
    , bc = "TILDE"
    , Np = "UNDERSCORE"
    , mA = "EMOJI"
    , Ip = "SYM";
var gA = Object.freeze({
    __proto__: null,
    WORD: Cs,
    UWORD: ly,
    LOCALHOST: Wc,
    TLD: uy,
    UTLD: cy,
    SCHEME: vh,
    SLASH_SCHEME: kl,
    NUM: $v,
    WS: pA,
    NL: zv,
    OPENBRACE: yc,
    CLOSEBRACE: vc,
    OPENBRACKET: op,
    CLOSEBRACKET: ap,
    OPENPAREN: lp,
    CLOSEPAREN: up,
    OPENANGLEBRACKET: cp,
    CLOSEANGLEBRACKET: dp,
    FULLWIDTHLEFTPAREN: fp,
    FULLWIDTHRIGHTPAREN: hp,
    LEFTCORNERBRACKET: pp,
    RIGHTCORNERBRACKET: mp,
    LEFTWHITECORNERBRACKET: gp,
    RIGHTWHITECORNERBRACKET: yp,
    FULLWIDTHLESSTHAN: vp,
    FULLWIDTHGREATERTHAN: bp,
    AMPERSAND: wp,
    APOSTROPHE: xp,
    ASTERISK: _p,
    AT: co,
    BACKSLASH: Sp,
    BACKTICK: kp,
    CARET: Cp,
    COLON: mo,
    COMMA: Fv,
    DOLLAR: Ep,
    DOT: $i,
    EQUALS: Tp,
    EXCLAMATION: Hv,
    HYPHEN: zi,
    PERCENT: Ap,
    PIPE: Op,
    PLUS: Mp,
    POUND: Rp,
    QUERY: Pp,
    QUOTE: Vv,
    SEMI: Wv,
    SLASH: Fi,
    TILDE: bc,
    UNDERSCORE: Np,
    EMOJI: mA,
    SYM: Ip
});
const yl = /[a-z]/
    , z0 = /\p{L}/u
    , F0 = /\p{Emoji}/u
    , H0 = /\d/
    , q3 = /\s/
    , G3 = `
`
    , $K = ""
    , zK = "";
let Yf = null
    , Xf = null;
function FK(t) {
    t === void 0 && (t = []);
    const e = {};
    Sr.groups = e;
    const n = new Sr;
    Yf == null && (Yf = J3(NK)),
        Xf == null && (Xf = J3(IK)),
        ye(n, "'", xp),
        ye(n, "{", yc),
        ye(n, "}", vc),
        ye(n, "[", op),
        ye(n, "]", ap),
        ye(n, "(", lp),
        ye(n, ")", up),
        ye(n, "<", cp),
        ye(n, ">", dp),
        ye(n, "", fp),
        ye(n, "", hp),
        ye(n, "", pp),
        ye(n, "", mp),
        ye(n, "", gp),
        ye(n, "", yp),
        ye(n, "", vp),
        ye(n, "", bp),
        ye(n, "&", wp),
        ye(n, "*", _p),
        ye(n, "@", co),
        ye(n, "`", kp),
        ye(n, "^", Cp),
        ye(n, ":", mo),
        ye(n, ",", Fv),
        ye(n, "$", Ep),
        ye(n, ".", $i),
        ye(n, "=", Tp),
        ye(n, "!", Hv),
        ye(n, "-", zi),
        ye(n, "%", Ap),
        ye(n, "|", Op),
        ye(n, "+", Mp),
        ye(n, "#", Rp),
        ye(n, "?", Pp),
        ye(n, '"', Vv),
        ye(n, "/", Fi),
        ye(n, ";", Wv),
        ye(n, "~", bc),
        ye(n, "_", Np),
        ye(n, "\\", Sp);
    const r = Xr(n, H0, $v, {
        [iy]: !0
    });
    Xr(r, H0, r);
    const i = Xr(n, yl, Cs, {
        [sy]: !0
    });
    Xr(i, yl, i);
    const s = Xr(n, z0, ly, {
        [oy]: !0
    });
    Xr(s, yl),
        Xr(s, z0, s);
    const o = Xr(n, q3, pA, {
        [U3]: !0
    });
    ye(n, G3, zv, {
        [U3]: !0
    }),
        ye(o, G3),
        Xr(o, q3, o);
    const a = Xr(n, F0, mA, {
        [hA]: !0
    });
    Xr(a, F0, a),
        ye(a, $K, a);
    const l = ye(a, zK);
    Xr(l, F0, a);
    const c = [[yl, i]]
        , d = [[yl, null], [z0, s]];
    for (let h = 0; h < Yf.length; h++)
        Qs(n, Yf[h], uy, Cs, c);
    for (let h = 0; h < Xf.length; h++)
        Qs(n, Xf[h], cy, ly, d);
    ma(uy, {
        tld: !0,
        ascii: !0
    }, e),
        ma(cy, {
            utld: !0,
            alpha: !0
        }, e),
        Qs(n, "file", vh, Cs, c),
        Qs(n, "mailto", vh, Cs, c),
        Qs(n, "http", kl, Cs, c),
        Qs(n, "https", kl, Cs, c),
        Qs(n, "ftp", kl, Cs, c),
        Qs(n, "ftps", kl, Cs, c),
        ma(vh, {
            scheme: !0,
            ascii: !0
        }, e),
        ma(kl, {
            slashscheme: !0,
            ascii: !0
        }, e),
        t = t.sort((h, p) => h[0] > p[0] ? 1 : -1);
    for (let h = 0; h < t.length; h++) {
        const p = t[h][0]
            , y = t[h][1] ? {
                [LK]: !0
            } : {
                [DK]: !0
            };
        p.indexOf("-") >= 0 ? y[ay] = !0 : yl.test(p) ? H0.test(p) ? y[yh] = !0 : y[sy] = !0 : y[iy] = !0,
            K3(n, p, p, y)
    }
    return K3(n, "localhost", Wc, {
        ascii: !0
    }),
        n.jd = new Sr(Ip),
    {
        start: n,
        tokens: su({
            groups: e
        }, gA)
    }
}
function HK(t, e) {
    const n = VK(e.replace(/[A-Z]/g, a => a.toLowerCase()))
        , r = n.length
        , i = [];
    let s = 0
        , o = 0;
    for (; o < r;) {
        let a = t
            , l = null
            , c = 0
            , d = null
            , h = -1
            , p = -1;
        for (; o < r && (l = a.go(n[o]));)
            a = l,
                a.accepts() ? (h = 0,
                    p = 0,
                    d = a) : h >= 0 && (h += n[o].length,
                        p++),
                c += n[o].length,
                s += n[o].length,
                o++;
        s -= h,
            o -= p,
            c -= h,
            i.push({
                t: d.t,
                v: e.slice(s - c, s),
                s: s - c,
                e: s
            })
    }
    return i
}
function VK(t) {
    const e = []
        , n = t.length;
    let r = 0;
    for (; r < n;) {
        let i = t.charCodeAt(r), s, o = i < 55296 || i > 56319 || r + 1 === n || (s = t.charCodeAt(r + 1)) < 56320 || s > 57343 ? t[r] : t.slice(r, r + 2);
        e.push(o),
            r += o.length
    }
    return e
}
function Qs(t, e, n, r, i) {
    let s;
    const o = e.length;
    for (let a = 0; a < o - 1; a++) {
        const l = e[a];
        t.j[l] ? s = t.j[l] : (s = new Sr(r),
            s.jr = i.slice(),
            t.j[l] = s),
            t = s
    }
    return s = new Sr(n),
        s.jr = i.slice(),
        t.j[e[o - 1]] = s,
        s
}
function J3(t) {
    const e = []
        , n = [];
    let r = 0
        , i = "0123456789";
    for (; r < t.length;) {
        let s = 0;
        for (; i.indexOf(t[r + s]) >= 0;)
            s++;
        if (s > 0) {
            e.push(n.join(""));
            for (let o = parseInt(t.substring(r, r + s), 10); o > 0; o--)
                n.pop();
            r += s
        } else
            n.push(t[r]),
                r++
    }
    return e
}
const Uc = {
    defaultProtocol: "http",
    events: null,
    format: Z3,
    formatHref: Z3,
    nl2br: !1,
    tagName: "a",
    target: null,
    rel: null,
    validate: !0,
    truncate: 1 / 0,
    className: null,
    attributes: null,
    ignoreTags: [],
    render: null
};
function Uv(t, e) {
    e === void 0 && (e = null);
    let n = su({}, Uc);
    t && (n = su(n, t instanceof Uv ? t.o : t));
    const r = n.ignoreTags
        , i = [];
    for (let s = 0; s < r.length; s++)
        i.push(r[s].toUpperCase());
    this.o = n,
        e && (this.defaultRender = e),
        this.ignoreTags = i
}
Uv.prototype = {
    o: Uc,
    ignoreTags: [],
    defaultRender(t) {
        return t
    },
    check(t) {
        return this.get("validate", t.toString(), t)
    },
    get(t, e, n) {
        const r = e != null;
        let i = this.o[t];
        return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : Uc[t],
            typeof i == "function" && r && (i = i(e, n))) : typeof i == "function" && r && (i = i(e, n.t, n)),
            i)
    },
    getObj(t, e, n) {
        let r = this.o[t];
        return typeof r == "function" && e != null && (r = r(e, n.t, n)),
            r
    },
    render(t) {
        const e = t.render(this);
        return (this.get("render", null, t) || this.defaultRender)(e, t.t, t)
    }
};
function Z3(t) {
    return t
}
function yA(t, e) {
    this.t = "token",
        this.v = t,
        this.tk = e
}
yA.prototype = {
    isLink: !1,
    toString() {
        return this.v
    },
    toHref(t) {
        return this.toString()
    },
    toFormattedString(t) {
        const e = this.toString()
            , n = t.get("truncate", e, this)
            , r = t.get("format", e, this);
        return n && r.length > n ? r.substring(0, n) + "" : r
    },
    toFormattedHref(t) {
        return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this)
    },
    startIndex() {
        return this.tk[0].s
    },
    endIndex() {
        return this.tk[this.tk.length - 1].e
    },
    toObject(t) {
        return t === void 0 && (t = Uc.defaultProtocol),
        {
            type: this.t,
            value: this.toString(),
            isLink: this.isLink,
            href: this.toHref(t),
            start: this.startIndex(),
            end: this.endIndex()
        }
    },
    toFormattedObject(t) {
        return {
            type: this.t,
            value: this.toFormattedString(t),
            isLink: this.isLink,
            href: this.toFormattedHref(t),
            start: this.startIndex(),
            end: this.endIndex()
        }
    },
    validate(t) {
        return t.get("validate", this.toString(), this)
    },
    render(t) {
        const e = this
            , n = this.toHref(t.get("defaultProtocol"))
            , r = t.get("formatHref", n, this)
            , i = t.get("tagName", n, e)
            , s = this.toFormattedString(t)
            , o = {}
            , a = t.get("className", n, e)
            , l = t.get("target", n, e)
            , c = t.get("rel", n, e)
            , d = t.getObj("attributes", n, e)
            , h = t.getObj("events", n, e);
        return o.href = r,
            a && (o.class = a),
            l && (o.target = l),
            c && (o.rel = c),
            d && su(o, d),
        {
            tagName: i,
            attributes: o,
            content: s,
            eventListeners: h
        }
    }
};
function Rm(t, e) {
    class n extends yA {
        constructor(i, s) {
            super(i, s),
                this.t = t
        }
    }
    for (const r in e)
        n.prototype[r] = e[r];
    return n.t = t,
        n
}
const Y3 = Rm("email", {
    isLink: !0,
    toHref() {
        return "mailto:" + this.toString()
    }
})
    , X3 = Rm("text")
    , WK = Rm("nl")
    , Qf = Rm("url", {
        isLink: !0,
        toHref(t) {
            return t === void 0 && (t = Uc.defaultProtocol),
                this.hasProtocol() ? this.v : `${t}://${this.v}`
        },
        hasProtocol() {
            const t = this.tk;
            return t.length >= 2 && t[0].t !== Wc && t[1].t === mo
        }
    })
    , Qr = t => new Sr(t);
function UK(t) {
    let { groups: e } = t;
    const n = e.domain.concat([wp, _p, co, Sp, kp, Cp, Ep, Tp, zi, $v, Ap, Op, Mp, Rp, Fi, Ip, bc, Np])
        , r = [xp, mo, Fv, $i, Hv, Pp, Vv, Wv, cp, dp, yc, vc, ap, op, lp, up, fp, hp, pp, mp, gp, yp, vp, bp]
        , i = [wp, xp, _p, Sp, kp, Cp, Ep, Tp, zi, yc, vc, Ap, Op, Mp, Rp, Pp, Fi, Ip, bc, Np]
        , s = Qr()
        , o = ye(s, bc);
    ct(o, i, o),
        ct(o, e.domain, o);
    const a = Qr()
        , l = Qr()
        , c = Qr();
    ct(s, e.domain, a),
        ct(s, e.scheme, l),
        ct(s, e.slashscheme, c),
        ct(a, i, o),
        ct(a, e.domain, a);
    const d = ye(a, co);
    ye(o, co, d),
        ye(l, co, d),
        ye(c, co, d);
    const h = ye(o, $i);
    ct(h, i, o),
        ct(h, e.domain, o);
    const p = Qr();
    ct(d, e.domain, p),
        ct(p, e.domain, p);
    const g = ye(p, $i);
    ct(g, e.domain, p);
    const y = Qr(Y3);
    ct(g, e.tld, y),
        ct(g, e.utld, y),
        ye(d, Wc, y);
    const x = ye(p, zi);
    ct(x, e.domain, p),
        ct(y, e.domain, p),
        ye(y, $i, g),
        ye(y, zi, x);
    const S = ye(y, mo);
    ct(S, e.numeric, Y3);
    const k = ye(a, zi)
        , A = ye(a, $i);
    ct(k, e.domain, a),
        ct(A, i, o),
        ct(A, e.domain, a);
    const C = Qr(Qf);
    ct(A, e.tld, C),
        ct(A, e.utld, C),
        ct(C, e.domain, a),
        ct(C, i, o),
        ye(C, $i, A),
        ye(C, zi, k),
        ye(C, co, d);
    const m = ye(C, mo)
        , b = Qr(Qf);
    ct(m, e.numeric, b);
    const w = Qr(Qf)
        , T = Qr();
    ct(w, n, w),
        ct(w, r, T),
        ct(T, n, w),
        ct(T, r, T),
        ye(C, Fi, w),
        ye(b, Fi, w);
    const O = ye(l, mo)
        , M = ye(c, mo)
        , E = ye(M, Fi)
        , N = ye(E, Fi);
    ct(l, e.domain, a),
        ye(l, $i, A),
        ye(l, zi, k),
        ct(c, e.domain, a),
        ye(c, $i, A),
        ye(c, zi, k),
        ct(O, e.domain, w),
        ye(O, Fi, w),
        ct(N, e.domain, w),
        ct(N, n, w),
        ye(N, Fi, w);
    const j = [[yc, vc], [op, ap], [lp, up], [cp, dp], [fp, hp], [pp, mp], [gp, yp], [vp, bp]];
    for (let z = 0; z < j.length; z++) {
        const [V, W] = j[z]
            , P = ye(w, V);
        ye(T, V, P),
            ye(P, W, w);
        const F = Qr(Qf);
        ct(P, n, F);
        const K = Qr();
        ct(P, r),
            ct(F, n, F),
            ct(F, r, K),
            ct(K, n, F),
            ct(K, r, K),
            ye(F, W, w),
            ye(K, W, w)
    }
    return ye(s, Wc, C),
        ye(s, zv, WK),
    {
        start: s,
        tokens: gA
    }
}
function KK(t, e, n) {
    let r = n.length
        , i = 0
        , s = []
        , o = [];
    for (; i < r;) {
        let a = t
            , l = null
            , c = null
            , d = 0
            , h = null
            , p = -1;
        for (; i < r && !(l = a.go(n[i].t));)
            o.push(n[i++]);
        for (; i < r && (c = l || a.go(n[i].t));)
            l = null,
                a = c,
                a.accepts() ? (p = 0,
                    h = a) : p >= 0 && p++,
                i++,
                d++;
        if (p < 0)
            i -= d,
                i < r && (o.push(n[i]),
                    i++);
        else {
            o.length > 0 && (s.push(V0(X3, e, o)),
                o = []),
                i -= p,
                d -= p;
            const g = h.t
                , y = n.slice(i - d, i);
            s.push(V0(g, e, y))
        }
    }
    return o.length > 0 && s.push(V0(X3, e, o)),
        s
}
function V0(t, e, n) {
    const r = n[0].s
        , i = n[n.length - 1].e
        , s = e.slice(r, i);
    return new t(s, n)
}
const qK = typeof console < "u" && console && console.warn || (() => { }
)
    , GK = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time."
    , Qt = {
        scanner: null,
        parser: null,
        tokenQueue: [],
        pluginQueue: [],
        customSchemes: [],
        initialized: !1
    };
function JK() {
    Sr.groups = {},
        Qt.scanner = null,
        Qt.parser = null,
        Qt.tokenQueue = [],
        Qt.pluginQueue = [],
        Qt.customSchemes = [],
        Qt.initialized = !1
}
function Q3(t, e) {
    if (e === void 0 && (e = !1),
        Qt.initialized && qK(`linkifyjs: already initialized - will not register custom scheme "${t}" ${GK}`),
        !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
        throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
    Qt.customSchemes.push([t, e])
}
function ZK() {
    Qt.scanner = FK(Qt.customSchemes);
    for (let t = 0; t < Qt.tokenQueue.length; t++)
        Qt.tokenQueue[t][1]({
            scanner: Qt.scanner
        });
    Qt.parser = UK(Qt.scanner.tokens);
    for (let t = 0; t < Qt.pluginQueue.length; t++)
        Qt.pluginQueue[t][1]({
            scanner: Qt.scanner,
            parser: Qt.parser
        });
    Qt.initialized = !0
}
function vA(t) {
    return Qt.initialized || ZK(),
        KK(Qt.parser.start, t, HK(Qt.scanner.start, t))
}
function bA(t, e, n) {
    if (e === void 0 && (e = null),
        n === void 0 && (n = null),
        e && typeof e == "object") {
        if (n)
            throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
        n = e,
            e = null
    }
    const r = new Uv(n)
        , i = vA(t)
        , s = [];
    for (let o = 0; o < i.length; o++) {
        const a = i[o];
        a.isLink && (!e || a.t === e) && r.check(a) && s.push(a.toFormattedObject(r))
    }
    return s
}
function YK(t) {
    return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1
}
function XK(t) {
    return new sn({
        key: new _n("autolink"),
        appendTransaction: (e, n, r) => {
            const i = e.some(c => c.docChanged) && !n.doc.eq(r.doc)
                , s = e.some(c => c.getMeta("preventAutolink"));
            if (!i || s)
                return;
            const { tr: o } = r
                , a = HV(n.doc, [...e]);
            if (ZV(a).forEach(({ newRange: c }) => {
                const d = WV(r.doc, c, g => g.isTextblock);
                let h, p;
                if (d.length > 1 ? (h = d[0],
                    p = r.doc.textBetween(h.pos, h.pos + h.node.nodeSize, void 0, " ")) : d.length && r.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (h = d[0],
                        p = r.doc.textBetween(h.pos, c.to, void 0, " ")),
                    h && p) {
                    const g = p.split(" ").filter(k => k !== "");
                    if (g.length <= 0)
                        return !1;
                    const y = g[g.length - 1]
                        , x = h.pos + p.lastIndexOf(y);
                    if (!y)
                        return !1;
                    const S = vA(y).map(k => k.toObject(t.defaultProtocol));
                    if (!YK(S))
                        return !1;
                    S.filter(k => k.isLink).map(k => ({
                        ...k,
                        from: x + k.start + 1,
                        to: x + k.end + 1
                    })).filter(k => r.schema.marks.code ? !r.doc.rangeHasMark(k.from, k.to, r.schema.marks.code) : !0).filter(k => t.validate(k.value)).forEach(k => {
                        Dv(k.from, k.to, r.doc).some(A => A.mark.type === t.type) || o.addMark(k.from, k.to, t.type.create({
                            href: k.href
                        }))
                    }
                    )
                }
            }
            ),
                !!o.steps.length)
                return o
        }
    })
}
function QK(t) {
    return new sn({
        key: new _n("handleClickLink"),
        props: {
            handleClick: (e, n, r) => {
                var i, s;
                if (r.button !== 0 || !e.editable)
                    return !1;
                let o = r.target;
                const a = [];
                for (; o.nodeName !== "DIV";)
                    a.push(o),
                        o = o.parentNode;
                if (!a.find(p => p.nodeName === "A"))
                    return !1;
                const l = XT(e.state, t.type.name)
                    , c = r.target
                    , d = (i = c?.href) !== null && i !== void 0 ? i : l.href
                    , h = (s = c?.target) !== null && s !== void 0 ? s : l.target;
                return c && d ? (window.open(d, h),
                    !0) : !1
            }
        }
    })
}
function eq(t) {
    return new sn({
        key: new _n("handlePasteLink"),
        props: {
            handlePaste: (e, n, r) => {
                const { state: i } = e
                    , { selection: s } = i
                    , { empty: o } = s;
                if (o)
                    return !1;
                let a = "";
                r.content.forEach(c => {
                    a += c.textContent
                }
                );
                const l = bA(a, {
                    defaultProtocol: t.defaultProtocol
                }).find(c => c.isLink && c.value === a);
                return !a || !l ? !1 : (t.editor.commands.setMark(t.type, {
                    href: l.href
                }),
                    !0)
            }
        }
    })
}
const tq = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function eS(t, e) {
    const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
    return e && e.forEach(r => {
        const i = typeof r == "string" ? r : r.scheme;
        i && n.push(i)
    }
    ),
        !t || t.replace(tq, "").match(new RegExp(`^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`, "i"))
}
const yee = Fr.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: !1,
    exitable: !0,
    onCreate() {
        this.options.protocols.forEach(t => {
            if (typeof t == "string") {
                Q3(t);
                return
            }
            Q3(t.scheme, t.optionalSlashes)
        }
        )
    },
    onDestroy() {
        JK()
    },
    inclusive() {
        return this.options.autolink
    },
    addOptions() {
        return {
            openOnClick: !0,
            linkOnPaste: !0,
            autolink: !0,
            protocols: [],
            defaultProtocol: "http",
            HTMLAttributes: {
                target: "_blank",
                rel: "noopener noreferrer nofollow",
                class: null
            },
            validate: t => !!t
        }
    },
    addAttributes() {
        return {
            href: {
                default: null,
                parseHTML(t) {
                    return t.getAttribute("href")
                }
            },
            target: {
                default: this.options.HTMLAttributes.target
            },
            rel: {
                default: this.options.HTMLAttributes.rel
            },
            class: {
                default: this.options.HTMLAttributes.class
            }
        }
    },
    parseHTML() {
        return [{
            tag: "a[href]",
            getAttrs: t => {
                const e = t.getAttribute("href");
                return !e || !eS(e, this.options.protocols) ? !1 : null
            }
        }]
    },
    renderHTML({ HTMLAttributes: t }) {
        return eS(t.href, this.options.protocols) ? ["a", Tt(this.options.HTMLAttributes, t), 0] : ["a", Tt(this.options.HTMLAttributes, {
            ...t,
            href: ""
        }), 0]
    },
    addCommands() {
        return {
            setLink: t => ({ chain: e }) => e().setMark(this.name, t).setMeta("preventAutolink", !0).run(),
            toggleLink: t => ({ chain: e }) => e().toggleMark(this.name, t, {
                extendEmptyMarkRange: !0
            }).setMeta("preventAutolink", !0).run(),
            unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, {
                extendEmptyMarkRange: !0
            }).setMeta("preventAutolink", !0).run()
        }
    },
    addPasteRules() {
        return [Io({
            find: t => {
                const e = [];
                if (t) {
                    const { validate: n } = this.options
                        , r = bA(t).filter(i => i.isLink && n(i.value));
                    r.length && r.forEach(i => e.push({
                        text: i.value,
                        data: {
                            href: i.href
                        },
                        index: i.start
                    }))
                }
                return e
            }
            ,
            type: this.type,
            getAttributes: t => {
                var e;
                return {
                    href: (e = t.data) === null || e === void 0 ? void 0 : e.href
                }
            }
        })]
    },
    addProseMirrorPlugins() {
        const t = [];
        return this.options.autolink && t.push(XK({
            type: this.type,
            defaultProtocol: this.options.defaultProtocol,
            validate: this.options.validate
        })),
            this.options.openOnClick === !0 && t.push(QK({
                type: this.type
            })),
            this.options.linkOnPaste && t.push(eq({
                editor: this.editor,
                defaultProtocol: this.options.defaultProtocol,
                type: this.type
            })),
            t
    }
})
    , nq = t => on({
        find: /--$/,
        replace: t ?? ""
    })
    , rq = t => on({
        find: /\.\.\.$/,
        replace: t ?? ""
    })
    , iq = t => on({
        find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
        replace: t ?? ""
    })
    , sq = t => on({
        find: /"$/,
        replace: t ?? ""
    })
    , oq = t => on({
        find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
        replace: t ?? ""
    })
    , aq = t => on({
        find: /'$/,
        replace: t ?? ""
    })
    , lq = t => on({
        find: /<-$/,
        replace: t ?? ""
    })
    , uq = t => on({
        find: /->$/,
        replace: t ?? ""
    })
    , cq = t => on({
        find: /\(c\)$/,
        replace: t ?? ""
    })
    , dq = t => on({
        find: /\(tm\)$/,
        replace: t ?? ""
    })
    , fq = t => on({
        find: /\(sm\)$/,
        replace: t ?? ""
    })
    , hq = t => on({
        find: /\(r\)$/,
        replace: t ?? ""
    })
    , pq = t => on({
        find: /(?:^|\s)(1\/2)\s$/,
        replace: t ?? ""
    })
    , mq = t => on({
        find: /\+\/-$/,
        replace: t ?? ""
    })
    , gq = t => on({
        find: /!=$/,
        replace: t ?? ""
    })
    , yq = t => on({
        find: /<<$/,
        replace: t ?? ""
    })
    , vq = t => on({
        find: />>$/,
        replace: t ?? ""
    })
    , bq = t => on({
        find: /\d+\s?([*x])\s?\d+$/,
        replace: t ?? ""
    })
    , wq = t => on({
        find: /\^2$/,
        replace: t ?? ""
    })
    , xq = t => on({
        find: /\^3$/,
        replace: t ?? ""
    })
    , _q = t => on({
        find: /(?:^|\s)(1\/4)\s$/,
        replace: t ?? ""
    })
    , Sq = t => on({
        find: /(?:^|\s)(3\/4)\s$/,
        replace: t ?? ""
    })
    , vee = Vn.create({
        name: "typography",
        addOptions() {
            return {
                closeDoubleQuote: "",
                closeSingleQuote: "",
                copyright: "",
                ellipsis: "",
                emDash: "",
                laquo: "",
                leftArrow: "",
                multiplication: "",
                notEqual: "",
                oneHalf: "",
                oneQuarter: "",
                openDoubleQuote: "",
                openSingleQuote: "",
                plusMinus: "",
                raquo: "",
                registeredTrademark: "",
                rightArrow: "",
                servicemark: "",
                superscriptThree: "",
                superscriptTwo: "",
                threeQuarters: "",
                trademark: ""
            }
        },
        addInputRules() {
            const t = [];
            return this.options.emDash !== !1 && t.push(nq(this.options.emDash)),
                this.options.ellipsis !== !1 && t.push(rq(this.options.ellipsis)),
                this.options.openDoubleQuote !== !1 && t.push(iq(this.options.openDoubleQuote)),
                this.options.closeDoubleQuote !== !1 && t.push(sq(this.options.closeDoubleQuote)),
                this.options.openSingleQuote !== !1 && t.push(oq(this.options.openSingleQuote)),
                this.options.closeSingleQuote !== !1 && t.push(aq(this.options.closeSingleQuote)),
                this.options.leftArrow !== !1 && t.push(lq(this.options.leftArrow)),
                this.options.rightArrow !== !1 && t.push(uq(this.options.rightArrow)),
                this.options.copyright !== !1 && t.push(cq(this.options.copyright)),
                this.options.trademark !== !1 && t.push(dq(this.options.trademark)),
                this.options.servicemark !== !1 && t.push(fq(this.options.servicemark)),
                this.options.registeredTrademark !== !1 && t.push(hq(this.options.registeredTrademark)),
                this.options.oneHalf !== !1 && t.push(pq(this.options.oneHalf)),
                this.options.plusMinus !== !1 && t.push(mq(this.options.plusMinus)),
                this.options.notEqual !== !1 && t.push(gq(this.options.notEqual)),
                this.options.laquo !== !1 && t.push(yq(this.options.laquo)),
                this.options.raquo !== !1 && t.push(vq(this.options.raquo)),
                this.options.multiplication !== !1 && t.push(bq(this.options.multiplication)),
                this.options.superscriptTwo !== !1 && t.push(wq(this.options.superscriptTwo)),
                this.options.superscriptThree !== !1 && t.push(xq(this.options.superscriptThree)),
                this.options.oneQuarter !== !1 && t.push(_q(this.options.oneQuarter)),
                this.options.threeQuarters !== !1 && t.push(Sq(this.options.threeQuarters)),
                t
        }
    })
    , bee = Fr.create({
        name: "textStyle",
        priority: 101,
        addOptions() {
            return {
                HTMLAttributes: {}
            }
        },
        parseHTML() {
            return [{
                tag: "span",
                getAttrs: t => t.hasAttribute("style") ? {} : !1
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["span", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
                    const n = Cd(t, this.type);
                    return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name)
                }
            }
        }
    })
    , kq = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/
    , Cq = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g
    , wee = Fr.create({
        name: "highlight",
        addOptions() {
            return {
                multicolor: !1,
                HTMLAttributes: {}
            }
        },
        addAttributes() {
            return this.options.multicolor ? {
                color: {
                    default: null,
                    parseHTML: t => t.getAttribute("data-color") || t.style.backgroundColor,
                    renderHTML: t => t.color ? {
                        "data-color": t.color,
                        style: `background-color: ${t.color}; color: inherit`
                    } : {}
                }
            } : {}
        },
        parseHTML() {
            return [{
                tag: "mark"
            }]
        },
        renderHTML({ HTMLAttributes: t }) {
            return ["mark", Tt(this.options.HTMLAttributes, t), 0]
        },
        addCommands() {
            return {
                setHighlight: t => ({ commands: e }) => e.setMark(this.name, t),
                toggleHighlight: t => ({ commands: e }) => e.toggleMark(this.name, t),
                unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
            }
        },
        addKeyboardShortcuts() {
            return {
                "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
            }
        },
        addInputRules() {
            return [Ba({
                find: kq,
                type: this.type
            })]
        },
        addPasteRules() {
            return [Io({
                find: Cq,
                type: this.type
            })]
        }
    })
    , xee = Vn.create({
        name: "color",
        addOptions() {
            return {
                types: ["textStyle"]
            }
        },
        addGlobalAttributes() {
            return [{
                types: this.options.types,
                attributes: {
                    color: {
                        default: null,
                        parseHTML: t => {
                            var e;
                            return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "")
                        }
                        ,
                        renderHTML: t => t.color ? {
                            style: `color: ${t.color}`
                        } : {}
                    }
                }
            }]
        },
        addCommands() {
            return {
                setColor: t => ({ chain: e }) => e().setMark("textStyle", {
                    color: t
                }).run(),
                unsetColor: () => ({ chain: t }) => t().setMark("textStyle", {
                    color: null
                }).removeEmptyTextStyle().run()
            }
        }
    });
function Eq(t) {
    var e;
    const { char: n, allowSpaces: r, allowedPrefixes: i, startOfLine: s, $position: o } = t
        , a = AW(n)
        , l = new RegExp(`\\s${a}$`)
        , c = s ? "^" : ""
        , d = r ? new RegExp(`${c}${a}.*?(?=\\s${a}|$)`, "gm") : new RegExp(`${c}(?:^)?${a}[^\\s${a}]*`, "gm")
        , h = ((e = o.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && o.nodeBefore.text;
    if (!h)
        return null;
    const p = o.pos - h.length
        , g = Array.from(h.matchAll(d)).pop();
    if (!g || g.input === void 0 || g.index === void 0)
        return null;
    const y = g.input.slice(Math.max(0, g.index - 1), g.index)
        , x = new RegExp(`^[${i?.join("")}\0]?$`).test(y);
    if (i !== null && !x)
        return null;
    const S = p + g.index;
    let k = S + g[0].length;
    return r && l.test(h.slice(k - 1, k + 1)) && (g[0] += " ",
        k += 1),
        S < o.pos && k >= o.pos ? {
            range: {
                from: S,
                to: k
            },
            query: g[0].slice(n.length),
            text: g[0]
        } : null
}
const Tq = new _n("suggestion");
function Aq({ pluginKey: t = Tq, editor: e, char: n = "@", allowSpaces: r = !1, allowedPrefixes: i = [" "], startOfLine: s = !1, decorationTag: o = "span", decorationClass: a = "suggestion", command: l = () => null, items: c = () => [], render: d = () => ({}), allow: h = () => !0, findSuggestionMatch: p = Eq }) {
    let g;
    const y = d?.()
        , x = new sn({
            key: t,
            view() {
                return {
                    update: async (S, k) => {
                        var A, C, m, b, w, T, O;
                        const M = (A = this.key) === null || A === void 0 ? void 0 : A.getState(k)
                            , E = (C = this.key) === null || C === void 0 ? void 0 : C.getState(S.state)
                            , N = M.active && E.active && M.range.from !== E.range.from
                            , j = !M.active && E.active
                            , z = M.active && !E.active
                            , V = !j && !z && M.query !== E.query
                            , W = j || N && V
                            , P = V || N
                            , F = z || N && V;
                        if (!W && !P && !F)
                            return;
                        const K = F && !W ? M : E
                            , re = S.dom.querySelector(`[data-decoration-id="${K.decorationId}"]`);
                        g = {
                            editor: e,
                            range: K.range,
                            query: K.query,
                            text: K.text,
                            items: [],
                            command: Te => l({
                                editor: e,
                                range: K.range,
                                props: Te
                            }),
                            decorationNode: re,
                            clientRect: re ? () => {
                                var Te;
                                const { decorationId: ee } = (Te = this.key) === null || Te === void 0 ? void 0 : Te.getState(e.state)
                                    , Se = S.dom.querySelector(`[data-decoration-id="${ee}"]`);
                                return Se?.getBoundingClientRect() || null
                            }
                                : null
                        },
                            W && ((m = y?.onBeforeStart) === null || m === void 0 || m.call(y, g)),
                            P && ((b = y?.onBeforeUpdate) === null || b === void 0 || b.call(y, g)),
                            (P || W) && (g.items = await c({
                                editor: e,
                                query: K.query
                            })),
                            F && ((w = y?.onExit) === null || w === void 0 || w.call(y, g)),
                            P && ((T = y?.onUpdate) === null || T === void 0 || T.call(y, g)),
                            W && ((O = y?.onStart) === null || O === void 0 || O.call(y, g))
                    }
                    ,
                    destroy: () => {
                        var S;
                        g && ((S = y?.onExit) === null || S === void 0 || S.call(y, g))
                    }
                }
            },
            state: {
                init() {
                    return {
                        active: !1,
                        range: {
                            from: 0,
                            to: 0
                        },
                        query: null,
                        text: null,
                        composing: !1
                    }
                },
                apply(S, k, A, C) {
                    const { isEditable: m } = e
                        , { composing: b } = e.view
                        , { selection: w } = S
                        , { empty: T, from: O } = w
                        , M = {
                            ...k
                        };
                    if (M.composing = b,
                        m && (T || e.view.composing)) {
                        (O < k.range.from || O > k.range.to) && !b && !k.composing && (M.active = !1);
                        const E = p({
                            char: n,
                            allowSpaces: r,
                            allowedPrefixes: i,
                            startOfLine: s,
                            $position: w.$from
                        })
                            , N = `id_${Math.floor(Math.random() * 4294967295)}`;
                        E && h({
                            editor: e,
                            state: C,
                            range: E.range,
                            isActive: k.active
                        }) ? (M.active = !0,
                            M.decorationId = k.decorationId ? k.decorationId : N,
                            M.range = E.range,
                            M.query = E.query,
                            M.text = E.text) : M.active = !1
                    } else
                        M.active = !1;
                    return M.active || (M.decorationId = null,
                        M.range = {
                            from: 0,
                            to: 0
                        },
                        M.query = null,
                        M.text = null),
                        M
                }
            },
            props: {
                handleKeyDown(S, k) {
                    var A;
                    const { active: C, range: m } = x.getState(S.state);
                    return C && ((A = y?.onKeyDown) === null || A === void 0 ? void 0 : A.call(y, {
                        view: S,
                        event: k,
                        range: m
                    })) || !1
                },
                decorations(S) {
                    const { active: k, range: A, decorationId: C } = x.getState(S);
                    return k ? Zt.create(S.doc, [Xn.inline(A.from, A.to, {
                        nodeName: o,
                        class: a,
                        "data-decoration-id": C
                    })]) : null
                }
            }
        });
    return x
}
const Oq = new _n("mention")
    , _ee = mn.create({
        name: "mention",
        addOptions() {
            return {
                HTMLAttributes: {},
                renderText({ options: t, node: e }) {
                    var n;
                    return `${t.suggestion.char}${(n = e.attrs.label) !== null && n !== void 0 ? n : e.attrs.id}`
                },
                deleteTriggerWithBackspace: !1,
                renderHTML({ options: t, node: e }) {
                    var n;
                    return ["span", Tt(this.HTMLAttributes, t.HTMLAttributes), `${t.suggestion.char}${(n = e.attrs.label) !== null && n !== void 0 ? n : e.attrs.id}`]
                },
                suggestion: {
                    char: "@",
                    pluginKey: Oq,
                    command: ({ editor: t, range: e, props: n }) => {
                        var r, i, s;
                        const o = t.view.state.selection.$to.nodeAfter;
                        ((r = o?.text) === null || r === void 0 ? void 0 : r.startsWith(" ")) && (e.to += 1),
                            t.chain().focus().insertContentAt(e, [{
                                type: this.name,
                                attrs: n
                            }, {
                                type: "text",
                                text: " "
                            }]).run(),
                            (s = (i = t.view.dom.ownerDocument.defaultView) === null || i === void 0 ? void 0 : i.getSelection()) === null || s === void 0 || s.collapseToEnd()
                    }
                    ,
                    allow: ({ state: t, range: e }) => {
                        const n = t.doc.resolve(e.from)
                            , r = t.schema.nodes[this.name];
                        return !!n.parent.type.contentMatch.matchType(r)
                    }
                }
            }
        },
        group: "inline",
        inline: !0,
        selectable: !1,
        atom: !0,
        addAttributes() {
            return {
                id: {
                    default: null,
                    parseHTML: t => t.getAttribute("data-id"),
                    renderHTML: t => t.id ? {
                        "data-id": t.id
                    } : {}
                },
                label: {
                    default: null,
                    parseHTML: t => t.getAttribute("data-label"),
                    renderHTML: t => t.label ? {
                        "data-label": t.label
                    } : {}
                }
            }
        },
        parseHTML() {
            return [{
                tag: `span[data-type="${this.name}"]`
            }]
        },
        renderHTML({ node: t, HTMLAttributes: e }) {
            if (this.options.renderLabel !== void 0)
                return console.warn("renderLabel is deprecated use renderText and renderHTML instead"),
                    ["span", Tt({
                        "data-type": this.name
                    }, this.options.HTMLAttributes, e), this.options.renderLabel({
                        options: this.options,
                        node: t
                    })];
            const n = {
                ...this.options
            };
            n.HTMLAttributes = Tt({
                "data-type": this.name
            }, this.options.HTMLAttributes, e);
            const r = this.options.renderHTML({
                options: n,
                node: t
            });
            return typeof r == "string" ? ["span", Tt({
                "data-type": this.name
            }, this.options.HTMLAttributes, e), r] : r
        },
        renderText({ node: t }) {
            return this.options.renderLabel !== void 0 ? (console.warn("renderLabel is deprecated use renderText and renderHTML instead"),
                this.options.renderLabel({
                    options: this.options,
                    node: t
                })) : this.options.renderText({
                    options: this.options,
                    node: t
                })
        },
        addKeyboardShortcuts() {
            return {
                Backspace: () => this.editor.commands.command(({ tr: t, state: e }) => {
                    let n = !1;
                    const { selection: r } = e
                        , { empty: i, anchor: s } = r;
                    return i ? (e.doc.nodesBetween(s - 1, s, (o, a) => {
                        if (o.type.name === this.name)
                            return n = !0,
                                t.insertText(this.options.deleteTriggerWithBackspace ? "" : this.options.suggestion.char || "", a, a + o.nodeSize),
                                !1
                    }
                    ),
                        n) : !1
                }
                )
            }
        },
        addProseMirrorPlugins() {
            return [Aq({
                editor: this.editor,
                ...this.options.suggestion
            })]
        }
    });
const Mq = "modulepreload"
    , Rq = function (t) {
        return "/assets/helpdesk/desk/" + t
    }
    , tS = {}
    , ot = function (e, n, r) {
        if (!n || n.length === 0)
            return e();
        const i = document.getElementsByTagName("link");
        return Promise.all(n.map(s => {
            if (s = Rq(s),
                s in tS)
                return;
            tS[s] = !0;
            const o = s.endsWith(".css")
                , a = o ? '[rel="stylesheet"]' : "";
            if (!!r)
                for (let d = i.length - 1; d >= 0; d--) {
                    const h = i[d];
                    if (h.href === s && (!o || h.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${s}"]${a}`))
                return;
            const c = document.createElement("link");
            if (c.rel = o ? "stylesheet" : Mq,
                o || (c.as = "script",
                    c.crossOrigin = ""),
                c.href = s,
                document.head.appendChild(c),
                o)
                return new Promise((d, h) => {
                    c.addEventListener("load", d),
                        c.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${s}`)))
                }
                )
        }
        )).then(() => e()).catch(s => {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = s,
                window.dispatchEvent(o),
                !o.defaultPrevented)
                throw s
        }
        )
    };
var wA = {
    exports: {}
};
(function (t) {
    (function () {
        function e(m) {
            var b = {
                omitExtraWLInCodeBlocks: {
                    defaultValue: !1,
                    describe: "Omit the default extra whiteline added to code blocks",
                    type: "boolean"
                },
                noHeaderId: {
                    defaultValue: !1,
                    describe: "Turn on/off generated header id",
                    type: "boolean"
                },
                prefixHeaderId: {
                    defaultValue: !1,
                    describe: "Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix",
                    type: "string"
                },
                rawPrefixHeaderId: {
                    defaultValue: !1,
                    describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
                    type: "boolean"
                },
                ghCompatibleHeaderId: {
                    defaultValue: !1,
                    describe: "Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)",
                    type: "boolean"
                },
                rawHeaderId: {
                    defaultValue: !1,
                    describe: `Remove only spaces, ' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`,
                    type: "boolean"
                },
                headerLevelStart: {
                    defaultValue: !1,
                    describe: "The header blocks level start",
                    type: "integer"
                },
                parseImgDimensions: {
                    defaultValue: !1,
                    describe: "Turn on/off image dimension parsing",
                    type: "boolean"
                },
                simplifiedAutoLink: {
                    defaultValue: !1,
                    describe: "Turn on/off GFM autolink style",
                    type: "boolean"
                },
                excludeTrailingPunctuationFromURLs: {
                    defaultValue: !1,
                    describe: "Excludes trailing punctuation from links generated with autoLinking",
                    type: "boolean"
                },
                literalMidWordUnderscores: {
                    defaultValue: !1,
                    describe: "Parse midword underscores as literal underscores",
                    type: "boolean"
                },
                literalMidWordAsterisks: {
                    defaultValue: !1,
                    describe: "Parse midword asterisks as literal asterisks",
                    type: "boolean"
                },
                strikethrough: {
                    defaultValue: !1,
                    describe: "Turn on/off strikethrough support",
                    type: "boolean"
                },
                tables: {
                    defaultValue: !1,
                    describe: "Turn on/off tables support",
                    type: "boolean"
                },
                tablesHeaderId: {
                    defaultValue: !1,
                    describe: "Add an id to table headers",
                    type: "boolean"
                },
                ghCodeBlocks: {
                    defaultValue: !0,
                    describe: "Turn on/off GFM fenced code blocks support",
                    type: "boolean"
                },
                tasklists: {
                    defaultValue: !1,
                    describe: "Turn on/off GFM tasklist support",
                    type: "boolean"
                },
                smoothLivePreview: {
                    defaultValue: !1,
                    describe: "Prevents weird effects in live previews due to incomplete input",
                    type: "boolean"
                },
                smartIndentationFix: {
                    defaultValue: !1,
                    describe: "Tries to smartly fix indentation in es6 strings",
                    type: "boolean"
                },
                disableForced4SpacesIndentedSublists: {
                    defaultValue: !1,
                    describe: "Disables the requirement of indenting nested sublists by 4 spaces",
                    type: "boolean"
                },
                simpleLineBreaks: {
                    defaultValue: !1,
                    describe: "Parses simple line breaks as <br> (GFM Style)",
                    type: "boolean"
                },
                requireSpaceBeforeHeadingText: {
                    defaultValue: !1,
                    describe: "Makes adding a space between `#` and the header text mandatory (GFM Style)",
                    type: "boolean"
                },
                ghMentions: {
                    defaultValue: !1,
                    describe: "Enables github @mentions",
                    type: "boolean"
                },
                ghMentionsLink: {
                    defaultValue: "https://github.com/{u}",
                    describe: "Changes the link generated by @mentions. Only applies if ghMentions option is enabled.",
                    type: "string"
                },
                encodeEmails: {
                    defaultValue: !0,
                    describe: "Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities",
                    type: "boolean"
                },
                openLinksInNewWindow: {
                    defaultValue: !1,
                    describe: "Open all links in new windows",
                    type: "boolean"
                },
                backslashEscapesHTMLTags: {
                    defaultValue: !1,
                    describe: "Support for HTML Tag escaping. ex: <div>foo</div>",
                    type: "boolean"
                },
                emoji: {
                    defaultValue: !1,
                    describe: "Enable emoji support. Ex: `this is a :smile: emoji`",
                    type: "boolean"
                },
                underline: {
                    defaultValue: !1,
                    describe: "Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`",
                    type: "boolean"
                },
                ellipsis: {
                    defaultValue: !0,
                    describe: "Replaces three dots with the ellipsis unicode character",
                    type: "boolean"
                },
                completeHTMLDocument: {
                    defaultValue: !1,
                    describe: "Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags",
                    type: "boolean"
                },
                metadata: {
                    defaultValue: !1,
                    describe: "Enable support for document metadata (defined at the top of the document between `` and `` or between `---` and `---`).",
                    type: "boolean"
                },
                splitAdjacentBlockquotes: {
                    defaultValue: !1,
                    describe: "Split adjacent blockquote blocks",
                    type: "boolean"
                }
            };
            if (m === !1)
                return JSON.parse(JSON.stringify(b));
            var w = {};
            for (var T in b)
                b.hasOwnProperty(T) && (w[T] = b[T].defaultValue);
            return w
        }
        function n() {
            var m = e(!0)
                , b = {};
            for (var w in m)
                m.hasOwnProperty(w) && (b[w] = !0);
            return b
        }
        var r = {}
            , i = {}
            , s = {}
            , o = e(!0)
            , a = "vanilla"
            , l = {
                github: {
                    omitExtraWLInCodeBlocks: !0,
                    simplifiedAutoLink: !0,
                    excludeTrailingPunctuationFromURLs: !0,
                    literalMidWordUnderscores: !0,
                    strikethrough: !0,
                    tables: !0,
                    tablesHeaderId: !0,
                    ghCodeBlocks: !0,
                    tasklists: !0,
                    disableForced4SpacesIndentedSublists: !0,
                    simpleLineBreaks: !0,
                    requireSpaceBeforeHeadingText: !0,
                    ghCompatibleHeaderId: !0,
                    ghMentions: !0,
                    backslashEscapesHTMLTags: !0,
                    emoji: !0,
                    splitAdjacentBlockquotes: !0
                },
                original: {
                    noHeaderId: !0,
                    ghCodeBlocks: !1
                },
                ghost: {
                    omitExtraWLInCodeBlocks: !0,
                    parseImgDimensions: !0,
                    simplifiedAutoLink: !0,
                    excludeTrailingPunctuationFromURLs: !0,
                    literalMidWordUnderscores: !0,
                    strikethrough: !0,
                    tables: !0,
                    tablesHeaderId: !0,
                    ghCodeBlocks: !0,
                    tasklists: !0,
                    smoothLivePreview: !0,
                    simpleLineBreaks: !0,
                    requireSpaceBeforeHeadingText: !0,
                    ghMentions: !1,
                    encodeEmails: !0
                },
                vanilla: e(!0),
                allOn: n()
            };
        r.helper = {},
            r.extensions = {},
            r.setOption = function (m, b) {
                return o[m] = b,
                    this
            }
            ,
            r.getOption = function (m) {
                return o[m]
            }
            ,
            r.getOptions = function () {
                return o
            }
            ,
            r.resetOptions = function () {
                o = e(!0)
            }
            ,
            r.setFlavor = function (m) {
                if (!l.hasOwnProperty(m))
                    throw Error(m + " flavor was not found");
                r.resetOptions();
                var b = l[m];
                a = m;
                for (var w in b)
                    b.hasOwnProperty(w) && (o[w] = b[w])
            }
            ,
            r.getFlavor = function () {
                return a
            }
            ,
            r.getFlavorOptions = function (m) {
                if (l.hasOwnProperty(m))
                    return l[m]
            }
            ,
            r.getDefaultOptions = function (m) {
                return e(m)
            }
            ,
            r.subParser = function (m, b) {
                if (r.helper.isString(m))
                    if (typeof b < "u")
                        i[m] = b;
                    else {
                        if (i.hasOwnProperty(m))
                            return i[m];
                        throw Error("SubParser named " + m + " not registered!")
                    }
            }
            ,
            r.extension = function (m, b) {
                if (!r.helper.isString(m))
                    throw Error("Extension 'name' must be a string");
                if (m = r.helper.stdExtName(m),
                    r.helper.isUndefined(b)) {
                    if (!s.hasOwnProperty(m))
                        throw Error("Extension named " + m + " is not registered!");
                    return s[m]
                } else {
                    typeof b == "function" && (b = b()),
                        r.helper.isArray(b) || (b = [b]);
                    var w = c(b, m);
                    if (w.valid)
                        s[m] = b;
                    else
                        throw Error(w.error)
                }
            }
            ,
            r.getAllExtensions = function () {
                return s
            }
            ,
            r.removeExtension = function (m) {
                delete s[m]
            }
            ,
            r.resetExtensions = function () {
                s = {}
            }
            ;
        function c(m, b) {
            var w = b ? "Error in " + b + " extension->" : "Error in unnamed extension"
                , T = {
                    valid: !0,
                    error: ""
                };
            r.helper.isArray(m) || (m = [m]);
            for (var O = 0; O < m.length; ++O) {
                var M = w + " sub-extension " + O + ": "
                    , E = m[O];
                if (typeof E != "object")
                    return T.valid = !1,
                        T.error = M + "must be an object, but " + typeof E + " given",
                        T;
                if (!r.helper.isString(E.type))
                    return T.valid = !1,
                        T.error = M + 'property "type" must be a string, but ' + typeof E.type + " given",
                        T;
                var N = E.type = E.type.toLowerCase();
                if (N === "language" && (N = E.type = "lang"),
                    N === "html" && (N = E.type = "output"),
                    N !== "lang" && N !== "output" && N !== "listener")
                    return T.valid = !1,
                        T.error = M + "type " + N + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"',
                        T;
                if (N === "listener") {
                    if (r.helper.isUndefined(E.listeners))
                        return T.valid = !1,
                            T.error = M + '. Extensions of type "listener" must have a property called "listeners"',
                            T
                } else if (r.helper.isUndefined(E.filter) && r.helper.isUndefined(E.regex))
                    return T.valid = !1,
                        T.error = M + N + ' extensions must define either a "regex" property or a "filter" method',
                        T;
                if (E.listeners) {
                    if (typeof E.listeners != "object")
                        return T.valid = !1,
                            T.error = M + '"listeners" property must be an object but ' + typeof E.listeners + " given",
                            T;
                    for (var j in E.listeners)
                        if (E.listeners.hasOwnProperty(j) && typeof E.listeners[j] != "function")
                            return T.valid = !1,
                                T.error = M + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + j + " must be a function but " + typeof E.listeners[j] + " given",
                                T
                }
                if (E.filter) {
                    if (typeof E.filter != "function")
                        return T.valid = !1,
                            T.error = M + '"filter" must be a function, but ' + typeof E.filter + " given",
                            T
                } else if (E.regex) {
                    if (r.helper.isString(E.regex) && (E.regex = new RegExp(E.regex, "g")),
                        !(E.regex instanceof RegExp))
                        return T.valid = !1,
                            T.error = M + '"regex" property must either be a string or a RegExp object, but ' + typeof E.regex + " given",
                            T;
                    if (r.helper.isUndefined(E.replace))
                        return T.valid = !1,
                            T.error = M + '"regex" extensions must implement a replace string or function',
                            T
                }
            }
            return T
        }
        r.validateExtension = function (m) {
            var b = c(m, null);
            return b.valid ? !0 : (console.warn(b.error),
                !1)
        }
            ,
            r.hasOwnProperty("helper") || (r.helper = {}),
            r.helper.isString = function (m) {
                return typeof m == "string" || m instanceof String
            }
            ,
            r.helper.isFunction = function (m) {
                var b = {};
                return m && b.toString.call(m) === "[object Function]"
            }
            ,
            r.helper.isArray = function (m) {
                return Array.isArray(m)
            }
            ,
            r.helper.isUndefined = function (m) {
                return typeof m > "u"
            }
            ,
            r.helper.forEach = function (m, b) {
                if (r.helper.isUndefined(m))
                    throw new Error("obj param is required");
                if (r.helper.isUndefined(b))
                    throw new Error("callback param is required");
                if (!r.helper.isFunction(b))
                    throw new Error("callback param must be a function/closure");
                if (typeof m.forEach == "function")
                    m.forEach(b);
                else if (r.helper.isArray(m))
                    for (var w = 0; w < m.length; w++)
                        b(m[w], w, m);
                else if (typeof m == "object")
                    for (var T in m)
                        m.hasOwnProperty(T) && b(m[T], T, m);
                else
                    throw new Error("obj does not seem to be an array or an iterable object")
            }
            ,
            r.helper.stdExtName = function (m) {
                return m.replace(/[_?*+\/\\.^-]/g, "").replace(/\s/g, "").toLowerCase()
            }
            ;
        function d(m, b) {
            var w = b.charCodeAt(0);
            return "E" + w + "E"
        }
        r.helper.escapeCharactersCallback = d,
            r.helper.escapeCharacters = function (m, b, w) {
                var T = "([" + b.replace(/([\[\]\\])/g, "\\$1") + "])";
                w && (T = "\\\\" + T);
                var O = new RegExp(T, "g");
                return m = m.replace(O, d),
                    m
            }
            ,
            r.helper.unescapeHTMLEntities = function (m) {
                return m.replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&")
            }
            ;
        var h = function (m, b, w, T) {
            var O = T || "", M = O.indexOf("g") > -1, E = new RegExp(b + "|" + w, "g" + O.replace(/g/g, "")), N = new RegExp(b, O.replace(/g/g, "")), j = [], z, V, W, P, F;
            do
                for (z = 0; W = E.exec(m);)
                    if (N.test(W[0]))
                        z++ || (V = E.lastIndex,
                            P = V - W[0].length);
                    else if (z && !--z) {
                        F = W.index + W[0].length;
                        var K = {
                            left: {
                                start: P,
                                end: V
                            },
                            match: {
                                start: V,
                                end: W.index
                            },
                            right: {
                                start: W.index,
                                end: F
                            },
                            wholeMatch: {
                                start: P,
                                end: F
                            }
                        };
                        if (j.push(K),
                            !M)
                            return j
                    }
            while (z && (E.lastIndex = V));
            return j
        };
        r.helper.matchRecursiveRegExp = function (m, b, w, T) {
            for (var O = h(m, b, w, T), M = [], E = 0; E < O.length; ++E)
                M.push([m.slice(O[E].wholeMatch.start, O[E].wholeMatch.end), m.slice(O[E].match.start, O[E].match.end), m.slice(O[E].left.start, O[E].left.end), m.slice(O[E].right.start, O[E].right.end)]);
            return M
        }
            ,
            r.helper.replaceRecursiveRegExp = function (m, b, w, T, O) {
                if (!r.helper.isFunction(b)) {
                    var M = b;
                    b = function () {
                        return M
                    }
                }
                var E = h(m, w, T, O)
                    , N = m
                    , j = E.length;
                if (j > 0) {
                    var z = [];
                    E[0].wholeMatch.start !== 0 && z.push(m.slice(0, E[0].wholeMatch.start));
                    for (var V = 0; V < j; ++V)
                        z.push(b(m.slice(E[V].wholeMatch.start, E[V].wholeMatch.end), m.slice(E[V].match.start, E[V].match.end), m.slice(E[V].left.start, E[V].left.end), m.slice(E[V].right.start, E[V].right.end))),
                            V < j - 1 && z.push(m.slice(E[V].wholeMatch.end, E[V + 1].wholeMatch.start));
                    E[j - 1].wholeMatch.end < m.length && z.push(m.slice(E[j - 1].wholeMatch.end)),
                        N = z.join("")
                }
                return N
            }
            ,
            r.helper.regexIndexOf = function (m, b, w) {
                if (!r.helper.isString(m))
                    throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
                if (!(b instanceof RegExp))
                    throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp";
                var T = m.substring(w || 0).search(b);
                return T >= 0 ? T + (w || 0) : T
            }
            ,
            r.helper.splitAtIndex = function (m, b) {
                if (!r.helper.isString(m))
                    throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
                return [m.substring(0, b), m.substring(b)]
            }
            ,
            r.helper.encodeEmailAddress = function (m) {
                var b = [function (w) {
                    return "&#" + w.charCodeAt(0) + ";"
                }
                    , function (w) {
                        return "&#x" + w.charCodeAt(0).toString(16) + ";"
                    }
                    , function (w) {
                        return w
                    }
                ];
                return m = m.replace(/./g, function (w) {
                    if (w === "@")
                        w = b[Math.floor(Math.random() * 2)](w);
                    else {
                        var T = Math.random();
                        w = T > .9 ? b[2](w) : T > .45 ? b[1](w) : b[0](w)
                    }
                    return w
                }),
                    m
            }
            ,
            r.helper.padEnd = function (b, w, T) {
                return w = w >> 0,
                    T = String(T || " "),
                    b.length > w ? String(b) : (w = w - b.length,
                        w > T.length && (T += T.repeat(w / T.length)),
                        String(b) + T.slice(0, w))
            }
            ,
            typeof console > "u" && (console = {
                warn: function (m) {
                    alert(m)
                },
                log: function (m) {
                    alert(m)
                },
                error: function (m) {
                    throw m
                }
            }),
            r.helper.regexes = {
                asteriskDashAndColon: /([*_:~])/g
            },
            r.helper.emojis = {
                "+1": "",
                "-1": "",
                100: "",
                1234: "",
                "1st_place_medal": "",
                "2nd_place_medal": "",
                "3rd_place_medal": "",
                "8ball": "",
                a: "",
                ab: "",
                abc: "",
                abcd: "",
                accept: "",
                aerial_tramway: "",
                airplane: "",
                alarm_clock: "",
                alembic: "",
                alien: "",
                ambulance: "",
                amphora: "",
                anchor: "",
                angel: "",
                anger: "",
                angry: "",
                anguished: "",
                ant: "",
                apple: "",
                aquarius: "",
                aries: "",
                arrow_backward: "",
                arrow_double_down: "",
                arrow_double_up: "",
                arrow_down: "",
                arrow_down_small: "",
                arrow_forward: "",
                arrow_heading_down: "",
                arrow_heading_up: "",
                arrow_left: "",
                arrow_lower_left: "",
                arrow_lower_right: "",
                arrow_right: "",
                arrow_right_hook: "",
                arrow_up: "",
                arrow_up_down: "",
                arrow_up_small: "",
                arrow_upper_left: "",
                arrow_upper_right: "",
                arrows_clockwise: "",
                arrows_counterclockwise: "",
                art: "",
                articulated_lorry: "",
                artificial_satellite: "",
                astonished: "",
                athletic_shoe: "",
                atm: "",
                atom_symbol: "",
                avocado: "",
                b: "",
                baby: "",
                baby_bottle: "",
                baby_chick: "",
                baby_symbol: "",
                back: "",
                bacon: "",
                badminton: "",
                baggage_claim: "",
                baguette_bread: "",
                balance_scale: "",
                balloon: "",
                ballot_box: "",
                ballot_box_with_check: "",
                bamboo: "",
                banana: "",
                bangbang: "",
                bank: "",
                bar_chart: "",
                barber: "",
                baseball: "",
                basketball: "",
                basketball_man: "",
                basketball_woman: "&zwj;",
                bat: "",
                bath: "",
                bathtub: "",
                battery: "",
                beach_umbrella: "",
                bear: "",
                bed: "",
                bee: "",
                beer: "",
                beers: "",
                beetle: "",
                beginner: "",
                bell: "",
                bellhop_bell: "",
                bento: "",
                biking_man: "",
                bike: "",
                biking_woman: "&zwj;",
                bikini: "",
                biohazard: "",
                bird: "",
                birthday: "",
                black_circle: "",
                black_flag: "",
                black_heart: "",
                black_joker: "",
                black_large_square: "",
                black_medium_small_square: "",
                black_medium_square: "",
                black_nib: "",
                black_small_square: "",
                black_square_button: "",
                blonde_man: "",
                blonde_woman: "&zwj;",
                blossom: "",
                blowfish: "",
                blue_book: "",
                blue_car: "",
                blue_heart: "",
                blush: "",
                boar: "",
                boat: "",
                bomb: "",
                book: "",
                bookmark: "",
                bookmark_tabs: "",
                books: "",
                boom: "",
                boot: "",
                bouquet: "",
                bowing_man: "",
                bow_and_arrow: "",
                bowing_woman: "&zwj;",
                bowling: "",
                boxing_glove: "",
                boy: "",
                bread: "",
                bride_with_veil: "",
                bridge_at_night: "",
                briefcase: "",
                broken_heart: "",
                bug: "",
                building_construction: "",
                bulb: "",
                bullettrain_front: "",
                bullettrain_side: "",
                burrito: "",
                bus: "",
                business_suit_levitating: "",
                busstop: "",
                bust_in_silhouette: "",
                busts_in_silhouette: "",
                butterfly: "",
                cactus: "",
                cake: "",
                calendar: "",
                call_me_hand: "",
                calling: "",
                camel: "",
                camera: "",
                camera_flash: "",
                camping: "",
                cancer: "",
                candle: "",
                candy: "",
                canoe: "",
                capital_abcd: "",
                capricorn: "",
                car: "",
                card_file_box: "",
                card_index: "",
                card_index_dividers: "",
                carousel_horse: "",
                carrot: "",
                cat: "",
                cat2: "",
                cd: "",
                chains: "",
                champagne: "",
                chart: "",
                chart_with_downwards_trend: "",
                chart_with_upwards_trend: "",
                checkered_flag: "",
                cheese: "",
                cherries: "",
                cherry_blossom: "",
                chestnut: "",
                chicken: "",
                children_crossing: "",
                chipmunk: "",
                chocolate_bar: "",
                christmas_tree: "",
                church: "",
                cinema: "",
                circus_tent: "",
                city_sunrise: "",
                city_sunset: "",
                cityscape: "",
                cl: "",
                clamp: "",
                clap: "",
                clapper: "",
                classical_building: "",
                clinking_glasses: "",
                clipboard: "",
                clock1: "",
                clock10: "",
                clock1030: "",
                clock11: "",
                clock1130: "",
                clock12: "",
                clock1230: "",
                clock130: "",
                clock2: "",
                clock230: "",
                clock3: "",
                clock330: "",
                clock4: "",
                clock430: "",
                clock5: "",
                clock530: "",
                clock6: "",
                clock630: "",
                clock7: "",
                clock730: "",
                clock8: "",
                clock830: "",
                clock9: "",
                clock930: "",
                closed_book: "",
                closed_lock_with_key: "",
                closed_umbrella: "",
                cloud: "",
                cloud_with_lightning: "",
                cloud_with_lightning_and_rain: "",
                cloud_with_rain: "",
                cloud_with_snow: "",
                clown_face: "",
                clubs: "",
                cocktail: "",
                coffee: "",
                coffin: "",
                cold_sweat: "",
                comet: "",
                computer: "",
                computer_mouse: "",
                confetti_ball: "",
                confounded: "",
                confused: "",
                congratulations: "",
                construction: "",
                construction_worker_man: "",
                construction_worker_woman: "&zwj;",
                control_knobs: "",
                convenience_store: "",
                cookie: "",
                cool: "",
                policeman: "",
                copyright: "",
                corn: "",
                couch_and_lamp: "",
                couple: "",
                couple_with_heart_woman_man: "",
                couple_with_heart_man_man: "&zwj;&zwj;",
                couple_with_heart_woman_woman: "&zwj;&zwj;",
                couplekiss_man_man: "&zwj;&zwj;&zwj;",
                couplekiss_man_woman: "",
                couplekiss_woman_woman: "&zwj;&zwj;&zwj;",
                cow: "",
                cow2: "",
                cowboy_hat_face: "",
                crab: "",
                crayon: "",
                credit_card: "",
                crescent_moon: "",
                cricket: "",
                crocodile: "",
                croissant: "",
                crossed_fingers: "",
                crossed_flags: "",
                crossed_swords: "",
                crown: "",
                cry: "",
                crying_cat_face: "",
                crystal_ball: "",
                cucumber: "",
                cupid: "",
                curly_loop: "",
                currency_exchange: "",
                curry: "",
                custard: "",
                customs: "",
                cyclone: "",
                dagger: "",
                dancer: "",
                dancing_women: "",
                dancing_men: "&zwj;",
                dango: "",
                dark_sunglasses: "",
                dart: "",
                dash: "",
                date: "",
                deciduous_tree: "",
                deer: "",
                department_store: "",
                derelict_house: "",
                desert: "",
                desert_island: "",
                desktop_computer: "",
                male_detective: "",
                diamond_shape_with_a_dot_inside: "",
                diamonds: "",
                disappointed: "",
                disappointed_relieved: "",
                dizzy: "",
                dizzy_face: "",
                do_not_litter: "",
                dog: "",
                dog2: "",
                dollar: "",
                dolls: "",
                dolphin: "",
                door: "",
                doughnut: "",
                dove: "",
                dragon: "",
                dragon_face: "",
                dress: "",
                dromedary_camel: "",
                drooling_face: "",
                droplet: "",
                drum: "",
                duck: "",
                dvd: "",
                "e-mail": "",
                eagle: "",
                ear: "",
                ear_of_rice: "",
                earth_africa: "",
                earth_americas: "",
                earth_asia: "",
                egg: "",
                eggplant: "",
                eight_pointed_black_star: "",
                eight_spoked_asterisk: "",
                electric_plug: "",
                elephant: "",
                email: "",
                end: "",
                envelope_with_arrow: "",
                euro: "",
                european_castle: "",
                european_post_office: "",
                evergreen_tree: "",
                exclamation: "",
                expressionless: "",
                eye: "",
                eye_speech_bubble: "&zwj;",
                eyeglasses: "",
                eyes: "",
                face_with_head_bandage: "",
                face_with_thermometer: "",
                fist_oncoming: "",
                factory: "",
                fallen_leaf: "",
                family_man_woman_boy: "",
                family_man_boy: "&zwj;",
                family_man_boy_boy: "&zwj;&zwj;",
                family_man_girl: "&zwj;",
                family_man_girl_boy: "&zwj;&zwj;",
                family_man_girl_girl: "&zwj;&zwj;",
                family_man_man_boy: "&zwj;&zwj;",
                family_man_man_boy_boy: "&zwj;&zwj;&zwj;",
                family_man_man_girl: "&zwj;&zwj;",
                family_man_man_girl_boy: "&zwj;&zwj;&zwj;",
                family_man_man_girl_girl: "&zwj;&zwj;&zwj;",
                family_man_woman_boy_boy: "&zwj;&zwj;&zwj;",
                family_man_woman_girl: "&zwj;&zwj;",
                family_man_woman_girl_boy: "&zwj;&zwj;&zwj;",
                family_man_woman_girl_girl: "&zwj;&zwj;&zwj;",
                family_woman_boy: "&zwj;",
                family_woman_boy_boy: "&zwj;&zwj;",
                family_woman_girl: "&zwj;",
                family_woman_girl_boy: "&zwj;&zwj;",
                family_woman_girl_girl: "&zwj;&zwj;",
                family_woman_woman_boy: "&zwj;&zwj;",
                family_woman_woman_boy_boy: "&zwj;&zwj;&zwj;",
                family_woman_woman_girl: "&zwj;&zwj;",
                family_woman_woman_girl_boy: "&zwj;&zwj;&zwj;",
                family_woman_woman_girl_girl: "&zwj;&zwj;&zwj;",
                fast_forward: "",
                fax: "",
                fearful: "",
                feet: "",
                female_detective: "&zwj;",
                ferris_wheel: "",
                ferry: "",
                field_hockey: "",
                file_cabinet: "",
                file_folder: "",
                film_projector: "",
                film_strip: "",
                fire: "",
                fire_engine: "",
                fireworks: "",
                first_quarter_moon: "",
                first_quarter_moon_with_face: "",
                fish: "",
                fish_cake: "",
                fishing_pole_and_fish: "",
                fist_raised: "",
                fist_left: "",
                fist_right: "",
                flags: "",
                flashlight: "",
                fleur_de_lis: "",
                flight_arrival: "",
                flight_departure: "",
                floppy_disk: "",
                flower_playing_cards: "",
                flushed: "",
                fog: "",
                foggy: "",
                football: "",
                footprints: "",
                fork_and_knife: "",
                fountain: "",
                fountain_pen: "",
                four_leaf_clover: "",
                fox_face: "",
                framed_picture: "",
                free: "",
                fried_egg: "",
                fried_shrimp: "",
                fries: "",
                frog: "",
                frowning: "",
                frowning_face: "",
                frowning_man: "&zwj;",
                frowning_woman: "",
                middle_finger: "",
                fuelpump: "",
                full_moon: "",
                full_moon_with_face: "",
                funeral_urn: "",
                game_die: "",
                gear: "",
                gem: "",
                gemini: "",
                ghost: "",
                gift: "",
                gift_heart: "",
                girl: "",
                globe_with_meridians: "",
                goal_net: "",
                goat: "",
                golf: "",
                golfing_man: "",
                golfing_woman: "&zwj;",
                gorilla: "",
                grapes: "",
                green_apple: "",
                green_book: "",
                green_heart: "",
                green_salad: "",
                grey_exclamation: "",
                grey_question: "",
                grimacing: "",
                grin: "",
                grinning: "",
                guardsman: "",
                guardswoman: "&zwj;",
                guitar: "",
                gun: "",
                haircut_woman: "",
                haircut_man: "&zwj;",
                hamburger: "",
                hammer: "",
                hammer_and_pick: "",
                hammer_and_wrench: "",
                hamster: "",
                hand: "",
                handbag: "",
                handshake: "",
                hankey: "",
                hatched_chick: "",
                hatching_chick: "",
                headphones: "",
                hear_no_evil: "",
                heart: "",
                heart_decoration: "",
                heart_eyes: "",
                heart_eyes_cat: "",
                heartbeat: "",
                heartpulse: "",
                hearts: "",
                heavy_check_mark: "",
                heavy_division_sign: "",
                heavy_dollar_sign: "",
                heavy_heart_exclamation: "",
                heavy_minus_sign: "",
                heavy_multiplication_x: "",
                heavy_plus_sign: "",
                helicopter: "",
                herb: "",
                hibiscus: "",
                high_brightness: "",
                high_heel: "",
                hocho: "",
                hole: "",
                honey_pot: "",
                horse: "",
                horse_racing: "",
                hospital: "",
                hot_pepper: "",
                hotdog: "",
                hotel: "",
                hotsprings: "",
                hourglass: "",
                hourglass_flowing_sand: "",
                house: "",
                house_with_garden: "",
                houses: "",
                hugs: "",
                hushed: "",
                ice_cream: "",
                ice_hockey: "",
                ice_skate: "",
                icecream: "",
                id: "",
                ideograph_advantage: "",
                imp: "",
                inbox_tray: "",
                incoming_envelope: "",
                tipping_hand_woman: "",
                information_source: "",
                innocent: "",
                interrobang: "",
                iphone: "",
                izakaya_lantern: "",
                jack_o_lantern: "",
                japan: "",
                japanese_castle: "",
                japanese_goblin: "",
                japanese_ogre: "",
                jeans: "",
                joy: "",
                joy_cat: "",
                joystick: "",
                kaaba: "",
                key: "",
                keyboard: "",
                keycap_ten: "",
                kick_scooter: "",
                kimono: "",
                kiss: "",
                kissing: "",
                kissing_cat: "",
                kissing_closed_eyes: "",
                kissing_heart: "",
                kissing_smiling_eyes: "",
                kiwi_fruit: "",
                koala: "",
                koko: "",
                label: "",
                large_blue_circle: "",
                large_blue_diamond: "",
                large_orange_diamond: "",
                last_quarter_moon: "",
                last_quarter_moon_with_face: "",
                latin_cross: "",
                laughing: "",
                leaves: "",
                ledger: "",
                left_luggage: "",
                left_right_arrow: "",
                leftwards_arrow_with_hook: "",
                lemon: "",
                leo: "",
                leopard: "",
                level_slider: "",
                libra: "",
                light_rail: "",
                link: "",
                lion: "",
                lips: "",
                lipstick: "",
                lizard: "",
                lock: "",
                lock_with_ink_pen: "",
                lollipop: "",
                loop: "",
                loud_sound: "",
                loudspeaker: "",
                love_hotel: "",
                love_letter: "",
                low_brightness: "",
                lying_face: "",
                m: "",
                mag: "",
                mag_right: "",
                mahjong: "",
                mailbox: "",
                mailbox_closed: "",
                mailbox_with_mail: "",
                mailbox_with_no_mail: "",
                man: "",
                man_artist: "&zwj;",
                man_astronaut: "&zwj;",
                man_cartwheeling: "&zwj;",
                man_cook: "&zwj;",
                man_dancing: "",
                man_facepalming: "&zwj;",
                man_factory_worker: "&zwj;",
                man_farmer: "&zwj;",
                man_firefighter: "&zwj;",
                man_health_worker: "&zwj;",
                man_in_tuxedo: "",
                man_judge: "&zwj;",
                man_juggling: "&zwj;",
                man_mechanic: "&zwj;",
                man_office_worker: "&zwj;",
                man_pilot: "&zwj;",
                man_playing_handball: "&zwj;",
                man_playing_water_polo: "&zwj;",
                man_scientist: "&zwj;",
                man_shrugging: "&zwj;",
                man_singer: "&zwj;",
                man_student: "&zwj;",
                man_teacher: "&zwj;",
                man_technologist: "&zwj;",
                man_with_gua_pi_mao: "",
                man_with_turban: "",
                tangerine: "",
                mans_shoe: "",
                mantelpiece_clock: "",
                maple_leaf: "",
                martial_arts_uniform: "",
                mask: "",
                massage_woman: "",
                massage_man: "&zwj;",
                meat_on_bone: "",
                medal_military: "",
                medal_sports: "",
                mega: "",
                melon: "",
                memo: "",
                men_wrestling: "&zwj;",
                menorah: "",
                mens: "",
                metal: "",
                metro: "",
                microphone: "",
                microscope: "",
                milk_glass: "",
                milky_way: "",
                minibus: "",
                minidisc: "",
                mobile_phone_off: "",
                money_mouth_face: "",
                money_with_wings: "",
                moneybag: "",
                monkey: "",
                monkey_face: "",
                monorail: "",
                moon: "",
                mortar_board: "",
                mosque: "",
                motor_boat: "",
                motor_scooter: "",
                motorcycle: "",
                motorway: "",
                mount_fuji: "",
                mountain: "",
                mountain_biking_man: "",
                mountain_biking_woman: "&zwj;",
                mountain_cableway: "",
                mountain_railway: "",
                mountain_snow: "",
                mouse: "",
                mouse2: "",
                movie_camera: "",
                moyai: "",
                mrs_claus: "",
                muscle: "",
                mushroom: "",
                musical_keyboard: "",
                musical_note: "",
                musical_score: "",
                mute: "",
                nail_care: "",
                name_badge: "",
                national_park: "",
                nauseated_face: "",
                necktie: "",
                negative_squared_cross_mark: "",
                nerd_face: "",
                neutral_face: "",
                new: "",
                new_moon: "",
                new_moon_with_face: "",
                newspaper: "",
                newspaper_roll: "",
                next_track_button: "",
                ng: "",
                no_good_man: "&zwj;",
                no_good_woman: "",
                night_with_stars: "",
                no_bell: "",
                no_bicycles: "",
                no_entry: "",
                no_entry_sign: "",
                no_mobile_phones: "",
                no_mouth: "",
                no_pedestrians: "",
                no_smoking: "",
                "non-potable_water": "",
                nose: "",
                notebook: "",
                notebook_with_decorative_cover: "",
                notes: "",
                nut_and_bolt: "",
                o: "",
                o2: "",
                ocean: "",
                octopus: "",
                oden: "",
                office: "",
                oil_drum: "",
                ok: "",
                ok_hand: "",
                ok_man: "&zwj;",
                ok_woman: "",
                old_key: "",
                older_man: "",
                older_woman: "",
                om: "",
                on: "",
                oncoming_automobile: "",
                oncoming_bus: "",
                oncoming_police_car: "",
                oncoming_taxi: "",
                open_file_folder: "",
                open_hands: "",
                open_mouth: "",
                open_umbrella: "",
                ophiuchus: "",
                orange_book: "",
                orthodox_cross: "",
                outbox_tray: "",
                owl: "",
                ox: "",
                package: "",
                page_facing_up: "",
                page_with_curl: "",
                pager: "",
                paintbrush: "",
                palm_tree: "",
                pancakes: "",
                panda_face: "",
                paperclip: "",
                paperclips: "",
                parasol_on_ground: "",
                parking: "",
                part_alternation_mark: "",
                partly_sunny: "",
                passenger_ship: "",
                passport_control: "",
                pause_button: "",
                peace_symbol: "",
                peach: "",
                peanuts: "",
                pear: "",
                pen: "",
                pencil2: "",
                penguin: "",
                pensive: "",
                performing_arts: "",
                persevere: "",
                person_fencing: "",
                pouting_woman: "",
                phone: "",
                pick: "",
                pig: "",
                pig2: "",
                pig_nose: "",
                pill: "",
                pineapple: "",
                ping_pong: "",
                pisces: "",
                pizza: "",
                place_of_worship: "",
                plate_with_cutlery: "",
                play_or_pause_button: "",
                point_down: "",
                point_left: "",
                point_right: "",
                point_up: "",
                point_up_2: "",
                police_car: "",
                policewoman: "&zwj;",
                poodle: "",
                popcorn: "",
                post_office: "",
                postal_horn: "",
                postbox: "",
                potable_water: "",
                potato: "",
                pouch: "",
                poultry_leg: "",
                pound: "",
                rage: "",
                pouting_cat: "",
                pouting_man: "&zwj;",
                pray: "",
                prayer_beads: "",
                pregnant_woman: "",
                previous_track_button: "",
                prince: "",
                princess: "",
                printer: "",
                purple_heart: "",
                purse: "",
                pushpin: "",
                put_litter_in_its_place: "",
                question: "",
                rabbit: "",
                rabbit2: "",
                racehorse: "",
                racing_car: "",
                radio: "",
                radio_button: "",
                radioactive: "",
                railway_car: "",
                railway_track: "",
                rainbow: "",
                rainbow_flag: "&zwj;",
                raised_back_of_hand: "",
                raised_hand_with_fingers_splayed: "",
                raised_hands: "",
                raising_hand_woman: "",
                raising_hand_man: "&zwj;",
                ram: "",
                ramen: "",
                rat: "",
                record_button: "",
                recycle: "",
                red_circle: "",
                registered: "",
                relaxed: "",
                relieved: "",
                reminder_ribbon: "",
                repeat: "",
                repeat_one: "",
                rescue_worker_helmet: "",
                restroom: "",
                revolving_hearts: "",
                rewind: "",
                rhinoceros: "",
                ribbon: "",
                rice: "",
                rice_ball: "",
                rice_cracker: "",
                rice_scene: "",
                right_anger_bubble: "",
                ring: "",
                robot: "",
                rocket: "",
                rofl: "",
                roll_eyes: "",
                roller_coaster: "",
                rooster: "",
                rose: "",
                rosette: "",
                rotating_light: "",
                round_pushpin: "",
                rowing_man: "",
                rowing_woman: "&zwj;",
                rugby_football: "",
                running_man: "",
                running_shirt_with_sash: "",
                running_woman: "&zwj;",
                sa: "",
                sagittarius: "",
                sake: "",
                sandal: "",
                santa: "",
                satellite: "",
                saxophone: "",
                school: "",
                school_satchel: "",
                scissors: "",
                scorpion: "",
                scorpius: "",
                scream: "",
                scream_cat: "",
                scroll: "",
                seat: "",
                secret: "",
                see_no_evil: "",
                seedling: "",
                selfie: "",
                shallow_pan_of_food: "",
                shamrock: "",
                shark: "",
                shaved_ice: "",
                sheep: "",
                shell: "",
                shield: "",
                shinto_shrine: "",
                ship: "",
                shirt: "",
                shopping: "",
                shopping_cart: "",
                shower: "",
                shrimp: "",
                signal_strength: "",
                six_pointed_star: "",
                ski: "",
                skier: "",
                skull: "",
                skull_and_crossbones: "",
                sleeping: "",
                sleeping_bed: "",
                sleepy: "",
                slightly_frowning_face: "",
                slightly_smiling_face: "",
                slot_machine: "",
                small_airplane: "",
                small_blue_diamond: "",
                small_orange_diamond: "",
                small_red_triangle: "",
                small_red_triangle_down: "",
                smile: "",
                smile_cat: "",
                smiley: "",
                smiley_cat: "",
                smiling_imp: "",
                smirk: "",
                smirk_cat: "",
                smoking: "",
                snail: "",
                snake: "",
                sneezing_face: "",
                snowboarder: "",
                snowflake: "",
                snowman: "",
                snowman_with_snow: "",
                sob: "",
                soccer: "",
                soon: "",
                sos: "",
                sound: "",
                space_invader: "",
                spades: "",
                spaghetti: "",
                sparkle: "",
                sparkler: "",
                sparkles: "",
                sparkling_heart: "",
                speak_no_evil: "",
                speaker: "",
                speaking_head: "",
                speech_balloon: "",
                speedboat: "",
                spider: "",
                spider_web: "",
                spiral_calendar: "",
                spiral_notepad: "",
                spoon: "",
                squid: "",
                stadium: "",
                star: "",
                star2: "",
                star_and_crescent: "",
                star_of_david: "",
                stars: "",
                station: "",
                statue_of_liberty: "",
                steam_locomotive: "",
                stew: "",
                stop_button: "",
                stop_sign: "",
                stopwatch: "",
                straight_ruler: "",
                strawberry: "",
                stuck_out_tongue: "",
                stuck_out_tongue_closed_eyes: "",
                stuck_out_tongue_winking_eye: "",
                studio_microphone: "",
                stuffed_flatbread: "",
                sun_behind_large_cloud: "",
                sun_behind_rain_cloud: "",
                sun_behind_small_cloud: "",
                sun_with_face: "",
                sunflower: "",
                sunglasses: "",
                sunny: "",
                sunrise: "",
                sunrise_over_mountains: "",
                surfing_man: "",
                surfing_woman: "&zwj;",
                sushi: "",
                suspension_railway: "",
                sweat: "",
                sweat_drops: "",
                sweat_smile: "",
                sweet_potato: "",
                swimming_man: "",
                swimming_woman: "&zwj;",
                symbols: "",
                synagogue: "",
                syringe: "",
                taco: "",
                tada: "",
                tanabata_tree: "",
                taurus: "",
                taxi: "",
                tea: "",
                telephone_receiver: "",
                telescope: "",
                tennis: "",
                tent: "",
                thermometer: "",
                thinking: "",
                thought_balloon: "",
                ticket: "",
                tickets: "",
                tiger: "",
                tiger2: "",
                timer_clock: "",
                tipping_hand_man: "&zwj;",
                tired_face: "",
                tm: "",
                toilet: "",
                tokyo_tower: "",
                tomato: "",
                tongue: "",
                top: "",
                tophat: "",
                tornado: "",
                trackball: "",
                tractor: "",
                traffic_light: "",
                train: "",
                train2: "",
                tram: "",
                triangular_flag_on_post: "",
                triangular_ruler: "",
                trident: "",
                triumph: "",
                trolleybus: "",
                trophy: "",
                tropical_drink: "",
                tropical_fish: "",
                truck: "",
                trumpet: "",
                tulip: "",
                tumbler_glass: "",
                turkey: "",
                turtle: "",
                tv: "",
                twisted_rightwards_arrows: "",
                two_hearts: "",
                two_men_holding_hands: "",
                two_women_holding_hands: "",
                u5272: "",
                u5408: "",
                u55b6: "",
                u6307: "",
                u6708: "",
                u6709: "",
                u6e80: "",
                u7121: "",
                u7533: "",
                u7981: "",
                u7a7a: "",
                umbrella: "",
                unamused: "",
                underage: "",
                unicorn: "",
                unlock: "",
                up: "",
                upside_down_face: "",
                v: "",
                vertical_traffic_light: "",
                vhs: "",
                vibration_mode: "",
                video_camera: "",
                video_game: "",
                violin: "",
                virgo: "",
                volcano: "",
                volleyball: "",
                vs: "",
                vulcan_salute: "",
                walking_man: "",
                walking_woman: "&zwj;",
                waning_crescent_moon: "",
                waning_gibbous_moon: "",
                warning: "",
                wastebasket: "",
                watch: "",
                water_buffalo: "",
                watermelon: "",
                wave: "",
                wavy_dash: "",
                waxing_crescent_moon: "",
                wc: "",
                weary: "",
                wedding: "",
                weight_lifting_man: "",
                weight_lifting_woman: "&zwj;",
                whale: "",
                whale2: "",
                wheel_of_dharma: "",
                wheelchair: "",
                white_check_mark: "",
                white_circle: "",
                white_flag: "",
                white_flower: "",
                white_large_square: "",
                white_medium_small_square: "",
                white_medium_square: "",
                white_small_square: "",
                white_square_button: "",
                wilted_flower: "",
                wind_chime: "",
                wind_face: "",
                wine_glass: "",
                wink: "",
                wolf: "",
                woman: "",
                woman_artist: "&zwj;",
                woman_astronaut: "&zwj;",
                woman_cartwheeling: "&zwj;",
                woman_cook: "&zwj;",
                woman_facepalming: "&zwj;",
                woman_factory_worker: "&zwj;",
                woman_farmer: "&zwj;",
                woman_firefighter: "&zwj;",
                woman_health_worker: "&zwj;",
                woman_judge: "&zwj;",
                woman_juggling: "&zwj;",
                woman_mechanic: "&zwj;",
                woman_office_worker: "&zwj;",
                woman_pilot: "&zwj;",
                woman_playing_handball: "&zwj;",
                woman_playing_water_polo: "&zwj;",
                woman_scientist: "&zwj;",
                woman_shrugging: "&zwj;",
                woman_singer: "&zwj;",
                woman_student: "&zwj;",
                woman_teacher: "&zwj;",
                woman_technologist: "&zwj;",
                woman_with_turban: "&zwj;",
                womans_clothes: "",
                womans_hat: "",
                women_wrestling: "&zwj;",
                womens: "",
                world_map: "",
                worried: "",
                wrench: "",
                writing_hand: "",
                x: "",
                yellow_heart: "",
                yen: "",
                yin_yang: "",
                yum: "",
                zap: "",
                zipper_mouth_face: "",
                zzz: "",
                octocat: '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
                showdown: `<span style="font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>`
            },
            r.Converter = function (m) {
                var b = {}
                    , w = []
                    , T = []
                    , O = {}
                    , M = a
                    , E = {
                        parsed: {},
                        raw: "",
                        format: ""
                    };
                N();
                function N() {
                    m = m || {};
                    for (var P in o)
                        o.hasOwnProperty(P) && (b[P] = o[P]);
                    if (typeof m == "object")
                        for (var F in m)
                            m.hasOwnProperty(F) && (b[F] = m[F]);
                    else
                        throw Error("Converter expects the passed parameter to be an object, but " + typeof m + " was passed instead.");
                    b.extensions && r.helper.forEach(b.extensions, j)
                }
                function j(P, F) {
                    if (F = F || null,
                        r.helper.isString(P))
                        if (P = r.helper.stdExtName(P),
                            F = P,
                            r.extensions[P]) {
                            console.warn("DEPRECATION WARNING: " + P + " is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!"),
                                z(r.extensions[P], P);
                            return
                        } else if (!r.helper.isUndefined(s[P]))
                            P = s[P];
                        else
                            throw Error('Extension "' + P + '" could not be loaded. It was either not found or is not a valid extension.');
                    typeof P == "function" && (P = P()),
                        r.helper.isArray(P) || (P = [P]);
                    var K = c(P, F);
                    if (!K.valid)
                        throw Error(K.error);
                    for (var re = 0; re < P.length; ++re) {
                        switch (P[re].type) {
                            case "lang":
                                w.push(P[re]);
                                break;
                            case "output":
                                T.push(P[re]);
                                break
                        }
                        if (P[re].hasOwnProperty("listeners"))
                            for (var Te in P[re].listeners)
                                P[re].listeners.hasOwnProperty(Te) && V(Te, P[re].listeners[Te])
                    }
                }
                function z(P, F) {
                    typeof P == "function" && (P = P(new r.Converter)),
                        r.helper.isArray(P) || (P = [P]);
                    var K = c(P, F);
                    if (!K.valid)
                        throw Error(K.error);
                    for (var re = 0; re < P.length; ++re)
                        switch (P[re].type) {
                            case "lang":
                                w.push(P[re]);
                                break;
                            case "output":
                                T.push(P[re]);
                                break;
                            default:
                                throw Error("Extension loader error: Type unrecognized!!!")
                        }
                }
                function V(P, F) {
                    if (!r.helper.isString(P))
                        throw Error("Invalid argument in converter.listen() method: name must be a string, but " + typeof P + " given");
                    if (typeof F != "function")
                        throw Error("Invalid argument in converter.listen() method: callback must be a function, but " + typeof F + " given");
                    O.hasOwnProperty(P) || (O[P] = []),
                        O[P].push(F)
                }
                function W(P) {
                    var F = P.match(/^\s*/)[0].length
                        , K = new RegExp("^\\s{0," + F + "}", "gm");
                    return P.replace(K, "")
                }
                this._dispatch = function (F, K, re, Te) {
                    if (O.hasOwnProperty(F))
                        for (var ee = 0; ee < O[F].length; ++ee) {
                            var Se = O[F][ee](F, K, this, re, Te);
                            Se && typeof Se < "u" && (K = Se)
                        }
                    return K
                }
                    ,
                    this.listen = function (P, F) {
                        return V(P, F),
                            this
                    }
                    ,
                    this.makeHtml = function (P) {
                        if (!P)
                            return P;
                        var F = {
                            gHtmlBlocks: [],
                            gHtmlMdBlocks: [],
                            gHtmlSpans: [],
                            gUrls: {},
                            gTitles: {},
                            gDimensions: {},
                            gListLevel: 0,
                            hashLinkCounts: {},
                            langExtensions: w,
                            outputModifiers: T,
                            converter: this,
                            ghCodeBlocks: [],
                            metadata: {
                                parsed: {},
                                raw: "",
                                format: ""
                            }
                        };
                        return P = P.replace(//g, "T"),
                            P = P.replace(/\$/g, "D"),
                            P = P.replace(/\r\n/g, `
`),
                            P = P.replace(/\r/g, `
`),
                            P = P.replace(/\u00A0/g, "&nbsp;"),
                            b.smartIndentationFix && (P = W(P)),
                            P = `

` + P + `

`,
                            P = r.subParser("detab")(P, b, F),
                            P = P.replace(/^[ \t]+$/mg, ""),
                            r.helper.forEach(w, function (K) {
                                P = r.subParser("runExtension")(K, P, b, F)
                            }),
                            P = r.subParser("metadata")(P, b, F),
                            P = r.subParser("hashPreCodeTags")(P, b, F),
                            P = r.subParser("githubCodeBlocks")(P, b, F),
                            P = r.subParser("hashHTMLBlocks")(P, b, F),
                            P = r.subParser("hashCodeTags")(P, b, F),
                            P = r.subParser("stripLinkDefinitions")(P, b, F),
                            P = r.subParser("blockGamut")(P, b, F),
                            P = r.subParser("unhashHTMLSpans")(P, b, F),
                            P = r.subParser("unescapeSpecialChars")(P, b, F),
                            P = P.replace(/D/g, "$$"),
                            P = P.replace(/T/g, ""),
                            P = r.subParser("completeHTMLDocument")(P, b, F),
                            r.helper.forEach(T, function (K) {
                                P = r.subParser("runExtension")(K, P, b, F)
                            }),
                            E = F.metadata,
                            P
                    }
                    ,
                    this.makeMarkdown = this.makeMd = function (P, F) {
                        if (P = P.replace(/\r\n/g, `
`),
                            P = P.replace(/\r/g, `
`),
                            P = P.replace(/>[ \t]+</, ">NBSP;<"),
                            !F)
                            if (window && window.document)
                                F = window.document;
                            else
                                throw new Error("HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM");
                        var K = F.createElement("div");
                        K.innerHTML = P;
                        var re = {
                            preList: Ke(K)
                        };
                        Ze(K);
                        for (var Te = K.childNodes, ee = "", Se = 0; Se < Te.length; Se++)
                            ee += r.subParser("makeMarkdown.node")(Te[Se], re);
                        function Ze(Ye) {
                            for (var Qe = 0; Qe < Ye.childNodes.length; ++Qe) {
                                var Y = Ye.childNodes[Qe];
                                Y.nodeType === 3 ? !/\S/.test(Y.nodeValue) && !/^[ ]+$/.test(Y.nodeValue) ? (Ye.removeChild(Y),
                                    --Qe) : (Y.nodeValue = Y.nodeValue.split(`
`).join(" "),
                                        Y.nodeValue = Y.nodeValue.replace(/(\s)+/g, "$1")) : Y.nodeType === 1 && Ze(Y)
                            }
                        }
                        function Ke(Ye) {
                            for (var Qe = Ye.querySelectorAll("pre"), Y = [], he = 0; he < Qe.length; ++he)
                                if (Qe[he].childElementCount === 1 && Qe[he].firstChild.tagName.toLowerCase() === "code") {
                                    var ge = Qe[he].firstChild.innerHTML.trim()
                                        , Ee = Qe[he].firstChild.getAttribute("data-language") || "";
                                    if (Ee === "")
                                        for (var st = Qe[he].firstChild.className.split(" "), xt = 0; xt < st.length; ++xt) {
                                            var D = st[xt].match(/^language-(.+)$/);
                                            if (D !== null) {
                                                Ee = D[1];
                                                break
                                            }
                                        }
                                    ge = r.helper.unescapeHTMLEntities(ge),
                                        Y.push(ge),
                                        Qe[he].outerHTML = '<precode language="' + Ee + '" precodenum="' + he.toString() + '"></precode>'
                                } else
                                    Y.push(Qe[he].innerHTML),
                                        Qe[he].innerHTML = "",
                                        Qe[he].setAttribute("prenum", he.toString());
                            return Y
                        }
                        return ee
                    }
                    ,
                    this.setOption = function (P, F) {
                        b[P] = F
                    }
                    ,
                    this.getOption = function (P) {
                        return b[P]
                    }
                    ,
                    this.getOptions = function () {
                        return b
                    }
                    ,
                    this.addExtension = function (P, F) {
                        F = F || null,
                            j(P, F)
                    }
                    ,
                    this.useExtension = function (P) {
                        j(P)
                    }
                    ,
                    this.setFlavor = function (P) {
                        if (!l.hasOwnProperty(P))
                            throw Error(P + " flavor was not found");
                        var F = l[P];
                        M = P;
                        for (var K in F)
                            F.hasOwnProperty(K) && (b[K] = F[K])
                    }
                    ,
                    this.getFlavor = function () {
                        return M
                    }
                    ,
                    this.removeExtension = function (P) {
                        r.helper.isArray(P) || (P = [P]);
                        for (var F = 0; F < P.length; ++F) {
                            for (var K = P[F], re = 0; re < w.length; ++re)
                                w[re] === K && w.splice(re, 1);
                            for (var Te = 0; Te < T.length; ++Te)
                                T[Te] === K && T.splice(Te, 1)
                        }
                    }
                    ,
                    this.getAllExtensions = function () {
                        return {
                            language: w,
                            output: T
                        }
                    }
                    ,
                    this.getMetadata = function (P) {
                        return P ? E.raw : E.parsed
                    }
                    ,
                    this.getMetadataFormat = function () {
                        return E.format
                    }
                    ,
                    this._setMetadataPair = function (P, F) {
                        E.parsed[P] = F
                    }
                    ,
                    this._setMetadataFormat = function (P) {
                        E.format = P
                    }
                    ,
                    this._setMetadataRaw = function (P) {
                        E.raw = P
                    }
            }
            ,
            r.subParser("anchors", function (m, b, w) {
                m = w.converter._dispatch("anchors.before", m, b, w);
                var T = function (O, M, E, N, j, z, V) {
                    if (r.helper.isUndefined(V) && (V = ""),
                        E = E.toLowerCase(),
                        O.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)
                        N = "";
                    else if (!N)
                        if (E || (E = M.toLowerCase().replace(/ ?\n/g, " ")),
                            N = "#" + E,
                            !r.helper.isUndefined(w.gUrls[E]))
                            N = w.gUrls[E],
                                r.helper.isUndefined(w.gTitles[E]) || (V = w.gTitles[E]);
                        else
                            return O;
                    N = N.replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback);
                    var W = '<a href="' + N + '"';
                    return V !== "" && V !== null && (V = V.replace(/"/g, "&quot;"),
                        V = V.replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback),
                        W += ' title="' + V + '"'),
                        b.openLinksInNewWindow && !/^#/.test(N) && (W += ' rel="noopener noreferrer" target="E95Eblank"'),
                        W += ">" + M + "</a>",
                        W
                };
                return m = m.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, T),
                    m = m.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g, T),
                    m = m.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g, T),
                    m = m.replace(/\[([^\[\]]+)]()()()()()/g, T),
                    b.ghMentions && (m = m.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (O, M, E, N, j) {
                        if (E === "\\")
                            return M + N;
                        if (!r.helper.isString(b.ghMentionsLink))
                            throw new Error("ghMentionsLink option must be a string");
                        var z = b.ghMentionsLink.replace(/\{u}/g, j)
                            , V = "";
                        return b.openLinksInNewWindow && (V = ' rel="noopener noreferrer" target="E95Eblank"'),
                            M + '<a href="' + z + '"' + V + ">" + N + "</a>"
                    })),
                    m = w.converter._dispatch("anchors.after", m, b, w),
                    m
            });
        var p = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi
            , g = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi
            , y = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi
            , x = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi
            , S = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi
            , k = function (m) {
                return function (b, w, T, O, M, E, N) {
                    T = T.replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback);
                    var j = T
                        , z = ""
                        , V = ""
                        , W = w || ""
                        , P = N || "";
                    return /^www\./i.test(T) && (T = T.replace(/^www\./i, "http://www.")),
                        m.excludeTrailingPunctuationFromURLs && E && (z = E),
                        m.openLinksInNewWindow && (V = ' rel="noopener noreferrer" target="E95Eblank"'),
                        W + '<a href="' + T + '"' + V + ">" + j + "</a>" + z + P
                }
            }
            , A = function (m, b) {
                return function (w, T, O) {
                    var M = "mailto:";
                    return T = T || "",
                        O = r.subParser("unescapeSpecialChars")(O, m, b),
                        m.encodeEmails ? (M = r.helper.encodeEmailAddress(M + O),
                            O = r.helper.encodeEmailAddress(O)) : M = M + O,
                        T + '<a href="' + M + '">' + O + "</a>"
                }
            };
        r.subParser("autoLinks", function (m, b, w) {
            return m = w.converter._dispatch("autoLinks.before", m, b, w),
                m = m.replace(y, k(b)),
                m = m.replace(S, A(b, w)),
                m = w.converter._dispatch("autoLinks.after", m, b, w),
                m
        }),
            r.subParser("simplifiedAutoLinks", function (m, b, w) {
                return b.simplifiedAutoLink && (m = w.converter._dispatch("simplifiedAutoLinks.before", m, b, w),
                    b.excludeTrailingPunctuationFromURLs ? m = m.replace(g, k(b)) : m = m.replace(p, k(b)),
                    m = m.replace(x, A(b, w)),
                    m = w.converter._dispatch("simplifiedAutoLinks.after", m, b, w)),
                    m
            }),
            r.subParser("blockGamut", function (m, b, w) {
                return m = w.converter._dispatch("blockGamut.before", m, b, w),
                    m = r.subParser("blockQuotes")(m, b, w),
                    m = r.subParser("headers")(m, b, w),
                    m = r.subParser("horizontalRule")(m, b, w),
                    m = r.subParser("lists")(m, b, w),
                    m = r.subParser("codeBlocks")(m, b, w),
                    m = r.subParser("tables")(m, b, w),
                    m = r.subParser("hashHTMLBlocks")(m, b, w),
                    m = r.subParser("paragraphs")(m, b, w),
                    m = w.converter._dispatch("blockGamut.after", m, b, w),
                    m
            }),
            r.subParser("blockQuotes", function (m, b, w) {
                m = w.converter._dispatch("blockQuotes.before", m, b, w),
                    m = m + `

`;
                var T = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;
                return b.splitAdjacentBlockquotes && (T = /^ {0,3}>[\s\S]*?(?:\n\n)/gm),
                    m = m.replace(T, function (O) {
                        return O = O.replace(/^[ \t]*>[ \t]?/gm, ""),
                            O = O.replace(/0/g, ""),
                            O = O.replace(/^[ \t]+$/gm, ""),
                            O = r.subParser("githubCodeBlocks")(O, b, w),
                            O = r.subParser("blockGamut")(O, b, w),
                            O = O.replace(/(^|\n)/g, "$1  "),
                            O = O.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (M, E) {
                                var N = E;
                                return N = N.replace(/^  /mg, "0"),
                                    N = N.replace(/0/g, ""),
                                    N
                            }),
                            r.subParser("hashBlock")(`<blockquote>
` + O + `
</blockquote>`, b, w)
                    }),
                    m = w.converter._dispatch("blockQuotes.after", m, b, w),
                    m
            }),
            r.subParser("codeBlocks", function (m, b, w) {
                m = w.converter._dispatch("codeBlocks.before", m, b, w),
                    m += "0";
                var T = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g;
                return m = m.replace(T, function (O, M, E) {
                    var N = M
                        , j = E
                        , z = `
`;
                    return N = r.subParser("outdent")(N, b, w),
                        N = r.subParser("encodeCode")(N, b, w),
                        N = r.subParser("detab")(N, b, w),
                        N = N.replace(/^\n+/g, ""),
                        N = N.replace(/\n+$/g, ""),
                        b.omitExtraWLInCodeBlocks && (z = ""),
                        N = "<pre><code>" + N + z + "</code></pre>",
                        r.subParser("hashBlock")(N, b, w) + j
                }),
                    m = m.replace(/0/, ""),
                    m = w.converter._dispatch("codeBlocks.after", m, b, w),
                    m
            }),
            r.subParser("codeSpans", function (m, b, w) {
                return m = w.converter._dispatch("codeSpans.before", m, b, w),
                    typeof m > "u" && (m = ""),
                    m = m.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm, function (T, O, M, E) {
                        var N = E;
                        return N = N.replace(/^([ \t]*)/g, ""),
                            N = N.replace(/[ \t]*$/g, ""),
                            N = r.subParser("encodeCode")(N, b, w),
                            N = O + "<code>" + N + "</code>",
                            N = r.subParser("hashHTMLSpans")(N, b, w),
                            N
                    }),
                    m = w.converter._dispatch("codeSpans.after", m, b, w),
                    m
            }),
            r.subParser("completeHTMLDocument", function (m, b, w) {
                if (!b.completeHTMLDocument)
                    return m;
                m = w.converter._dispatch("completeHTMLDocument.before", m, b, w);
                var T = "html"
                    , O = `<!DOCTYPE HTML>
`
                    , M = ""
                    , E = `<meta charset="utf-8">
`
                    , N = ""
                    , j = "";
                typeof w.metadata.parsed.doctype < "u" && (O = "<!DOCTYPE " + w.metadata.parsed.doctype + `>
`,
                    T = w.metadata.parsed.doctype.toString().toLowerCase(),
                    (T === "html" || T === "html5") && (E = '<meta charset="utf-8">'));
                for (var z in w.metadata.parsed)
                    if (w.metadata.parsed.hasOwnProperty(z))
                        switch (z.toLowerCase()) {
                            case "doctype":
                                break;
                            case "title":
                                M = "<title>" + w.metadata.parsed.title + `</title>
`;
                                break;
                            case "charset":
                                T === "html" || T === "html5" ? E = '<meta charset="' + w.metadata.parsed.charset + `">
` : E = '<meta name="charset" content="' + w.metadata.parsed.charset + `">
`;
                                break;
                            case "language":
                            case "lang":
                                N = ' lang="' + w.metadata.parsed[z] + '"',
                                    j += '<meta name="' + z + '" content="' + w.metadata.parsed[z] + `">
`;
                                break;
                            default:
                                j += '<meta name="' + z + '" content="' + w.metadata.parsed[z] + `">
`
                        }
                return m = O + "<html" + N + `>
<head>
` + M + E + j + `</head>
<body>
` + m.trim() + `
</body>
</html>`,
                    m = w.converter._dispatch("completeHTMLDocument.after", m, b, w),
                    m
            }),
            r.subParser("detab", function (m, b, w) {
                return m = w.converter._dispatch("detab.before", m, b, w),
                    m = m.replace(/\t(?=\t)/g, "    "),
                    m = m.replace(/\t/g, "AB"),
                    m = m.replace(/B(.+?)A/g, function (T, O) {
                        for (var M = O, E = 4 - M.length % 4, N = 0; N < E; N++)
                            M += " ";
                        return M
                    }),
                    m = m.replace(/A/g, "    "),
                    m = m.replace(/B/g, ""),
                    m = w.converter._dispatch("detab.after", m, b, w),
                    m
            }),
            r.subParser("ellipsis", function (m, b, w) {
                return b.ellipsis && (m = w.converter._dispatch("ellipsis.before", m, b, w),
                    m = m.replace(/\.\.\./g, ""),
                    m = w.converter._dispatch("ellipsis.after", m, b, w)),
                    m
            }),
            r.subParser("emoji", function (m, b, w) {
                if (!b.emoji)
                    return m;
                m = w.converter._dispatch("emoji.before", m, b, w);
                var T = /:([\S]+?):/g;
                return m = m.replace(T, function (O, M) {
                    return r.helper.emojis.hasOwnProperty(M) ? r.helper.emojis[M] : O
                }),
                    m = w.converter._dispatch("emoji.after", m, b, w),
                    m
            }),
            r.subParser("encodeAmpsAndAngles", function (m, b, w) {
                return m = w.converter._dispatch("encodeAmpsAndAngles.before", m, b, w),
                    m = m.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;"),
                    m = m.replace(/<(?![a-z\/?$!])/gi, "&lt;"),
                    m = m.replace(/</g, "&lt;"),
                    m = m.replace(/>/g, "&gt;"),
                    m = w.converter._dispatch("encodeAmpsAndAngles.after", m, b, w),
                    m
            }),
            r.subParser("encodeBackslashEscapes", function (m, b, w) {
                return m = w.converter._dispatch("encodeBackslashEscapes.before", m, b, w),
                    m = m.replace(/\\(\\)/g, r.helper.escapeCharactersCallback),
                    m = m.replace(/\\([`*_{}\[\]()>#+.!~=|:-])/g, r.helper.escapeCharactersCallback),
                    m = w.converter._dispatch("encodeBackslashEscapes.after", m, b, w),
                    m
            }),
            r.subParser("encodeCode", function (m, b, w) {
                return m = w.converter._dispatch("encodeCode.before", m, b, w),
                    m = m.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/([*_{}\[\]\\=~-])/g, r.helper.escapeCharactersCallback),
                    m = w.converter._dispatch("encodeCode.after", m, b, w),
                    m
            }),
            r.subParser("escapeSpecialCharsWithinTagAttributes", function (m, b, w) {
                m = w.converter._dispatch("escapeSpecialCharsWithinTagAttributes.before", m, b, w);
                var T = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi
                    , O = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;
                return m = m.replace(T, function (M) {
                    return M.replace(/(.)<\/?code>(?=.)/g, "$1`").replace(/([\\`*_~=|])/g, r.helper.escapeCharactersCallback)
                }),
                    m = m.replace(O, function (M) {
                        return M.replace(/([\\`*_~=|])/g, r.helper.escapeCharactersCallback)
                    }),
                    m = w.converter._dispatch("escapeSpecialCharsWithinTagAttributes.after", m, b, w),
                    m
            }),
            r.subParser("githubCodeBlocks", function (m, b, w) {
                return b.ghCodeBlocks ? (m = w.converter._dispatch("githubCodeBlocks.before", m, b, w),
                    m += "0",
                    m = m.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (T, O, M, E) {
                        var N = b.omitExtraWLInCodeBlocks ? "" : `
`;
                        return E = r.subParser("encodeCode")(E, b, w),
                            E = r.subParser("detab")(E, b, w),
                            E = E.replace(/^\n+/g, ""),
                            E = E.replace(/\n+$/g, ""),
                            E = "<pre><code" + (M ? ' class="' + M + " language-" + M + '"' : "") + ">" + E + N + "</code></pre>",
                            E = r.subParser("hashBlock")(E, b, w),
                            `

G` + (w.ghCodeBlocks.push({
                                text: T,
                                codeblock: E
                            }) - 1) + `G

`
                    }),
                    m = m.replace(/0/, ""),
                    w.converter._dispatch("githubCodeBlocks.after", m, b, w)) : m
            }),
            r.subParser("hashBlock", function (m, b, w) {
                return m = w.converter._dispatch("hashBlock.before", m, b, w),
                    m = m.replace(/(^\n+|\n+$)/g, ""),
                    m = `

K` + (w.gHtmlBlocks.push(m) - 1) + `K

`,
                    m = w.converter._dispatch("hashBlock.after", m, b, w),
                    m
            }),
            r.subParser("hashCodeTags", function (m, b, w) {
                m = w.converter._dispatch("hashCodeTags.before", m, b, w);
                var T = function (O, M, E, N) {
                    var j = E + r.subParser("encodeCode")(M, b, w) + N;
                    return "C" + (w.gHtmlSpans.push(j) - 1) + "C"
                };
                return m = r.helper.replaceRecursiveRegExp(m, T, "<code\\b[^>]*>", "</code>", "gim"),
                    m = w.converter._dispatch("hashCodeTags.after", m, b, w),
                    m
            }),
            r.subParser("hashElement", function (m, b, w) {
                return function (T, O) {
                    var M = O;
                    return M = M.replace(/\n\n/g, `
`),
                        M = M.replace(/^\n/, ""),
                        M = M.replace(/\n+$/g, ""),
                        M = `

K` + (w.gHtmlBlocks.push(M) - 1) + `K

`,
                        M
                }
            }),
            r.subParser("hashHTMLBlocks", function (m, b, w) {
                m = w.converter._dispatch("hashHTMLBlocks.before", m, b, w);
                var T = ["pre", "div", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "table", "dl", "ol", "ul", "script", "noscript", "form", "fieldset", "iframe", "math", "style", "section", "header", "footer", "nav", "article", "aside", "address", "audio", "canvas", "figure", "hgroup", "output", "video", "p"]
                    , O = function (P, F, K, re) {
                        var Te = P;
                        return K.search(/\bmarkdown\b/) !== -1 && (Te = K + w.converter.makeHtml(F) + re),
                            `

K` + (w.gHtmlBlocks.push(Te) - 1) + `K

`
                    };
                b.backslashEscapesHTMLTags && (m = m.replace(/\\<(\/?[^>]+?)>/g, function (P, F) {
                    return "&lt;" + F + "&gt;"
                }));
                for (var M = 0; M < T.length; ++M)
                    for (var E, N = new RegExp("^ {0,3}(<" + T[M] + "\\b[^>]*>)", "im"), j = "<" + T[M] + "\\b[^>]*>", z = "</" + T[M] + ">"; (E = r.helper.regexIndexOf(m, N)) !== -1;) {
                        var V = r.helper.splitAtIndex(m, E)
                            , W = r.helper.replaceRecursiveRegExp(V[1], O, j, z, "im");
                        if (W === V[1])
                            break;
                        m = V[0].concat(W)
                    }
                return m = m.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g, r.subParser("hashElement")(m, b, w)),
                    m = r.helper.replaceRecursiveRegExp(m, function (P) {
                        return `

K` + (w.gHtmlBlocks.push(P) - 1) + `K

`
                    }, "^ {0,3}<!--", "-->", "gm"),
                    m = m.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g, r.subParser("hashElement")(m, b, w)),
                    m = w.converter._dispatch("hashHTMLBlocks.after", m, b, w),
                    m
            }),
            r.subParser("hashHTMLSpans", function (m, b, w) {
                m = w.converter._dispatch("hashHTMLSpans.before", m, b, w);
                function T(O) {
                    return "C" + (w.gHtmlSpans.push(O) - 1) + "C"
                }
                return m = m.replace(/<[^>]+?\/>/gi, function (O) {
                    return T(O)
                }),
                    m = m.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (O) {
                        return T(O)
                    }),
                    m = m.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (O) {
                        return T(O)
                    }),
                    m = m.replace(/<[^>]+?>/gi, function (O) {
                        return T(O)
                    }),
                    m = w.converter._dispatch("hashHTMLSpans.after", m, b, w),
                    m
            }),
            r.subParser("unhashHTMLSpans", function (m, b, w) {
                m = w.converter._dispatch("unhashHTMLSpans.before", m, b, w);
                for (var T = 0; T < w.gHtmlSpans.length; ++T) {
                    for (var O = w.gHtmlSpans[T], M = 0; /C(\d+)C/.test(O);) {
                        var E = RegExp.$1;
                        if (O = O.replace("C" + E + "C", w.gHtmlSpans[E]),
                            M === 10) {
                            console.error("maximum nesting of 10 spans reached!!!");
                            break
                        }
                        ++M
                    }
                    m = m.replace("C" + T + "C", O)
                }
                return m = w.converter._dispatch("unhashHTMLSpans.after", m, b, w),
                    m
            }),
            r.subParser("hashPreCodeTags", function (m, b, w) {
                m = w.converter._dispatch("hashPreCodeTags.before", m, b, w);
                var T = function (O, M, E, N) {
                    var j = E + r.subParser("encodeCode")(M, b, w) + N;
                    return `

G` + (w.ghCodeBlocks.push({
                        text: O,
                        codeblock: j
                    }) - 1) + `G

`
                };
                return m = r.helper.replaceRecursiveRegExp(m, T, "^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>", "^ {0,3}</code>\\s*</pre>", "gim"),
                    m = w.converter._dispatch("hashPreCodeTags.after", m, b, w),
                    m
            }),
            r.subParser("headers", function (m, b, w) {
                m = w.converter._dispatch("headers.before", m, b, w);
                var T = isNaN(parseInt(b.headerLevelStart)) ? 1 : parseInt(b.headerLevelStart)
                    , O = b.smoothLivePreview ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm
                    , M = b.smoothLivePreview ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;
                m = m.replace(O, function (j, z) {
                    var V = r.subParser("spanGamut")(z, b, w)
                        , W = b.noHeaderId ? "" : ' id="' + N(z) + '"'
                        , P = T
                        , F = "<h" + P + W + ">" + V + "</h" + P + ">";
                    return r.subParser("hashBlock")(F, b, w)
                }),
                    m = m.replace(M, function (j, z) {
                        var V = r.subParser("spanGamut")(z, b, w)
                            , W = b.noHeaderId ? "" : ' id="' + N(z) + '"'
                            , P = T + 1
                            , F = "<h" + P + W + ">" + V + "</h" + P + ">";
                        return r.subParser("hashBlock")(F, b, w)
                    });
                var E = b.requireSpaceBeforeHeadingText ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;
                m = m.replace(E, function (j, z, V) {
                    var W = V;
                    b.customizedHeaderId && (W = V.replace(/\s?\{([^{]+?)}\s*$/, ""));
                    var P = r.subParser("spanGamut")(W, b, w)
                        , F = b.noHeaderId ? "" : ' id="' + N(V) + '"'
                        , K = T - 1 + z.length
                        , re = "<h" + K + F + ">" + P + "</h" + K + ">";
                    return r.subParser("hashBlock")(re, b, w)
                });
                function N(j) {
                    var z, V;
                    if (b.customizedHeaderId) {
                        var W = j.match(/\{([^{]+?)}\s*$/);
                        W && W[1] && (j = W[1])
                    }
                    return z = j,
                        r.helper.isString(b.prefixHeaderId) ? V = b.prefixHeaderId : b.prefixHeaderId === !0 ? V = "section-" : V = "",
                        b.rawPrefixHeaderId || (z = V + z),
                        b.ghCompatibleHeaderId ? z = z.replace(/ /g, "-").replace(/&amp;/g, "").replace(/T/g, "").replace(/D/g, "").replace(/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g, "").toLowerCase() : b.rawHeaderId ? z = z.replace(/ /g, "-").replace(/&amp;/g, "&").replace(/T/g, "").replace(/D/g, "$").replace(/["']/g, "-").toLowerCase() : z = z.replace(/[^\w]/g, "").toLowerCase(),
                        b.rawPrefixHeaderId && (z = V + z),
                        w.hashLinkCounts[z] ? z = z + "-" + w.hashLinkCounts[z]++ : w.hashLinkCounts[z] = 1,
                        z
                }
                return m = w.converter._dispatch("headers.after", m, b, w),
                    m
            }),
            r.subParser("horizontalRule", function (m, b, w) {
                m = w.converter._dispatch("horizontalRule.before", m, b, w);
                var T = r.subParser("hashBlock")("<hr />", b, w);
                return m = m.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, T),
                    m = m.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, T),
                    m = m.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, T),
                    m = w.converter._dispatch("horizontalRule.after", m, b, w),
                    m
            }),
            r.subParser("images", function (m, b, w) {
                m = w.converter._dispatch("images.before", m, b, w);
                var T = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g
                    , O = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g
                    , M = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g
                    , E = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g
                    , N = /!\[([^\[\]]+)]()()()()()/g;
                function j(V, W, P, F, K, re, Te, ee) {
                    return F = F.replace(/\s/g, ""),
                        z(V, W, P, F, K, re, Te, ee)
                }
                function z(V, W, P, F, K, re, Te, ee) {
                    var Se = w.gUrls
                        , Ze = w.gTitles
                        , Ke = w.gDimensions;
                    if (P = P.toLowerCase(),
                        ee || (ee = ""),
                        V.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)
                        F = "";
                    else if (F === "" || F === null)
                        if ((P === "" || P === null) && (P = W.toLowerCase().replace(/ ?\n/g, " ")),
                            F = "#" + P,
                            !r.helper.isUndefined(Se[P]))
                            F = Se[P],
                                r.helper.isUndefined(Ze[P]) || (ee = Ze[P]),
                                r.helper.isUndefined(Ke[P]) || (K = Ke[P].width,
                                    re = Ke[P].height);
                        else
                            return V;
                    W = W.replace(/"/g, "&quot;").replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback),
                        F = F.replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback);
                    var Ye = '<img src="' + F + '" alt="' + W + '"';
                    return ee && r.helper.isString(ee) && (ee = ee.replace(/"/g, "&quot;").replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback),
                        Ye += ' title="' + ee + '"'),
                        K && re && (K = K === "*" ? "auto" : K,
                            re = re === "*" ? "auto" : re,
                            Ye += ' width="' + K + '"',
                            Ye += ' height="' + re + '"'),
                        Ye += " />",
                        Ye
                }
                return m = m.replace(E, z),
                    m = m.replace(M, j),
                    m = m.replace(O, z),
                    m = m.replace(T, z),
                    m = m.replace(N, z),
                    m = w.converter._dispatch("images.after", m, b, w),
                    m
            }),
            r.subParser("italicsAndBold", function (m, b, w) {
                m = w.converter._dispatch("italicsAndBold.before", m, b, w);
                function T(O, M, E) {
                    return M + O + E
                }
                return b.literalMidWordUnderscores ? (m = m.replace(/\b___(\S[\s\S]*?)___\b/g, function (O, M) {
                    return T(M, "<strong><em>", "</em></strong>")
                }),
                    m = m.replace(/\b__(\S[\s\S]*?)__\b/g, function (O, M) {
                        return T(M, "<strong>", "</strong>")
                    }),
                    m = m.replace(/\b_(\S[\s\S]*?)_\b/g, function (O, M) {
                        return T(M, "<em>", "</em>")
                    })) : (m = m.replace(/___(\S[\s\S]*?)___/g, function (O, M) {
                        return /\S$/.test(M) ? T(M, "<strong><em>", "</em></strong>") : O
                    }),
                        m = m.replace(/__(\S[\s\S]*?)__/g, function (O, M) {
                            return /\S$/.test(M) ? T(M, "<strong>", "</strong>") : O
                        }),
                        m = m.replace(/_([^\s_][\s\S]*?)_/g, function (O, M) {
                            return /\S$/.test(M) ? T(M, "<em>", "</em>") : O
                        })),
                    b.literalMidWordAsterisks ? (m = m.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (O, M, E) {
                        return T(E, M + "<strong><em>", "</em></strong>")
                    }),
                        m = m.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (O, M, E) {
                            return T(E, M + "<strong>", "</strong>")
                        }),
                        m = m.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (O, M, E) {
                            return T(E, M + "<em>", "</em>")
                        })) : (m = m.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (O, M) {
                            return /\S$/.test(M) ? T(M, "<strong><em>", "</em></strong>") : O
                        }),
                            m = m.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (O, M) {
                                return /\S$/.test(M) ? T(M, "<strong>", "</strong>") : O
                            }),
                            m = m.replace(/\*([^\s*][\s\S]*?)\*/g, function (O, M) {
                                return /\S$/.test(M) ? T(M, "<em>", "</em>") : O
                            })),
                    m = w.converter._dispatch("italicsAndBold.after", m, b, w),
                    m
            }),
            r.subParser("lists", function (m, b, w) {
                function T(E, N) {
                    w.gListLevel++,
                        E = E.replace(/\n{2,}$/, `
`),
                        E += "0";
                    var j = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm
                        , z = /\n[ \t]*\n(?!0)/.test(E);
                    return b.disableForced4SpacesIndentedSublists && (j = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm),
                        E = E.replace(j, function (V, W, P, F, K, re, Te) {
                            Te = Te && Te.trim() !== "";
                            var ee = r.subParser("outdent")(K, b, w)
                                , Se = "";
                            return re && b.tasklists && (Se = ' class="task-list-item" style="list-style-type: none;"',
                                ee = ee.replace(/^[ \t]*\[(x|X| )?]/m, function () {
                                    var Ze = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
                                    return Te && (Ze += " checked"),
                                        Ze += ">",
                                        Ze
                                })),
                                ee = ee.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (Ze) {
                                    return "A" + Ze
                                }),
                                W || ee.search(/\n{2,}/) > -1 ? (ee = r.subParser("githubCodeBlocks")(ee, b, w),
                                    ee = r.subParser("blockGamut")(ee, b, w)) : (ee = r.subParser("lists")(ee, b, w),
                                        ee = ee.replace(/\n$/, ""),
                                        ee = r.subParser("hashHTMLBlocks")(ee, b, w),
                                        ee = ee.replace(/\n\n+/g, `

`),
                                        z ? ee = r.subParser("paragraphs")(ee, b, w) : ee = r.subParser("spanGamut")(ee, b, w)),
                                ee = ee.replace("A", ""),
                                ee = "<li" + Se + ">" + ee + `</li>
`,
                                ee
                        }),
                        E = E.replace(/0/g, ""),
                        w.gListLevel--,
                        N && (E = E.replace(/\s+$/, "")),
                        E
                }
                function O(E, N) {
                    if (N === "ol") {
                        var j = E.match(/^ *(\d+)\./);
                        if (j && j[1] !== "1")
                            return ' start="' + j[1] + '"'
                    }
                    return ""
                }
                function M(E, N, j) {
                    var z = b.disableForced4SpacesIndentedSublists ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm
                        , V = b.disableForced4SpacesIndentedSublists ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm
                        , W = N === "ul" ? z : V
                        , P = "";
                    if (E.search(W) !== -1)
                        (function K(re) {
                            var Te = re.search(W)
                                , ee = O(E, N);
                            Te !== -1 ? (P += `

<` + N + ee + `>
` + T(re.slice(0, Te), !!j) + "</" + N + `>
`,
                                N = N === "ul" ? "ol" : "ul",
                                W = N === "ul" ? z : V,
                                K(re.slice(Te))) : P += `

<` + N + ee + `>
` + T(re, !!j) + "</" + N + `>
`
                        }
                        )(E);
                    else {
                        var F = O(E, N);
                        P = `

<` + N + F + `>
` + T(E, !!j) + "</" + N + `>
`
                    }
                    return P
                }
                return m = w.converter._dispatch("lists.before", m, b, w),
                    m += "0",
                    w.gListLevel ? m = m.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm, function (E, N, j) {
                        var z = j.search(/[*+-]/g) > -1 ? "ul" : "ol";
                        return M(N, z, !0)
                    }) : m = m.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm, function (E, N, j, z) {
                        var V = z.search(/[*+-]/g) > -1 ? "ul" : "ol";
                        return M(j, V, !1)
                    }),
                    m = m.replace(/0/, ""),
                    m = w.converter._dispatch("lists.after", m, b, w),
                    m
            }),
            r.subParser("metadata", function (m, b, w) {
                if (!b.metadata)
                    return m;
                m = w.converter._dispatch("metadata.before", m, b, w);
                function T(O) {
                    w.metadata.raw = O,
                        O = O.replace(/&/g, "&amp;").replace(/"/g, "&quot;"),
                        O = O.replace(/\n {4}/g, " "),
                        O.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (M, E, N) {
                            return w.metadata.parsed[E] = N,
                                ""
                        })
                }
                return m = m.replace(/^\s*+(\S*?)\n([\s\S]+?)\n+\n/, function (O, M, E) {
                    return T(E),
                        "M"
                }),
                    m = m.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (O, M, E) {
                        return M && (w.metadata.format = M),
                            T(E),
                            "M"
                    }),
                    m = m.replace(/M/g, ""),
                    m = w.converter._dispatch("metadata.after", m, b, w),
                    m
            }),
            r.subParser("outdent", function (m, b, w) {
                return m = w.converter._dispatch("outdent.before", m, b, w),
                    m = m.replace(/^(\t|[ ]{1,4})/gm, "0"),
                    m = m.replace(/0/g, ""),
                    m = w.converter._dispatch("outdent.after", m, b, w),
                    m
            }),
            r.subParser("paragraphs", function (m, b, w) {
                m = w.converter._dispatch("paragraphs.before", m, b, w),
                    m = m.replace(/^\n+/g, ""),
                    m = m.replace(/\n+$/g, "");
                for (var T = m.split(/\n{2,}/g), O = [], M = T.length, E = 0; E < M; E++) {
                    var N = T[E];
                    N.search(/(K|G)(\d+)\1/g) >= 0 ? O.push(N) : N.search(/\S/) >= 0 && (N = r.subParser("spanGamut")(N, b, w),
                        N = N.replace(/^([ \t]*)/g, "<p>"),
                        N += "</p>",
                        O.push(N))
                }
                for (M = O.length,
                    E = 0; E < M; E++) {
                    for (var j = "", z = O[E], V = !1; /(K|G)(\d+)\1/.test(z);) {
                        var W = RegExp.$1
                            , P = RegExp.$2;
                        W === "K" ? j = w.gHtmlBlocks[P] : V ? j = r.subParser("encodeCode")(w.ghCodeBlocks[P].text, b, w) : j = w.ghCodeBlocks[P].codeblock,
                            j = j.replace(/\$/g, "$$$$"),
                            z = z.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, j),
                            /^<pre\b[^>]*>\s*<code\b[^>]*>/.test(z) && (V = !0)
                    }
                    O[E] = z
                }
                return m = O.join(`
`),
                    m = m.replace(/^\n+/g, ""),
                    m = m.replace(/\n+$/g, ""),
                    w.converter._dispatch("paragraphs.after", m, b, w)
            }),
            r.subParser("runExtension", function (m, b, w, T) {
                if (m.filter)
                    b = m.filter(b, T.converter, w);
                else if (m.regex) {
                    var O = m.regex;
                    O instanceof RegExp || (O = new RegExp(O, "g")),
                        b = b.replace(O, m.replace)
                }
                return b
            }),
            r.subParser("spanGamut", function (m, b, w) {
                return m = w.converter._dispatch("spanGamut.before", m, b, w),
                    m = r.subParser("codeSpans")(m, b, w),
                    m = r.subParser("escapeSpecialCharsWithinTagAttributes")(m, b, w),
                    m = r.subParser("encodeBackslashEscapes")(m, b, w),
                    m = r.subParser("images")(m, b, w),
                    m = r.subParser("anchors")(m, b, w),
                    m = r.subParser("autoLinks")(m, b, w),
                    m = r.subParser("simplifiedAutoLinks")(m, b, w),
                    m = r.subParser("emoji")(m, b, w),
                    m = r.subParser("underline")(m, b, w),
                    m = r.subParser("italicsAndBold")(m, b, w),
                    m = r.subParser("strikethrough")(m, b, w),
                    m = r.subParser("ellipsis")(m, b, w),
                    m = r.subParser("hashHTMLSpans")(m, b, w),
                    m = r.subParser("encodeAmpsAndAngles")(m, b, w),
                    b.simpleLineBreaks ? /\n\nK/.test(m) || (m = m.replace(/\n+/g, `<br />
`)) : m = m.replace(/  +\n/g, `<br />
`),
                    m = w.converter._dispatch("spanGamut.after", m, b, w),
                    m
            }),
            r.subParser("strikethrough", function (m, b, w) {
                function T(O) {
                    return b.simplifiedAutoLink && (O = r.subParser("simplifiedAutoLinks")(O, b, w)),
                        "<del>" + O + "</del>"
                }
                return b.strikethrough && (m = w.converter._dispatch("strikethrough.before", m, b, w),
                    m = m.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (O, M) {
                        return T(M)
                    }),
                    m = w.converter._dispatch("strikethrough.after", m, b, w)),
                    m
            }),
            r.subParser("stripLinkDefinitions", function (m, b, w) {
                var T = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm
                    , O = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm;
                m += "0";
                var M = function (E, N, j, z, V, W, P) {
                    return N = N.toLowerCase(),
                        m.toLowerCase().split(N).length - 1 < 2 ? E : (j.match(/^data:.+?\/.+?;base64,/) ? w.gUrls[N] = j.replace(/\s/g, "") : w.gUrls[N] = r.subParser("encodeAmpsAndAngles")(j, b, w),
                            W ? W + P : (P && (w.gTitles[N] = P.replace(/"|'/g, "&quot;")),
                                b.parseImgDimensions && z && V && (w.gDimensions[N] = {
                                    width: z,
                                    height: V
                                }),
                                ""))
                };
                return m = m.replace(O, M),
                    m = m.replace(T, M),
                    m = m.replace(/0/, ""),
                    m
            }),
            r.subParser("tables", function (m, b, w) {
                if (!b.tables)
                    return m;
                var T = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm
                    , O = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm;
                function M(V) {
                    return /^:[ \t]*--*$/.test(V) ? ' style="text-align:left;"' : /^--*[ \t]*:[ \t]*$/.test(V) ? ' style="text-align:right;"' : /^:[ \t]*--*[ \t]*:$/.test(V) ? ' style="text-align:center;"' : ""
                }
                function E(V, W) {
                    var P = "";
                    return V = V.trim(),
                        (b.tablesHeaderId || b.tableHeaderId) && (P = ' id="' + V.replace(/ /g, "_").toLowerCase() + '"'),
                        V = r.subParser("spanGamut")(V, b, w),
                        "<th" + P + W + ">" + V + `</th>
`
                }
                function N(V, W) {
                    var P = r.subParser("spanGamut")(V, b, w);
                    return "<td" + W + ">" + P + `</td>
`
                }
                function j(V, W) {
                    for (var P = `<table>
<thead>
<tr>
`, F = V.length, K = 0; K < F; ++K)
                        P += V[K];
                    for (P += `</tr>
</thead>
<tbody>
`,
                        K = 0; K < W.length; ++K) {
                        P += `<tr>
`;
                        for (var re = 0; re < F; ++re)
                            P += W[K][re];
                        P += `</tr>
`
                    }
                    return P += `</tbody>
</table>
`,
                        P
                }
                function z(V) {
                    var W, P = V.split(`
`);
                    for (W = 0; W < P.length; ++W)
                        /^ {0,3}\|/.test(P[W]) && (P[W] = P[W].replace(/^ {0,3}\|/, "")),
                            /\|[ \t]*$/.test(P[W]) && (P[W] = P[W].replace(/\|[ \t]*$/, "")),
                            P[W] = r.subParser("codeSpans")(P[W], b, w);
                    var F = P[0].split("|").map(function (Ye) {
                        return Ye.trim()
                    })
                        , K = P[1].split("|").map(function (Ye) {
                            return Ye.trim()
                        })
                        , re = []
                        , Te = []
                        , ee = []
                        , Se = [];
                    for (P.shift(),
                        P.shift(),
                        W = 0; W < P.length; ++W)
                        P[W].trim() !== "" && re.push(P[W].split("|").map(function (Ye) {
                            return Ye.trim()
                        }));
                    if (F.length < K.length)
                        return V;
                    for (W = 0; W < K.length; ++W)
                        ee.push(M(K[W]));
                    for (W = 0; W < F.length; ++W)
                        r.helper.isUndefined(ee[W]) && (ee[W] = ""),
                            Te.push(E(F[W], ee[W]));
                    for (W = 0; W < re.length; ++W) {
                        for (var Ze = [], Ke = 0; Ke < Te.length; ++Ke)
                            r.helper.isUndefined(re[W][Ke]),
                                Ze.push(N(re[W][Ke], ee[Ke]));
                        Se.push(Ze)
                    }
                    return j(Te, Se)
                }
                return m = w.converter._dispatch("tables.before", m, b, w),
                    m = m.replace(/\\(\|)/g, r.helper.escapeCharactersCallback),
                    m = m.replace(T, z),
                    m = m.replace(O, z),
                    m = w.converter._dispatch("tables.after", m, b, w),
                    m
            }),
            r.subParser("underline", function (m, b, w) {
                return b.underline && (m = w.converter._dispatch("underline.before", m, b, w),
                    b.literalMidWordUnderscores ? (m = m.replace(/\b___(\S[\s\S]*?)___\b/g, function (T, O) {
                        return "<u>" + O + "</u>"
                    }),
                        m = m.replace(/\b__(\S[\s\S]*?)__\b/g, function (T, O) {
                            return "<u>" + O + "</u>"
                        })) : (m = m.replace(/___(\S[\s\S]*?)___/g, function (T, O) {
                            return /\S$/.test(O) ? "<u>" + O + "</u>" : T
                        }),
                            m = m.replace(/__(\S[\s\S]*?)__/g, function (T, O) {
                                return /\S$/.test(O) ? "<u>" + O + "</u>" : T
                            })),
                    m = m.replace(/(_)/g, r.helper.escapeCharactersCallback),
                    m = w.converter._dispatch("underline.after", m, b, w)),
                    m
            }),
            r.subParser("unescapeSpecialChars", function (m, b, w) {
                return m = w.converter._dispatch("unescapeSpecialChars.before", m, b, w),
                    m = m.replace(/E(\d+)E/g, function (T, O) {
                        var M = parseInt(O);
                        return String.fromCharCode(M)
                    }),
                    m = w.converter._dispatch("unescapeSpecialChars.after", m, b, w),
                    m
            }),
            r.subParser("makeMarkdown.blockquote", function (m, b) {
                var w = "";
                if (m.hasChildNodes())
                    for (var T = m.childNodes, O = T.length, M = 0; M < O; ++M) {
                        var E = r.subParser("makeMarkdown.node")(T[M], b);
                        E !== "" && (w += E)
                    }
                return w = w.trim(),
                    w = "> " + w.split(`
`).join(`
> `),
                    w
            }),
            r.subParser("makeMarkdown.codeBlock", function (m, b) {
                var w = m.getAttribute("language")
                    , T = m.getAttribute("precodenum");
                return "```" + w + `
` + b.preList[T] + "\n```"
            }),
            r.subParser("makeMarkdown.codeSpan", function (m) {
                return "`" + m.innerHTML + "`"
            }),
            r.subParser("makeMarkdown.emphasis", function (m, b) {
                var w = "";
                if (m.hasChildNodes()) {
                    w += "*";
                    for (var T = m.childNodes, O = T.length, M = 0; M < O; ++M)
                        w += r.subParser("makeMarkdown.node")(T[M], b);
                    w += "*"
                }
                return w
            }),
            r.subParser("makeMarkdown.header", function (m, b, w) {
                var T = new Array(w + 1).join("#")
                    , O = "";
                if (m.hasChildNodes()) {
                    O = T + " ";
                    for (var M = m.childNodes, E = M.length, N = 0; N < E; ++N)
                        O += r.subParser("makeMarkdown.node")(M[N], b)
                }
                return O
            }),
            r.subParser("makeMarkdown.hr", function () {
                return "---"
            }),
            r.subParser("makeMarkdown.image", function (m) {
                var b = "";
                return m.hasAttribute("src") && (b += "![" + m.getAttribute("alt") + "](",
                    b += "<" + m.getAttribute("src") + ">",
                    m.hasAttribute("width") && m.hasAttribute("height") && (b += " =" + m.getAttribute("width") + "x" + m.getAttribute("height")),
                    m.hasAttribute("title") && (b += ' "' + m.getAttribute("title") + '"'),
                    b += ")"),
                    b
            }),
            r.subParser("makeMarkdown.links", function (m, b) {
                var w = "";
                if (m.hasChildNodes() && m.hasAttribute("href")) {
                    var T = m.childNodes
                        , O = T.length;
                    w = "[";
                    for (var M = 0; M < O; ++M)
                        w += r.subParser("makeMarkdown.node")(T[M], b);
                    w += "](",
                        w += "<" + m.getAttribute("href") + ">",
                        m.hasAttribute("title") && (w += ' "' + m.getAttribute("title") + '"'),
                        w += ")"
                }
                return w
            }),
            r.subParser("makeMarkdown.list", function (m, b, w) {
                var T = "";
                if (!m.hasChildNodes())
                    return "";
                for (var O = m.childNodes, M = O.length, E = m.getAttribute("start") || 1, N = 0; N < M; ++N)
                    if (!(typeof O[N].tagName > "u" || O[N].tagName.toLowerCase() !== "li")) {
                        var j = "";
                        w === "ol" ? j = E.toString() + ". " : j = "- ",
                            T += j + r.subParser("makeMarkdown.listItem")(O[N], b),
                            ++E
                    }
                return T += `
<!-- -->
`,
                    T.trim()
            }),
            r.subParser("makeMarkdown.listItem", function (m, b) {
                for (var w = "", T = m.childNodes, O = T.length, M = 0; M < O; ++M)
                    w += r.subParser("makeMarkdown.node")(T[M], b);
                return /\n$/.test(w) ? w = w.split(`
`).join(`
    `).replace(/^ {4}$/gm, "").replace(/\n\n+/g, `

`) : w += `
`,
                    w
            }),
            r.subParser("makeMarkdown.node", function (m, b, w) {
                w = w || !1;
                var T = "";
                if (m.nodeType === 3)
                    return r.subParser("makeMarkdown.txt")(m, b);
                if (m.nodeType === 8)
                    return "<!--" + m.data + `-->

`;
                if (m.nodeType !== 1)
                    return "";
                var O = m.tagName.toLowerCase();
                switch (O) {
                    case "h1":
                        w || (T = r.subParser("makeMarkdown.header")(m, b, 1) + `

`);
                        break;
                    case "h2":
                        w || (T = r.subParser("makeMarkdown.header")(m, b, 2) + `

`);
                        break;
                    case "h3":
                        w || (T = r.subParser("makeMarkdown.header")(m, b, 3) + `

`);
                        break;
                    case "h4":
                        w || (T = r.subParser("makeMarkdown.header")(m, b, 4) + `

`);
                        break;
                    case "h5":
                        w || (T = r.subParser("makeMarkdown.header")(m, b, 5) + `

`);
                        break;
                    case "h6":
                        w || (T = r.subParser("makeMarkdown.header")(m, b, 6) + `

`);
                        break;
                    case "p":
                        w || (T = r.subParser("makeMarkdown.paragraph")(m, b) + `

`);
                        break;
                    case "blockquote":
                        w || (T = r.subParser("makeMarkdown.blockquote")(m, b) + `

`);
                        break;
                    case "hr":
                        w || (T = r.subParser("makeMarkdown.hr")(m, b) + `

`);
                        break;
                    case "ol":
                        w || (T = r.subParser("makeMarkdown.list")(m, b, "ol") + `

`);
                        break;
                    case "ul":
                        w || (T = r.subParser("makeMarkdown.list")(m, b, "ul") + `

`);
                        break;
                    case "precode":
                        w || (T = r.subParser("makeMarkdown.codeBlock")(m, b) + `

`);
                        break;
                    case "pre":
                        w || (T = r.subParser("makeMarkdown.pre")(m, b) + `

`);
                        break;
                    case "table":
                        w || (T = r.subParser("makeMarkdown.table")(m, b) + `

`);
                        break;
                    case "code":
                        T = r.subParser("makeMarkdown.codeSpan")(m, b);
                        break;
                    case "em":
                    case "i":
                        T = r.subParser("makeMarkdown.emphasis")(m, b);
                        break;
                    case "strong":
                    case "b":
                        T = r.subParser("makeMarkdown.strong")(m, b);
                        break;
                    case "del":
                        T = r.subParser("makeMarkdown.strikethrough")(m, b);
                        break;
                    case "a":
                        T = r.subParser("makeMarkdown.links")(m, b);
                        break;
                    case "img":
                        T = r.subParser("makeMarkdown.image")(m, b);
                        break;
                    default:
                        T = m.outerHTML + `

`
                }
                return T
            }),
            r.subParser("makeMarkdown.paragraph", function (m, b) {
                var w = "";
                if (m.hasChildNodes())
                    for (var T = m.childNodes, O = T.length, M = 0; M < O; ++M)
                        w += r.subParser("makeMarkdown.node")(T[M], b);
                return w = w.trim(),
                    w
            }),
            r.subParser("makeMarkdown.pre", function (m, b) {
                var w = m.getAttribute("prenum");
                return "<pre>" + b.preList[w] + "</pre>"
            }),
            r.subParser("makeMarkdown.strikethrough", function (m, b) {
                var w = "";
                if (m.hasChildNodes()) {
                    w += "~~";
                    for (var T = m.childNodes, O = T.length, M = 0; M < O; ++M)
                        w += r.subParser("makeMarkdown.node")(T[M], b);
                    w += "~~"
                }
                return w
            }),
            r.subParser("makeMarkdown.strong", function (m, b) {
                var w = "";
                if (m.hasChildNodes()) {
                    w += "**";
                    for (var T = m.childNodes, O = T.length, M = 0; M < O; ++M)
                        w += r.subParser("makeMarkdown.node")(T[M], b);
                    w += "**"
                }
                return w
            }),
            r.subParser("makeMarkdown.table", function (m, b) {
                var w = "", T = [[], []], O = m.querySelectorAll("thead>tr>th"), M = m.querySelectorAll("tbody>tr"), E, N;
                for (E = 0; E < O.length; ++E) {
                    var j = r.subParser("makeMarkdown.tableCell")(O[E], b)
                        , z = "---";
                    if (O[E].hasAttribute("style")) {
                        var V = O[E].getAttribute("style").toLowerCase().replace(/\s/g, "");
                        switch (V) {
                            case "text-align:left;":
                                z = ":---";
                                break;
                            case "text-align:right;":
                                z = "---:";
                                break;
                            case "text-align:center;":
                                z = ":---:";
                                break
                        }
                    }
                    T[0][E] = j.trim(),
                        T[1][E] = z
                }
                for (E = 0; E < M.length; ++E) {
                    var W = T.push([]) - 1
                        , P = M[E].getElementsByTagName("td");
                    for (N = 0; N < O.length; ++N) {
                        var F = " ";
                        typeof P[N] < "u" && (F = r.subParser("makeMarkdown.tableCell")(P[N], b)),
                            T[W].push(F)
                    }
                }
                var K = 3;
                for (E = 0; E < T.length; ++E)
                    for (N = 0; N < T[E].length; ++N) {
                        var re = T[E][N].length;
                        re > K && (K = re)
                    }
                for (E = 0; E < T.length; ++E) {
                    for (N = 0; N < T[E].length; ++N)
                        E === 1 ? T[E][N].slice(-1) === ":" ? T[E][N] = r.helper.padEnd(T[E][N].slice(-1), K - 1, "-") + ":" : T[E][N] = r.helper.padEnd(T[E][N], K, "-") : T[E][N] = r.helper.padEnd(T[E][N], K);
                    w += "| " + T[E].join(" | ") + ` |
`
                }
                return w.trim()
            }),
            r.subParser("makeMarkdown.tableCell", function (m, b) {
                var w = "";
                if (!m.hasChildNodes())
                    return "";
                for (var T = m.childNodes, O = T.length, M = 0; M < O; ++M)
                    w += r.subParser("makeMarkdown.node")(T[M], b, !0);
                return w.trim()
            }),
            r.subParser("makeMarkdown.txt", function (m) {
                var b = m.nodeValue;
                return b = b.replace(/ +/g, " "),
                    b = b.replace(/NBSP;/g, " "),
                    b = r.helper.unescapeHTMLEntities(b),
                    b = b.replace(/([*_~|`])/g, "\\$1"),
                    b = b.replace(/^(\s*)>/g, "\\$1>"),
                    b = b.replace(/^#/gm, "\\#"),
                    b = b.replace(/^(\s*)([-=]{3,})(\s*)$/, "$1\\$2$3"),
                    b = b.replace(/^( {0,3}\d+)\./gm, "$1\\."),
                    b = b.replace(/^( {0,3})([+-])/gm, "$1\\$2"),
                    b = b.replace(/]([\s]*)\(/g, "\\]$1\\("),
                    b = b.replace(/^ {0,3}\[([\S \t]*?)]:/gm, "\\[$1]:"),
                    b
            });
        var C = this;
        t.exports ? t.exports = r : C.showdown = r
    }
    ).call(ua)
}
)(wA);
var Pq = wA.exports;
const See = tE(Pq);
const Nq = {
    name: "Toast",
    props: {
        position: {
            type: String,
            default: "top-center"
        },
        icon: {
            type: String
        },
        iconClasses: {
            type: String
        },
        title: {
            type: String
        },
        text: {
            type: String
        },
        timeout: {
            type: Number,
            default: 5
        }
    },
    emits: ["close"],
    components: {
        FeatherIcon: ko
    },
    mounted() {
        this.timeout > 0 && setTimeout(() => {
            this.$emit("close")
        }
            , this.timeout * 1e3)
    }
}
    , Iq = {
        class: "my-2 min-w-[15rem] max-w-[40rem] rounded-lg border bg-white p-4 shadow-md"
    }
    , Lq = {
        class: "flex items-start"
    }
    , Dq = {
        key: 0,
        class: "mr-3 grid h-5 w-5 place-items-center"
    }
    , jq = {
        key: 1,
        class: "text-base text-gray-600"
    }
    , Bq = {
        class: "ml-auto pl-2"
    };
function $q(t, e, n, r, i, s) {
    const o = Cn("FeatherIcon");
    return oe(),
        Ae("div", Iq, [Xe("div", Lq, [n.icon ? (oe(),
            Ae("div", Dq, [$e(o, {
                name: n.icon,
                class: mt(["h-5 w-5", n.iconClasses])
            }, null, 8, ["name", "class"])])) : pt("", !0), Xe("div", null, [Ue(t.$slots, "default", {}, () => [n.title ? (oe(),
                Ae("p", {
                    key: 0,
                    class: mt(["text-base font-medium text-gray-900", {
                        "mb-1": n.text
                    }])
                }, Vt(n.title), 3)) : pt("", !0), n.text ? (oe(),
                    Ae("p", jq, Vt(n.text), 1)) : pt("", !0)])]), Xe("div", Bq, [Ue(t.$slots, "actions", {}, () => [Xe("button", {
                        class: "grid h-5 w-5 place-items-center rounded hover:bg-gray-100",
                        onClick: e[0] || (e[0] = a => t.$emit("close"))
                    }, [$e(o, {
                        name: "x",
                        class: "h-4 w-4 text-gray-700"
                    })])])])])])
}
const zq = Ua(Nq, [["render", $q]]);
let bh = ce([])
    , Fq = {
        name: "Toasts",
        created() {
            if (!(typeof window > "u") && !document.getElementById("frappeui-toast-root")) {
                const t = document.createElement("div");
                t.id = "frappeui-toast-root",
                    t.style.position = "fixed",
                    t.style.top = "16px",
                    t.style.right = "16px",
                    t.style.bottom = "16px",
                    t.style.left = "16px",
                    t.style.zIndex = "9999",
                    t.style.pointerEvents = "none",
                    document.body.appendChild(t)
            }
        },
        render() {
            return Mt(im, {
                to: "#frappeui-toast-root"
            }, [vl("top-left"), vl("top-center"), vl("top-right"), vl("bottom-left"), vl("bottom-center"), vl("bottom-right")])
        }
    };
function vl(t) {
    let e = "transition duration-[230ms] ease-[cubic-bezier(.21,1.02,.73,1)]"
        , n = ["absolute"];
    return t === "top-left" && n.push("top-0 left-0"),
        t === "top-right" && n.push("top-0 right-0"),
        t === "top-center" && n.push("top-0 left-1/2 -translate-x-1/2"),
        t === "bottom-left" && n.push("bottom-0 left-0"),
        t === "bottom-right" && n.push("bottom-0 right-0"),
        t === "bottom-center" && n.push("bottom-0 left-1/2 -translate-x-1/2"),
        Mt(OL, {
            tag: "div",
            class: n,
            moveClass: e,
            enterActiveClass: e,
            enterFromClass: "translate-y-1 opacity-0",
            enterToClass: "translate-y-0 opacity-100",
            leaveActiveClass: `${e} absolute`,
            leaveFromClass: "translate-y-0 opacity-100",
            leaveToClass: "translate-y-1 opacity-0"
        }, () => bh.value.filter(r => r.position === t).map(r => Mt("div", {
            key: r.key,
            class: "pointer-events-auto flex"
        }, Mt(zq, {
            ...r,
            onClose: () => {
                bh.value = bh.value.filter(i => i !== r)
            }
        }))))
}
function Hq(t) {
    let e = `toast-${Math.random().toString(36).slice(2, 9)}`
        , n = wn({
            key: e,
            position: "top-center",
            ...t
        });
    return bh.value.push(n),
        e
}
const Vq = ["top", "right", "bottom", "left"]
    , Lo = Math.min
    , Lr = Math.max
    , Lp = Math.round
    , eh = Math.floor
    , Do = t => ({
        x: t,
        y: t
    })
    , Wq = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    }
    , Uq = {
        start: "end",
        end: "start"
    };
function dy(t, e, n) {
    return Lr(t, Lo(e, n))
}
function Ds(t, e) {
    return typeof t == "function" ? t(e) : t
}
function js(t) {
    return t.split("-")[0]
}
function gu(t) {
    return t.split("-")[1]
}
function Kv(t) {
    return t === "x" ? "y" : "x"
}
function qv(t) {
    return t === "y" ? "height" : "width"
}
function jo(t) {
    return ["top", "bottom"].includes(js(t)) ? "y" : "x"
}
function Gv(t) {
    return Kv(jo(t))
}
function Kq(t, e, n) {
    n === void 0 && (n = !1);
    const r = gu(t)
        , i = Gv(t)
        , s = qv(i);
    let o = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return e.reference[s] > e.floating[s] && (o = Dp(o)),
        [o, Dp(o)]
}
function qq(t) {
    const e = Dp(t);
    return [fy(t), e, fy(e)]
}
function fy(t) {
    return t.replace(/start|end/g, e => Uq[e])
}
function Gq(t, e, n) {
    const r = ["left", "right"]
        , i = ["right", "left"]
        , s = ["top", "bottom"]
        , o = ["bottom", "top"];
    switch (t) {
        case "top":
        case "bottom":
            return n ? e ? i : r : e ? r : i;
        case "left":
        case "right":
            return e ? s : o;
        default:
            return []
    }
}
function Jq(t, e, n, r) {
    const i = gu(t);
    let s = Gq(js(t), n === "start", r);
    return i && (s = s.map(o => o + "-" + i),
        e && (s = s.concat(s.map(fy)))),
        s
}
function Dp(t) {
    return t.replace(/left|right|bottom|top/g, e => Wq[e])
}
function Zq(t) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...t
    }
}
function xA(t) {
    return typeof t != "number" ? Zq(t) : {
        top: t,
        right: t,
        bottom: t,
        left: t
    }
}
function jp(t) {
    const { x: e, y: n, width: r, height: i } = t;
    return {
        width: r,
        height: i,
        top: n,
        left: e,
        right: e + r,
        bottom: n + i,
        x: e,
        y: n
    }
}
function nS(t, e, n) {
    let { reference: r, floating: i } = t;
    const s = jo(e)
        , o = Gv(e)
        , a = qv(o)
        , l = js(e)
        , c = s === "y"
        , d = r.x + r.width / 2 - i.width / 2
        , h = r.y + r.height / 2 - i.height / 2
        , p = r[a] / 2 - i[a] / 2;
    let g;
    switch (l) {
        case "top":
            g = {
                x: d,
                y: r.y - i.height
            };
            break;
        case "bottom":
            g = {
                x: d,
                y: r.y + r.height
            };
            break;
        case "right":
            g = {
                x: r.x + r.width,
                y: h
            };
            break;
        case "left":
            g = {
                x: r.x - i.width,
                y: h
            };
            break;
        default:
            g = {
                x: r.x,
                y: r.y
            }
    }
    switch (gu(e)) {
        case "start":
            g[o] -= p * (n && c ? -1 : 1);
            break;
        case "end":
            g[o] += p * (n && c ? -1 : 1);
            break
    }
    return g
}
const Yq = async (t, e, n) => {
    const { placement: r = "bottom", strategy: i = "absolute", middleware: s = [], platform: o } = n
        , a = s.filter(Boolean)
        , l = await (o.isRTL == null ? void 0 : o.isRTL(e));
    let c = await o.getElementRects({
        reference: t,
        floating: e,
        strategy: i
    })
        , { x: d, y: h } = nS(c, r, l)
        , p = r
        , g = {}
        , y = 0;
    for (let x = 0; x < a.length; x++) {
        const { name: S, fn: k } = a[x]
            , { x: A, y: C, data: m, reset: b } = await k({
                x: d,
                y: h,
                initialPlacement: r,
                placement: p,
                strategy: i,
                middlewareData: g,
                rects: c,
                platform: o,
                elements: {
                    reference: t,
                    floating: e
                }
            });
        d = A ?? d,
            h = C ?? h,
            g = {
                ...g,
                [S]: {
                    ...g[S],
                    ...m
                }
            },
            b && y <= 50 && (y++,
                typeof b == "object" && (b.placement && (p = b.placement),
                    b.rects && (c = b.rects === !0 ? await o.getElementRects({
                        reference: t,
                        floating: e,
                        strategy: i
                    }) : b.rects),
                    { x: d, y: h } = nS(c, p, l)),
                x = -1)
    }
    return {
        x: d,
        y: h,
        placement: p,
        strategy: i,
        middlewareData: g
    }
}
    ;
async function Kc(t, e) {
    var n;
    e === void 0 && (e = {});
    const { x: r, y: i, platform: s, rects: o, elements: a, strategy: l } = t
        , { boundary: c = "clippingAncestors", rootBoundary: d = "viewport", elementContext: h = "floating", altBoundary: p = !1, padding: g = 0 } = Ds(e, t)
        , y = xA(g)
        , S = a[p ? h === "floating" ? "reference" : "floating" : h]
        , k = jp(await s.getClippingRect({
            element: (n = await (s.isElement == null ? void 0 : s.isElement(S))) == null || n ? S : S.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
            boundary: c,
            rootBoundary: d,
            strategy: l
        }))
        , A = h === "floating" ? {
            x: r,
            y: i,
            width: o.floating.width,
            height: o.floating.height
        } : o.reference
        , C = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating))
        , m = await (s.isElement == null ? void 0 : s.isElement(C)) ? await (s.getScale == null ? void 0 : s.getScale(C)) || {
            x: 1,
            y: 1
        } : {
            x: 1,
            y: 1
        }
        , b = jp(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: a,
            rect: A,
            offsetParent: C,
            strategy: l
        }) : A);
    return {
        top: (k.top - b.top + y.top) / m.y,
        bottom: (b.bottom - k.bottom + y.bottom) / m.y,
        left: (k.left - b.left + y.left) / m.x,
        right: (b.right - k.right + y.right) / m.x
    }
}
const Xq = t => ({
    name: "arrow",
    options: t,
    async fn(e) {
        const { x: n, y: r, placement: i, rects: s, platform: o, elements: a, middlewareData: l } = e
            , { element: c, padding: d = 0 } = Ds(t, e) || {};
        if (c == null)
            return {};
        const h = xA(d)
            , p = {
                x: n,
                y: r
            }
            , g = Gv(i)
            , y = qv(g)
            , x = await o.getDimensions(c)
            , S = g === "y"
            , k = S ? "top" : "left"
            , A = S ? "bottom" : "right"
            , C = S ? "clientHeight" : "clientWidth"
            , m = s.reference[y] + s.reference[g] - p[g] - s.floating[y]
            , b = p[g] - s.reference[g]
            , w = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
        let T = w ? w[C] : 0;
        (!T || !await (o.isElement == null ? void 0 : o.isElement(w))) && (T = a.floating[C] || s.floating[y]);
        const O = m / 2 - b / 2
            , M = T / 2 - x[y] / 2 - 1
            , E = Lo(h[k], M)
            , N = Lo(h[A], M)
            , j = E
            , z = T - x[y] - N
            , V = T / 2 - x[y] / 2 + O
            , W = dy(j, V, z)
            , P = !l.arrow && gu(i) != null && V !== W && s.reference[y] / 2 - (V < j ? E : N) - x[y] / 2 < 0
            , F = P ? V < j ? V - j : V - z : 0;
        return {
            [g]: p[g] + F,
            data: {
                [g]: W,
                centerOffset: V - W - F,
                ...P && {
                    alignmentOffset: F
                }
            },
            reset: P
        }
    }
})
    , Qq = function (t) {
        return t === void 0 && (t = {}),
        {
            name: "flip",
            options: t,
            async fn(e) {
                var n, r;
                const { placement: i, middlewareData: s, rects: o, initialPlacement: a, platform: l, elements: c } = e
                    , { mainAxis: d = !0, crossAxis: h = !0, fallbackPlacements: p, fallbackStrategy: g = "bestFit", fallbackAxisSideDirection: y = "none", flipAlignment: x = !0, ...S } = Ds(t, e);
                if ((n = s.arrow) != null && n.alignmentOffset)
                    return {};
                const k = js(i)
                    , A = jo(a)
                    , C = js(a) === a
                    , m = await (l.isRTL == null ? void 0 : l.isRTL(c.floating))
                    , b = p || (C || !x ? [Dp(a)] : qq(a))
                    , w = y !== "none";
                !p && w && b.push(...Jq(a, x, y, m));
                const T = [a, ...b]
                    , O = await Kc(e, S)
                    , M = [];
                let E = ((r = s.flip) == null ? void 0 : r.overflows) || [];
                if (d && M.push(O[k]),
                    h) {
                    const V = Kq(i, o, m);
                    M.push(O[V[0]], O[V[1]])
                }
                if (E = [...E, {
                    placement: i,
                    overflows: M
                }],
                    !M.every(V => V <= 0)) {
                    var N, j;
                    const V = (((N = s.flip) == null ? void 0 : N.index) || 0) + 1
                        , W = T[V];
                    if (W)
                        return {
                            data: {
                                index: V,
                                overflows: E
                            },
                            reset: {
                                placement: W
                            }
                        };
                    let P = (j = E.filter(F => F.overflows[0] <= 0).sort((F, K) => F.overflows[1] - K.overflows[1])[0]) == null ? void 0 : j.placement;
                    if (!P)
                        switch (g) {
                            case "bestFit":
                                {
                                    var z;
                                    const F = (z = E.filter(K => {
                                        if (w) {
                                            const re = jo(K.placement);
                                            return re === A || re === "y"
                                        }
                                        return !0
                                    }
                                    ).map(K => [K.placement, K.overflows.filter(re => re > 0).reduce((re, Te) => re + Te, 0)]).sort((K, re) => K[1] - re[1])[0]) == null ? void 0 : z[0];
                                    F && (P = F);
                                    break
                                }
                            case "initialPlacement":
                                P = a;
                                break
                        }
                    if (i !== P)
                        return {
                            reset: {
                                placement: P
                            }
                        }
                }
                return {}
            }
        }
    };
function rS(t, e) {
    return {
        top: t.top - e.height,
        right: t.right - e.width,
        bottom: t.bottom - e.height,
        left: t.left - e.width
    }
}
function iS(t) {
    return Vq.some(e => t[e] >= 0)
}
const eG = function (t) {
    return t === void 0 && (t = {}),
    {
        name: "hide",
        options: t,
        async fn(e) {
            const { rects: n } = e
                , { strategy: r = "referenceHidden", ...i } = Ds(t, e);
            switch (r) {
                case "referenceHidden":
                    {
                        const s = await Kc(e, {
                            ...i,
                            elementContext: "reference"
                        })
                            , o = rS(s, n.reference);
                        return {
                            data: {
                                referenceHiddenOffsets: o,
                                referenceHidden: iS(o)
                            }
                        }
                    }
                case "escaped":
                    {
                        const s = await Kc(e, {
                            ...i,
                            altBoundary: !0
                        })
                            , o = rS(s, n.floating);
                        return {
                            data: {
                                escapedOffsets: o,
                                escaped: iS(o)
                            }
                        }
                    }
                default:
                    return {}
            }
        }
    }
};
async function tG(t, e) {
    const { placement: n, platform: r, elements: i } = t
        , s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating))
        , o = js(n)
        , a = gu(n)
        , l = jo(n) === "y"
        , c = ["left", "top"].includes(o) ? -1 : 1
        , d = s && l ? -1 : 1
        , h = Ds(e, t);
    let { mainAxis: p, crossAxis: g, alignmentAxis: y } = typeof h == "number" ? {
        mainAxis: h,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: h.mainAxis || 0,
        crossAxis: h.crossAxis || 0,
        alignmentAxis: h.alignmentAxis
    };
    return a && typeof y == "number" && (g = a === "end" ? y * -1 : y),
        l ? {
            x: g * d,
            y: p * c
        } : {
            x: p * c,
            y: g * d
        }
}
const nG = function (t) {
    return t === void 0 && (t = 0),
    {
        name: "offset",
        options: t,
        async fn(e) {
            var n, r;
            const { x: i, y: s, placement: o, middlewareData: a } = e
                , l = await tG(e, t);
            return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
                x: i + l.x,
                y: s + l.y,
                data: {
                    ...l,
                    placement: o
                }
            }
        }
    }
}
    , rG = function (t) {
        return t === void 0 && (t = {}),
        {
            name: "shift",
            options: t,
            async fn(e) {
                const { x: n, y: r, placement: i } = e
                    , { mainAxis: s = !0, crossAxis: o = !1, limiter: a = {
                        fn: S => {
                            let { x: k, y: A } = S;
                            return {
                                x: k,
                                y: A
                            }
                        }
                    }, ...l } = Ds(t, e)
                    , c = {
                        x: n,
                        y: r
                    }
                    , d = await Kc(e, l)
                    , h = jo(js(i))
                    , p = Kv(h);
                let g = c[p]
                    , y = c[h];
                if (s) {
                    const S = p === "y" ? "top" : "left"
                        , k = p === "y" ? "bottom" : "right"
                        , A = g + d[S]
                        , C = g - d[k];
                    g = dy(A, g, C)
                }
                if (o) {
                    const S = h === "y" ? "top" : "left"
                        , k = h === "y" ? "bottom" : "right"
                        , A = y + d[S]
                        , C = y - d[k];
                    y = dy(A, y, C)
                }
                const x = a.fn({
                    ...e,
                    [p]: g,
                    [h]: y
                });
                return {
                    ...x,
                    data: {
                        x: x.x - n,
                        y: x.y - r,
                        enabled: {
                            [p]: s,
                            [h]: o
                        }
                    }
                }
            }
        }
    }
    , iG = function (t) {
        return t === void 0 && (t = {}),
        {
            options: t,
            fn(e) {
                const { x: n, y: r, placement: i, rects: s, middlewareData: o } = e
                    , { offset: a = 0, mainAxis: l = !0, crossAxis: c = !0 } = Ds(t, e)
                    , d = {
                        x: n,
                        y: r
                    }
                    , h = jo(i)
                    , p = Kv(h);
                let g = d[p]
                    , y = d[h];
                const x = Ds(a, e)
                    , S = typeof x == "number" ? {
                        mainAxis: x,
                        crossAxis: 0
                    } : {
                        mainAxis: 0,
                        crossAxis: 0,
                        ...x
                    };
                if (l) {
                    const C = p === "y" ? "height" : "width"
                        , m = s.reference[p] - s.floating[C] + S.mainAxis
                        , b = s.reference[p] + s.reference[C] - S.mainAxis;
                    g < m ? g = m : g > b && (g = b)
                }
                if (c) {
                    var k, A;
                    const C = p === "y" ? "width" : "height"
                        , m = ["top", "left"].includes(js(i))
                        , b = s.reference[h] - s.floating[C] + (m && ((k = o.offset) == null ? void 0 : k[h]) || 0) + (m ? 0 : S.crossAxis)
                        , w = s.reference[h] + s.reference[C] + (m ? 0 : ((A = o.offset) == null ? void 0 : A[h]) || 0) - (m ? S.crossAxis : 0);
                    y < b ? y = b : y > w && (y = w)
                }
                return {
                    [p]: g,
                    [h]: y
                }
            }
        }
    }
    , sG = function (t) {
        return t === void 0 && (t = {}),
        {
            name: "size",
            options: t,
            async fn(e) {
                var n, r;
                const { placement: i, rects: s, platform: o, elements: a } = e
                    , { apply: l = () => { }
                        , ...c } = Ds(t, e)
                    , d = await Kc(e, c)
                    , h = js(i)
                    , p = gu(i)
                    , g = jo(i) === "y"
                    , { width: y, height: x } = s.floating;
                let S, k;
                h === "top" || h === "bottom" ? (S = h,
                    k = p === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (k = h,
                        S = p === "end" ? "top" : "bottom");
                const A = x - d.top - d.bottom
                    , C = y - d.left - d.right
                    , m = Lo(x - d[S], A)
                    , b = Lo(y - d[k], C)
                    , w = !e.middlewareData.shift;
                let T = m
                    , O = b;
                if ((n = e.middlewareData.shift) != null && n.enabled.x && (O = C),
                    (r = e.middlewareData.shift) != null && r.enabled.y && (T = A),
                    w && !p) {
                    const E = Lr(d.left, 0)
                        , N = Lr(d.right, 0)
                        , j = Lr(d.top, 0)
                        , z = Lr(d.bottom, 0);
                    g ? O = y - 2 * (E !== 0 || N !== 0 ? E + N : Lr(d.left, d.right)) : T = x - 2 * (j !== 0 || z !== 0 ? j + z : Lr(d.top, d.bottom))
                }
                await l({
                    ...e,
                    availableWidth: O,
                    availableHeight: T
                });
                const M = await o.getDimensions(a.floating);
                return y !== M.width || x !== M.height ? {
                    reset: {
                        rects: !0
                    }
                } : {}
            }
        }
    };
function Pm() {
    return typeof window < "u"
}
function qa(t) {
    return Jv(t) ? (t.nodeName || "").toLowerCase() : "#document"
}
function Br(t) {
    var e;
    return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}
function ls(t) {
    var e;
    return (e = (Jv(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement
}
function Jv(t) {
    return Pm() ? t instanceof Node || t instanceof Br(t).Node : !1
}
function Mi(t) {
    return Pm() ? t instanceof Element || t instanceof Br(t).Element : !1
}
function ts(t) {
    return Pm() ? t instanceof HTMLElement || t instanceof Br(t).HTMLElement : !1
}
function sS(t) {
    return !Pm() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Br(t).ShadowRoot
}
function Ed(t) {
    const { overflow: e, overflowX: n, overflowY: r, display: i } = Ri(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i)
}
function oG(t) {
    return ["table", "td", "th"].includes(qa(t))
}
function Nm(t) {
    return [":popover-open", ":modal"].some(e => {
        try {
            return t.matches(e)
        } catch {
            return !1
        }
    }
    )
}
function Zv(t) {
    const e = Yv()
        , n = Mi(t) ? Ri(t) : t;
    return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r))
}
function aG(t) {
    let e = Bo(t);
    for (; ts(e) && !ou(e);) {
        if (Zv(e))
            return e;
        if (Nm(e))
            return null;
        e = Bo(e)
    }
    return null
}
function Yv() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function ou(t) {
    return ["html", "body", "#document"].includes(qa(t))
}
function Ri(t) {
    return Br(t).getComputedStyle(t)
}
function Im(t) {
    return Mi(t) ? {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    } : {
        scrollLeft: t.scrollX,
        scrollTop: t.scrollY
    }
}
function Bo(t) {
    if (qa(t) === "html")
        return t;
    const e = t.assignedSlot || t.parentNode || sS(t) && t.host || ls(t);
    return sS(e) ? e.host : e
}
function _A(t) {
    const e = Bo(t);
    return ou(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : ts(e) && Ed(e) ? e : _A(e)
}
function qc(t, e, n) {
    var r;
    e === void 0 && (e = []),
        n === void 0 && (n = !0);
    const i = _A(t)
        , s = i === ((r = t.ownerDocument) == null ? void 0 : r.body)
        , o = Br(i);
    if (s) {
        const a = hy(o);
        return e.concat(o, o.visualViewport || [], Ed(i) ? i : [], a && n ? qc(a) : [])
    }
    return e.concat(i, qc(i, [], n))
}
function hy(t) {
    return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null
}
function SA(t) {
    const e = Ri(t);
    let n = parseFloat(e.width) || 0
        , r = parseFloat(e.height) || 0;
    const i = ts(t)
        , s = i ? t.offsetWidth : n
        , o = i ? t.offsetHeight : r
        , a = Lp(n) !== s || Lp(r) !== o;
    return a && (n = s,
        r = o),
    {
        width: n,
        height: r,
        $: a
    }
}
function Xv(t) {
    return Mi(t) ? t : t.contextElement
}
function Vl(t) {
    const e = Xv(t);
    if (!ts(e))
        return Do(1);
    const n = e.getBoundingClientRect()
        , { width: r, height: i, $: s } = SA(e);
    let o = (s ? Lp(n.width) : n.width) / r
        , a = (s ? Lp(n.height) : n.height) / i;
    return (!o || !Number.isFinite(o)) && (o = 1),
        (!a || !Number.isFinite(a)) && (a = 1),
    {
        x: o,
        y: a
    }
}
const lG = Do(0);
function kA(t) {
    const e = Br(t);
    return !Yv() || !e.visualViewport ? lG : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}
function uG(t, e, n) {
    return e === void 0 && (e = !1),
        !n || e && n !== Br(t) ? !1 : e
}
function za(t, e, n, r) {
    e === void 0 && (e = !1),
        n === void 0 && (n = !1);
    const i = t.getBoundingClientRect()
        , s = Xv(t);
    let o = Do(1);
    e && (r ? Mi(r) && (o = Vl(r)) : o = Vl(t));
    const a = uG(s, n, r) ? kA(s) : Do(0);
    let l = (i.left + a.x) / o.x
        , c = (i.top + a.y) / o.y
        , d = i.width / o.x
        , h = i.height / o.y;
    if (s) {
        const p = Br(s)
            , g = r && Mi(r) ? Br(r) : r;
        let y = p
            , x = hy(y);
        for (; x && r && g !== y;) {
            const S = Vl(x)
                , k = x.getBoundingClientRect()
                , A = Ri(x)
                , C = k.left + (x.clientLeft + parseFloat(A.paddingLeft)) * S.x
                , m = k.top + (x.clientTop + parseFloat(A.paddingTop)) * S.y;
            l *= S.x,
                c *= S.y,
                d *= S.x,
                h *= S.y,
                l += C,
                c += m,
                y = Br(x),
                x = hy(y)
        }
    }
    return jp({
        width: d,
        height: h,
        x: l,
        y: c
    })
}
function cG(t) {
    let { elements: e, rect: n, offsetParent: r, strategy: i } = t;
    const s = i === "fixed"
        , o = ls(r)
        , a = e ? Nm(e.floating) : !1;
    if (r === o || a && s)
        return n;
    let l = {
        scrollLeft: 0,
        scrollTop: 0
    }
        , c = Do(1);
    const d = Do(0)
        , h = ts(r);
    if ((h || !h && !s) && ((qa(r) !== "body" || Ed(o)) && (l = Im(r)),
        ts(r))) {
        const p = za(r);
        c = Vl(r),
            d.x = p.x + r.clientLeft,
            d.y = p.y + r.clientTop
    }
    return {
        width: n.width * c.x,
        height: n.height * c.y,
        x: n.x * c.x - l.scrollLeft * c.x + d.x,
        y: n.y * c.y - l.scrollTop * c.y + d.y
    }
}
function dG(t) {
    return Array.from(t.getClientRects())
}
function py(t, e) {
    const n = Im(t).scrollLeft;
    return e ? e.left + n : za(ls(t)).left + n
}
function fG(t) {
    const e = ls(t)
        , n = Im(t)
        , r = t.ownerDocument.body
        , i = Lr(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth)
        , s = Lr(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
    let o = -n.scrollLeft + py(t);
    const a = -n.scrollTop;
    return Ri(r).direction === "rtl" && (o += Lr(e.clientWidth, r.clientWidth) - i),
    {
        width: i,
        height: s,
        x: o,
        y: a
    }
}
function hG(t, e) {
    const n = Br(t)
        , r = ls(t)
        , i = n.visualViewport;
    let s = r.clientWidth
        , o = r.clientHeight
        , a = 0
        , l = 0;
    if (i) {
        s = i.width,
            o = i.height;
        const c = Yv();
        (!c || c && e === "fixed") && (a = i.offsetLeft,
            l = i.offsetTop)
    }
    return {
        width: s,
        height: o,
        x: a,
        y: l
    }
}
function pG(t, e) {
    const n = za(t, !0, e === "fixed")
        , r = n.top + t.clientTop
        , i = n.left + t.clientLeft
        , s = ts(t) ? Vl(t) : Do(1)
        , o = t.clientWidth * s.x
        , a = t.clientHeight * s.y
        , l = i * s.x
        , c = r * s.y;
    return {
        width: o,
        height: a,
        x: l,
        y: c
    }
}
function oS(t, e, n) {
    let r;
    if (e === "viewport")
        r = hG(t, n);
    else if (e === "document")
        r = fG(ls(t));
    else if (Mi(e))
        r = pG(e, n);
    else {
        const i = kA(t);
        r = {
            ...e,
            x: e.x - i.x,
            y: e.y - i.y
        }
    }
    return jp(r)
}
function CA(t, e) {
    const n = Bo(t);
    return n === e || !Mi(n) || ou(n) ? !1 : Ri(n).position === "fixed" || CA(n, e)
}
function mG(t, e) {
    const n = e.get(t);
    if (n)
        return n;
    let r = qc(t, [], !1).filter(a => Mi(a) && qa(a) !== "body")
        , i = null;
    const s = Ri(t).position === "fixed";
    let o = s ? Bo(t) : t;
    for (; Mi(o) && !ou(o);) {
        const a = Ri(o)
            , l = Zv(o);
        !l && a.position === "fixed" && (i = null),
            (s ? !l && !i : !l && a.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || Ed(o) && !l && CA(t, o)) ? r = r.filter(d => d !== o) : i = a,
            o = Bo(o)
    }
    return e.set(t, r),
        r
}
function gG(t) {
    let { element: e, boundary: n, rootBoundary: r, strategy: i } = t;
    const o = [...n === "clippingAncestors" ? Nm(e) ? [] : mG(e, this._c) : [].concat(n), r]
        , a = o[0]
        , l = o.reduce((c, d) => {
            const h = oS(e, d, i);
            return c.top = Lr(h.top, c.top),
                c.right = Lo(h.right, c.right),
                c.bottom = Lo(h.bottom, c.bottom),
                c.left = Lr(h.left, c.left),
                c
        }
            , oS(e, a, i));
    return {
        width: l.right - l.left,
        height: l.bottom - l.top,
        x: l.left,
        y: l.top
    }
}
function yG(t) {
    const { width: e, height: n } = SA(t);
    return {
        width: e,
        height: n
    }
}
function vG(t, e, n) {
    const r = ts(e)
        , i = ls(e)
        , s = n === "fixed"
        , o = za(t, !0, s, e);
    let a = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const l = Do(0);
    if (r || !r && !s)
        if ((qa(e) !== "body" || Ed(i)) && (a = Im(e)),
            r) {
            const g = za(e, !0, s, e);
            l.x = g.x + e.clientLeft,
                l.y = g.y + e.clientTop
        } else
            i && (l.x = py(i));
    let c = 0
        , d = 0;
    if (i && !r && !s) {
        const g = i.getBoundingClientRect();
        d = g.top + a.scrollTop,
            c = g.left + a.scrollLeft - py(i, g)
    }
    const h = o.left + a.scrollLeft - l.x - c
        , p = o.top + a.scrollTop - l.y - d;
    return {
        x: h,
        y: p,
        width: o.width,
        height: o.height
    }
}
function W0(t) {
    return Ri(t).position === "static"
}
function aS(t, e) {
    if (!ts(t) || Ri(t).position === "fixed")
        return null;
    if (e)
        return e(t);
    let n = t.offsetParent;
    return ls(t) === n && (n = n.ownerDocument.body),
        n
}
function EA(t, e) {
    const n = Br(t);
    if (Nm(t))
        return n;
    if (!ts(t)) {
        let i = Bo(t);
        for (; i && !ou(i);) {
            if (Mi(i) && !W0(i))
                return i;
            i = Bo(i)
        }
        return n
    }
    let r = aS(t, e);
    for (; r && oG(r) && W0(r);)
        r = aS(r, e);
    return r && ou(r) && W0(r) && !Zv(r) ? n : r || aG(t) || n
}
const bG = async function (t) {
    const e = this.getOffsetParent || EA
        , n = this.getDimensions
        , r = await n(t.floating);
    return {
        reference: vG(t.reference, await e(t.floating), t.strategy),
        floating: {
            x: 0,
            y: 0,
            width: r.width,
            height: r.height
        }
    }
};
function wG(t) {
    return Ri(t).direction === "rtl"
}
const xG = {
    convertOffsetParentRelativeRectToViewportRelativeRect: cG,
    getDocumentElement: ls,
    getClippingRect: gG,
    getOffsetParent: EA,
    getElementRects: bG,
    getClientRects: dG,
    getDimensions: yG,
    getScale: Vl,
    isElement: Mi,
    isRTL: wG
};
function _G(t, e) {
    let n = null, r;
    const i = ls(t);
    function s() {
        var a;
        clearTimeout(r),
            (a = n) == null || a.disconnect(),
            n = null
    }
    function o(a, l) {
        a === void 0 && (a = !1),
            l === void 0 && (l = 1),
            s();
        const { left: c, top: d, width: h, height: p } = t.getBoundingClientRect();
        if (a || e(),
            !h || !p)
            return;
        const g = eh(d)
            , y = eh(i.clientWidth - (c + h))
            , x = eh(i.clientHeight - (d + p))
            , S = eh(c)
            , A = {
                rootMargin: -g + "px " + -y + "px " + -x + "px " + -S + "px",
                threshold: Lr(0, Lo(1, l)) || 1
            };
        let C = !0;
        function m(b) {
            const w = b[0].intersectionRatio;
            if (w !== l) {
                if (!C)
                    return o();
                w ? o(!1, w) : r = setTimeout(() => {
                    o(!1, 1e-7)
                }
                    , 1e3)
            }
            C = !1
        }
        try {
            n = new IntersectionObserver(m, {
                ...A,
                root: i.ownerDocument
            })
        } catch {
            n = new IntersectionObserver(m, A)
        }
        n.observe(t)
    }
    return o(!0),
        s
}
function SG(t, e, n, r) {
    r === void 0 && (r = {});
    const { ancestorScroll: i = !0, ancestorResize: s = !0, elementResize: o = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = !1 } = r
        , c = Xv(t)
        , d = i || s ? [...c ? qc(c) : [], ...qc(e)] : [];
    d.forEach(k => {
        i && k.addEventListener("scroll", n, {
            passive: !0
        }),
            s && k.addEventListener("resize", n)
    }
    );
    const h = c && a ? _G(c, n) : null;
    let p = -1
        , g = null;
    o && (g = new ResizeObserver(k => {
        let [A] = k;
        A && A.target === c && g && (g.unobserve(e),
            cancelAnimationFrame(p),
            p = requestAnimationFrame(() => {
                var C;
                (C = g) == null || C.observe(e)
            }
            )),
            n()
    }
    ),
        c && !l && g.observe(c),
        g.observe(e));
    let y, x = l ? za(t) : null;
    l && S();
    function S() {
        const k = za(t);
        x && (k.x !== x.x || k.y !== x.y || k.width !== x.width || k.height !== x.height) && n(),
            x = k,
            y = requestAnimationFrame(S)
    }
    return n(),
        () => {
            var k;
            d.forEach(A => {
                i && A.removeEventListener("scroll", n),
                    s && A.removeEventListener("resize", n)
            }
            ),
                h?.(),
                (k = g) == null || k.disconnect(),
                g = null,
                l && cancelAnimationFrame(y)
        }
}
const kG = nG
    , CG = rG
    , lS = Qq
    , EG = sG
    , TG = eG
    , AG = Xq
    , OG = iG
    , MG = (t, e, n) => {
        const r = new Map
            , i = {
                platform: xG,
                ...n
            }
            , s = {
                ...i.platform,
                _c: r
            };
        return Yq(t, e, {
            ...i,
            platform: s
        })
    }
    ;
function RG(t) {
    return t != null && typeof t == "object" && "$el" in t
}
function my(t) {
    if (RG(t)) {
        const e = t.$el;
        return Jv(e) && qa(e) === "#comment" ? null : e
    }
    return t
}
function Cl(t) {
    return typeof t == "function" ? t() : ie(t)
}
function PG(t) {
    return {
        name: "arrow",
        options: t,
        fn(e) {
            const n = my(Cl(t.element));
            return n == null ? {} : AG({
                element: n,
                padding: t.padding
            }).fn(e)
        }
    }
}
function TA(t) {
    return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function uS(t, e) {
    const n = TA(t);
    return Math.round(e * n) / n
}
function NG(t, e, n) {
    n === void 0 && (n = {});
    const r = n.whileElementsMounted
        , i = G(() => {
            var T;
            return (T = Cl(n.open)) != null ? T : !0
        }
        )
        , s = G(() => Cl(n.middleware))
        , o = G(() => {
            var T;
            return (T = Cl(n.placement)) != null ? T : "bottom"
        }
        )
        , a = G(() => {
            var T;
            return (T = Cl(n.strategy)) != null ? T : "absolute"
        }
        )
        , l = G(() => {
            var T;
            return (T = Cl(n.transform)) != null ? T : !0
        }
        )
        , c = G(() => my(t.value))
        , d = G(() => my(e.value))
        , h = ce(0)
        , p = ce(0)
        , g = ce(a.value)
        , y = ce(o.value)
        , x = Wa({})
        , S = ce(!1)
        , k = G(() => {
            const T = {
                position: g.value,
                left: "0",
                top: "0"
            };
            if (!d.value)
                return T;
            const O = uS(d.value, h.value)
                , M = uS(d.value, p.value);
            return l.value ? {
                ...T,
                transform: "translate(" + O + "px, " + M + "px)",
                ...TA(d.value) >= 1.5 && {
                    willChange: "transform"
                }
            } : {
                position: g.value,
                left: O + "px",
                top: M + "px"
            }
        }
        );
    let A;
    function C() {
        if (c.value == null || d.value == null)
            return;
        const T = i.value;
        MG(c.value, d.value, {
            middleware: s.value,
            placement: o.value,
            strategy: a.value
        }).then(O => {
            h.value = O.x,
                p.value = O.y,
                g.value = O.strategy,
                y.value = O.placement,
                x.value = O.middlewareData,
                S.value = T !== !1
        }
        )
    }
    function m() {
        typeof A == "function" && (A(),
            A = void 0)
    }
    function b() {
        if (m(),
            r === void 0) {
            C();
            return
        }
        if (c.value != null && d.value != null) {
            A = r(c.value, d.value, C);
            return
        }
    }
    function w() {
        i.value || (S.value = !1)
    }
    return vt([s, o, a, i], C, {
        flush: "sync"
    }),
        vt([c, d], b, {
            flush: "sync"
        }),
        vt(i, w, {
            flush: "sync"
        }),
        ud() && cd(m),
    {
        x: dl(h),
        y: dl(p),
        strategy: dl(g),
        placement: dl(y),
        middlewareData: dl(x),
        isPositioned: dl(S),
        floatingStyles: k,
        update: C
    }
}
function Td(t, e) {
    const n = typeof t == "string" && !e ? `${t}Context` : e
        , r = Symbol(n);
    return [i => {
        const s = Dt(r, i);
        if (s || s === null)
            return s;
        throw new Error(`Injection \`${r.toString()}\` not found. Component must be used within ${Array.isArray(t) ? `one of the following components: ${t.join(", ")}` : `\`${t}\``}`)
    }
        , i => (Hn(r, i),
            i)]
}
function AA(t, e, n) {
    const r = n.originalEvent.target
        , i = new CustomEvent(t, {
            bubbles: !1,
            cancelable: !0,
            detail: n
        });
    e && r.addEventListener(t, e, {
        once: !0
    }),
        r.dispatchEvent(i)
}
function IG(t, e) {
    var n;
    const r = Wa();
    return Ft(() => {
        r.value = t()
    }
        , {
            ...e,
            flush: (n = void 0) != null ? n : "sync"
        }),
        du(r)
}
function Lm(t) {
    return ud() ? (cd(t),
        !0) : !1
}
function LG() {
    const t = new Set
        , e = n => {
            t.delete(n)
        }
        ;
    return {
        on: n => {
            t.add(n);
            const r = () => e(n);
            return Lm(r),
            {
                off: r
            }
        }
        ,
        off: e,
        trigger: (...n) => Promise.all(Array.from(t).map(r => r(...n)))
    }
}
function DG(t) {
    let e = !1, n;
    const r = Iy(!0);
    return (...i) => (e || (n = r.run(() => t(...i)),
        e = !0),
        n)
}
function Ea(t) {
    return typeof t == "function" ? t() : ie(t)
}
const Ad = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const jG = t => typeof t < "u"
    , BG = Object.prototype.toString
    , $G = t => BG.call(t) === "[object Object]"
    , zG = () => { }
    ;
function FG(t, e = 1e4) {
    return YS((n, r) => {
        let i = Ea(t), s;
        const o = () => setTimeout(() => {
            i = Ea(t),
                r()
        }
            , Ea(e));
        return Lm(() => {
            clearTimeout(s)
        }
        ),
        {
            get() {
                return n(),
                    i
            },
            set(a) {
                i = a,
                    r(),
                    clearTimeout(s),
                    s = o()
            }
        }
    }
    )
}
function OA(t, e, n = {}) {
    const { immediate: r = !0 } = n
        , i = ce(!1);
    let s = null;
    function o() {
        s && (clearTimeout(s),
            s = null)
    }
    function a() {
        i.value = !1,
            o()
    }
    function l(...c) {
        o(),
            i.value = !0,
            s = setTimeout(() => {
                i.value = !1,
                    s = null,
                    t(...c)
            }
                , Ea(e))
    }
    return r && (i.value = !0,
        Ad && l()),
        Lm(a),
    {
        isPending: du(i),
        start: l,
        stop: a
    }
}
function Dm(t) {
    var e;
    const n = Ea(t);
    return (e = n?.$el) != null ? e : n
}
const MA = Ad ? window : void 0;
function gy(...t) {
    let e, n, r, i;
    if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, r, i] = t,
        e = MA) : [e, n, r, i] = t,
        !e)
        return zG;
    Array.isArray(n) || (n = [n]),
        Array.isArray(r) || (r = [r]);
    const s = []
        , o = () => {
            s.forEach(d => d()),
                s.length = 0
        }
        , a = (d, h, p, g) => (d.addEventListener(h, p, g),
            () => d.removeEventListener(h, p, g))
        , l = vt(() => [Dm(e), Ea(i)], ([d, h]) => {
            if (o(),
                !d)
                return;
            const p = $G(h) ? {
                ...h
            } : h;
            s.push(...n.flatMap(g => r.map(y => a(d, g, y, p))))
        }
            , {
                immediate: !0,
                flush: "post"
            })
        , c = () => {
            l(),
                o()
        }
        ;
    return Lm(c),
        c
}
function HG(t) {
    return typeof t == "function" ? t : typeof t == "string" ? e => e.key === t : Array.isArray(t) ? e => t.includes(e.key) : () => !0
}
function VG(...t) {
    let e, n, r = {};
    t.length === 3 ? (e = t[0],
        n = t[1],
        r = t[2]) : t.length === 2 ? typeof t[1] == "object" ? (e = !0,
            n = t[0],
            r = t[1]) : (e = t[0],
                n = t[1]) : (e = !0,
                    n = t[0]);
    const { target: i = MA, eventName: s = "keydown", passive: o = !1, dedupe: a = !1 } = r
        , l = HG(e);
    return gy(i, s, c => {
        c.repeat && Ea(a) || l(c) && n(c)
    }
        , o)
}
function WG() {
    const t = ce(!1)
        , e = pn();
    return e && Nt(() => {
        t.value = !0
    }
        , e),
        t
}
function UG(t) {
    return JSON.parse(JSON.stringify(t))
}
function KG(t, e, n, r = {}) {
    var i, s, o;
    const { clone: a = !1, passive: l = !1, eventName: c, deep: d = !1, defaultValue: h, shouldEmit: p } = r
        , g = pn()
        , y = n || g?.emit || ((i = g?.$emit) == null ? void 0 : i.bind(g)) || ((o = (s = g?.proxy) == null ? void 0 : s.$emit) == null ? void 0 : o.bind(g?.proxy));
    let x = c;
    e || (e = "modelValue"),
        x = x || `update:${e.toString()}`;
    const S = C => a ? typeof a == "function" ? a(C) : UG(C) : C
        , k = () => jG(t[e]) ? S(t[e]) : h
        , A = C => {
            p ? p(C) && y(x, C) : y(x, C)
        }
        ;
    if (l) {
        const C = k()
            , m = ce(C);
        let b = !1;
        return vt(() => t[e], w => {
            b || (b = !0,
                m.value = S(w),
                un(() => b = !1))
        }
        ),
            vt(m, w => {
                !b && (w !== t[e] || d) && A(w)
            }
                , {
                    deep: d
                }),
            m
    } else
        return G({
            get() {
                return k()
            },
            set(C) {
                A(C)
            }
        })
}
function Qv(t) {
    return t ? t.flatMap(e => e.type === Rt ? Qv(e.children) : [e]) : []
}
const [qG, kee] = Td("ConfigProvider");
function GG(t) {
    const e = pn()
        , n = e?.type.emits
        , r = {};
    return n != null && n.length || console.warn(`No emitted event found. Please check component: ${e?.type.__name}`),
        n?.forEach(i => {
            r[ec(Fn(i))] = (...s) => t(i, ...s)
        }
        ),
        r
}
function RA(t) {
    const e = pn()
        , n = Object.keys(e?.type.props ?? {}).reduce((i, s) => {
            const o = (e?.type.props[s]).default;
            return o !== void 0 && (i[s] = o),
                i
        }
            , {})
        , r = XS(t);
    return G(() => {
        const i = {}
            , s = e?.vnode.props ?? {};
        return Object.keys(s).forEach(o => {
            i[Fn(o)] = s[o]
        }
        ),
            Object.keys({
                ...n,
                ...i
            }).reduce((o, a) => (r.value[a] !== void 0 && (o[a] = r.value[a]),
                o), {})
    }
    )
}
function JG(t, e) {
    const n = RA(t)
        , r = e ? GG(e) : {};
    return G(() => ({
        ...n.value,
        ...r
    }))
}
function Hr() {
    const t = pn()
        , e = ce()
        , n = G(() => {
            var o, a;
            return ["#text", "#comment"].includes((o = e.value) == null ? void 0 : o.$el.nodeName) ? (a = e.value) == null ? void 0 : a.$el.nextElementSibling : Dm(e)
        }
        )
        , r = Object.assign({}, t.exposed)
        , i = {};
    for (const o in t.props)
        Object.defineProperty(i, o, {
            enumerable: !0,
            configurable: !0,
            get: () => t.props[o]
        });
    if (Object.keys(r).length > 0)
        for (const o in r)
            Object.defineProperty(i, o, {
                enumerable: !0,
                configurable: !0,
                get: () => r[o]
            });
    Object.defineProperty(i, "$el", {
        enumerable: !0,
        configurable: !0,
        get: () => t.vnode.el
    }),
        t.exposed = i;
    function s(o) {
        e.value = o,
            !(o instanceof Element || !o) && (Object.defineProperty(i, "$el", {
                enumerable: !0,
                configurable: !0,
                get: () => o.$el
            }),
                t.exposed = i)
    }
    return {
        forwardRef: s,
        currentRef: e,
        currentElement: n
    }
}
function ZG(t, e) {
    const n = FG(!1, 300)
        , r = ce(null)
        , i = LG();
    function s() {
        r.value = null,
            n.value = !1
    }
    function o(a, l) {
        const c = a.currentTarget
            , d = {
                x: a.clientX,
                y: a.clientY
            }
            , h = YG(d, c.getBoundingClientRect())
            , p = XG(d, h)
            , g = QG(l.getBoundingClientRect())
            , y = tJ([...p, ...g]);
        r.value = y,
            n.value = !0
    }
    return Ft(a => {
        if (t.value && e.value) {
            const l = d => o(d, e.value)
                , c = d => o(d, t.value);
            t.value.addEventListener("pointerleave", l),
                e.value.addEventListener("pointerleave", c),
                a(() => {
                    var d, h;
                    (d = t.value) == null || d.removeEventListener("pointerleave", l),
                        (h = e.value) == null || h.removeEventListener("pointerleave", c)
                }
                )
        }
    }
    ),
        Ft(a => {
            if (r.value) {
                const l = c => {
                    var d, h;
                    if (!r.value)
                        return;
                    const p = c.target
                        , g = {
                            x: c.clientX,
                            y: c.clientY
                        }
                        , y = ((d = t.value) == null ? void 0 : d.contains(p)) || ((h = e.value) == null ? void 0 : h.contains(p))
                        , x = !eJ(g, r.value)
                        , S = p.hasAttribute("data-grace-area-trigger");
                    y ? s() : (x || S) && (s(),
                        i.trigger())
                }
                    ;
                document.addEventListener("pointermove", l),
                    a(() => document.removeEventListener("pointermove", l))
            }
        }
        ),
    {
        isPointerInTransit: n,
        onPointerExit: i.on
    }
}
function YG(t, e) {
    const n = Math.abs(e.top - t.y)
        , r = Math.abs(e.bottom - t.y)
        , i = Math.abs(e.right - t.x)
        , s = Math.abs(e.left - t.x);
    switch (Math.min(n, r, i, s)) {
        case s:
            return "left";
        case i:
            return "right";
        case n:
            return "top";
        case r:
            return "bottom";
        default:
            throw new Error("unreachable")
    }
}
function XG(t, e, n = 5) {
    const r = [];
    switch (e) {
        case "top":
            r.push({
                x: t.x - n,
                y: t.y + n
            }, {
                x: t.x + n,
                y: t.y + n
            });
            break;
        case "bottom":
            r.push({
                x: t.x - n,
                y: t.y - n
            }, {
                x: t.x + n,
                y: t.y - n
            });
            break;
        case "left":
            r.push({
                x: t.x + n,
                y: t.y - n
            }, {
                x: t.x + n,
                y: t.y + n
            });
            break;
        case "right":
            r.push({
                x: t.x - n,
                y: t.y - n
            }, {
                x: t.x - n,
                y: t.y + n
            });
            break
    }
    return r
}
function QG(t) {
    const { top: e, right: n, bottom: r, left: i } = t;
    return [{
        x: i,
        y: e
    }, {
        x: n,
        y: e
    }, {
        x: n,
        y: r
    }, {
        x: i,
        y: r
    }]
}
function eJ(t, e) {
    const { x: n, y: r } = t;
    let i = !1;
    for (let s = 0, o = e.length - 1; s < e.length; o = s++) {
        const a = e[s].x
            , l = e[s].y
            , c = e[o].x
            , d = e[o].y;
        l > r != d > r && n < (c - a) * (r - l) / (d - l) + a && (i = !i)
    }
    return i
}
function tJ(t) {
    const e = t.slice();
    return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0),
        nJ(e)
}
function nJ(t) {
    if (t.length <= 1)
        return t.slice();
    const e = [];
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        for (; e.length >= 2;) {
            const s = e[e.length - 1]
                , o = e[e.length - 2];
            if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
                e.pop();
            else
                break
        }
        e.push(i)
    }
    e.pop();
    const n = [];
    for (let r = t.length - 1; r >= 0; r--) {
        const i = t[r];
        for (; n.length >= 2;) {
            const s = n[n.length - 1]
                , o = n[n.length - 2];
            if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
                n.pop();
            else
                break
        }
        n.push(i)
    }
    return n.pop(),
        e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n)
}
let rJ = 0;
function iJ(t, e = "radix") {
    if (t)
        return t;
    const n = qG({
        useId: void 0
    });
    return e1 ? `${e}-${e1()}` : n.useId ? `${e}-${n.useId()}` : `${e}-${++rJ}`
}
function sJ(t) {
    const e = ce()
        , n = G(() => {
            var i;
            return ((i = e.value) == null ? void 0 : i.width) ?? 0
        }
        )
        , r = G(() => {
            var i;
            return ((i = e.value) == null ? void 0 : i.height) ?? 0
        }
        );
    return Nt(() => {
        const i = Dm(t);
        if (i) {
            e.value = {
                width: i.offsetWidth,
                height: i.offsetHeight
            };
            const s = new ResizeObserver(o => {
                if (!Array.isArray(o) || !o.length)
                    return;
                const a = o[0];
                let l, c;
                if ("borderBoxSize" in a) {
                    const d = a.borderBoxSize
                        , h = Array.isArray(d) ? d[0] : d;
                    l = h.inlineSize,
                        c = h.blockSize
                } else
                    l = i.offsetWidth,
                        c = i.offsetHeight;
                e.value = {
                    width: l,
                    height: c
                }
            }
            );
            return s.observe(i, {
                box: "border-box"
            }),
                () => s.unobserve(i)
        } else
            e.value = void 0
    }
    ),
    {
        width: n,
        height: r
    }
}
function oJ(t, e) {
    const n = ce(t);
    function r(i) {
        return e[n.value][i] ?? n.value
    }
    return {
        state: n,
        dispatch: i => {
            n.value = r(i)
        }
    }
}
const aJ = je({
    name: "PrimitiveSlot",
    inheritAttrs: !1,
    setup(t, { attrs: e, slots: n }) {
        return () => {
            var r, i;
            if (!n.default)
                return null;
            const s = Qv(n.default())
                , o = s.findIndex(d => d.type !== cn);
            if (o === -1)
                return s;
            const a = s[o];
            (r = a.props) == null || delete r.ref;
            const l = a.props ? Wt(e, a.props) : e;
            e.class && (i = a.props) != null && i.class && delete a.props.class;
            const c = ui(a, l);
            for (const d in l)
                d.startsWith("on") && (c.props || (c.props = {}),
                    c.props[d] = l[d]);
            return s.length === 1 ? c : (s[o] = c,
                s)
        }
    }
})
    , yu = je({
        name: "Primitive",
        inheritAttrs: !1,
        props: {
            asChild: {
                type: Boolean,
                default: !1
            },
            as: {
                type: [String, Object],
                default: "div"
            }
        },
        setup(t, { attrs: e, slots: n }) {
            const r = t.asChild ? "template" : t.as;
            return typeof r == "string" && ["area", "img", "input"].includes(r) ? () => Mt(r, e) : r !== "template" ? () => Mt(t.as, e, {
                default: n.default
            }) : () => Mt(aJ, e, {
                default: n.default
            })
        }
    });
function lJ(t, e) {
    const n = ce({})
        , r = ce("none")
        , i = t.value ? "mounted" : "unmounted"
        , { state: s, dispatch: o } = oJ(i, {
            mounted: {
                UNMOUNT: "unmounted",
                ANIMATION_OUT: "unmountSuspended"
            },
            unmountSuspended: {
                MOUNT: "mounted",
                ANIMATION_END: "unmounted"
            },
            unmounted: {
                MOUNT: "mounted"
            }
        })
        , a = p => {
            var g;
            if (Ad) {
                const y = new CustomEvent(p, {
                    bubbles: !1,
                    cancelable: !1
                });
                (g = e.value) == null || g.dispatchEvent(y)
            }
        }
        ;
    vt(t, async (p, g) => {
        var y;
        const x = g !== p;
        if (await un(),
            x) {
            const S = r.value
                , k = th(e.value);
            p ? (o("MOUNT"),
                a("enter"),
                k === "none" && a("after-enter")) : k === "none" || ((y = n.value) == null ? void 0 : y.display) === "none" ? (o("UNMOUNT"),
                    a("leave"),
                    a("after-leave")) : g && S !== k ? (o("ANIMATION_OUT"),
                        a("leave")) : (o("UNMOUNT"),
                            a("after-leave"))
        }
    }
        , {
            immediate: !0
        });
    const l = p => {
        const g = th(e.value)
            , y = g.includes(p.animationName)
            , x = s.value === "mounted" ? "enter" : "leave";
        p.target === e.value && y && (a(`after-${x}`),
            o("ANIMATION_END")),
            p.target === e.value && g === "none" && o("ANIMATION_END")
    }
        , c = p => {
            p.target === e.value && (r.value = th(e.value))
        }
        , d = vt(e, (p, g) => {
            p ? (n.value = getComputedStyle(p),
                p.addEventListener("animationstart", c),
                p.addEventListener("animationcancel", l),
                p.addEventListener("animationend", l)) : (o("ANIMATION_END"),
                    g?.removeEventListener("animationstart", c),
                    g?.removeEventListener("animationcancel", l),
                    g?.removeEventListener("animationend", l))
        }
            , {
                immediate: !0
            })
        , h = vt(s, () => {
            const p = th(e.value);
            r.value = s.value === "mounted" ? p : "none"
        }
        );
    return xn(() => {
        d(),
            h()
    }
    ),
    {
        isPresent: G(() => ["mounted", "unmountSuspended"].includes(s.value))
    }
}
function th(t) {
    return t && getComputedStyle(t).animationName || "none"
}
const uJ = je({
    name: "Presence",
    props: {
        present: {
            type: Boolean,
            required: !0
        },
        forceMount: {
            type: Boolean
        }
    },
    slots: {},
    setup(t, { slots: e, expose: n }) {
        var r;
        const { present: i, forceMount: s } = Hy(t)
            , o = ce()
            , { isPresent: a } = lJ(i, o);
        n({
            present: a
        });
        let l = e.default({
            present: a
        });
        l = Qv(l || []);
        const c = pn();
        if (l && l?.length > 1) {
            const d = (r = c?.parent) != null && r.type.name ? `<${c.parent.type.name} />` : "component";
            throw new Error([`Detected an invalid children for \`${d}\` for  \`Presence\` component.`, "", "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.", "You can apply a few solutions:", ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map(h => `  - ${h}`).join(`
`)].join(`
`))
        }
        return () => s.value || i.value || a.value ? Mt(e.default({
            present: a
        })[0], {
            ref: d => {
                const h = Dm(d);
                return typeof h?.hasAttribute > "u" || (h != null && h.hasAttribute("data-radix-popper-content-wrapper") ? o.value = h.firstElementChild : o.value = h),
                    h
            }
        }) : null
    }
})
    , cJ = je({
        __name: "Teleport",
        props: {
            to: {
                default: "body"
            },
            disabled: {
                type: Boolean
            },
            forceMount: {
                type: Boolean
            }
        },
        setup(t) {
            const e = WG();
            return (n, r) => ie(e) || n.forceMount ? (oe(),
                gt(im, {
                    key: 0,
                    to: n.to,
                    disabled: n.disabled
                }, [Ue(n.$slots, "default")], 8, ["to", "disabled"])) : pt("", !0)
        }
    })
    , dJ = "dismissableLayer.pointerDownOutside"
    , fJ = "dismissableLayer.focusOutside";
function PA(t, e) {
    const n = e.closest("[data-dismissable-layer]")
        , r = t.dataset.dismissableLayer === "" ? t : t.querySelector("[data-dismissable-layer]")
        , i = Array.from(t.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
    return !!(n && r === n || i.indexOf(r) < i.indexOf(n))
}
function hJ(t, e) {
    var n;
    const r = ((n = e?.value) == null ? void 0 : n.ownerDocument) ?? globalThis?.document
        , i = ce(!1)
        , s = ce(() => { }
        );
    return Ft(o => {
        if (!Ad)
            return;
        const a = async c => {
            const d = c.target;
            if (e != null && e.value) {
                if (PA(e.value, d)) {
                    i.value = !1;
                    return
                }
                if (c.target && !i.value) {
                    let h = function () {
                        AA(dJ, t, p)
                    };
                    const p = {
                        originalEvent: c
                    };
                    c.pointerType === "touch" ? (r.removeEventListener("click", s.value),
                        s.value = h,
                        r.addEventListener("click", s.value, {
                            once: !0
                        })) : h()
                } else
                    r.removeEventListener("click", s.value);
                i.value = !1
            }
        }
            , l = window.setTimeout(() => {
                r.addEventListener("pointerdown", a)
            }
                , 0);
        o(() => {
            window.clearTimeout(l),
                r.removeEventListener("pointerdown", a),
                r.removeEventListener("click", s.value)
        }
        )
    }
    ),
    {
        onPointerDownCapture: () => i.value = !0
    }
}
function pJ(t, e) {
    var n;
    const r = ((n = e?.value) == null ? void 0 : n.ownerDocument) ?? globalThis?.document
        , i = ce(!1);
    return Ft(s => {
        if (!Ad)
            return;
        const o = async a => {
            e != null && e.value && (await un(),
                !(!e.value || PA(e.value, a.target)) && a.target && !i.value && AA(fJ, t, {
                    originalEvent: a
                }))
        }
            ;
        r.addEventListener("focusin", o),
            s(() => r.removeEventListener("focusin", o))
    }
    ),
    {
        onFocusCapture: () => i.value = !0,
        onBlurCapture: () => i.value = !1
    }
}
const _s = wn({
    layersRoot: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
})
    , mJ = je({
        __name: "DismissableLayer",
        props: {
            disableOutsidePointerEvents: {
                type: Boolean,
                default: !1
            },
            asChild: {
                type: Boolean
            },
            as: {}
        },
        emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
        setup(t, { emit: e }) {
            const n = t
                , r = e
                , { forwardRef: i, currentElement: s } = Hr()
                , o = G(() => {
                    var y;
                    return ((y = s.value) == null ? void 0 : y.ownerDocument) ?? globalThis.document
                }
                )
                , a = G(() => _s.layersRoot)
                , l = G(() => s.value ? Array.from(a.value).indexOf(s.value) : -1)
                , c = G(() => _s.layersWithOutsidePointerEventsDisabled.size > 0)
                , d = G(() => {
                    const y = Array.from(a.value)
                        , [x] = [..._s.layersWithOutsidePointerEventsDisabled].slice(-1)
                        , S = y.indexOf(x);
                    return l.value >= S
                }
                )
                , h = hJ(async y => {
                    const x = [..._s.branches].some(S => S?.contains(y.target));
                    !d.value || x || (r("pointerDownOutside", y),
                        r("interactOutside", y),
                        await un(),
                        y.defaultPrevented || r("dismiss"))
                }
                    , s)
                , p = pJ(y => {
                    [..._s.branches].some(x => x?.contains(y.target)) || (r("focusOutside", y),
                        r("interactOutside", y),
                        y.defaultPrevented || r("dismiss"))
                }
                    , s);
            VG("Escape", y => {
                l.value === a.value.size - 1 && (r("escapeKeyDown", y),
                    y.defaultPrevented || r("dismiss"))
            }
            );
            let g;
            return Ft(y => {
                s.value && (n.disableOutsidePointerEvents && (_s.layersWithOutsidePointerEventsDisabled.size === 0 && (g = o.value.body.style.pointerEvents,
                    o.value.body.style.pointerEvents = "none"),
                    _s.layersWithOutsidePointerEventsDisabled.add(s.value)),
                    a.value.add(s.value),
                    y(() => {
                        n.disableOutsidePointerEvents && _s.layersWithOutsidePointerEventsDisabled.size === 1 && (o.value.body.style.pointerEvents = g)
                    }
                    ))
            }
            ),
                Ft(y => {
                    y(() => {
                        s.value && (a.value.delete(s.value),
                            _s.layersWithOutsidePointerEventsDisabled.delete(s.value))
                    }
                    )
                }
                ),
                (y, x) => (oe(),
                    gt(ie(yu), {
                        ref: ie(i),
                        "as-child": y.asChild,
                        as: y.as,
                        "data-dismissable-layer": "",
                        style: Vo({
                            pointerEvents: c.value ? d.value ? "auto" : "none" : void 0
                        }),
                        onFocusCapture: ie(p).onFocusCapture,
                        onBlurCapture: ie(p).onBlurCapture,
                        onPointerdownCapture: ie(h).onPointerDownCapture
                    }, {
                        default: tt(() => [Ue(y.$slots, "default")]),
                        _: 3
                    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]))
        }
    });
DG(() => ce([]));
const [NA, gJ] = Td("PopperRoot")
    , yJ = je({
        __name: "PopperRoot",
        setup(t) {
            const e = ce();
            return gJ({
                anchor: e,
                onAnchorChange: n => e.value = n
            }),
                (n, r) => Ue(n.$slots, "default")
        }
    })
    , vJ = je({
        __name: "PopperAnchor",
        props: {
            element: {},
            asChild: {
                type: Boolean
            },
            as: {}
        },
        setup(t) {
            const e = t
                , { forwardRef: n, currentElement: r } = Hr()
                , i = NA();
            return Ft(() => {
                i.onAnchorChange(e.element ?? r.value)
            }
            ),
                (s, o) => (oe(),
                    gt(ie(yu), {
                        ref: ie(n),
                        as: s.as,
                        "as-child": s.asChild
                    }, {
                        default: tt(() => [Ue(s.$slots, "default")]),
                        _: 3
                    }, 8, ["as", "as-child"]))
        }
    });
function bJ(t) {
    return t !== null
}
function wJ(t) {
    return {
        name: "transformOrigin",
        options: t,
        fn(e) {
            var n, r, i;
            const { placement: s, rects: o, middlewareData: a } = e
                , l = ((n = a.arrow) == null ? void 0 : n.centerOffset) !== 0
                , c = l ? 0 : t.arrowWidth
                , d = l ? 0 : t.arrowHeight
                , [h, p] = yy(s)
                , g = {
                    start: "0%",
                    center: "50%",
                    end: "100%"
                }[p]
                , y = (((r = a.arrow) == null ? void 0 : r.x) ?? 0) + c / 2
                , x = (((i = a.arrow) == null ? void 0 : i.y) ?? 0) + d / 2;
            let S = ""
                , k = "";
            return h === "bottom" ? (S = l ? g : `${y}px`,
                k = `${-d}px`) : h === "top" ? (S = l ? g : `${y}px`,
                    k = `${o.floating.height + d}px`) : h === "right" ? (S = `${-d}px`,
                        k = l ? g : `${x}px`) : h === "left" && (S = `${o.floating.width + d}px`,
                            k = l ? g : `${x}px`),
            {
                data: {
                    x: S,
                    y: k
                }
            }
        }
    }
}
function yy(t) {
    const [e, n = "center"] = t.split("-");
    return [e, n]
}
const xJ = {
    side: "bottom",
    sideOffset: 0,
    align: "center",
    alignOffset: 0,
    arrowPadding: 0,
    avoidCollisions: !0,
    collisionBoundary: () => [],
    collisionPadding: 0,
    sticky: "partial",
    hideWhenDetached: !1,
    updatePositionStrategy: "optimized",
    prioritizePosition: !1
}
    , [_J, SJ] = Td("PopperContent")
    , kJ = je({
        inheritAttrs: !1,
        __name: "PopperContent",
        props: p5({
            side: {},
            sideOffset: {},
            align: {},
            alignOffset: {},
            avoidCollisions: {
                type: Boolean
            },
            collisionBoundary: {},
            collisionPadding: {},
            arrowPadding: {},
            sticky: {},
            hideWhenDetached: {
                type: Boolean
            },
            updatePositionStrategy: {},
            prioritizePosition: {
                type: Boolean
            },
            asChild: {
                type: Boolean
            },
            as: {}
        }, {
            ...xJ
        }),
        emits: ["placed"],
        setup(t, { emit: e }) {
            const n = t
                , r = e
                , i = NA()
                , { forwardRef: s, currentElement: o } = Hr()
                , a = ce()
                , l = ce()
                , { width: c, height: d } = sJ(l)
                , h = G(() => n.side + (n.align !== "center" ? `-${n.align}` : ""))
                , p = G(() => typeof n.collisionPadding == "number" ? n.collisionPadding : {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    ...n.collisionPadding
                })
                , g = G(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary])
                , y = G(() => ({
                    padding: p.value,
                    boundary: g.value.filter(bJ),
                    altBoundary: g.value.length > 0
                }))
                , x = IG(() => [kG({
                    mainAxis: n.sideOffset + d.value,
                    alignmentAxis: n.alignOffset
                }), n.prioritizePosition && n.avoidCollisions && lS({
                    ...y.value
                }), n.avoidCollisions && CG({
                    mainAxis: !0,
                    crossAxis: !!n.prioritizePosition,
                    limiter: n.sticky === "partial" ? OG() : void 0,
                    ...y.value
                }), !n.prioritizePosition && n.avoidCollisions && lS({
                    ...y.value
                }), EG({
                    ...y.value,
                    apply: ({ elements: E, rects: N, availableWidth: j, availableHeight: z }) => {
                        const { width: V, height: W } = N.reference
                            , P = E.floating.style;
                        P.setProperty("--radix-popper-available-width", `${j}px`),
                            P.setProperty("--radix-popper-available-height", `${z}px`),
                            P.setProperty("--radix-popper-anchor-width", `${V}px`),
                            P.setProperty("--radix-popper-anchor-height", `${W}px`)
                    }
                }), l.value && PG({
                    element: l.value,
                    padding: n.arrowPadding
                }), wJ({
                    arrowWidth: c.value,
                    arrowHeight: d.value
                }), n.hideWhenDetached && TG({
                    strategy: "referenceHidden",
                    ...y.value
                })])
                , { floatingStyles: S, placement: k, isPositioned: A, middlewareData: C } = NG(i.anchor, a, {
                    strategy: "fixed",
                    placement: h,
                    whileElementsMounted: (...E) => SG(...E, {
                        animationFrame: n.updatePositionStrategy === "always"
                    }),
                    middleware: x
                })
                , m = G(() => yy(k.value)[0])
                , b = G(() => yy(k.value)[1]);
            Rk(() => {
                A.value && r("placed")
            }
            );
            const w = G(() => {
                var E;
                return ((E = C.value.arrow) == null ? void 0 : E.centerOffset) !== 0
            }
            )
                , T = ce("");
            Ft(() => {
                o.value && (T.value = window.getComputedStyle(o.value).zIndex)
            }
            );
            const O = G(() => {
                var E;
                return ((E = C.value.arrow) == null ? void 0 : E.x) ?? 0
            }
            )
                , M = G(() => {
                    var E;
                    return ((E = C.value.arrow) == null ? void 0 : E.y) ?? 0
                }
                );
            return SJ({
                placedSide: m,
                onArrowChange: E => l.value = E,
                arrowX: O,
                arrowY: M,
                shouldHideArrow: w
            }),
                (E, N) => {
                    var j, z, V;
                    return oe(),
                        Ae("div", {
                            ref_key: "floatingRef",
                            ref: a,
                            "data-radix-popper-content-wrapper": "",
                            style: Vo({
                                ...ie(S),
                                transform: ie(A) ? ie(S).transform : "translate(0, -200%)",
                                minWidth: "max-content",
                                zIndex: T.value,
                                "--radix-popper-transform-origin": [(j = ie(C).transformOrigin) == null ? void 0 : j.x, (z = ie(C).transformOrigin) == null ? void 0 : z.y].join(" "),
                                ...((V = ie(C).hide) == null ? void 0 : V.referenceHidden) && {
                                    visibility: "hidden",
                                    pointerEvents: "none"
                                }
                            })
                        }, [$e(ie(yu), Wt({
                            ref: ie(s)
                        }, E.$attrs, {
                            "as-child": n.asChild,
                            as: E.as,
                            "data-side": m.value,
                            "data-align": b.value,
                            style: {
                                animation: ie(A) ? void 0 : "none"
                            }
                        }), {
                            default: tt(() => [Ue(E.$slots, "default")]),
                            _: 3
                        }, 16, ["as-child", "as", "data-side", "data-align", "style"])], 4)
                }
        }
    })
    , CJ = Xe("polygon", {
        points: "0,0 30,0 15,10"
    }, null, -1)
    , EJ = je({
        __name: "Arrow",
        props: {
            width: {
                default: 10
            },
            height: {
                default: 5
            },
            asChild: {
                type: Boolean
            },
            as: {
                default: "svg"
            }
        },
        setup(t) {
            const e = t;
            return Hr(),
                (n, r) => (oe(),
                    gt(ie(yu), Wt(e, {
                        width: n.width,
                        height: n.height,
                        viewBox: n.asChild ? void 0 : "0 0 30 10",
                        preserveAspectRatio: n.asChild ? void 0 : "none"
                    }), {
                        default: tt(() => [Ue(n.$slots, "default", {}, () => [CJ])]),
                        _: 3
                    }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]))
        }
    })
    , TJ = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
    }
    , AJ = je({
        inheritAttrs: !1,
        __name: "PopperArrow",
        props: {
            width: {},
            height: {},
            asChild: {
                type: Boolean
            },
            as: {
                default: "svg"
            }
        },
        setup(t) {
            const { forwardRef: e } = Hr()
                , n = _J()
                , r = G(() => TJ[n.placedSide.value]);
            return (i, s) => {
                var o, a, l, c;
                return oe(),
                    Ae("span", {
                        ref: d => {
                            ie(n).onArrowChange(d)
                        }
                        ,
                        style: Vo({
                            position: "absolute",
                            left: (o = ie(n).arrowX) != null && o.value ? `${(a = ie(n).arrowX) == null ? void 0 : a.value}px` : void 0,
                            top: (l = ie(n).arrowY) != null && l.value ? `${(c = ie(n).arrowY) == null ? void 0 : c.value}px` : void 0,
                            [r.value]: 0,
                            transformOrigin: {
                                top: "",
                                right: "0 0",
                                bottom: "center 0",
                                left: "100% 0"
                            }[ie(n).placedSide.value],
                            transform: {
                                top: "translateY(100%)",
                                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                                bottom: "rotate(180deg)",
                                left: "translateY(50%) rotate(-90deg) translateX(50%)"
                            }[ie(n).placedSide.value],
                            visibility: ie(n).shouldHideArrow.value ? "hidden" : void 0
                        })
                    }, [$e(EJ, Wt(i.$attrs, {
                        ref: ie(e),
                        style: {
                            display: "block"
                        },
                        as: i.as,
                        "as-child": i.asChild,
                        width: i.width,
                        height: i.height
                    }), {
                        default: tt(() => [Ue(i.$slots, "default")]),
                        _: 3
                    }, 16, ["as", "as-child", "width", "height"])], 4)
            }
        }
    })
    , OJ = je({
        __name: "VisuallyHidden",
        props: {
            asChild: {
                type: Boolean
            },
            as: {
                default: "span"
            }
        },
        setup(t) {
            return Hr(),
                (e, n) => (oe(),
                    gt(ie(yu), {
                        as: e.as,
                        "as-child": e.asChild,
                        style: {
                            position: "absolute",
                            border: 0,
                            width: "1px",
                            display: "inline-block",
                            height: "1px",
                            padding: 0,
                            margin: "-1px",
                            overflow: "hidden",
                            clip: "rect(0, 0, 0, 0)",
                            whiteSpace: "nowrap",
                            wordWrap: "normal"
                        }
                    }, {
                        default: tt(() => [Ue(e.$slots, "default")]),
                        _: 3
                    }, 8, ["as", "as-child"]))
        }
    });
function MJ() {
    if (typeof matchMedia == "function")
        return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine"
}
MJ();
const IA = "tooltip.open"
    , [eb, RJ] = Td("TooltipProvider")
    , PJ = je({
        __name: "TooltipProvider",
        props: {
            delayDuration: {
                default: 700
            },
            skipDelayDuration: {
                default: 300
            },
            disableHoverableContent: {
                type: Boolean,
                default: !1
            },
            disableClosingTrigger: {
                type: Boolean
            },
            disabled: {
                type: Boolean
            },
            ignoreNonKeyboardFocus: {
                type: Boolean,
                default: !1
            }
        },
        setup(t) {
            const e = t
                , { delayDuration: n, skipDelayDuration: r, disableHoverableContent: i, disableClosingTrigger: s, ignoreNonKeyboardFocus: o, disabled: a } = Hy(e);
            Hr();
            const l = ce(!0)
                , c = ce(!1)
                , { start: d, stop: h } = OA(() => {
                    l.value = !0
                }
                    , r, {
                    immediate: !1
                });
            return RJ({
                isOpenDelayed: l,
                delayDuration: n,
                onOpen() {
                    h(),
                        l.value = !1
                },
                onClose() {
                    d()
                },
                isPointerInTransitRef: c,
                disableHoverableContent: i,
                disableClosingTrigger: s,
                disabled: a,
                ignoreNonKeyboardFocus: o
            }),
                (p, g) => Ue(p.$slots, "default")
        }
    })
    , [jm, NJ] = Td("TooltipRoot")
    , IJ = je({
        __name: "TooltipRoot",
        props: {
            defaultOpen: {
                type: Boolean,
                default: !1
            },
            open: {
                type: Boolean,
                default: void 0
            },
            delayDuration: {
                default: void 0
            },
            disableHoverableContent: {
                type: Boolean,
                default: void 0
            },
            disableClosingTrigger: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            ignoreNonKeyboardFocus: {
                type: Boolean,
                default: void 0
            }
        },
        emits: ["update:open"],
        setup(t, { emit: e }) {
            const n = t
                , r = e;
            Hr();
            const i = eb()
                , s = G(() => n.disableHoverableContent ?? i.disableHoverableContent.value)
                , o = G(() => n.disableClosingTrigger ?? i.disableClosingTrigger.value)
                , a = G(() => n.disabled ?? i.disabled.value)
                , l = G(() => n.delayDuration ?? i.delayDuration.value)
                , c = G(() => n.ignoreNonKeyboardFocus ?? i.ignoreNonKeyboardFocus.value)
                , d = KG(n, "open", r, {
                    defaultValue: n.defaultOpen,
                    passive: n.open === void 0
                });
            vt(d, C => {
                i.onClose && (C ? (i.onOpen(),
                    document.dispatchEvent(new CustomEvent(IA))) : i.onClose())
            }
            );
            const h = ce(!1)
                , p = ce()
                , g = G(() => d.value ? h.value ? "delayed-open" : "instant-open" : "closed")
                , { start: y, stop: x } = OA(() => {
                    h.value = !0,
                        d.value = !0
                }
                    , l, {
                    immediate: !1
                });
            function S() {
                x(),
                    h.value = !1,
                    d.value = !0
            }
            function k() {
                x(),
                    d.value = !1
            }
            function A() {
                y()
            }
            return NJ({
                contentId: "",
                open: d,
                stateAttribute: g,
                trigger: p,
                onTriggerChange(C) {
                    p.value = C
                },
                onTriggerEnter() {
                    i.isOpenDelayed.value ? A() : S()
                },
                onTriggerLeave() {
                    s.value ? k() : x()
                },
                onOpen: S,
                onClose: k,
                disableHoverableContent: s,
                disableClosingTrigger: o,
                disabled: a,
                ignoreNonKeyboardFocus: c
            }),
                (C, m) => (oe(),
                    gt(ie(yJ), null, {
                        default: tt(() => [Ue(C.$slots, "default", {
                            open: ie(d)
                        })]),
                        _: 3
                    }))
        }
    })
    , LJ = je({
        __name: "TooltipTrigger",
        props: {
            asChild: {
                type: Boolean
            },
            as: {
                default: "button"
            }
        },
        setup(t) {
            const e = t
                , n = jm()
                , r = eb();
            n.contentId || (n.contentId = iJ(void 0, "radix-vue-tooltip-content"));
            const { forwardRef: i, currentElement: s } = Hr()
                , o = ce(!1)
                , a = ce(!1)
                , l = G(() => n.disabled.value ? {} : {
                    click: x,
                    focus: g,
                    pointermove: h,
                    pointerleave: p,
                    pointerdown: d,
                    blur: y
                });
            Nt(() => {
                n.onTriggerChange(s.value)
            }
            );
            function c() {
                setTimeout(() => {
                    o.value = !1
                }
                    , 1)
            }
            function d() {
                o.value = !0,
                    document.addEventListener("pointerup", c, {
                        once: !0
                    })
            }
            function h(S) {
                S.pointerType !== "touch" && !a.value && !r.isPointerInTransitRef.value && (n.onTriggerEnter(),
                    a.value = !0)
            }
            function p() {
                n.onTriggerLeave(),
                    a.value = !1
            }
            function g(S) {
                var k, A;
                o.value || n.ignoreNonKeyboardFocus.value && !((A = (k = S.target).matches) != null && A.call(k, ":focus-visible")) || n.onOpen()
            }
            function y() {
                n.onClose()
            }
            function x() {
                n.disableClosingTrigger.value || n.onClose()
            }
            return (S, k) => (oe(),
                gt(ie(vJ), {
                    "as-child": ""
                }, {
                    default: tt(() => [$e(ie(yu), Wt({
                        ref: ie(i),
                        "aria-describedby": ie(n).open.value ? ie(n).contentId : void 0,
                        "data-state": ie(n).stateAttribute.value,
                        as: S.as,
                        "as-child": e.asChild,
                        "data-grace-area-trigger": ""
                    }, f5(l.value)), {
                        default: tt(() => [Ue(S.$slots, "default")]),
                        _: 3
                    }, 16, ["aria-describedby", "data-state", "as", "as-child"])]),
                    _: 3
                }))
        }
    })
    , LA = je({
        __name: "TooltipContentImpl",
        props: {
            ariaLabel: {},
            asChild: {
                type: Boolean
            },
            as: {},
            side: {
                default: "top"
            },
            sideOffset: {
                default: 0
            },
            align: {
                default: "center"
            },
            alignOffset: {},
            avoidCollisions: {
                type: Boolean,
                default: !0
            },
            collisionBoundary: {
                default: () => []
            },
            collisionPadding: {
                default: 0
            },
            arrowPadding: {
                default: 0
            },
            sticky: {
                default: "partial"
            },
            hideWhenDetached: {
                type: Boolean,
                default: !1
            }
        },
        emits: ["escapeKeyDown", "pointerDownOutside"],
        setup(t, { emit: e }) {
            const n = t
                , r = e
                , i = jm()
                , { forwardRef: s } = Hr()
                , o = om()
                , a = G(() => {
                    var d;
                    return (d = o.default) == null ? void 0 : d.call(o)
                }
                )
                , l = G(() => {
                    var d;
                    if (n.ariaLabel)
                        return n.ariaLabel;
                    let h = "";
                    function p(g) {
                        typeof g.children == "string" && g.type !== cn ? h += g.children : Array.isArray(g.children) && g.children.forEach(y => p(y))
                    }
                    return (d = a.value) == null || d.forEach(g => p(g)),
                        h
                }
                )
                , c = G(() => {
                    const { ariaLabel: d, ...h } = n;
                    return h
                }
                );
            return Nt(() => {
                gy(window, "scroll", d => {
                    const h = d.target;
                    h != null && h.contains(i.trigger.value) && i.onClose()
                }
                ),
                    gy(window, IA, i.onClose)
            }
            ),
                (d, h) => (oe(),
                    gt(ie(mJ), {
                        "as-child": "",
                        "disable-outside-pointer-events": !1,
                        onEscapeKeyDown: h[0] || (h[0] = p => r("escapeKeyDown", p)),
                        onPointerDownOutside: h[1] || (h[1] = p => {
                            var g;
                            ie(i).disableClosingTrigger.value && (g = ie(i).trigger.value) != null && g.contains(p.target) && p.preventDefault(),
                                r("pointerDownOutside", p)
                        }
                        ),
                        onFocusOutside: h[2] || (h[2] = m1(() => { }
                            , ["prevent"])),
                        onDismiss: h[3] || (h[3] = p => ie(i).onClose())
                    }, {
                        default: tt(() => [$e(ie(kJ), Wt({
                            ref: ie(s),
                            "data-state": ie(i).stateAttribute.value
                        }, {
                            ...d.$attrs,
                            ...c.value
                        }, {
                            style: {
                                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
                            }
                        }), {
                            default: tt(() => [Ue(d.$slots, "default"), $e(ie(OJ), {
                                id: ie(i).contentId,
                                role: "tooltip"
                            }, {
                                default: tt(() => [Pa(Vt(l.value), 1)]),
                                _: 1
                            }, 8, ["id"])]),
                            _: 3
                        }, 16, ["data-state"])]),
                        _: 3
                    }))
        }
    })
    , DJ = je({
        __name: "TooltipContentHoverable",
        props: {
            ariaLabel: {},
            asChild: {
                type: Boolean
            },
            as: {},
            side: {},
            sideOffset: {},
            align: {},
            alignOffset: {},
            avoidCollisions: {
                type: Boolean
            },
            collisionBoundary: {},
            collisionPadding: {},
            arrowPadding: {},
            sticky: {},
            hideWhenDetached: {
                type: Boolean
            }
        },
        setup(t) {
            const e = RA(t)
                , { forwardRef: n, currentElement: r } = Hr()
                , { trigger: i, onClose: s } = jm()
                , o = eb()
                , { isPointerInTransit: a, onPointerExit: l } = ZG(i, r);
            return o.isPointerInTransitRef = a,
                l(() => {
                    s()
                }
                ),
                (c, d) => (oe(),
                    gt(LA, Wt({
                        ref: ie(n)
                    }, ie(e)), {
                        default: tt(() => [Ue(c.$slots, "default")]),
                        _: 3
                    }, 16))
        }
    })
    , jJ = je({
        __name: "TooltipContent",
        props: {
            forceMount: {
                type: Boolean
            },
            ariaLabel: {},
            asChild: {
                type: Boolean
            },
            as: {},
            side: {
                default: "top"
            },
            sideOffset: {},
            align: {},
            alignOffset: {},
            avoidCollisions: {
                type: Boolean
            },
            collisionBoundary: {},
            collisionPadding: {},
            arrowPadding: {},
            sticky: {},
            hideWhenDetached: {
                type: Boolean
            }
        },
        emits: ["escapeKeyDown", "pointerDownOutside"],
        setup(t, { emit: e }) {
            const n = t
                , r = e
                , i = jm()
                , s = JG(n, r)
                , { forwardRef: o } = Hr();
            return (a, l) => (oe(),
                gt(ie(uJ), {
                    present: a.forceMount || ie(i).open.value
                }, {
                    default: tt(() => [(oe(),
                        gt(d5(ie(i).disableHoverableContent.value ? LA : DJ), Wt({
                            ref: ie(o)
                        }, ie(s)), {
                            default: tt(() => [Ue(a.$slots, "default")]),
                            _: 3
                        }, 16))]),
                    _: 3
                }, 8, ["present"]))
        }
    })
    , BJ = je({
        __name: "TooltipArrow",
        props: {
            width: {
                default: 10
            },
            height: {
                default: 5
            },
            asChild: {
                type: Boolean
            },
            as: {
                default: "svg"
            }
        },
        setup(t) {
            const e = t;
            return Hr(),
                (n, r) => (oe(),
                    gt(ie(AJ), xi(_i(e)), {
                        default: tt(() => [Ue(n.$slots, "default")]),
                        _: 3
                    }, 16))
        }
    })
    , $J = je({
        __name: "TooltipPortal",
        props: {
            to: {},
            disabled: {
                type: Boolean
            },
            forceMount: {
                type: Boolean
            }
        },
        setup(t) {
            const e = t;
            return (n, r) => (oe(),
                gt(ie(cJ), xi(_i(e)), {
                    default: tt(() => [Ue(n.$slots, "default")]),
                    _: 3
                }, 16))
        }
    })
    , zJ = {
        class: "rounded bg-gray-900 px-2 py-1 text-xs text-white shadow-xl"
    }
    , FJ = je({
        inheritAttrs: !1,
        __name: "Tooltip",
        props: {
            text: {
                default: ""
            },
            hoverDelay: {
                default: .5
            },
            placement: {
                default: "top"
            },
            arrowClass: {
                default: "fill-gray-900"
            },
            disabled: {
                type: Boolean,
                default: !1
            }
        },
        setup(t) {
            const e = t
                , n = G(() => e.hoverDelay * 1e3);
            return (r, i) => r.disabled ? Ue(r.$slots, "default", {
                key: 0
            }) : (oe(),
                gt(ie(PJ), {
                    key: 1,
                    delayDuration: n.value
                }, {
                    default: tt(() => [$e(ie(IJ), null, {
                        default: tt(() => [$e(ie(LJ), {
                            "as-child": ""
                        }, {
                            default: tt(() => [Ue(r.$slots, "default")]),
                            _: 3
                        }), $e(ie($J), null, {
                            default: tt(() => [e.text || r.$slots.body ? (oe(),
                                gt(ie(jJ), {
                                    key: 0,
                                    side: e.placement,
                                    "side-offset": 4,
                                    class: "z-[100]"
                                }, {
                                    default: tt(() => [Ue(r.$slots, "body", {}, () => [Xe("div", zJ, [Xe("div", null, Vt(e.text), 1)])]), $e(ie(BJ), {
                                        class: mt(e.arrowClass),
                                        width: 8,
                                        height: 4
                                    }, null, 8, ["class"])]),
                                    _: 3
                                }, 8, ["side"])) : pt("", !0)]),
                            _: 3
                        })]),
                        _: 3
                    })]),
                    _: 3
                }, 8, ["delayDuration"]))
        }
    });
async function tb(t, e, n = {}) {
    e || (e = {});
    let r = Object.assign({
        Accept: "application/json",
        "Content-Type": "application/json; charset=utf-8",
        "X-Frappe-Site-Name": window.location.hostname
    }, n.headers || {});
    window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (r["X-Frappe-CSRF-Token"] = window.csrf_token);
    let i = t.startsWith("/") ? t : `/api/method/${t}`;
    const s = await fetch(i, {
        method: "POST",
        headers: r,
        body: JSON.stringify(e)
    });
    if (s.ok) {
        const o = await s.json();
        if (o.docs || t === "login")
            return o;
        if (o.exc)
            try {
                console.groupCollapsed(t),
                    console.log(`method: ${t}`),
                    console.log("params:", e);
                let a = JSON.parse(o.exc);
                for (let l of a)
                    console.log(l);
                console.groupEnd()
            } catch (a) {
                console.warn("Error printing debug messages", a)
            }
        return o.message
    } else {
        let o = await s.text(), a, l;
        try {
            a = JSON.parse(o)
        } catch { }
        let c = [[t, a.exc_type, a._error_message].filter(Boolean).join(" ")];
        if (a.exc) {
            l = a.exc;
            try {
                l = JSON.parse(l)[0],
                    console.log(l)
            } catch { }
        }
        let d = new Error(c.join(`
`));
        throw d.exc_type = a.exc_type,
        d.exc = l,
        d.status = s.status,
        d.messages = a._server_messages ? JSON.parse(a._server_messages) : [],
        d.messages = d.messages.concat(a.message),
        d.messages = d.messages.map(h => {
            try {
                return JSON.parse(h).message
            } catch {
                return h
            }
        }
        ),
        d.messages = d.messages.filter(Boolean),
        d.messages.length || (d.messages = a._error_message ? [a._error_message] : ["Internal Server Error"]),
        n.onError && n.onError({
            response: s,
            status: s.status,
            error: d
        }),
        d
    }
}
let wh = document.querySelector('link[rel="icon"]')
    , HJ = wh?.href;
function Cee(t) {
    vt(() => {
        try {
            return t()
        } catch {
            return null
        }
    }
        , e => {
            if (e)
                if (e.title && (document.title = e.title),
                    e.emoji) {
                    let n = `data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>${e.emoji}</text></svg>`;
                    wh.href = n
                } else
                    e.icon ? wh.href = e.icon : wh.href = HJ
        }
        , {
            immediate: !0,
            deep: !0
        })
}
function DA(t) {
    let e = Object.assign({}, t);
    if (!e.url)
        throw new Error("[request] options.url is required");
    e.transformRequest && (e = e.transformRequest(t)),
        e.responseType || (e.responseType = "json"),
        e.method || (e.method = "GET");
    let n = e.url, r;
    if (e.params)
        if (e.method === "GET") {
            let i = new URLSearchParams;
            for (let s in e.params)
                i.append(s, e.params[s]);
            n = e.url + "?" + i.toString()
        } else
            r = JSON.stringify(e.params);
    return fetch(n, {
        method: e.method || "GET",
        headers: e.headers,
        body: r
    }).then(i => {
        if (e.transformResponse)
            return e.transformResponse(i, e);
        if (i.status >= 200 && i.status < 300)
            return e.responseType === "json" ? i.json() : i;
        {
            let s = new Error(i.statusText);
            throw s.response = i,
            s
        }
    }
    )
}
function Bm(t) {
    return new Promise((e, n) => {
        t.oncomplete = t.onsuccess = () => e(t.result),
            t.onabort = t.onerror = () => n(t.error)
    }
    )
}
function VJ(t, e) {
    const n = indexedDB.open(t);
    n.onupgradeneeded = () => n.result.createObjectStore(e);
    const r = Bm(n);
    return (i, s) => r.then(o => s(o.transaction(e, i).objectStore(e)))
}
let U0;
function nb() {
    return U0 || (U0 = VJ("keyval-store", "keyval")),
        U0
}
function WJ(t, e = nb()) {
    return e("readonly", n => Bm(n.get(t)))
}
function UJ(t, e, n = nb()) {
    return n("readwrite", r => (r.put(e, t),
        Bm(r.transaction)))
}
function KJ(t, e = nb()) {
    return e("readwrite", n => (n.delete(t),
        Bm(n.transaction)))
}
function rb(t, e) {
    return typeof indexedDB > "u" ? Promise.resolve(null) : t ? UJ(t, JSON.stringify(e)) : Promise.resolve()
}
function qJ(t) {
    return typeof indexedDB > "u" ? Promise.resolve(null) : t ? KJ(t) : Promise.resolve()
}
function ib(t) {
    return typeof indexedDB > "u" ? Promise.resolve(null) : WJ(t).then(e => e && JSON.parse(e))
}
let jA = {};
function BA(t, e) {
    jA[t] = e
}
function wi(t) {
    return jA[t] || null
}
let xh = {};
function zn(t, e) {
    let n = null;
    if (t.cache) {
        n = vu(t.cache);
        let h = xh[n];
        if (h)
            return h.auto && h.reload(),
                h
    }
    typeof t == "string" && (t = {
        url: t,
        auto: !0
    });
    let r = t.debounce ? gm(s, t.debounce) : s
        , i = wn({
            method: t.method,
            url: t.url,
            data: t.initialData || null,
            previousData: null,
            loading: !1,
            fetched: !1,
            error: null,
            promise: null,
            auto: t.auto,
            params: null,
            fetch: r,
            reload: r,
            submit: r,
            reset: a,
            update: o,
            setData: c
        });
    async function s(h, p = {}) {
        let g = t.resourceFetcher || wi("resourceFetcher") || DA;
        h instanceof Event && (h = null),
            h = h || i.params,
            t.makeParams && (h = t.makeParams.call(e, h)),
            i.params = h,
            i.previousData = i.data ? JSON.parse(JSON.stringify(i.data)) : null,
            i.loading = !0,
            i.error = null,
            t.onFetch && t.onFetch.call(e, i.params);
        let y = [t.beforeSubmit, p.beforeSubmit];
        for (let C of y)
            C && C.call(e, i.params);
        let x = p.validate || t.validate
            , S = [t.onError, p.onError]
            , k = [t.onSuccess, p.onSuccess]
            , A = [t.onData, p.onData];
        if (x) {
            let C;
            try {
                if (C = await x.call(e, i.params),
                    C && typeof C == "string")
                    throw new Error(C)
            } catch (m) {
                l(m, S);
                return
            }
        }
        try {
            i.promise = g({
                ...t,
                params: h || t.params
            });
            let C = await i.promise;
            rb(n, C),
                i.data = d(C),
                i.fetched = !0;
            for (let m of k)
                m && m.call(e, C);
            for (let m of A)
                m && m.call(e, C)
        } catch (C) {
            l(C, S)
        }
        return i.loading = !1,
            i.data
    }
    function o({ method: h, url: p, params: g, auto: y }) {
        h && h !== t.method && (i.method = h),
            p && p !== t.url && (i.url = p),
            g && g !== t.params && (i.params = g),
            y !== void 0 && y !== i.auto && (i.auto = y)
    }
    function a() {
        i.data = t.initialData || null,
            i.previousData = null,
            i.loading = !1,
            i.fetched = !1,
            i.error = null,
            i.params = null,
            i.auto = t.auto
    }
    function l(h, p) {
        i.loading = !1,
            i.previousData && (i.data = i.previousData),
            i.error = h;
        for (let g of p)
            g && g.call(e, h);
        if (p.every(g => g == null)) {
            let g = wi("fallbackErrorHandler");
            if (g)
                try {
                    g(h)
                } catch (y) {
                    console.warn("Error in fallbackErrorHandler", y)
                }
        }
        throw h
    }
    function c(h) {
        typeof h == "function" && (h = h.call(e, i.data)),
            i.data = d(h)
    }
    function d(h) {
        if (t.transform) {
            let p = t.transform.call(e, h);
            if (p != null)
                return p
        }
        return h
    }
    return n && !xh[n] && (xh[n] = i,
        ib(n).then(h => {
            (i.loading || !i.fetched) && h && (c(h),
                t.onData?.call(e, h))
        }
        )),
        t.auto && i.fetch(),
        i
}
function vu(t) {
    return t ? (typeof t == "string" && (t = [t]),
        JSON.stringify(t)) : null
}
function $A(t) {
    return t = vu(t),
        xh[t] || null
}
function zA(t, e, n) {
    GJ(t, e),
        t.on("list_update", r => {
            r.doctype == e && n(r.name)
        }
        )
}
let cS = {};
function GJ(t, e) {
    cS[e] || (t.emit("doctype_subscribe", e),
        cS[e] = !0)
}
let vy = wn({})
    , Wl = {};
function JJ(t, e) {
    if (!t.doctype)
        throw new Error("List resource requires doctype");
    let n = vu(t.cache);
    if (n) {
        let k = vy[n];
        if (k)
            return k.auto && k.reload(),
                k
    }
    let r = wi("defaultListUrl") || "frappe.client.get_list"
        , i = wi("defaultDocInsertUrl") || "frappe.client.insert"
        , s = wi("defaultDocUpdateUrl") || "frappe.client.set_value"
        , o = wi("defaultDocDeleteUrl") || "frappe.client.delete"
        , a = wi("defaultRunDocMethodUrl") || "run_doc_method"
        , l = wn({
            doctype: t.doctype,
            fields: t.fields,
            filters: t.filters,
            orFilters: t.orFilters,
            orderBy: t.orderBy,
            start: t.start || 0,
            pageLength: t.pageLength || 20,
            groupBy: t.groupBy,
            parent: t.parent,
            debug: t.debug || 0,
            originalData: null,
            dataMap: {},
            data: null,
            previous: y,
            hasPreviousPage: !1,
            next: x,
            hasNextPage: !0,
            auto: t.auto,
            list: zn({
                url: t.url || r,
                makeParams() {
                    return {
                        doctype: l.doctype,
                        fields: l.fields,
                        filters: l.filters,
                        or_filters: l.orFilters,
                        order_by: l.orderBy,
                        start: l.start,
                        limit: l.pageLength,
                        limit_start: l.start,
                        limit_page_length: l.pageLength,
                        group_by: l.groupBy,
                        parent: l.parent,
                        debug: l.debug
                    }
                },
                onSuccess(k) {
                    l.hasPreviousPage = !!l.start,
                        l.hasNextPage = !(k.length < l.pageLength);
                    let A;
                    !l.start || l.start == 0 ? A = k : l.start > 0 && (A = l.originalData.concat(k)),
                        rb(n, A),
                        g(A),
                        t.onSuccess?.call(e, l.data)
                },
                onError: t.onError
            }, e),
            fetchOne: zn({
                url: t.url || r,
                makeParams(k) {
                    return {
                        doctype: l.doctype,
                        fields: l.fields || "*",
                        filters: {
                            name: k
                        }
                    }
                },
                onSuccess(k) {
                    if (k.length > 0 && l.originalData) {
                        let A = k[0];
                        wc(l.doctype, A)
                    }
                    t.fetchOne?.onSuccess?.call(e, l.data)
                },
                onError: t.fetchOne?.onError
            }, e),
            insert: zn({
                url: i,
                makeParams(k) {
                    return {
                        doc: {
                            doctype: l.doctype,
                            ...k
                        }
                    }
                },
                onSuccess(k) {
                    l.list.fetch(),
                        t.insert?.onSuccess?.call(e, k)
                },
                onError: t.insert?.onError
            }, e),
            setValue: zn({
                url: s,
                makeParams(k) {
                    let { name: A, ...C } = k;
                    return {
                        doctype: l.doctype,
                        name: A,
                        fieldname: C
                    }
                },
                onSuccess(k) {
                    wc(l.doctype, k),
                        t.setValue?.onSuccess?.call(e, k)
                },
                onError: t.setValue?.onError
            }, e),
            delete: zn({
                url: o,
                makeParams(k) {
                    return {
                        doctype: l.doctype,
                        name: k
                    }
                },
                onSuccess(k) {
                    l.list.fetch(),
                        t.delete?.onSuccess?.call(e, k)
                },
                onError: t.delete?.onError
            }, e),
            runDocMethod: zn({
                url: a,
                makeParams({ method: k, name: A, ...C }) {
                    return {
                        dt: l.doctype,
                        dn: A,
                        method: k,
                        args: C
                    }
                },
                onSuccess(k) {
                    if (k.docs)
                        for (let A of k.docs)
                            wc(A.doctype, A);
                    t.runDocMethod?.onSuccess?.call(e, k)
                },
                onError: t.runDocMethod?.onError
            }, e),
            update: c,
            fetch: p,
            reload: h,
            setData: g,
            transform: d,
            getRow: S
        });
    function c(k) {
        Object.assign(l, k)
    }
    function d(k) {
        if (t.transform) {
            let A = t.transform.call(e, k);
            if (A != null)
                return A
        }
        return k
    }
    function h() {
        let k = l.start
            , A = l.pageLength;
        return l.start > 0 && (l.start = 0,
            l.pageLength = l.originalData.length),
            l.list.fetch().finally(() => {
                l.start = k,
                    l.pageLength = A
            }
            )
    }
    function p() {
        h()
    }
    function g(k) {
        if (l.originalData = k,
            typeof k == "function" && (k = k.call(e, l.data)),
            l.data = d(k),
            Array.isArray(l.data)) {
            l.dataMap = {};
            for (let A of l.data) {
                if (!A.name)
                    continue;
                let C = A.name.toString();
                l.dataMap[C] = A
            }
        }
    }
    function y() {
        l.start = l.start - l.pageLength,
            l.list.fetch()
    }
    function x() {
        l.start = l.start + l.pageLength,
            l.list.fetch()
    }
    function S(k) {
        let A = k.toString();
        return l.dataMap[A]
    }
    return t.realtime && e?.$socket && zA(e.$socket, l.doctype, k => {
        l.originalData?.find(A => A.name === k) && l.fetchOne.submit(k)
    }
    ),
        n && (vy[n] = l,
            ib(n).then(k => {
                (l.list.loading || !l.list.fetched) && k && (g(k),
                    t.onData?.call(e, k))
            }
            )),
        t.auto && l.list.fetch(),
        Wl[l.doctype] = Wl[l.doctype] || [],
        Wl[l.doctype].push(l),
        l
}
function FA(t) {
    return t = vu(t),
        vy[t] || null
}
function wc(t, e) {
    if (!e.name)
        return;
    let n = Wl[t] || [];
    for (let r of n)
        if (r.originalData) {
            for (let i of r.originalData)
                if (i.name && i.name == e.name) {
                    delete i._previousData;
                    let s = JSON.stringify(i);
                    for (let o in i)
                        o in e && (i[o] = e[o]);
                    i._previousData = s
                }
            r.data = r.transform(r.originalData)
        }
}
function ZJ(t, e) {
    let n = Wl[t] || [];
    for (let r of n)
        r.originalData && (r.originalData = r.originalData.filter(i => i.name.toString() !== e.toString()),
            r.data = r.transform(r.originalData))
}
function YJ(t, e) {
    let n = Wl[t] || [];
    for (let r of n)
        if (r.originalData) {
            for (let i of r.originalData)
                if (i.name && i.name == e.name) {
                    let s = JSON.parse(i._previousData);
                    for (let o in i)
                        i[o] = s[o];
                    delete i._previousData
                }
            r.data = r.transform(r.originalData)
        }
}
let by = wn({});
function XJ(t, e) {
    if (!(t.doctype && t.name))
        return;
    let n = vu([t.doctype, t.name])
        , r = by[n];
    if (r)
        return r.auto && r.reload(),
            r;
    let i = wi("defaultDocGetUrl") || "frappe.client.get"
        , s = wi("defaultDocUpdateUrl") || "frappe.client.set_value"
        , o = wi("defaultDocDeleteUrl") || "frappe.client.delete"
        , a = wi("defaultRunDocMethodUrl") || "run_doc_method"
        , l = {
            url: s,
            makeParams(y) {
                return {
                    doctype: d.doctype,
                    name: d.name,
                    fieldname: y
                }
            },
            beforeSubmit(y) {
                d.previousDoc = JSON.stringify(d.doc),
                    Object.assign(d.doc, y.fieldname || {}),
                    wc(d.doctype, d.doc)
            },
            onSuccess(y) {
                d.doc = g(y),
                    d.originalDoc = JSON.parse(JSON.stringify(d.doc)),
                    t.setValue?.onSuccess?.call(e, y)
            },
            onError(y) {
                d.doc = JSON.parse(d.previousDoc),
                    t.setValue?.onError?.call(e, y),
                    YJ(d.doctype, d.doc)
            }
        };
    const c = t.auto !== void 0;
    let d = wn({
        doctype: t.doctype,
        name: t.name,
        doc: null,
        originalDoc: null,
        isDirty: !1,
        auto: c ? t.auto : !0,
        get: zn({
            url: i,
            makeParams() {
                return {
                    doctype: d.doctype,
                    name: d.name
                }
            },
            onSuccess(y) {
                rb(n, y),
                    d.doc = g(y),
                    d.originalDoc = JSON.parse(JSON.stringify(d.doc)),
                    t.onSuccess?.call(e, d.doc)
            },
            onError(y) {
                qJ(n),
                    d.doc = null,
                    d.originalDoc = null,
                    t.onError?.call(e, y)
            }
        }, e),
        setValue: zn(l, e),
        setValueDebounced: zn({
            ...l,
            debounce: t.debounce || 500
        }, e),
        save: zn({
            ...l,
            makeParams() {
                let y = JSON.parse(JSON.stringify(d.doc));
                return delete y.doctype,
                    delete y.name,
                {
                    doctype: d.doctype,
                    name: d.name,
                    fieldname: y
                }
            }
        }, e),
        delete: zn({
            url: o,
            makeParams() {
                return {
                    doctype: d.doctype,
                    name: d.name
                }
            },
            onSuccess() {
                d.doc = null,
                    t.delete?.onSuccess?.call(e),
                    ZJ(d.doctype, d.name)
            },
            onError: t.delete?.onError
        }, e),
        reload: h,
        setDoc: p
    });
    vt(() => d.doc, () => {
        d.isDirty = JSON.stringify(d.doc) !== JSON.stringify(d.originalDoc)
    }
        , {
            deep: !0
        });
    for (let y in t.whitelistedMethods) {
        let x = t.whitelistedMethods[y];
        typeof x == "string" && (x = {
            method: x
        });
        let { method: S, onSuccess: k, makeParams: A, transform: C, ...m } = x;
        d[y] = zn({
            url: a,
            makeParams(b) {
                return b = A ? A.call(e, b) : b,
                {
                    dt: d.doctype,
                    dn: d.name,
                    method: S,
                    args: b
                }
            },
            transform(b) {
                if (C) {
                    let w = C.call(e, b.message);
                    if (w != null)
                        return w
                }
                return b.message
            },
            onSuccess(b) {
                if (b.docs) {
                    for (let w of b.docs)
                        if (w.doctype === d.doctype && w.name.toString() === d.name.toString()) {
                            d.doc = g(w),
                                wc(d.doctype, d.doc);
                            break
                        }
                }
                k?.call(e, b.message)
            },
            ...m
        }, e)
    }
    function h() {
        return d.get.fetch()
    }
    function p(y) {
        typeof y == "function" && (y = y.call(e, d.doc)),
            d.doc = g(y)
    }
    function g(y) {
        if (t.transform) {
            let x = t.transform.call(e, y);
            if (typeof x == "object")
                return x
        }
        return y
    }
    return t.realtime && e.$socket && zA(e.$socket, d.doctype, y => {
        y == d.name && d.get.fetch()
    }
    ),
        by[n] = d,
        ib(n).then(y => {
            (d.get.loading || !d.get.fetched) && y && (d.doc = g(y))
        }
        ),
        d.auto && d.get.fetch(),
        d
}
function QJ(t, e) {
    let n = vu([t, e]);
    return by[n] || null
}
let eZ = t => ({
    created() {
        if (this.$options.resources) {
            this._resources = wn({});
            for (let e in this.$options.resources) {
                let n = this.$options.resources[e];
                if (typeof n == "function")
                    vt(() => {
                        let r = null;
                        try {
                            r = n.call(this)
                        } catch (i) {
                            console.warn(`Failed to get resource options

`, i),
                                r = null
                        }
                        return r
                    }
                        , (r, i) => {
                            !r || !(!i || JSON.stringify(r) !== JSON.stringify(i)) || (this._resources[e] = dS(r, this))
                        }
                        , {
                            immediate: !0,
                            deep: !0
                        });
                else {
                    let r = dS(n, this);
                    this._resources[e] = r
                }
            }
        }
    },
    methods: {
        $getResource(e) {
            return $A(e)
        },
        $getDocumentResource(e, n) {
            return QJ(e, n)
        },
        $getDoc(e, n) {
            let r = this.$getDocumentResource(e, n);
            return r ? r.doc : null
        },
        $getListResource(e) {
            return FA(e)
        },
        $refetchResource(e) {
            let n = this.$getResource(e);
            n && n.fetch()
        }
    },
    computed: {
        $resources() {
            return this._resources
        }
    }
});
function dS(t, e) {
    return t.type === "document" ? XJ(t, e) : t.type === "list" ? JJ(t, e) : zn(t, e)
}
const tZ = {
    install(t, e) {
        let n = eZ();
        t.mixin(n)
    }
};
function nZ(t) {
    return DA({
        ...t,
        transformRequest: (e = {}) => {
            if (!e.url)
                throw new Error("[frappeRequest] options.url is required");
            let n = Object.assign({
                Accept: "application/json",
                "Content-Type": "application/json; charset=utf-8",
                "X-Frappe-Site-Name": window.location.hostname
            }, e.headers || {});
            return window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (n["X-Frappe-CSRF-Token"] = window.csrf_token),
                !e.url.startsWith("/") && !e.url.startsWith("http") && (e.url = "/api/method/" + e.url),
            {
                ...e,
                method: e.method || "POST",
                headers: n
            }
        }
        ,
        transformResponse: async (e, n) => {
            let r = n.url;
            if (e.ok) {
                const i = await e.json();
                if (i.docs || r === "/api/method/login")
                    return i;
                if (i.exc)
                    try {
                        console.groupCollapsed(r),
                            console.log(n);
                        let s = JSON.parse(i.exc);
                        for (let o of s)
                            console.log(o);
                        console.groupEnd()
                    } catch (s) {
                        console.warn("Error printing debug messages", s)
                    }
                return i.message
            } else {
                let i = await e.text(), s, o;
                try {
                    s = JSON.parse(i)
                } catch { }
                let a = [[n.url, s.exc_type, s._error_message].filter(Boolean).join(" ")];
                if (s.exc) {
                    o = s.exc;
                    try {
                        o = JSON.parse(o)[0],
                            console.log(o)
                    } catch { }
                }
                let l = new Error(a.join(`
`));
                throw l.exc_type = s.exc_type,
                l.exc = o,
                l.response = e,
                l.status = i.status,
                l.messages = s._server_messages ? JSON.parse(s._server_messages) : [],
                l.messages = l.messages.concat(s.message),
                l.messages = l.messages.map(c => {
                    try {
                        return JSON.parse(c).message
                    } catch {
                        return c
                    }
                }
                ),
                l.messages = l.messages.filter(Boolean),
                l.messages.length || (l.messages = s._error_message ? [s._error_message] : ["Internal Server Error"]),
                n.onError && n.onError(l),
                l
            }
        }
    })
}
const ns = Object.create(null);
ns.open = "0";
ns.close = "1";
ns.ping = "2";
ns.pong = "3";
ns.message = "4";
ns.upgrade = "5";
ns.noop = "6";
const _h = Object.create(null);
Object.keys(ns).forEach(t => {
    _h[ns[t]] = t
}
);
const wy = {
    type: "error",
    data: "parser error"
}
    , HA = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]"
    , VA = typeof ArrayBuffer == "function"
    , WA = t => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer
    , sb = ({ type: t, data: e }, n, r) => HA && e instanceof Blob ? n ? r(e) : fS(e, r) : VA && (e instanceof ArrayBuffer || WA(e)) ? n ? r(e) : fS(new Blob([e]), r) : r(ns[t] + (e || ""))
    , fS = (t, e) => {
        const n = new FileReader;
        return n.onload = function () {
            const r = n.result.split(",")[1];
            e("b" + (r || ""))
        }
            ,
            n.readAsDataURL(t)
    }
    ;
function hS(t) {
    return t instanceof Uint8Array ? t : t instanceof ArrayBuffer ? new Uint8Array(t) : new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
}
let K0;
function rZ(t, e) {
    if (HA && t.data instanceof Blob)
        return t.data.arrayBuffer().then(hS).then(e);
    if (VA && (t.data instanceof ArrayBuffer || WA(t.data)))
        return e(hS(t.data));
    sb(t, !1, n => {
        K0 || (K0 = new TextEncoder),
            e(K0.encode(n))
    }
    )
}
const pS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    , Yu = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let t = 0; t < pS.length; t++)
    Yu[pS.charCodeAt(t)] = t;
const iZ = t => {
    let e = t.length * .75, n = t.length, r, i = 0, s, o, a, l;
    t[t.length - 1] === "=" && (e--,
        t[t.length - 2] === "=" && e--);
    const c = new ArrayBuffer(e)
        , d = new Uint8Array(c);
    for (r = 0; r < n; r += 4)
        s = Yu[t.charCodeAt(r)],
            o = Yu[t.charCodeAt(r + 1)],
            a = Yu[t.charCodeAt(r + 2)],
            l = Yu[t.charCodeAt(r + 3)],
            d[i++] = s << 2 | o >> 4,
            d[i++] = (o & 15) << 4 | a >> 2,
            d[i++] = (a & 3) << 6 | l & 63;
    return c
}
    , sZ = typeof ArrayBuffer == "function"
    , ob = (t, e) => {
        if (typeof t != "string")
            return {
                type: "message",
                data: UA(t, e)
            };
        const n = t.charAt(0);
        return n === "b" ? {
            type: "message",
            data: oZ(t.substring(1), e)
        } : _h[n] ? t.length > 1 ? {
            type: _h[n],
            data: t.substring(1)
        } : {
            type: _h[n]
        } : wy
    }
    , oZ = (t, e) => {
        if (sZ) {
            const n = iZ(t);
            return UA(n, e)
        } else
            return {
                base64: !0,
                data: t
            }
    }
    , UA = (t, e) => {
        switch (e) {
            case "blob":
                return t instanceof Blob ? t : new Blob([t]);
            case "arraybuffer":
            default:
                return t instanceof ArrayBuffer ? t : t.buffer
        }
    }
    , KA = String.fromCharCode(30)
    , aZ = (t, e) => {
        const n = t.length
            , r = new Array(n);
        let i = 0;
        t.forEach((s, o) => {
            sb(s, !1, a => {
                r[o] = a,
                    ++i === n && e(r.join(KA))
            }
            )
        }
        )
    }
    , lZ = (t, e) => {
        const n = t.split(KA)
            , r = [];
        for (let i = 0; i < n.length; i++) {
            const s = ob(n[i], e);
            if (r.push(s),
                s.type === "error")
                break
        }
        return r
    }
    ;
function uZ() {
    return new TransformStream({
        transform(t, e) {
            rZ(t, n => {
                const r = n.length;
                let i;
                if (r < 126)
                    i = new Uint8Array(1),
                        new DataView(i.buffer).setUint8(0, r);
                else if (r < 65536) {
                    i = new Uint8Array(3);
                    const s = new DataView(i.buffer);
                    s.setUint8(0, 126),
                        s.setUint16(1, r)
                } else {
                    i = new Uint8Array(9);
                    const s = new DataView(i.buffer);
                    s.setUint8(0, 127),
                        s.setBigUint64(1, BigInt(r))
                }
                t.data && typeof t.data != "string" && (i[0] |= 128),
                    e.enqueue(i),
                    e.enqueue(n)
            }
            )
        }
    })
}
let q0;
function nh(t) {
    return t.reduce((e, n) => e + n.length, 0)
}
function rh(t, e) {
    if (t[0].length === e)
        return t.shift();
    const n = new Uint8Array(e);
    let r = 0;
    for (let i = 0; i < e; i++)
        n[i] = t[0][r++],
            r === t[0].length && (t.shift(),
                r = 0);
    return t.length && r < t[0].length && (t[0] = t[0].slice(r)),
        n
}
function cZ(t, e) {
    q0 || (q0 = new TextDecoder);
    const n = [];
    let r = 0
        , i = -1
        , s = !1;
    return new TransformStream({
        transform(o, a) {
            for (n.push(o); ;) {
                if (r === 0) {
                    if (nh(n) < 1)
                        break;
                    const l = rh(n, 1);
                    s = (l[0] & 128) === 128,
                        i = l[0] & 127,
                        i < 126 ? r = 3 : i === 126 ? r = 1 : r = 2
                } else if (r === 1) {
                    if (nh(n) < 2)
                        break;
                    const l = rh(n, 2);
                    i = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0),
                        r = 3
                } else if (r === 2) {
                    if (nh(n) < 8)
                        break;
                    const l = rh(n, 8)
                        , c = new DataView(l.buffer, l.byteOffset, l.length)
                        , d = c.getUint32(0);
                    if (d > Math.pow(2, 53 - 32) - 1) {
                        a.enqueue(wy);
                        break
                    }
                    i = d * Math.pow(2, 32) + c.getUint32(4),
                        r = 3
                } else {
                    if (nh(n) < i)
                        break;
                    const l = rh(n, i);
                    a.enqueue(ob(s ? l : q0.decode(l), e)),
                        r = 0
                }
                if (i === 0 || i > t) {
                    a.enqueue(wy);
                    break
                }
            }
        }
    })
}
const qA = 4;
function hn(t) {
    if (t)
        return dZ(t)
}
function dZ(t) {
    for (var e in hn.prototype)
        t[e] = hn.prototype[e];
    return t
}
hn.prototype.on = hn.prototype.addEventListener = function (t, e) {
    return this._callbacks = this._callbacks || {},
        (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e),
        this
}
    ;
hn.prototype.once = function (t, e) {
    function n() {
        this.off(t, n),
            e.apply(this, arguments)
    }
    return n.fn = e,
        this.on(t, n),
        this
}
    ;
hn.prototype.off = hn.prototype.removeListener = hn.prototype.removeAllListeners = hn.prototype.removeEventListener = function (t, e) {
    if (this._callbacks = this._callbacks || {},
        arguments.length == 0)
        return this._callbacks = {},
            this;
    var n = this._callbacks["$" + t];
    if (!n)
        return this;
    if (arguments.length == 1)
        return delete this._callbacks["$" + t],
            this;
    for (var r, i = 0; i < n.length; i++)
        if (r = n[i],
            r === e || r.fn === e) {
            n.splice(i, 1);
            break
        }
    return n.length === 0 && delete this._callbacks["$" + t],
        this
}
    ;
hn.prototype.emit = function (t) {
    this._callbacks = this._callbacks || {};
    for (var e = new Array(arguments.length - 1), n = this._callbacks["$" + t], r = 1; r < arguments.length; r++)
        e[r - 1] = arguments[r];
    if (n) {
        n = n.slice(0);
        for (var r = 0, i = n.length; r < i; ++r)
            n[r].apply(this, e)
    }
    return this
}
    ;
hn.prototype.emitReserved = hn.prototype.emit;
hn.prototype.listeners = function (t) {
    return this._callbacks = this._callbacks || {},
        this._callbacks["$" + t] || []
}
    ;
hn.prototype.hasListeners = function (t) {
    return !!this.listeners(t).length
}
    ;
const ti = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function GA(t, ...e) {
    return e.reduce((n, r) => (t.hasOwnProperty(r) && (n[r] = t[r]),
        n), {})
}
const fZ = ti.setTimeout
    , hZ = ti.clearTimeout;
function $m(t, e) {
    e.useNativeTimers ? (t.setTimeoutFn = fZ.bind(ti),
        t.clearTimeoutFn = hZ.bind(ti)) : (t.setTimeoutFn = ti.setTimeout.bind(ti),
            t.clearTimeoutFn = ti.clearTimeout.bind(ti))
}
const pZ = 1.33;
function mZ(t) {
    return typeof t == "string" ? gZ(t) : Math.ceil((t.byteLength || t.size) * pZ)
}
function gZ(t) {
    let e = 0
        , n = 0;
    for (let r = 0, i = t.length; r < i; r++)
        e = t.charCodeAt(r),
            e < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (r++,
                n += 4);
    return n
}
function yZ(t) {
    let e = "";
    for (let n in t)
        t.hasOwnProperty(n) && (e.length && (e += "&"),
            e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n]));
    return e
}
function vZ(t) {
    let e = {}
        , n = t.split("&");
    for (let r = 0, i = n.length; r < i; r++) {
        let s = n[r].split("=");
        e[decodeURIComponent(s[0])] = decodeURIComponent(s[1])
    }
    return e
}
class bZ extends Error {
    constructor(e, n, r) {
        super(e),
            this.description = n,
            this.context = r,
            this.type = "TransportError"
    }
}
class ab extends hn {
    constructor(e) {
        super(),
            this.writable = !1,
            $m(this, e),
            this.opts = e,
            this.query = e.query,
            this.socket = e.socket
    }
    onError(e, n, r) {
        return super.emitReserved("error", new bZ(e, n, r)),
            this
    }
    open() {
        return this.readyState = "opening",
            this.doOpen(),
            this
    }
    close() {
        return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(),
            this.onClose()),
            this
    }
    send(e) {
        this.readyState === "open" && this.write(e)
    }
    onOpen() {
        this.readyState = "open",
            this.writable = !0,
            super.emitReserved("open")
    }
    onData(e) {
        const n = ob(e, this.socket.binaryType);
        this.onPacket(n)
    }
    onPacket(e) {
        super.emitReserved("packet", e)
    }
    onClose(e) {
        this.readyState = "closed",
            super.emitReserved("close", e)
    }
    pause(e) { }
    createUri(e, n = {}) {
        return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(n)
    }
    _hostname() {
        const e = this.opts.hostname;
        return e.indexOf(":") === -1 ? e : "[" + e + "]"
    }
    _port() {
        return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : ""
    }
    _query(e) {
        const n = yZ(e);
        return n.length ? "?" + n : ""
    }
}
const JA = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("")
    , xy = 64
    , wZ = {};
let mS = 0, ih = 0, gS;
function yS(t) {
    let e = "";
    do
        e = JA[t % xy] + e,
            t = Math.floor(t / xy);
    while (t > 0);
    return e
}
function ZA() {
    const t = yS(+new Date);
    return t !== gS ? (mS = 0,
        gS = t) : t + "." + yS(mS++)
}
for (; ih < xy; ih++)
    wZ[JA[ih]] = ih;
let YA = !1;
try {
    YA = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest
} catch { }
const xZ = YA;
function XA(t) {
    const e = t.xdomain;
    try {
        if (typeof XMLHttpRequest < "u" && (!e || xZ))
            return new XMLHttpRequest
    } catch { }
    if (!e)
        try {
            return new ti[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")
        } catch { }
}
function _Z() { }
const SZ = function () {
    return new XA({
        xdomain: !1
    }).responseType != null
}();
class kZ extends ab {
    constructor(e) {
        if (super(e),
            this.polling = !1,
            typeof location < "u") {
            const r = location.protocol === "https:";
            let i = location.port;
            i || (i = r ? "443" : "80"),
                this.xd = typeof location < "u" && e.hostname !== location.hostname || i !== e.port
        }
        const n = e && e.forceBase64;
        this.supportsBinary = SZ && !n,
            this.opts.withCredentials && (this.cookieJar = void 0)
    }
    get name() {
        return "polling"
    }
    doOpen() {
        this.poll()
    }
    pause(e) {
        this.readyState = "pausing";
        const n = () => {
            this.readyState = "paused",
                e()
        }
            ;
        if (this.polling || !this.writable) {
            let r = 0;
            this.polling && (r++,
                this.once("pollComplete", function () {
                    --r || n()
                })),
                this.writable || (r++,
                    this.once("drain", function () {
                        --r || n()
                    }))
        } else
            n()
    }
    poll() {
        this.polling = !0,
            this.doPoll(),
            this.emitReserved("poll")
    }
    onData(e) {
        const n = r => {
            if (this.readyState === "opening" && r.type === "open" && this.onOpen(),
                r.type === "close")
                return this.onClose({
                    description: "transport closed by the server"
                }),
                    !1;
            this.onPacket(r)
        }
            ;
        lZ(e, this.socket.binaryType).forEach(n),
            this.readyState !== "closed" && (this.polling = !1,
                this.emitReserved("pollComplete"),
                this.readyState === "open" && this.poll())
    }
    doClose() {
        const e = () => {
            this.write([{
                type: "close"
            }])
        }
            ;
        this.readyState === "open" ? e() : this.once("open", e)
    }
    write(e) {
        this.writable = !1,
            aZ(e, n => {
                this.doWrite(n, () => {
                    this.writable = !0,
                        this.emitReserved("drain")
                }
                )
            }
            )
    }
    uri() {
        const e = this.opts.secure ? "https" : "http"
            , n = this.query || {};
        return this.opts.timestampRequests !== !1 && (n[this.opts.timestampParam] = ZA()),
            !this.supportsBinary && !n.sid && (n.b64 = 1),
            this.createUri(e, n)
    }
    request(e = {}) {
        return Object.assign(e, {
            xd: this.xd,
            cookieJar: this.cookieJar
        }, this.opts),
            new Gi(this.uri(), e)
    }
    doWrite(e, n) {
        const r = this.request({
            method: "POST",
            data: e
        });
        r.on("success", n),
            r.on("error", (i, s) => {
                this.onError("xhr post error", i, s)
            }
            )
    }
    doPoll() {
        const e = this.request();
        e.on("data", this.onData.bind(this)),
            e.on("error", (n, r) => {
                this.onError("xhr poll error", n, r)
            }
            ),
            this.pollXhr = e
    }
}
class Gi extends hn {
    constructor(e, n) {
        super(),
            $m(this, n),
            this.opts = n,
            this.method = n.method || "GET",
            this.uri = e,
            this.data = n.data !== void 0 ? n.data : null,
            this.create()
    }
    create() {
        var e;
        const n = GA(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        n.xdomain = !!this.opts.xd;
        const r = this.xhr = new XA(n);
        try {
            r.open(this.method, this.uri, !0);
            try {
                if (this.opts.extraHeaders) {
                    r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
                    for (let i in this.opts.extraHeaders)
                        this.opts.extraHeaders.hasOwnProperty(i) && r.setRequestHeader(i, this.opts.extraHeaders[i])
                }
            } catch { }
            if (this.method === "POST")
                try {
                    r.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                } catch { }
            try {
                r.setRequestHeader("Accept", "*/*")
            } catch { }
            (e = this.opts.cookieJar) === null || e === void 0 || e.addCookies(r),
                "withCredentials" in r && (r.withCredentials = this.opts.withCredentials),
                this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout),
                r.onreadystatechange = () => {
                    var i;
                    r.readyState === 3 && ((i = this.opts.cookieJar) === null || i === void 0 || i.parseCookies(r)),
                        r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
                            this.onError(typeof r.status == "number" ? r.status : 0)
                        }
                            , 0))
                }
                ,
                r.send(this.data)
        } catch (i) {
            this.setTimeoutFn(() => {
                this.onError(i)
            }
                , 0);
            return
        }
        typeof document < "u" && (this.index = Gi.requestsCount++,
            Gi.requests[this.index] = this)
    }
    onError(e) {
        this.emitReserved("error", e, this.xhr),
            this.cleanup(!0)
    }
    cleanup(e) {
        if (!(typeof this.xhr > "u" || this.xhr === null)) {
            if (this.xhr.onreadystatechange = _Z,
                e)
                try {
                    this.xhr.abort()
                } catch { }
            typeof document < "u" && delete Gi.requests[this.index],
                this.xhr = null
        }
    }
    onLoad() {
        const e = this.xhr.responseText;
        e !== null && (this.emitReserved("data", e),
            this.emitReserved("success"),
            this.cleanup())
    }
    abort() {
        this.cleanup()
    }
}
Gi.requestsCount = 0;
Gi.requests = {};
if (typeof document < "u") {
    if (typeof attachEvent == "function")
        attachEvent("onunload", vS);
    else if (typeof addEventListener == "function") {
        const t = "onpagehide" in ti ? "pagehide" : "unload";
        addEventListener(t, vS, !1)
    }
}
function vS() {
    for (let t in Gi.requests)
        Gi.requests.hasOwnProperty(t) && Gi.requests[t].abort()
}
const lb = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? e => Promise.resolve().then(e) : (e, n) => n(e, 0))()
    , sh = ti.WebSocket || ti.MozWebSocket
    , bS = !0
    , CZ = "arraybuffer"
    , wS = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class EZ extends ab {
    constructor(e) {
        super(e),
            this.supportsBinary = !e.forceBase64
    }
    get name() {
        return "websocket"
    }
    doOpen() {
        if (!this.check())
            return;
        const e = this.uri()
            , n = this.opts.protocols
            , r = wS ? {} : GA(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
        try {
            this.ws = bS && !wS ? n ? new sh(e, n) : new sh(e) : new sh(e, n, r)
        } catch (i) {
            return this.emitReserved("error", i)
        }
        this.ws.binaryType = this.socket.binaryType,
            this.addEventListeners()
    }
    addEventListeners() {
        this.ws.onopen = () => {
            this.opts.autoUnref && this.ws._socket.unref(),
                this.onOpen()
        }
            ,
            this.ws.onclose = e => this.onClose({
                description: "websocket connection closed",
                context: e
            }),
            this.ws.onmessage = e => this.onData(e.data),
            this.ws.onerror = e => this.onError("websocket error", e)
    }
    write(e) {
        this.writable = !1;
        for (let n = 0; n < e.length; n++) {
            const r = e[n]
                , i = n === e.length - 1;
            sb(r, this.supportsBinary, s => {
                const o = {};
                try {
                    bS && this.ws.send(s)
                } catch { }
                i && lb(() => {
                    this.writable = !0,
                        this.emitReserved("drain")
                }
                    , this.setTimeoutFn)
            }
            )
        }
    }
    doClose() {
        typeof this.ws < "u" && (this.ws.close(),
            this.ws = null)
    }
    uri() {
        const e = this.opts.secure ? "wss" : "ws"
            , n = this.query || {};
        return this.opts.timestampRequests && (n[this.opts.timestampParam] = ZA()),
            this.supportsBinary || (n.b64 = 1),
            this.createUri(e, n)
    }
    check() {
        return !!sh
    }
}
class TZ extends ab {
    get name() {
        return "webtransport"
    }
    doOpen() {
        typeof WebTransport == "function" && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]),
            this.transport.closed.then(() => {
                this.onClose()
            }
            ).catch(e => {
                this.onError("webtransport error", e)
            }
            ),
            this.transport.ready.then(() => {
                this.transport.createBidirectionalStream().then(e => {
                    const n = cZ(Number.MAX_SAFE_INTEGER, this.socket.binaryType)
                        , r = e.readable.pipeThrough(n).getReader()
                        , i = uZ();
                    i.readable.pipeTo(e.writable),
                        this.writer = i.writable.getWriter();
                    const s = () => {
                        r.read().then(({ done: a, value: l }) => {
                            a || (this.onPacket(l),
                                s())
                        }
                        ).catch(a => { }
                        )
                    }
                        ;
                    s();
                    const o = {
                        type: "open"
                    };
                    this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`),
                        this.writer.write(o).then(() => this.onOpen())
                }
                )
            }
            ))
    }
    write(e) {
        this.writable = !1;
        for (let n = 0; n < e.length; n++) {
            const r = e[n]
                , i = n === e.length - 1;
            this.writer.write(r).then(() => {
                i && lb(() => {
                    this.writable = !0,
                        this.emitReserved("drain")
                }
                    , this.setTimeoutFn)
            }
            )
        }
    }
    doClose() {
        var e;
        (e = this.transport) === null || e === void 0 || e.close()
    }
}
const AZ = {
    websocket: EZ,
    webtransport: TZ,
    polling: kZ
}
    , OZ = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    , MZ = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
function _y(t) {
    if (t.length > 2e3)
        throw "URI too long";
    const e = t
        , n = t.indexOf("[")
        , r = t.indexOf("]");
    n != -1 && r != -1 && (t = t.substring(0, n) + t.substring(n, r).replace(/:/g, ";") + t.substring(r, t.length));
    let i = OZ.exec(t || "")
        , s = {}
        , o = 14;
    for (; o--;)
        s[MZ[o]] = i[o] || "";
    return n != -1 && r != -1 && (s.source = e,
        s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"),
        s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"),
        s.ipv6uri = !0),
        s.pathNames = RZ(s, s.path),
        s.queryKey = PZ(s, s.query),
        s
}
function RZ(t, e) {
    const n = /\/{2,9}/g
        , r = e.replace(n, "/").split("/");
    return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1),
        e.slice(-1) == "/" && r.splice(r.length - 1, 1),
        r
}
function PZ(t, e) {
    const n = {};
    return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (r, i, s) {
        i && (n[i] = s)
    }),
        n
}
let QA = class El extends hn {
    constructor(e, n = {}) {
        super(),
            this.binaryType = CZ,
            this.writeBuffer = [],
            e && typeof e == "object" && (n = e,
                e = null),
            e ? (e = _y(e),
                n.hostname = e.host,
                n.secure = e.protocol === "https" || e.protocol === "wss",
                n.port = e.port,
                e.query && (n.query = e.query)) : n.host && (n.hostname = _y(n.host).host),
            $m(this, n),
            this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:",
            n.hostname && !n.port && (n.port = this.secure ? "443" : "80"),
            this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"),
            this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"),
            this.transports = n.transports || ["polling", "websocket", "webtransport"],
            this.writeBuffer = [],
            this.prevBufferLen = 0,
            this.opts = Object.assign({
                path: "/engine.io",
                agent: !1,
                withCredentials: !1,
                upgrade: !0,
                timestampParam: "t",
                rememberUpgrade: !1,
                addTrailingSlash: !0,
                rejectUnauthorized: !0,
                perMessageDeflate: {
                    threshold: 1024
                },
                transportOptions: {},
                closeOnBeforeunload: !1
            }, n),
            this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""),
            typeof this.opts.query == "string" && (this.opts.query = vZ(this.opts.query)),
            this.id = null,
            this.upgrades = null,
            this.pingInterval = null,
            this.pingTimeout = null,
            this.pingTimeoutTimer = null,
            typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
                this.transport && (this.transport.removeAllListeners(),
                    this.transport.close())
            }
                ,
                addEventListener("beforeunload", this.beforeunloadEventListener, !1)),
                this.hostname !== "localhost" && (this.offlineEventListener = () => {
                    this.onClose("transport close", {
                        description: "network connection lost"
                    })
                }
                    ,
                    addEventListener("offline", this.offlineEventListener, !1))),
            this.open()
    }
    createTransport(e) {
        const n = Object.assign({}, this.opts.query);
        n.EIO = qA,
            n.transport = e,
            this.id && (n.sid = this.id);
        const r = Object.assign({}, this.opts, {
            query: n,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
        }, this.opts.transportOptions[e]);
        return new AZ[e](r)
    }
    open() {
        let e;
        if (this.opts.rememberUpgrade && El.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
            e = "websocket";
        else if (this.transports.length === 0) {
            this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available")
            }
                , 0);
            return
        } else
            e = this.transports[0];
        this.readyState = "opening";
        try {
            e = this.createTransport(e)
        } catch {
            this.transports.shift(),
                this.open();
            return
        }
        e.open(),
            this.setTransport(e)
    }
    setTransport(e) {
        this.transport && this.transport.removeAllListeners(),
            this.transport = e,
            e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", n => this.onClose("transport close", n))
    }
    probe(e) {
        let n = this.createTransport(e)
            , r = !1;
        El.priorWebsocketSuccess = !1;
        const i = () => {
            r || (n.send([{
                type: "ping",
                data: "probe"
            }]),
                n.once("packet", h => {
                    if (!r)
                        if (h.type === "pong" && h.data === "probe") {
                            if (this.upgrading = !0,
                                this.emitReserved("upgrading", n),
                                !n)
                                return;
                            El.priorWebsocketSuccess = n.name === "websocket",
                                this.transport.pause(() => {
                                    r || this.readyState !== "closed" && (d(),
                                        this.setTransport(n),
                                        n.send([{
                                            type: "upgrade"
                                        }]),
                                        this.emitReserved("upgrade", n),
                                        n = null,
                                        this.upgrading = !1,
                                        this.flush())
                                }
                                )
                        } else {
                            const p = new Error("probe error");
                            p.transport = n.name,
                                this.emitReserved("upgradeError", p)
                        }
                }
                ))
        }
            ;
        function s() {
            r || (r = !0,
                d(),
                n.close(),
                n = null)
        }
        const o = h => {
            const p = new Error("probe error: " + h);
            p.transport = n.name,
                s(),
                this.emitReserved("upgradeError", p)
        }
            ;
        function a() {
            o("transport closed")
        }
        function l() {
            o("socket closed")
        }
        function c(h) {
            n && h.name !== n.name && s()
        }
        const d = () => {
            n.removeListener("open", i),
                n.removeListener("error", o),
                n.removeListener("close", a),
                this.off("close", l),
                this.off("upgrading", c)
        }
            ;
        n.once("open", i),
            n.once("error", o),
            n.once("close", a),
            this.once("close", l),
            this.once("upgrading", c),
            this.upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => {
                r || n.open()
            }
                , 200) : n.open()
    }
    onOpen() {
        if (this.readyState = "open",
            El.priorWebsocketSuccess = this.transport.name === "websocket",
            this.emitReserved("open"),
            this.flush(),
            this.readyState === "open" && this.opts.upgrade) {
            let e = 0;
            const n = this.upgrades.length;
            for (; e < n; e++)
                this.probe(this.upgrades[e])
        }
    }
    onPacket(e) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
            switch (this.emitReserved("packet", e),
            this.emitReserved("heartbeat"),
            this.resetPingTimeout(),
            e.type) {
                case "open":
                    this.onHandshake(JSON.parse(e.data));
                    break;
                case "ping":
                    this.sendPacket("pong"),
                        this.emitReserved("ping"),
                        this.emitReserved("pong");
                    break;
                case "error":
                    const n = new Error("server error");
                    n.code = e.data,
                        this.onError(n);
                    break;
                case "message":
                    this.emitReserved("data", e.data),
                        this.emitReserved("message", e.data);
                    break
            }
    }
    onHandshake(e) {
        this.emitReserved("handshake", e),
            this.id = e.sid,
            this.transport.query.sid = e.sid,
            this.upgrades = this.filterUpgrades(e.upgrades),
            this.pingInterval = e.pingInterval,
            this.pingTimeout = e.pingTimeout,
            this.maxPayload = e.maxPayload,
            this.onOpen(),
            this.readyState !== "closed" && this.resetPingTimeout()
    }
    resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer),
            this.pingTimeoutTimer = this.setTimeoutFn(() => {
                this.onClose("ping timeout")
            }
                , this.pingInterval + this.pingTimeout),
            this.opts.autoUnref && this.pingTimeoutTimer.unref()
    }
    onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen),
            this.prevBufferLen = 0,
            this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush()
    }
    flush() {
        if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            const e = this.getWritablePackets();
            this.transport.send(e),
                this.prevBufferLen = e.length,
                this.emitReserved("flush")
        }
    }
    getWritablePackets() {
        if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
            return this.writeBuffer;
        let n = 1;
        for (let r = 0; r < this.writeBuffer.length; r++) {
            const i = this.writeBuffer[r].data;
            if (i && (n += mZ(i)),
                r > 0 && n > this.maxPayload)
                return this.writeBuffer.slice(0, r);
            n += 2
        }
        return this.writeBuffer
    }
    write(e, n, r) {
        return this.sendPacket("message", e, n, r),
            this
    }
    send(e, n, r) {
        return this.sendPacket("message", e, n, r),
            this
    }
    sendPacket(e, n, r, i) {
        if (typeof n == "function" && (i = n,
            n = void 0),
            typeof r == "function" && (i = r,
                r = null),
            this.readyState === "closing" || this.readyState === "closed")
            return;
        r = r || {},
            r.compress = r.compress !== !1;
        const s = {
            type: e,
            data: n,
            options: r
        };
        this.emitReserved("packetCreate", s),
            this.writeBuffer.push(s),
            i && this.once("flush", i),
            this.flush()
    }
    close() {
        const e = () => {
            this.onClose("forced close"),
                this.transport.close()
        }
            , n = () => {
                this.off("upgrade", n),
                    this.off("upgradeError", n),
                    e()
            }
            , r = () => {
                this.once("upgrade", n),
                    this.once("upgradeError", n)
            }
            ;
        return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing",
            this.writeBuffer.length ? this.once("drain", () => {
                this.upgrading ? r() : e()
            }
            ) : this.upgrading ? r() : e()),
            this
    }
    onError(e) {
        El.priorWebsocketSuccess = !1,
            this.emitReserved("error", e),
            this.onClose("transport error", e)
    }
    onClose(e, n) {
        (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer),
            this.transport.removeAllListeners("close"),
            this.transport.close(),
            this.transport.removeAllListeners(),
            typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1),
                removeEventListener("offline", this.offlineEventListener, !1)),
            this.readyState = "closed",
            this.id = null,
            this.emitReserved("close", e, n),
            this.writeBuffer = [],
            this.prevBufferLen = 0)
    }
    filterUpgrades(e) {
        const n = [];
        let r = 0;
        const i = e.length;
        for (; r < i; r++)
            ~this.transports.indexOf(e[r]) && n.push(e[r]);
        return n
    }
}
    ;
QA.protocol = qA;
function NZ(t, e = "", n) {
    let r = t;
    n = n || typeof location < "u" && location,
        t == null && (t = n.protocol + "//" + n.host),
        typeof t == "string" && (t.charAt(0) === "/" && (t.charAt(1) === "/" ? t = n.protocol + t : t = n.host + t),
            /^(https?|wss?):\/\//.test(t) || (typeof n < "u" ? t = n.protocol + "//" + t : t = "https://" + t),
            r = _y(t)),
        r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")),
        r.path = r.path || "/";
    const s = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
    return r.id = r.protocol + "://" + s + ":" + r.port + e,
        r.href = r.protocol + "://" + s + (n && n.port === r.port ? "" : ":" + r.port),
        r
}
const IZ = typeof ArrayBuffer == "function"
    , LZ = t => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer
    , eO = Object.prototype.toString
    , DZ = typeof Blob == "function" || typeof Blob < "u" && eO.call(Blob) === "[object BlobConstructor]"
    , jZ = typeof File == "function" || typeof File < "u" && eO.call(File) === "[object FileConstructor]";
function ub(t) {
    return IZ && (t instanceof ArrayBuffer || LZ(t)) || DZ && t instanceof Blob || jZ && t instanceof File
}
function Sh(t, e) {
    if (!t || typeof t != "object")
        return !1;
    if (Array.isArray(t)) {
        for (let n = 0, r = t.length; n < r; n++)
            if (Sh(t[n]))
                return !0;
        return !1
    }
    if (ub(t))
        return !0;
    if (t.toJSON && typeof t.toJSON == "function" && arguments.length === 1)
        return Sh(t.toJSON(), !0);
    for (const n in t)
        if (Object.prototype.hasOwnProperty.call(t, n) && Sh(t[n]))
            return !0;
    return !1
}
function BZ(t) {
    const e = []
        , n = t.data
        , r = t;
    return r.data = Sy(n, e),
        r.attachments = e.length,
    {
        packet: r,
        buffers: e
    }
}
function Sy(t, e) {
    if (!t)
        return t;
    if (ub(t)) {
        const n = {
            _placeholder: !0,
            num: e.length
        };
        return e.push(t),
            n
    } else if (Array.isArray(t)) {
        const n = new Array(t.length);
        for (let r = 0; r < t.length; r++)
            n[r] = Sy(t[r], e);
        return n
    } else if (typeof t == "object" && !(t instanceof Date)) {
        const n = {};
        for (const r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = Sy(t[r], e));
        return n
    }
    return t
}
function $Z(t, e) {
    return t.data = ky(t.data, e),
        delete t.attachments,
        t
}
function ky(t, e) {
    if (!t)
        return t;
    if (t && t._placeholder === !0) {
        if (typeof t.num == "number" && t.num >= 0 && t.num < e.length)
            return e[t.num];
        throw new Error("illegal attachments")
    } else if (Array.isArray(t))
        for (let n = 0; n < t.length; n++)
            t[n] = ky(t[n], e);
    else if (typeof t == "object")
        for (const n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (t[n] = ky(t[n], e));
    return t
}
const zZ = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"]
    , FZ = 5;
var St;
(function (t) {
    t[t.CONNECT = 0] = "CONNECT",
        t[t.DISCONNECT = 1] = "DISCONNECT",
        t[t.EVENT = 2] = "EVENT",
        t[t.ACK = 3] = "ACK",
        t[t.CONNECT_ERROR = 4] = "CONNECT_ERROR",
        t[t.BINARY_EVENT = 5] = "BINARY_EVENT",
        t[t.BINARY_ACK = 6] = "BINARY_ACK"
}
)(St || (St = {}));
class HZ {
    constructor(e) {
        this.replacer = e
    }
    encode(e) {
        return (e.type === St.EVENT || e.type === St.ACK) && Sh(e) ? this.encodeAsBinary({
            type: e.type === St.EVENT ? St.BINARY_EVENT : St.BINARY_ACK,
            nsp: e.nsp,
            data: e.data,
            id: e.id
        }) : [this.encodeAsString(e)]
    }
    encodeAsString(e) {
        let n = "" + e.type;
        return (e.type === St.BINARY_EVENT || e.type === St.BINARY_ACK) && (n += e.attachments + "-"),
            e.nsp && e.nsp !== "/" && (n += e.nsp + ","),
            e.id != null && (n += e.id),
            e.data != null && (n += JSON.stringify(e.data, this.replacer)),
            n
    }
    encodeAsBinary(e) {
        const n = BZ(e)
            , r = this.encodeAsString(n.packet)
            , i = n.buffers;
        return i.unshift(r),
            i
    }
}
function xS(t) {
    return Object.prototype.toString.call(t) === "[object Object]"
}
class cb extends hn {
    constructor(e) {
        super(),
            this.reviver = e
    }
    add(e) {
        let n;
        if (typeof e == "string") {
            if (this.reconstructor)
                throw new Error("got plaintext data when reconstructing a packet");
            n = this.decodeString(e);
            const r = n.type === St.BINARY_EVENT;
            r || n.type === St.BINARY_ACK ? (n.type = r ? St.EVENT : St.ACK,
                this.reconstructor = new VZ(n),
                n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n)
        } else if (ub(e) || e.base64)
            if (this.reconstructor)
                n = this.reconstructor.takeBinaryData(e),
                    n && (this.reconstructor = null,
                        super.emitReserved("decoded", n));
            else
                throw new Error("got binary data when not reconstructing a packet");
        else
            throw new Error("Unknown type: " + e)
    }
    decodeString(e) {
        let n = 0;
        const r = {
            type: Number(e.charAt(0))
        };
        if (St[r.type] === void 0)
            throw new Error("unknown packet type " + r.type);
        if (r.type === St.BINARY_EVENT || r.type === St.BINARY_ACK) {
            const s = n + 1;
            for (; e.charAt(++n) !== "-" && n != e.length;)
                ;
            const o = e.substring(s, n);
            if (o != Number(o) || e.charAt(n) !== "-")
                throw new Error("Illegal attachments");
            r.attachments = Number(o)
        }
        if (e.charAt(n + 1) === "/") {
            const s = n + 1;
            for (; ++n && !(e.charAt(n) === "," || n === e.length);)
                ;
            r.nsp = e.substring(s, n)
        } else
            r.nsp = "/";
        const i = e.charAt(n + 1);
        if (i !== "" && Number(i) == i) {
            const s = n + 1;
            for (; ++n;) {
                const o = e.charAt(n);
                if (o == null || Number(o) != o) {
                    --n;
                    break
                }
                if (n === e.length)
                    break
            }
            r.id = Number(e.substring(s, n + 1))
        }
        if (e.charAt(++n)) {
            const s = this.tryParse(e.substr(n));
            if (cb.isPayloadValid(r.type, s))
                r.data = s;
            else
                throw new Error("invalid payload")
        }
        return r
    }
    tryParse(e) {
        try {
            return JSON.parse(e, this.reviver)
        } catch {
            return !1
        }
    }
    static isPayloadValid(e, n) {
        switch (e) {
            case St.CONNECT:
                return xS(n);
            case St.DISCONNECT:
                return n === void 0;
            case St.CONNECT_ERROR:
                return typeof n == "string" || xS(n);
            case St.EVENT:
            case St.BINARY_EVENT:
                return Array.isArray(n) && (typeof n[0] == "number" || typeof n[0] == "string" && zZ.indexOf(n[0]) === -1);
            case St.ACK:
            case St.BINARY_ACK:
                return Array.isArray(n)
        }
    }
    destroy() {
        this.reconstructor && (this.reconstructor.finishedReconstruction(),
            this.reconstructor = null)
    }
}
class VZ {
    constructor(e) {
        this.packet = e,
            this.buffers = [],
            this.reconPack = e
    }
    takeBinaryData(e) {
        if (this.buffers.push(e),
            this.buffers.length === this.reconPack.attachments) {
            const n = $Z(this.reconPack, this.buffers);
            return this.finishedReconstruction(),
                n
        }
        return null
    }
    finishedReconstruction() {
        this.reconPack = null,
            this.buffers = []
    }
}
const WZ = Object.freeze(Object.defineProperty({
    __proto__: null,
    Decoder: cb,
    Encoder: HZ,
    get PacketType() {
        return St
    },
    protocol: FZ
}, Symbol.toStringTag, {
    value: "Module"
}));
function gi(t, e, n) {
    return t.on(e, n),
        function () {
            t.off(e, n)
        }
}
const UZ = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
});
class tO extends hn {
    constructor(e, n, r) {
        super(),
            this.connected = !1,
            this.recovered = !1,
            this.receiveBuffer = [],
            this.sendBuffer = [],
            this._queue = [],
            this._queueSeq = 0,
            this.ids = 0,
            this.acks = {},
            this.flags = {},
            this.io = e,
            this.nsp = n,
            r && r.auth && (this.auth = r.auth),
            this._opts = Object.assign({}, r),
            this.io._autoConnect && this.open()
    }
    get disconnected() {
        return !this.connected
    }
    subEvents() {
        if (this.subs)
            return;
        const e = this.io;
        this.subs = [gi(e, "open", this.onopen.bind(this)), gi(e, "packet", this.onpacket.bind(this)), gi(e, "error", this.onerror.bind(this)), gi(e, "close", this.onclose.bind(this))]
    }
    get active() {
        return !!this.subs
    }
    connect() {
        return this.connected ? this : (this.subEvents(),
            this.io._reconnecting || this.io.open(),
            this.io._readyState === "open" && this.onopen(),
            this)
    }
    open() {
        return this.connect()
    }
    send(...e) {
        return e.unshift("message"),
            this.emit.apply(this, e),
            this
    }
    emit(e, ...n) {
        if (UZ.hasOwnProperty(e))
            throw new Error('"' + e.toString() + '" is a reserved event name');
        if (n.unshift(e),
            this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
            return this._addToQueue(n),
                this;
        const r = {
            type: St.EVENT,
            data: n
        };
        if (r.options = {},
            r.options.compress = this.flags.compress !== !1,
            typeof n[n.length - 1] == "function") {
            const o = this.ids++
                , a = n.pop();
            this._registerAckCallback(o, a),
                r.id = o
        }
        const i = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        return this.flags.volatile && (!i || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r),
            this.packet(r)) : this.sendBuffer.push(r)),
            this.flags = {},
            this
    }
    _registerAckCallback(e, n) {
        var r;
        const i = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
        if (i === void 0) {
            this.acks[e] = n;
            return
        }
        const s = this.io.setTimeoutFn(() => {
            delete this.acks[e];
            for (let a = 0; a < this.sendBuffer.length; a++)
                this.sendBuffer[a].id === e && this.sendBuffer.splice(a, 1);
            n.call(this, new Error("operation has timed out"))
        }
            , i)
            , o = (...a) => {
                this.io.clearTimeoutFn(s),
                    n.apply(this, a)
            }
            ;
        o.withError = !0,
            this.acks[e] = o
    }
    emitWithAck(e, ...n) {
        return new Promise((r, i) => {
            const s = (o, a) => o ? i(o) : r(a);
            s.withError = !0,
                n.push(s),
                this.emit(e, ...n)
        }
        )
    }
    _addToQueue(e) {
        let n;
        typeof e[e.length - 1] == "function" && (n = e.pop());
        const r = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: !1,
            args: e,
            flags: Object.assign({
                fromQueue: !0
            }, this.flags)
        };
        e.push((i, ...s) => r !== this._queue[0] ? void 0 : (i !== null ? r.tryCount > this._opts.retries && (this._queue.shift(),
            n && n(i)) : (this._queue.shift(),
                n && n(null, ...s)),
            r.pending = !1,
            this._drainQueue())),
            this._queue.push(r),
            this._drainQueue()
    }
    _drainQueue(e = !1) {
        if (!this.connected || this._queue.length === 0)
            return;
        const n = this._queue[0];
        n.pending && !e || (n.pending = !0,
            n.tryCount++,
            this.flags = n.flags,
            this.emit.apply(this, n.args))
    }
    packet(e) {
        e.nsp = this.nsp,
            this.io._packet(e)
    }
    onopen() {
        typeof this.auth == "function" ? this.auth(e => {
            this._sendConnectPacket(e)
        }
        ) : this._sendConnectPacket(this.auth)
    }
    _sendConnectPacket(e) {
        this.packet({
            type: St.CONNECT,
            data: this._pid ? Object.assign({
                pid: this._pid,
                offset: this._lastOffset
            }, e) : e
        })
    }
    onerror(e) {
        this.connected || this.emitReserved("connect_error", e)
    }
    onclose(e, n) {
        this.connected = !1,
            delete this.id,
            this.emitReserved("disconnect", e, n),
            this._clearAcks()
    }
    _clearAcks() {
        Object.keys(this.acks).forEach(e => {
            if (!this.sendBuffer.some(r => String(r.id) === e)) {
                const r = this.acks[e];
                delete this.acks[e],
                    r.withError && r.call(this, new Error("socket has been disconnected"))
            }
        }
        )
    }
    onpacket(e) {
        if (e.nsp === this.nsp)
            switch (e.type) {
                case St.CONNECT:
                    e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                    break;
                case St.EVENT:
                case St.BINARY_EVENT:
                    this.onevent(e);
                    break;
                case St.ACK:
                case St.BINARY_ACK:
                    this.onack(e);
                    break;
                case St.DISCONNECT:
                    this.ondisconnect();
                    break;
                case St.CONNECT_ERROR:
                    this.destroy();
                    const r = new Error(e.data.message);
                    r.data = e.data.data,
                        this.emitReserved("connect_error", r);
                    break
            }
    }
    onevent(e) {
        const n = e.data || [];
        e.id != null && n.push(this.ack(e.id)),
            this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n))
    }
    emitEvent(e) {
        if (this._anyListeners && this._anyListeners.length) {
            const n = this._anyListeners.slice();
            for (const r of n)
                r.apply(this, e)
        }
        super.emit.apply(this, e),
            this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1])
    }
    ack(e) {
        const n = this;
        let r = !1;
        return function (...i) {
            r || (r = !0,
                n.packet({
                    type: St.ACK,
                    id: e,
                    data: i
                }))
        }
    }
    onack(e) {
        const n = this.acks[e.id];
        typeof n == "function" && (delete this.acks[e.id],
            n.withError && e.data.unshift(null),
            n.apply(this, e.data))
    }
    onconnect(e, n) {
        this.id = e,
            this.recovered = n && this._pid === n,
            this._pid = n,
            this.connected = !0,
            this.emitBuffered(),
            this.emitReserved("connect"),
            this._drainQueue(!0)
    }
    emitBuffered() {
        this.receiveBuffer.forEach(e => this.emitEvent(e)),
            this.receiveBuffer = [],
            this.sendBuffer.forEach(e => {
                this.notifyOutgoingListeners(e),
                    this.packet(e)
            }
            ),
            this.sendBuffer = []
    }
    ondisconnect() {
        this.destroy(),
            this.onclose("io server disconnect")
    }
    destroy() {
        this.subs && (this.subs.forEach(e => e()),
            this.subs = void 0),
            this.io._destroy(this)
    }
    disconnect() {
        return this.connected && this.packet({
            type: St.DISCONNECT
        }),
            this.destroy(),
            this.connected && this.onclose("io client disconnect"),
            this
    }
    close() {
        return this.disconnect()
    }
    compress(e) {
        return this.flags.compress = e,
            this
    }
    get volatile() {
        return this.flags.volatile = !0,
            this
    }
    timeout(e) {
        return this.flags.timeout = e,
            this
    }
    onAny(e) {
        return this._anyListeners = this._anyListeners || [],
            this._anyListeners.push(e),
            this
    }
    prependAny(e) {
        return this._anyListeners = this._anyListeners || [],
            this._anyListeners.unshift(e),
            this
    }
    offAny(e) {
        if (!this._anyListeners)
            return this;
        if (e) {
            const n = this._anyListeners;
            for (let r = 0; r < n.length; r++)
                if (e === n[r])
                    return n.splice(r, 1),
                        this
        } else
            this._anyListeners = [];
        return this
    }
    listenersAny() {
        return this._anyListeners || []
    }
    onAnyOutgoing(e) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [],
            this._anyOutgoingListeners.push(e),
            this
    }
    prependAnyOutgoing(e) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [],
            this._anyOutgoingListeners.unshift(e),
            this
    }
    offAnyOutgoing(e) {
        if (!this._anyOutgoingListeners)
            return this;
        if (e) {
            const n = this._anyOutgoingListeners;
            for (let r = 0; r < n.length; r++)
                if (e === n[r])
                    return n.splice(r, 1),
                        this
        } else
            this._anyOutgoingListeners = [];
        return this
    }
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || []
    }
    notifyOutgoingListeners(e) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const n = this._anyOutgoingListeners.slice();
            for (const r of n)
                r.apply(this, e.data)
        }
    }
}
function bu(t) {
    t = t || {},
        this.ms = t.min || 100,
        this.max = t.max || 1e4,
        this.factor = t.factor || 2,
        this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0,
        this.attempts = 0
}
bu.prototype.duration = function () {
    var t = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var e = Math.random()
            , n = Math.floor(e * this.jitter * t);
        t = Math.floor(e * 10) & 1 ? t + n : t - n
    }
    return Math.min(t, this.max) | 0
}
    ;
bu.prototype.reset = function () {
    this.attempts = 0
}
    ;
bu.prototype.setMin = function (t) {
    this.ms = t
}
    ;
bu.prototype.setMax = function (t) {
    this.max = t
}
    ;
bu.prototype.setJitter = function (t) {
    this.jitter = t
}
    ;
class Cy extends hn {
    constructor(e, n) {
        var r;
        super(),
            this.nsps = {},
            this.subs = [],
            e && typeof e == "object" && (n = e,
                e = void 0),
            n = n || {},
            n.path = n.path || "/socket.io",
            this.opts = n,
            $m(this, n),
            this.reconnection(n.reconnection !== !1),
            this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
            this.reconnectionDelay(n.reconnectionDelay || 1e3),
            this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
            this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : .5),
            this.backoff = new bu({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor()
            }),
            this.timeout(n.timeout == null ? 2e4 : n.timeout),
            this._readyState = "closed",
            this.uri = e;
        const i = n.parser || WZ;
        this.encoder = new i.Encoder,
            this.decoder = new i.Decoder,
            this._autoConnect = n.autoConnect !== !1,
            this._autoConnect && this.open()
    }
    reconnection(e) {
        return arguments.length ? (this._reconnection = !!e,
            this) : this._reconnection
    }
    reconnectionAttempts(e) {
        return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e,
            this)
    }
    reconnectionDelay(e) {
        var n;
        return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e,
            (n = this.backoff) === null || n === void 0 || n.setMin(e),
            this)
    }
    randomizationFactor(e) {
        var n;
        return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e,
            (n = this.backoff) === null || n === void 0 || n.setJitter(e),
            this)
    }
    reconnectionDelayMax(e) {
        var n;
        return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e,
            (n = this.backoff) === null || n === void 0 || n.setMax(e),
            this)
    }
    timeout(e) {
        return arguments.length ? (this._timeout = e,
            this) : this._timeout
    }
    maybeReconnectOnOpen() {
        !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
    }
    open(e) {
        if (~this._readyState.indexOf("open"))
            return this;
        this.engine = new QA(this.uri, this.opts);
        const n = this.engine
            , r = this;
        this._readyState = "opening",
            this.skipReconnect = !1;
        const i = gi(n, "open", function () {
            r.onopen(),
                e && e()
        })
            , s = a => {
                this.cleanup(),
                    this._readyState = "closed",
                    this.emitReserved("error", a),
                    e ? e(a) : this.maybeReconnectOnOpen()
            }
            , o = gi(n, "error", s);
        if (this._timeout !== !1) {
            const a = this._timeout
                , l = this.setTimeoutFn(() => {
                    i(),
                        s(new Error("timeout")),
                        n.close()
                }
                    , a);
            this.opts.autoUnref && l.unref(),
                this.subs.push(() => {
                    this.clearTimeoutFn(l)
                }
                )
        }
        return this.subs.push(i),
            this.subs.push(o),
            this
    }
    connect(e) {
        return this.open(e)
    }
    onopen() {
        this.cleanup(),
            this._readyState = "open",
            this.emitReserved("open");
        const e = this.engine;
        this.subs.push(gi(e, "ping", this.onping.bind(this)), gi(e, "data", this.ondata.bind(this)), gi(e, "error", this.onerror.bind(this)), gi(e, "close", this.onclose.bind(this)), gi(this.decoder, "decoded", this.ondecoded.bind(this)))
    }
    onping() {
        this.emitReserved("ping")
    }
    ondata(e) {
        try {
            this.decoder.add(e)
        } catch (n) {
            this.onclose("parse error", n)
        }
    }
    ondecoded(e) {
        lb(() => {
            this.emitReserved("packet", e)
        }
            , this.setTimeoutFn)
    }
    onerror(e) {
        this.emitReserved("error", e)
    }
    socket(e, n) {
        let r = this.nsps[e];
        return r ? this._autoConnect && !r.active && r.connect() : (r = new tO(this, e, n),
            this.nsps[e] = r),
            r
    }
    _destroy(e) {
        const n = Object.keys(this.nsps);
        for (const r of n)
            if (this.nsps[r].active)
                return;
        this._close()
    }
    _packet(e) {
        const n = this.encoder.encode(e);
        for (let r = 0; r < n.length; r++)
            this.engine.write(n[r], e.options)
    }
    cleanup() {
        this.subs.forEach(e => e()),
            this.subs.length = 0,
            this.decoder.destroy()
    }
    _close() {
        this.skipReconnect = !0,
            this._reconnecting = !1,
            this.onclose("forced close"),
            this.engine && this.engine.close()
    }
    disconnect() {
        return this._close()
    }
    onclose(e, n) {
        this.cleanup(),
            this.backoff.reset(),
            this._readyState = "closed",
            this.emitReserved("close", e, n),
            this._reconnection && !this.skipReconnect && this.reconnect()
    }
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const e = this;
        if (this.backoff.attempts >= this._reconnectionAttempts)
            this.backoff.reset(),
                this.emitReserved("reconnect_failed"),
                this._reconnecting = !1;
        else {
            const n = this.backoff.duration();
            this._reconnecting = !0;
            const r = this.setTimeoutFn(() => {
                e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts),
                    !e.skipReconnect && e.open(i => {
                        i ? (e._reconnecting = !1,
                            e.reconnect(),
                            this.emitReserved("reconnect_error", i)) : e.onreconnect()
                    }
                    ))
            }
                , n);
            this.opts.autoUnref && r.unref(),
                this.subs.push(() => {
                    this.clearTimeoutFn(r)
                }
                )
        }
    }
    onreconnect() {
        const e = this.backoff.attempts;
        this._reconnecting = !1,
            this.backoff.reset(),
            this.emitReserved("reconnect", e)
    }
}
const Wu = {};
function kh(t, e) {
    typeof t == "object" && (e = t,
        t = void 0),
        e = e || {};
    const n = NZ(t, e.path || "/socket.io")
        , r = n.source
        , i = n.id
        , s = n.path
        , o = Wu[i] && s in Wu[i].nsps
        , a = e.forceNew || e["force new connection"] || e.multiplex === !1 || o;
    let l;
    return a ? l = new Cy(r, e) : (Wu[i] || (Wu[i] = new Cy(r, e)),
        l = Wu[i]),
        n.query && !e.query && (e.query = n.queryKey),
        l.socket(n.path, e)
}
Object.assign(kh, {
    Manager: Cy,
    Socket: tO,
    io: kh,
    connect: kh
});
var Ct;
(function (t) {
    t.assertEqual = i => i;
    function e(i) { }
    t.assertIs = e;
    function n(i) {
        throw new Error
    }
    t.assertNever = n,
        t.arrayToEnum = i => {
            const s = {};
            for (const o of i)
                s[o] = o;
            return s
        }
        ,
        t.getValidEnumValues = i => {
            const s = t.objectKeys(i).filter(a => typeof i[i[a]] != "number")
                , o = {};
            for (const a of s)
                o[a] = i[a];
            return t.objectValues(o)
        }
        ,
        t.objectValues = i => t.objectKeys(i).map(function (s) {
            return i[s]
        }),
        t.objectKeys = typeof Object.keys == "function" ? i => Object.keys(i) : i => {
            const s = [];
            for (const o in i)
                Object.prototype.hasOwnProperty.call(i, o) && s.push(o);
            return s
        }
        ,
        t.find = (i, s) => {
            for (const o of i)
                if (s(o))
                    return o
        }
        ,
        t.isInteger = typeof Number.isInteger == "function" ? i => Number.isInteger(i) : i => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
    function r(i, s = " | ") {
        return i.map(o => typeof o == "string" ? `'${o}'` : o).join(s)
    }
    t.joinValues = r,
        t.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s
}
)(Ct || (Ct = {}));
var Ey;
(function (t) {
    t.mergeShapes = (e, n) => ({
        ...e,
        ...n
    })
}
)(Ey || (Ey = {}));
const ke = Ct.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
    , go = t => {
        switch (typeof t) {
            case "undefined":
                return ke.undefined;
            case "string":
                return ke.string;
            case "number":
                return isNaN(t) ? ke.nan : ke.number;
            case "boolean":
                return ke.boolean;
            case "function":
                return ke.function;
            case "bigint":
                return ke.bigint;
            case "symbol":
                return ke.symbol;
            case "object":
                return Array.isArray(t) ? ke.array : t === null ? ke.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? ke.promise : typeof Map < "u" && t instanceof Map ? ke.map : typeof Set < "u" && t instanceof Set ? ke.set : typeof Date < "u" && t instanceof Date ? ke.date : ke.object;
            default:
                return ke.unknown
        }
    }
    , me = Ct.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
    , KZ = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class $r extends Error {
    constructor(e) {
        super(),
            this.issues = [],
            this.addIssue = r => {
                this.issues = [...this.issues, r]
            }
            ,
            this.addIssues = (r = []) => {
                this.issues = [...this.issues, ...r]
            }
            ;
        const n = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n,
            this.name = "ZodError",
            this.issues = e
    }
    get errors() {
        return this.issues
    }
    format(e) {
        const n = e || function (s) {
            return s.message
        }
            , r = {
                _errors: []
            }
            , i = s => {
                for (const o of s.issues)
                    if (o.code === "invalid_union")
                        o.unionErrors.map(i);
                    else if (o.code === "invalid_return_type")
                        i(o.returnTypeError);
                    else if (o.code === "invalid_arguments")
                        i(o.argumentsError);
                    else if (o.path.length === 0)
                        r._errors.push(n(o));
                    else {
                        let a = r
                            , l = 0;
                        for (; l < o.path.length;) {
                            const c = o.path[l];
                            l === o.path.length - 1 ? (a[c] = a[c] || {
                                _errors: []
                            },
                                a[c]._errors.push(n(o))) : a[c] = a[c] || {
                                    _errors: []
                                },
                                a = a[c],
                                l++
                        }
                    }
            }
            ;
        return i(this),
            r
    }
    static assert(e) {
        if (!(e instanceof $r))
            throw new Error(`Not a ZodError: ${e}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, Ct.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(e = n => n.message) {
        const n = {}
            , r = [];
        for (const i of this.issues)
            i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [],
                n[i.path[0]].push(e(i))) : r.push(e(i));
        return {
            formErrors: r,
            fieldErrors: n
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
$r.create = t => new $r(t);
const au = (t, e) => {
    let n;
    switch (t.code) {
        case me.invalid_type:
            t.received === ke.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
            break;
        case me.invalid_literal:
            n = `Invalid literal value, expected ${JSON.stringify(t.expected, Ct.jsonStringifyReplacer)}`;
            break;
        case me.unrecognized_keys:
            n = `Unrecognized key(s) in object: ${Ct.joinValues(t.keys, ", ")}`;
            break;
        case me.invalid_union:
            n = "Invalid input";
            break;
        case me.invalid_union_discriminator:
            n = `Invalid discriminator value. Expected ${Ct.joinValues(t.options)}`;
            break;
        case me.invalid_enum_value:
            n = `Invalid enum value. Expected ${Ct.joinValues(t.options)}, received '${t.received}'`;
            break;
        case me.invalid_arguments:
            n = "Invalid function arguments";
            break;
        case me.invalid_return_type:
            n = "Invalid function return type";
            break;
        case me.invalid_date:
            n = "Invalid date";
            break;
        case me.invalid_string:
            typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`,
                typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : Ct.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
            break;
        case me.too_small:
            t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
            break;
        case me.too_big:
            t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
            break;
        case me.custom:
            n = "Invalid input";
            break;
        case me.invalid_intersection_types:
            n = "Intersection results could not be merged";
            break;
        case me.not_multiple_of:
            n = `Number must be a multiple of ${t.multipleOf}`;
            break;
        case me.not_finite:
            n = "Number must be finite";
            break;
        default:
            n = e.defaultError,
                Ct.assertNever(t)
    }
    return {
        message: n
    }
}
    ;
let nO = au;
function qZ(t) {
    nO = t
}
function Bp() {
    return nO
}
const $p = t => {
    const { data: e, path: n, errorMaps: r, issueData: i } = t
        , s = [...n, ...i.path || []]
        , o = {
            ...i,
            path: s
        };
    if (i.message !== void 0)
        return {
            ...i,
            path: s,
            message: i.message
        };
    let a = "";
    const l = r.filter(c => !!c).slice().reverse();
    for (const c of l)
        a = c(o, {
            data: e,
            defaultError: a
        }).message;
    return {
        ...i,
        path: s,
        message: a
    }
}
    , GZ = [];
function _e(t, e) {
    const n = Bp()
        , r = $p({
            issueData: e,
            data: t.data,
            path: t.path,
            errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, n, n === au ? void 0 : au].filter(i => !!i)
        });
    t.common.issues.push(r)
}
class tr {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(e, n) {
        const r = [];
        for (const i of n) {
            if (i.status === "aborted")
                return Je;
            i.status === "dirty" && e.dirty(),
                r.push(i.value)
        }
        return {
            status: e.value,
            value: r
        }
    }
    static async mergeObjectAsync(e, n) {
        const r = [];
        for (const i of n) {
            const s = await i.key
                , o = await i.value;
            r.push({
                key: s,
                value: o
            })
        }
        return tr.mergeObjectSync(e, r)
    }
    static mergeObjectSync(e, n) {
        const r = {};
        for (const i of n) {
            const { key: s, value: o } = i;
            if (s.status === "aborted" || o.status === "aborted")
                return Je;
            s.status === "dirty" && e.dirty(),
                o.status === "dirty" && e.dirty(),
                s.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[s.value] = o.value)
        }
        return {
            status: e.value,
            value: r
        }
    }
}
const Je = Object.freeze({
    status: "aborted"
})
    , Rl = t => ({
        status: "dirty",
        value: t
    })
    , pr = t => ({
        status: "valid",
        value: t
    })
    , Ty = t => t.status === "aborted"
    , Ay = t => t.status === "dirty"
    , Gc = t => t.status === "valid"
    , Jc = t => typeof Promise < "u" && t instanceof Promise;
function zp(t, e, n, r) {
    if (n === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}
function rO(t, e, n, r, i) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n),
        n
}
var Ie;
(function (t) {
    t.errToObj = e => typeof e == "string" ? {
        message: e
    } : e || {},
        t.toString = e => typeof e == "string" ? e : e?.message
}
)(Ie || (Ie = {}));
var Xu, Qu;
class rs {
    constructor(e, n, r, i) {
        this._cachedPath = [],
            this.parent = e,
            this.data = n,
            this._path = r,
            this._key = i
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
    }
}
const _S = (t, e) => {
    if (Gc(e))
        return {
            success: !0,
            data: e.value
        };
    if (!t.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const n = new $r(t.common.issues);
            return this._error = n,
                this._error
        }
    }
}
    ;
function at(t) {
    if (!t)
        return {};
    const { errorMap: e, invalid_type_error: n, required_error: r, description: i } = t;
    if (e && (n || r))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? {
        errorMap: e,
        description: i
    } : {
        errorMap: (o, a) => {
            var l, c;
            const { message: d } = t;
            return o.code === "invalid_enum_value" ? {
                message: d ?? a.defaultError
            } : typeof a.data > "u" ? {
                message: (l = d ?? r) !== null && l !== void 0 ? l : a.defaultError
            } : o.code !== "invalid_type" ? {
                message: a.defaultError
            } : {
                message: (c = d ?? n) !== null && c !== void 0 ? c : a.defaultError
            }
        }
        ,
        description: i
    }
}
class dt {
    constructor(e) {
        this.spa = this.safeParseAsync,
            this._def = e,
            this.parse = this.parse.bind(this),
            this.safeParse = this.safeParse.bind(this),
            this.parseAsync = this.parseAsync.bind(this),
            this.safeParseAsync = this.safeParseAsync.bind(this),
            this.spa = this.spa.bind(this),
            this.refine = this.refine.bind(this),
            this.refinement = this.refinement.bind(this),
            this.superRefine = this.superRefine.bind(this),
            this.optional = this.optional.bind(this),
            this.nullable = this.nullable.bind(this),
            this.nullish = this.nullish.bind(this),
            this.array = this.array.bind(this),
            this.promise = this.promise.bind(this),
            this.or = this.or.bind(this),
            this.and = this.and.bind(this),
            this.transform = this.transform.bind(this),
            this.brand = this.brand.bind(this),
            this.default = this.default.bind(this),
            this.catch = this.catch.bind(this),
            this.describe = this.describe.bind(this),
            this.pipe = this.pipe.bind(this),
            this.readonly = this.readonly.bind(this),
            this.isNullable = this.isNullable.bind(this),
            this.isOptional = this.isOptional.bind(this)
    }
    get description() {
        return this._def.description
    }
    _getType(e) {
        return go(e.data)
    }
    _getOrReturnCtx(e, n) {
        return n || {
            common: e.parent.common,
            data: e.data,
            parsedType: go(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        }
    }
    _processInputParams(e) {
        return {
            status: new tr,
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: go(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
    }
    _parseSync(e) {
        const n = this._parse(e);
        if (Jc(n))
            throw new Error("Synchronous parse encountered promise.");
        return n
    }
    _parseAsync(e) {
        const n = this._parse(e);
        return Promise.resolve(n)
    }
    parse(e, n) {
        const r = this.safeParse(e, n);
        if (r.success)
            return r.data;
        throw r.error
    }
    safeParse(e, n) {
        var r;
        const i = {
            common: {
                issues: [],
                async: (r = n?.async) !== null && r !== void 0 ? r : !1,
                contextualErrorMap: n?.errorMap
            },
            path: n?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: go(e)
        }
            , s = this._parseSync({
                data: e,
                path: i.path,
                parent: i
            });
        return _S(i, s)
    }
    async parseAsync(e, n) {
        const r = await this.safeParseAsync(e, n);
        if (r.success)
            return r.data;
        throw r.error
    }
    async safeParseAsync(e, n) {
        const r = {
            common: {
                issues: [],
                contextualErrorMap: n?.errorMap,
                async: !0
            },
            path: n?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: go(e)
        }
            , i = this._parse({
                data: e,
                path: r.path,
                parent: r
            })
            , s = await (Jc(i) ? i : Promise.resolve(i));
        return _S(r, s)
    }
    refine(e, n) {
        const r = i => typeof n == "string" || typeof n > "u" ? {
            message: n
        } : typeof n == "function" ? n(i) : n;
        return this._refinement((i, s) => {
            const o = e(i)
                , a = () => s.addIssue({
                    code: me.custom,
                    ...r(i)
                });
            return typeof Promise < "u" && o instanceof Promise ? o.then(l => l ? !0 : (a(),
                !1)) : o ? !0 : (a(),
                    !1)
        }
        )
    }
    refinement(e, n) {
        return this._refinement((r, i) => e(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n),
            !1))
    }
    _refinement(e) {
        return new Pi({
            schema: this,
            typeName: qe.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        })
    }
    superRefine(e) {
        return this._refinement(e)
    }
    optional() {
        return Ji.create(this, this._def)
    }
    nullable() {
        return Ho.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return Ei.create(this, this._def)
    }
    promise() {
        return uu.create(this, this._def)
    }
    or(e) {
        return Qc.create([this, e], this._def)
    }
    and(e) {
        return ed.create(this, e, this._def)
    }
    transform(e) {
        return new Pi({
            ...at(this._def),
            schema: this,
            typeName: qe.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        })
    }
    default(e) {
        const n = typeof e == "function" ? e : () => e;
        return new sd({
            ...at(this._def),
            innerType: this,
            defaultValue: n,
            typeName: qe.ZodDefault
        })
    }
    brand() {
        return new db({
            typeName: qe.ZodBranded,
            type: this,
            ...at(this._def)
        })
    }
    catch(e) {
        const n = typeof e == "function" ? e : () => e;
        return new od({
            ...at(this._def),
            innerType: this,
            catchValue: n,
            typeName: qe.ZodCatch
        })
    }
    describe(e) {
        const n = this.constructor;
        return new n({
            ...this._def,
            description: e
        })
    }
    pipe(e) {
        return Od.create(this, e)
    }
    readonly() {
        return ad.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const JZ = /^c[^\s-]{8,}$/i
    , ZZ = /^[0-9a-z]+$/
    , YZ = /^[0-9A-HJKMNP-TV-Z]{26}$/
    , XZ = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
    , QZ = /^[a-z0-9_-]{21}$/i
    , eY = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
    , tY = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
    , nY = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let G0;
const rY = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
    , iY = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/
    , sY = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
    , iO = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
    , oY = new RegExp(`^${iO}$`);
function sO(t) {
    let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`),
        e
}
function aY(t) {
    return new RegExp(`^${sO(t)}$`)
}
function oO(t) {
    let e = `${iO}T${sO(t)}`;
    const n = [];
    return n.push(t.local ? "Z?" : "Z"),
        t.offset && n.push("([+-]\\d{2}:?\\d{2})"),
        e = `${e}(${n.join("|")})`,
        new RegExp(`^${e}$`)
}
function lY(t, e) {
    return !!((e === "v4" || !e) && rY.test(t) || (e === "v6" || !e) && iY.test(t))
}
class Si extends dt {
    _parse(e) {
        if (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== ke.string) {
            const s = this._getOrReturnCtx(e);
            return _e(s, {
                code: me.invalid_type,
                expected: ke.string,
                received: s.parsedType
            }),
                Je
        }
        const r = new tr;
        let i;
        for (const s of this._def.checks)
            if (s.kind === "min")
                e.data.length < s.value && (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        code: me.too_small,
                        minimum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: s.message
                    }),
                    r.dirty());
            else if (s.kind === "max")
                e.data.length > s.value && (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        code: me.too_big,
                        maximum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: s.message
                    }),
                    r.dirty());
            else if (s.kind === "length") {
                const o = e.data.length > s.value
                    , a = e.data.length < s.value;
                (o || a) && (i = this._getOrReturnCtx(e, i),
                    o ? _e(i, {
                        code: me.too_big,
                        maximum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: s.message
                    }) : a && _e(i, {
                        code: me.too_small,
                        minimum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: s.message
                    }),
                    r.dirty())
            } else if (s.kind === "email")
                tY.test(e.data) || (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        validation: "email",
                        code: me.invalid_string,
                        message: s.message
                    }),
                    r.dirty());
            else if (s.kind === "emoji")
                G0 || (G0 = new RegExp(nY, "u")),
                    G0.test(e.data) || (i = this._getOrReturnCtx(e, i),
                        _e(i, {
                            validation: "emoji",
                            code: me.invalid_string,
                            message: s.message
                        }),
                        r.dirty());
            else if (s.kind === "uuid")
                XZ.test(e.data) || (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        validation: "uuid",
                        code: me.invalid_string,
                        message: s.message
                    }),
                    r.dirty());
            else if (s.kind === "nanoid")
                QZ.test(e.data) || (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        validation: "nanoid",
                        code: me.invalid_string,
                        message: s.message
                    }),
                    r.dirty());
            else if (s.kind === "cuid")
                JZ.test(e.data) || (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        validation: "cuid",
                        code: me.invalid_string,
                        message: s.message
                    }),
                    r.dirty());
            else if (s.kind === "cuid2")
                ZZ.test(e.data) || (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        validation: "cuid2",
                        code: me.invalid_string,
                        message: s.message
                    }),
                    r.dirty());
            else if (s.kind === "ulid")
                YZ.test(e.data) || (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        validation: "ulid",
                        code: me.invalid_string,
                        message: s.message
                    }),
                    r.dirty());
            else if (s.kind === "url")
                try {
                    new URL(e.data)
                } catch {
                    i = this._getOrReturnCtx(e, i),
                        _e(i, {
                            validation: "url",
                            code: me.invalid_string,
                            message: s.message
                        }),
                        r.dirty()
                }
            else
                s.kind === "regex" ? (s.regex.lastIndex = 0,
                    s.regex.test(e.data) || (i = this._getOrReturnCtx(e, i),
                        _e(i, {
                            validation: "regex",
                            code: me.invalid_string,
                            message: s.message
                        }),
                        r.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (i = this._getOrReturnCtx(e, i),
                            _e(i, {
                                code: me.invalid_string,
                                validation: {
                                    includes: s.value,
                                    position: s.position
                                },
                                message: s.message
                            }),
                            r.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (i = this._getOrReturnCtx(e, i),
                                _e(i, {
                                    code: me.invalid_string,
                                    validation: {
                                        startsWith: s.value
                                    },
                                    message: s.message
                                }),
                                r.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (i = this._getOrReturnCtx(e, i),
                                    _e(i, {
                                        code: me.invalid_string,
                                        validation: {
                                            endsWith: s.value
                                        },
                                        message: s.message
                                    }),
                                    r.dirty()) : s.kind === "datetime" ? oO(s).test(e.data) || (i = this._getOrReturnCtx(e, i),
                                        _e(i, {
                                            code: me.invalid_string,
                                            validation: "datetime",
                                            message: s.message
                                        }),
                                        r.dirty()) : s.kind === "date" ? oY.test(e.data) || (i = this._getOrReturnCtx(e, i),
                                            _e(i, {
                                                code: me.invalid_string,
                                                validation: "date",
                                                message: s.message
                                            }),
                                            r.dirty()) : s.kind === "time" ? aY(s).test(e.data) || (i = this._getOrReturnCtx(e, i),
                                                _e(i, {
                                                    code: me.invalid_string,
                                                    validation: "time",
                                                    message: s.message
                                                }),
                                                r.dirty()) : s.kind === "duration" ? eY.test(e.data) || (i = this._getOrReturnCtx(e, i),
                                                    _e(i, {
                                                        validation: "duration",
                                                        code: me.invalid_string,
                                                        message: s.message
                                                    }),
                                                    r.dirty()) : s.kind === "ip" ? lY(e.data, s.version) || (i = this._getOrReturnCtx(e, i),
                                                        _e(i, {
                                                            validation: "ip",
                                                            code: me.invalid_string,
                                                            message: s.message
                                                        }),
                                                        r.dirty()) : s.kind === "base64" ? sY.test(e.data) || (i = this._getOrReturnCtx(e, i),
                                                            _e(i, {
                                                                validation: "base64",
                                                                code: me.invalid_string,
                                                                message: s.message
                                                            }),
                                                            r.dirty()) : Ct.assertNever(s);
        return {
            status: r.value,
            value: e.data
        }
    }
    _regex(e, n, r) {
        return this.refinement(i => e.test(i), {
            validation: n,
            code: me.invalid_string,
            ...Ie.errToObj(r)
        })
    }
    _addCheck(e) {
        return new Si({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    email(e) {
        return this._addCheck({
            kind: "email",
            ...Ie.errToObj(e)
        })
    }
    url(e) {
        return this._addCheck({
            kind: "url",
            ...Ie.errToObj(e)
        })
    }
    emoji(e) {
        return this._addCheck({
            kind: "emoji",
            ...Ie.errToObj(e)
        })
    }
    uuid(e) {
        return this._addCheck({
            kind: "uuid",
            ...Ie.errToObj(e)
        })
    }
    nanoid(e) {
        return this._addCheck({
            kind: "nanoid",
            ...Ie.errToObj(e)
        })
    }
    cuid(e) {
        return this._addCheck({
            kind: "cuid",
            ...Ie.errToObj(e)
        })
    }
    cuid2(e) {
        return this._addCheck({
            kind: "cuid2",
            ...Ie.errToObj(e)
        })
    }
    ulid(e) {
        return this._addCheck({
            kind: "ulid",
            ...Ie.errToObj(e)
        })
    }
    base64(e) {
        return this._addCheck({
            kind: "base64",
            ...Ie.errToObj(e)
        })
    }
    ip(e) {
        return this._addCheck({
            kind: "ip",
            ...Ie.errToObj(e)
        })
    }
    datetime(e) {
        var n, r;
        return typeof e == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof e?.precision > "u" ? null : e?.precision,
            offset: (n = e?.offset) !== null && n !== void 0 ? n : !1,
            local: (r = e?.local) !== null && r !== void 0 ? r : !1,
            ...Ie.errToObj(e?.message)
        })
    }
    date(e) {
        return this._addCheck({
            kind: "date",
            message: e
        })
    }
    time(e) {
        return typeof e == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: e
        }) : this._addCheck({
            kind: "time",
            precision: typeof e?.precision > "u" ? null : e?.precision,
            ...Ie.errToObj(e?.message)
        })
    }
    duration(e) {
        return this._addCheck({
            kind: "duration",
            ...Ie.errToObj(e)
        })
    }
    regex(e, n) {
        return this._addCheck({
            kind: "regex",
            regex: e,
            ...Ie.errToObj(n)
        })
    }
    includes(e, n) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: n?.position,
            ...Ie.errToObj(n?.message)
        })
    }
    startsWith(e, n) {
        return this._addCheck({
            kind: "startsWith",
            value: e,
            ...Ie.errToObj(n)
        })
    }
    endsWith(e, n) {
        return this._addCheck({
            kind: "endsWith",
            value: e,
            ...Ie.errToObj(n)
        })
    }
    min(e, n) {
        return this._addCheck({
            kind: "min",
            value: e,
            ...Ie.errToObj(n)
        })
    }
    max(e, n) {
        return this._addCheck({
            kind: "max",
            value: e,
            ...Ie.errToObj(n)
        })
    }
    length(e, n) {
        return this._addCheck({
            kind: "length",
            value: e,
            ...Ie.errToObj(n)
        })
    }
    nonempty(e) {
        return this.min(1, Ie.errToObj(e))
    }
    trim() {
        return new Si({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new Si({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new Si({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(e => e.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find(e => e.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find(e => e.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find(e => e.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find(e => e.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(e => e.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(e => e.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(e => e.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find(e => e.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find(e => e.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(e => e.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(e => e.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(e => e.kind === "ip")
    }
    get isBase64() {
        return !!this._def.checks.find(e => e.kind === "base64")
    }
    get minLength() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxLength() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
}
Si.create = t => {
    var e;
    return new Si({
        checks: [],
        typeName: qe.ZodString,
        coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
        ...at(t)
    })
}
    ;
function uY(t, e) {
    const n = (t.toString().split(".")[1] || "").length
        , r = (e.toString().split(".")[1] || "").length
        , i = n > r ? n : r
        , s = parseInt(t.toFixed(i).replace(".", ""))
        , o = parseInt(e.toFixed(i).replace(".", ""));
    return s % o / Math.pow(10, i)
}
class $o extends dt {
    constructor() {
        super(...arguments),
            this.min = this.gte,
            this.max = this.lte,
            this.step = this.multipleOf
    }
    _parse(e) {
        if (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== ke.number) {
            const s = this._getOrReturnCtx(e);
            return _e(s, {
                code: me.invalid_type,
                expected: ke.number,
                received: s.parsedType
            }),
                Je
        }
        let r;
        const i = new tr;
        for (const s of this._def.checks)
            s.kind === "int" ? Ct.isInteger(e.data) || (r = this._getOrReturnCtx(e, r),
                _e(r, {
                    code: me.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: s.message
                }),
                i.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (r = this._getOrReturnCtx(e, r),
                    _e(r, {
                        code: me.too_small,
                        minimum: s.value,
                        type: "number",
                        inclusive: s.inclusive,
                        exact: !1,
                        message: s.message
                    }),
                    i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (r = this._getOrReturnCtx(e, r),
                        _e(r, {
                            code: me.too_big,
                            maximum: s.value,
                            type: "number",
                            inclusive: s.inclusive,
                            exact: !1,
                            message: s.message
                        }),
                        i.dirty()) : s.kind === "multipleOf" ? uY(e.data, s.value) !== 0 && (r = this._getOrReturnCtx(e, r),
                            _e(r, {
                                code: me.not_multiple_of,
                                multipleOf: s.value,
                                message: s.message
                            }),
                            i.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r),
                                _e(r, {
                                    code: me.not_finite,
                                    message: s.message
                                }),
                                i.dirty()) : Ct.assertNever(s);
        return {
            status: i.value,
            value: e.data
        }
    }
    gte(e, n) {
        return this.setLimit("min", e, !0, Ie.toString(n))
    }
    gt(e, n) {
        return this.setLimit("min", e, !1, Ie.toString(n))
    }
    lte(e, n) {
        return this.setLimit("max", e, !0, Ie.toString(n))
    }
    lt(e, n) {
        return this.setLimit("max", e, !1, Ie.toString(n))
    }
    setLimit(e, n, r, i) {
        return new $o({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: n,
                inclusive: r,
                message: Ie.toString(i)
            }]
        })
    }
    _addCheck(e) {
        return new $o({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    int(e) {
        return this._addCheck({
            kind: "int",
            message: Ie.toString(e)
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: Ie.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: Ie.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: Ie.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: Ie.toString(e)
        })
    }
    multipleOf(e, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Ie.toString(n)
        })
    }
    finite(e) {
        return this._addCheck({
            kind: "finite",
            message: Ie.toString(e)
        })
    }
    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: Ie.toString(e)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: Ie.toString(e)
        })
    }
    get minValue() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
    get isInt() {
        return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && Ct.isInteger(e.value))
    }
    get isFinite() {
        let e = null
            , n = null;
        for (const r of this._def.checks) {
            if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
                return !0;
            r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value)
        }
        return Number.isFinite(n) && Number.isFinite(e)
    }
}
$o.create = t => new $o({
    checks: [],
    typeName: qe.ZodNumber,
    coerce: t?.coerce || !1,
    ...at(t)
});
class zo extends dt {
    constructor() {
        super(...arguments),
            this.min = this.gte,
            this.max = this.lte
    }
    _parse(e) {
        if (this._def.coerce && (e.data = BigInt(e.data)),
            this._getType(e) !== ke.bigint) {
            const s = this._getOrReturnCtx(e);
            return _e(s, {
                code: me.invalid_type,
                expected: ke.bigint,
                received: s.parsedType
            }),
                Je
        }
        let r;
        const i = new tr;
        for (const s of this._def.checks)
            s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (r = this._getOrReturnCtx(e, r),
                _e(r, {
                    code: me.too_small,
                    type: "bigint",
                    minimum: s.value,
                    inclusive: s.inclusive,
                    message: s.message
                }),
                i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (r = this._getOrReturnCtx(e, r),
                    _e(r, {
                        code: me.too_big,
                        type: "bigint",
                        maximum: s.value,
                        inclusive: s.inclusive,
                        message: s.message
                    }),
                    i.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r),
                        _e(r, {
                            code: me.not_multiple_of,
                            multipleOf: s.value,
                            message: s.message
                        }),
                        i.dirty()) : Ct.assertNever(s);
        return {
            status: i.value,
            value: e.data
        }
    }
    gte(e, n) {
        return this.setLimit("min", e, !0, Ie.toString(n))
    }
    gt(e, n) {
        return this.setLimit("min", e, !1, Ie.toString(n))
    }
    lte(e, n) {
        return this.setLimit("max", e, !0, Ie.toString(n))
    }
    lt(e, n) {
        return this.setLimit("max", e, !1, Ie.toString(n))
    }
    setLimit(e, n, r, i) {
        return new zo({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: n,
                inclusive: r,
                message: Ie.toString(i)
            }]
        })
    }
    _addCheck(e) {
        return new zo({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: Ie.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: Ie.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: Ie.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: Ie.toString(e)
        })
    }
    multipleOf(e, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Ie.toString(n)
        })
    }
    get minValue() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
}
zo.create = t => {
    var e;
    return new zo({
        checks: [],
        typeName: qe.ZodBigInt,
        coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
        ...at(t)
    })
}
    ;
class Zc extends dt {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== ke.boolean) {
            const r = this._getOrReturnCtx(e);
            return _e(r, {
                code: me.invalid_type,
                expected: ke.boolean,
                received: r.parsedType
            }),
                Je
        }
        return pr(e.data)
    }
}
Zc.create = t => new Zc({
    typeName: qe.ZodBoolean,
    coerce: t?.coerce || !1,
    ...at(t)
});
class Fa extends dt {
    _parse(e) {
        if (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== ke.date) {
            const s = this._getOrReturnCtx(e);
            return _e(s, {
                code: me.invalid_type,
                expected: ke.date,
                received: s.parsedType
            }),
                Je
        }
        if (isNaN(e.data.getTime())) {
            const s = this._getOrReturnCtx(e);
            return _e(s, {
                code: me.invalid_date
            }),
                Je
        }
        const r = new tr;
        let i;
        for (const s of this._def.checks)
            s.kind === "min" ? e.data.getTime() < s.value && (i = this._getOrReturnCtx(e, i),
                _e(i, {
                    code: me.too_small,
                    message: s.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: s.value,
                    type: "date"
                }),
                r.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (i = this._getOrReturnCtx(e, i),
                    _e(i, {
                        code: me.too_big,
                        message: s.message,
                        inclusive: !0,
                        exact: !1,
                        maximum: s.value,
                        type: "date"
                    }),
                    r.dirty()) : Ct.assertNever(s);
        return {
            status: r.value,
            value: new Date(e.data.getTime())
        }
    }
    _addCheck(e) {
        return new Fa({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    min(e, n) {
        return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: Ie.toString(n)
        })
    }
    max(e, n) {
        return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: Ie.toString(n)
        })
    }
    get minDate() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e != null ? new Date(e) : null
    }
    get maxDate() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e != null ? new Date(e) : null
    }
}
Fa.create = t => new Fa({
    checks: [],
    coerce: t?.coerce || !1,
    typeName: qe.ZodDate,
    ...at(t)
});
class Fp extends dt {
    _parse(e) {
        if (this._getType(e) !== ke.symbol) {
            const r = this._getOrReturnCtx(e);
            return _e(r, {
                code: me.invalid_type,
                expected: ke.symbol,
                received: r.parsedType
            }),
                Je
        }
        return pr(e.data)
    }
}
Fp.create = t => new Fp({
    typeName: qe.ZodSymbol,
    ...at(t)
});
class Yc extends dt {
    _parse(e) {
        if (this._getType(e) !== ke.undefined) {
            const r = this._getOrReturnCtx(e);
            return _e(r, {
                code: me.invalid_type,
                expected: ke.undefined,
                received: r.parsedType
            }),
                Je
        }
        return pr(e.data)
    }
}
Yc.create = t => new Yc({
    typeName: qe.ZodUndefined,
    ...at(t)
});
class Xc extends dt {
    _parse(e) {
        if (this._getType(e) !== ke.null) {
            const r = this._getOrReturnCtx(e);
            return _e(r, {
                code: me.invalid_type,
                expected: ke.null,
                received: r.parsedType
            }),
                Je
        }
        return pr(e.data)
    }
}
Xc.create = t => new Xc({
    typeName: qe.ZodNull,
    ...at(t)
});
class lu extends dt {
    constructor() {
        super(...arguments),
            this._any = !0
    }
    _parse(e) {
        return pr(e.data)
    }
}
lu.create = t => new lu({
    typeName: qe.ZodAny,
    ...at(t)
});
class Ta extends dt {
    constructor() {
        super(...arguments),
            this._unknown = !0
    }
    _parse(e) {
        return pr(e.data)
    }
}
Ta.create = t => new Ta({
    typeName: qe.ZodUnknown,
    ...at(t)
});
class Bs extends dt {
    _parse(e) {
        const n = this._getOrReturnCtx(e);
        return _e(n, {
            code: me.invalid_type,
            expected: ke.never,
            received: n.parsedType
        }),
            Je
    }
}
Bs.create = t => new Bs({
    typeName: qe.ZodNever,
    ...at(t)
});
class Hp extends dt {
    _parse(e) {
        if (this._getType(e) !== ke.undefined) {
            const r = this._getOrReturnCtx(e);
            return _e(r, {
                code: me.invalid_type,
                expected: ke.void,
                received: r.parsedType
            }),
                Je
        }
        return pr(e.data)
    }
}
Hp.create = t => new Hp({
    typeName: qe.ZodVoid,
    ...at(t)
});
class Ei extends dt {
    _parse(e) {
        const { ctx: n, status: r } = this._processInputParams(e)
            , i = this._def;
        if (n.parsedType !== ke.array)
            return _e(n, {
                code: me.invalid_type,
                expected: ke.array,
                received: n.parsedType
            }),
                Je;
        if (i.exactLength !== null) {
            const o = n.data.length > i.exactLength.value
                , a = n.data.length < i.exactLength.value;
            (o || a) && (_e(n, {
                code: o ? me.too_big : me.too_small,
                minimum: a ? i.exactLength.value : void 0,
                maximum: o ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }),
                r.dirty())
        }
        if (i.minLength !== null && n.data.length < i.minLength.value && (_e(n, {
            code: me.too_small,
            minimum: i.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.minLength.message
        }),
            r.dirty()),
            i.maxLength !== null && n.data.length > i.maxLength.value && (_e(n, {
                code: me.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message
            }),
                r.dirty()),
            n.common.async)
            return Promise.all([...n.data].map((o, a) => i.type._parseAsync(new rs(n, o, n.path, a)))).then(o => tr.mergeArray(r, o));
        const s = [...n.data].map((o, a) => i.type._parseSync(new rs(n, o, n.path, a)));
        return tr.mergeArray(r, s)
    }
    get element() {
        return this._def.type
    }
    min(e, n) {
        return new Ei({
            ...this._def,
            minLength: {
                value: e,
                message: Ie.toString(n)
            }
        })
    }
    max(e, n) {
        return new Ei({
            ...this._def,
            maxLength: {
                value: e,
                message: Ie.toString(n)
            }
        })
    }
    length(e, n) {
        return new Ei({
            ...this._def,
            exactLength: {
                value: e,
                message: Ie.toString(n)
            }
        })
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Ei.create = (t, e) => new Ei({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: qe.ZodArray,
    ...at(e)
});
function Tl(t) {
    if (t instanceof en) {
        const e = {};
        for (const n in t.shape) {
            const r = t.shape[n];
            e[n] = Ji.create(Tl(r))
        }
        return new en({
            ...t._def,
            shape: () => e
        })
    } else
        return t instanceof Ei ? new Ei({
            ...t._def,
            type: Tl(t.element)
        }) : t instanceof Ji ? Ji.create(Tl(t.unwrap())) : t instanceof Ho ? Ho.create(Tl(t.unwrap())) : t instanceof is ? is.create(t.items.map(e => Tl(e))) : t
}
class en extends dt {
    constructor() {
        super(...arguments),
            this._cached = null,
            this.nonstrict = this.passthrough,
            this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const e = this._def.shape()
            , n = Ct.objectKeys(e);
        return this._cached = {
            shape: e,
            keys: n
        }
    }
    _parse(e) {
        if (this._getType(e) !== ke.object) {
            const c = this._getOrReturnCtx(e);
            return _e(c, {
                code: me.invalid_type,
                expected: ke.object,
                received: c.parsedType
            }),
                Je
        }
        const { status: r, ctx: i } = this._processInputParams(e)
            , { shape: s, keys: o } = this._getCached()
            , a = [];
        if (!(this._def.catchall instanceof Bs && this._def.unknownKeys === "strip"))
            for (const c in i.data)
                o.includes(c) || a.push(c);
        const l = [];
        for (const c of o) {
            const d = s[c]
                , h = i.data[c];
            l.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: d._parse(new rs(i, h, i.path, c)),
                alwaysSet: c in i.data
            })
        }
        if (this._def.catchall instanceof Bs) {
            const c = this._def.unknownKeys;
            if (c === "passthrough")
                for (const d of a)
                    l.push({
                        key: {
                            status: "valid",
                            value: d
                        },
                        value: {
                            status: "valid",
                            value: i.data[d]
                        }
                    });
            else if (c === "strict")
                a.length > 0 && (_e(i, {
                    code: me.unrecognized_keys,
                    keys: a
                }),
                    r.dirty());
            else if (c !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const c = this._def.catchall;
            for (const d of a) {
                const h = i.data[d];
                l.push({
                    key: {
                        status: "valid",
                        value: d
                    },
                    value: c._parse(new rs(i, h, i.path, d)),
                    alwaysSet: d in i.data
                })
            }
        }
        return i.common.async ? Promise.resolve().then(async () => {
            const c = [];
            for (const d of l) {
                const h = await d.key
                    , p = await d.value;
                c.push({
                    key: h,
                    value: p,
                    alwaysSet: d.alwaysSet
                })
            }
            return c
        }
        ).then(c => tr.mergeObjectSync(r, c)) : tr.mergeObjectSync(r, l)
    }
    get shape() {
        return this._def.shape()
    }
    strict(e) {
        return Ie.errToObj,
            new en({
                ...this._def,
                unknownKeys: "strict",
                ...e !== void 0 ? {
                    errorMap: (n, r) => {
                        var i, s, o, a;
                        const l = (o = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
                        return n.code === "unrecognized_keys" ? {
                            message: (a = Ie.errToObj(e).message) !== null && a !== void 0 ? a : l
                        } : {
                            message: l
                        }
                    }
                } : {}
            })
    }
    strip() {
        return new en({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new en({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(e) {
        return new en({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...e
            })
        })
    }
    merge(e) {
        return new en({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...e._def.shape()
            }),
            typeName: qe.ZodObject
        })
    }
    setKey(e, n) {
        return this.augment({
            [e]: n
        })
    }
    catchall(e) {
        return new en({
            ...this._def,
            catchall: e
        })
    }
    pick(e) {
        const n = {};
        return Ct.objectKeys(e).forEach(r => {
            e[r] && this.shape[r] && (n[r] = this.shape[r])
        }
        ),
            new en({
                ...this._def,
                shape: () => n
            })
    }
    omit(e) {
        const n = {};
        return Ct.objectKeys(this.shape).forEach(r => {
            e[r] || (n[r] = this.shape[r])
        }
        ),
            new en({
                ...this._def,
                shape: () => n
            })
    }
    deepPartial() {
        return Tl(this)
    }
    partial(e) {
        const n = {};
        return Ct.objectKeys(this.shape).forEach(r => {
            const i = this.shape[r];
            e && !e[r] ? n[r] = i : n[r] = i.optional()
        }
        ),
            new en({
                ...this._def,
                shape: () => n
            })
    }
    required(e) {
        const n = {};
        return Ct.objectKeys(this.shape).forEach(r => {
            if (e && !e[r])
                n[r] = this.shape[r];
            else {
                let s = this.shape[r];
                for (; s instanceof Ji;)
                    s = s._def.innerType;
                n[r] = s
            }
        }
        ),
            new en({
                ...this._def,
                shape: () => n
            })
    }
    keyof() {
        return aO(Ct.objectKeys(this.shape))
    }
}
en.create = (t, e) => new en({
    shape: () => t,
    unknownKeys: "strip",
    catchall: Bs.create(),
    typeName: qe.ZodObject,
    ...at(e)
});
en.strictCreate = (t, e) => new en({
    shape: () => t,
    unknownKeys: "strict",
    catchall: Bs.create(),
    typeName: qe.ZodObject,
    ...at(e)
});
en.lazycreate = (t, e) => new en({
    shape: t,
    unknownKeys: "strip",
    catchall: Bs.create(),
    typeName: qe.ZodObject,
    ...at(e)
});
class Qc extends dt {
    _parse(e) {
        const { ctx: n } = this._processInputParams(e)
            , r = this._def.options;
        function i(s) {
            for (const a of s)
                if (a.result.status === "valid")
                    return a.result;
            for (const a of s)
                if (a.result.status === "dirty")
                    return n.common.issues.push(...a.ctx.common.issues),
                        a.result;
            const o = s.map(a => new $r(a.ctx.common.issues));
            return _e(n, {
                code: me.invalid_union,
                unionErrors: o
            }),
                Je
        }
        if (n.common.async)
            return Promise.all(r.map(async s => {
                const o = {
                    ...n,
                    common: {
                        ...n.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await s._parseAsync({
                        data: n.data,
                        path: n.path,
                        parent: o
                    }),
                    ctx: o
                }
            }
            )).then(i);
        {
            let s;
            const o = [];
            for (const l of r) {
                const c = {
                    ...n,
                    common: {
                        ...n.common,
                        issues: []
                    },
                    parent: null
                }
                    , d = l._parseSync({
                        data: n.data,
                        path: n.path,
                        parent: c
                    });
                if (d.status === "valid")
                    return d;
                d.status === "dirty" && !s && (s = {
                    result: d,
                    ctx: c
                }),
                    c.common.issues.length && o.push(c.common.issues)
            }
            if (s)
                return n.common.issues.push(...s.ctx.common.issues),
                    s.result;
            const a = o.map(l => new $r(l));
            return _e(n, {
                code: me.invalid_union,
                unionErrors: a
            }),
                Je
        }
    }
    get options() {
        return this._def.options
    }
}
Qc.create = (t, e) => new Qc({
    options: t,
    typeName: qe.ZodUnion,
    ...at(e)
});
const Es = t => t instanceof nd ? Es(t.schema) : t instanceof Pi ? Es(t.innerType()) : t instanceof rd ? [t.value] : t instanceof Fo ? t.options : t instanceof id ? Ct.objectValues(t.enum) : t instanceof sd ? Es(t._def.innerType) : t instanceof Yc ? [void 0] : t instanceof Xc ? [null] : t instanceof Ji ? [void 0, ...Es(t.unwrap())] : t instanceof Ho ? [null, ...Es(t.unwrap())] : t instanceof db || t instanceof ad ? Es(t.unwrap()) : t instanceof od ? Es(t._def.innerType) : [];
class zm extends dt {
    _parse(e) {
        const { ctx: n } = this._processInputParams(e);
        if (n.parsedType !== ke.object)
            return _e(n, {
                code: me.invalid_type,
                expected: ke.object,
                received: n.parsedType
            }),
                Je;
        const r = this.discriminator
            , i = n.data[r]
            , s = this.optionsMap.get(i);
        return s ? n.common.async ? s._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }) : s._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }) : (_e(n, {
            code: me.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [r]
        }),
            Je)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(e, n, r) {
        const i = new Map;
        for (const s of n) {
            const o = Es(s.shape[e]);
            if (!o.length)
                throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
            for (const a of o) {
                if (i.has(a))
                    throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
                i.set(a, s)
            }
        }
        return new zm({
            typeName: qe.ZodDiscriminatedUnion,
            discriminator: e,
            options: n,
            optionsMap: i,
            ...at(r)
        })
    }
}
function Oy(t, e) {
    const n = go(t)
        , r = go(e);
    if (t === e)
        return {
            valid: !0,
            data: t
        };
    if (n === ke.object && r === ke.object) {
        const i = Ct.objectKeys(e)
            , s = Ct.objectKeys(t).filter(a => i.indexOf(a) !== -1)
            , o = {
                ...t,
                ...e
            };
        for (const a of s) {
            const l = Oy(t[a], e[a]);
            if (!l.valid)
                return {
                    valid: !1
                };
            o[a] = l.data
        }
        return {
            valid: !0,
            data: o
        }
    } else if (n === ke.array && r === ke.array) {
        if (t.length !== e.length)
            return {
                valid: !1
            };
        const i = [];
        for (let s = 0; s < t.length; s++) {
            const o = t[s]
                , a = e[s]
                , l = Oy(o, a);
            if (!l.valid)
                return {
                    valid: !1
                };
            i.push(l.data)
        }
        return {
            valid: !0,
            data: i
        }
    } else
        return n === ke.date && r === ke.date && +t == +e ? {
            valid: !0,
            data: t
        } : {
            valid: !1
        }
}
class ed extends dt {
    _parse(e) {
        const { status: n, ctx: r } = this._processInputParams(e)
            , i = (s, o) => {
                if (Ty(s) || Ty(o))
                    return Je;
                const a = Oy(s.value, o.value);
                return a.valid ? ((Ay(s) || Ay(o)) && n.dirty(),
                {
                    status: n.value,
                    value: a.data
                }) : (_e(r, {
                    code: me.invalid_intersection_types
                }),
                    Je)
            }
            ;
        return r.common.async ? Promise.all([this._def.left._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        })]).then(([s, o]) => i(s, o)) : i(this._def.left._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }))
    }
}
ed.create = (t, e, n) => new ed({
    left: t,
    right: e,
    typeName: qe.ZodIntersection,
    ...at(n)
});
class is extends dt {
    _parse(e) {
        const { status: n, ctx: r } = this._processInputParams(e);
        if (r.parsedType !== ke.array)
            return _e(r, {
                code: me.invalid_type,
                expected: ke.array,
                received: r.parsedType
            }),
                Je;
        if (r.data.length < this._def.items.length)
            return _e(r, {
                code: me.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
                Je;
        !this._def.rest && r.data.length > this._def.items.length && (_e(r, {
            code: me.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
            n.dirty());
        const s = [...r.data].map((o, a) => {
            const l = this._def.items[a] || this._def.rest;
            return l ? l._parse(new rs(r, o, r.path, a)) : null
        }
        ).filter(o => !!o);
        return r.common.async ? Promise.all(s).then(o => tr.mergeArray(n, o)) : tr.mergeArray(n, s)
    }
    get items() {
        return this._def.items
    }
    rest(e) {
        return new is({
            ...this._def,
            rest: e
        })
    }
}
is.create = (t, e) => {
    if (!Array.isArray(t))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new is({
        items: t,
        typeName: qe.ZodTuple,
        rest: null,
        ...at(e)
    })
}
    ;
class td extends dt {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const { status: n, ctx: r } = this._processInputParams(e);
        if (r.parsedType !== ke.object)
            return _e(r, {
                code: me.invalid_type,
                expected: ke.object,
                received: r.parsedType
            }),
                Je;
        const i = []
            , s = this._def.keyType
            , o = this._def.valueType;
        for (const a in r.data)
            i.push({
                key: s._parse(new rs(r, a, r.path, a)),
                value: o._parse(new rs(r, r.data[a], r.path, a)),
                alwaysSet: a in r.data
            });
        return r.common.async ? tr.mergeObjectAsync(n, i) : tr.mergeObjectSync(n, i)
    }
    get element() {
        return this._def.valueType
    }
    static create(e, n, r) {
        return n instanceof dt ? new td({
            keyType: e,
            valueType: n,
            typeName: qe.ZodRecord,
            ...at(r)
        }) : new td({
            keyType: Si.create(),
            valueType: e,
            typeName: qe.ZodRecord,
            ...at(n)
        })
    }
}
class Vp extends dt {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const { status: n, ctx: r } = this._processInputParams(e);
        if (r.parsedType !== ke.map)
            return _e(r, {
                code: me.invalid_type,
                expected: ke.map,
                received: r.parsedType
            }),
                Je;
        const i = this._def.keyType
            , s = this._def.valueType
            , o = [...r.data.entries()].map(([a, l], c) => ({
                key: i._parse(new rs(r, a, r.path, [c, "key"])),
                value: s._parse(new rs(r, l, r.path, [c, "value"]))
            }));
        if (r.common.async) {
            const a = new Map;
            return Promise.resolve().then(async () => {
                for (const l of o) {
                    const c = await l.key
                        , d = await l.value;
                    if (c.status === "aborted" || d.status === "aborted")
                        return Je;
                    (c.status === "dirty" || d.status === "dirty") && n.dirty(),
                        a.set(c.value, d.value)
                }
                return {
                    status: n.value,
                    value: a
                }
            }
            )
        } else {
            const a = new Map;
            for (const l of o) {
                const c = l.key
                    , d = l.value;
                if (c.status === "aborted" || d.status === "aborted")
                    return Je;
                (c.status === "dirty" || d.status === "dirty") && n.dirty(),
                    a.set(c.value, d.value)
            }
            return {
                status: n.value,
                value: a
            }
        }
    }
}
Vp.create = (t, e, n) => new Vp({
    valueType: e,
    keyType: t,
    typeName: qe.ZodMap,
    ...at(n)
});
class Ha extends dt {
    _parse(e) {
        const { status: n, ctx: r } = this._processInputParams(e);
        if (r.parsedType !== ke.set)
            return _e(r, {
                code: me.invalid_type,
                expected: ke.set,
                received: r.parsedType
            }),
                Je;
        const i = this._def;
        i.minSize !== null && r.data.size < i.minSize.value && (_e(r, {
            code: me.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }),
            n.dirty()),
            i.maxSize !== null && r.data.size > i.maxSize.value && (_e(r, {
                code: me.too_big,
                maximum: i.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: i.maxSize.message
            }),
                n.dirty());
        const s = this._def.valueType;
        function o(l) {
            const c = new Set;
            for (const d of l) {
                if (d.status === "aborted")
                    return Je;
                d.status === "dirty" && n.dirty(),
                    c.add(d.value)
            }
            return {
                status: n.value,
                value: c
            }
        }
        const a = [...r.data.values()].map((l, c) => s._parse(new rs(r, l, r.path, c)));
        return r.common.async ? Promise.all(a).then(l => o(l)) : o(a)
    }
    min(e, n) {
        return new Ha({
            ...this._def,
            minSize: {
                value: e,
                message: Ie.toString(n)
            }
        })
    }
    max(e, n) {
        return new Ha({
            ...this._def,
            maxSize: {
                value: e,
                message: Ie.toString(n)
            }
        })
    }
    size(e, n) {
        return this.min(e, n).max(e, n)
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Ha.create = (t, e) => new Ha({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: qe.ZodSet,
    ...at(e)
});
class Ul extends dt {
    constructor() {
        super(...arguments),
            this.validate = this.implement
    }
    _parse(e) {
        const { ctx: n } = this._processInputParams(e);
        if (n.parsedType !== ke.function)
            return _e(n, {
                code: me.invalid_type,
                expected: ke.function,
                received: n.parsedType
            }),
                Je;
        function r(a, l) {
            return $p({
                data: a,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Bp(), au].filter(c => !!c),
                issueData: {
                    code: me.invalid_arguments,
                    argumentsError: l
                }
            })
        }
        function i(a, l) {
            return $p({
                data: a,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Bp(), au].filter(c => !!c),
                issueData: {
                    code: me.invalid_return_type,
                    returnTypeError: l
                }
            })
        }
        const s = {
            errorMap: n.common.contextualErrorMap
        }
            , o = n.data;
        if (this._def.returns instanceof uu) {
            const a = this;
            return pr(async function (...l) {
                const c = new $r([])
                    , d = await a._def.args.parseAsync(l, s).catch(g => {
                        throw c.addIssue(r(l, g)),
                        c
                    }
                    )
                    , h = await Reflect.apply(o, this, d);
                return await a._def.returns._def.type.parseAsync(h, s).catch(g => {
                    throw c.addIssue(i(h, g)),
                    c
                }
                )
            })
        } else {
            const a = this;
            return pr(function (...l) {
                const c = a._def.args.safeParse(l, s);
                if (!c.success)
                    throw new $r([r(l, c.error)]);
                const d = Reflect.apply(o, this, c.data)
                    , h = a._def.returns.safeParse(d, s);
                if (!h.success)
                    throw new $r([i(d, h.error)]);
                return h.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...e) {
        return new Ul({
            ...this._def,
            args: is.create(e).rest(Ta.create())
        })
    }
    returns(e) {
        return new Ul({
            ...this._def,
            returns: e
        })
    }
    implement(e) {
        return this.parse(e)
    }
    strictImplement(e) {
        return this.parse(e)
    }
    static create(e, n, r) {
        return new Ul({
            args: e || is.create([]).rest(Ta.create()),
            returns: n || Ta.create(),
            typeName: qe.ZodFunction,
            ...at(r)
        })
    }
}
class nd extends dt {
    get schema() {
        return this._def.getter()
    }
    _parse(e) {
        const { ctx: n } = this._processInputParams(e);
        return this._def.getter()._parse({
            data: n.data,
            path: n.path,
            parent: n
        })
    }
}
nd.create = (t, e) => new nd({
    getter: t,
    typeName: qe.ZodLazy,
    ...at(e)
});
class rd extends dt {
    _parse(e) {
        if (e.data !== this._def.value) {
            const n = this._getOrReturnCtx(e);
            return _e(n, {
                received: n.data,
                code: me.invalid_literal,
                expected: this._def.value
            }),
                Je
        }
        return {
            status: "valid",
            value: e.data
        }
    }
    get value() {
        return this._def.value
    }
}
rd.create = (t, e) => new rd({
    value: t,
    typeName: qe.ZodLiteral,
    ...at(e)
});
function aO(t, e) {
    return new Fo({
        values: t,
        typeName: qe.ZodEnum,
        ...at(e)
    })
}
class Fo extends dt {
    constructor() {
        super(...arguments),
            Xu.set(this, void 0)
    }
    _parse(e) {
        if (typeof e.data != "string") {
            const n = this._getOrReturnCtx(e)
                , r = this._def.values;
            return _e(n, {
                expected: Ct.joinValues(r),
                received: n.parsedType,
                code: me.invalid_type
            }),
                Je
        }
        if (zp(this, Xu, "f") || rO(this, Xu, new Set(this._def.values), "f"),
            !zp(this, Xu, "f").has(e.data)) {
            const n = this._getOrReturnCtx(e)
                , r = this._def.values;
            return _e(n, {
                received: n.data,
                code: me.invalid_enum_value,
                options: r
            }),
                Je
        }
        return pr(e.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const e = {};
        for (const n of this._def.values)
            e[n] = n;
        return e
    }
    get Values() {
        const e = {};
        for (const n of this._def.values)
            e[n] = n;
        return e
    }
    get Enum() {
        const e = {};
        for (const n of this._def.values)
            e[n] = n;
        return e
    }
    extract(e, n = this._def) {
        return Fo.create(e, {
            ...this._def,
            ...n
        })
    }
    exclude(e, n = this._def) {
        return Fo.create(this.options.filter(r => !e.includes(r)), {
            ...this._def,
            ...n
        })
    }
}
Xu = new WeakMap;
Fo.create = aO;
class id extends dt {
    constructor() {
        super(...arguments),
            Qu.set(this, void 0)
    }
    _parse(e) {
        const n = Ct.getValidEnumValues(this._def.values)
            , r = this._getOrReturnCtx(e);
        if (r.parsedType !== ke.string && r.parsedType !== ke.number) {
            const i = Ct.objectValues(n);
            return _e(r, {
                expected: Ct.joinValues(i),
                received: r.parsedType,
                code: me.invalid_type
            }),
                Je
        }
        if (zp(this, Qu, "f") || rO(this, Qu, new Set(Ct.getValidEnumValues(this._def.values)), "f"),
            !zp(this, Qu, "f").has(e.data)) {
            const i = Ct.objectValues(n);
            return _e(r, {
                received: r.data,
                code: me.invalid_enum_value,
                options: i
            }),
                Je
        }
        return pr(e.data)
    }
    get enum() {
        return this._def.values
    }
}
Qu = new WeakMap;
id.create = (t, e) => new id({
    values: t,
    typeName: qe.ZodNativeEnum,
    ...at(e)
});
class uu extends dt {
    unwrap() {
        return this._def.type
    }
    _parse(e) {
        const { ctx: n } = this._processInputParams(e);
        if (n.parsedType !== ke.promise && n.common.async === !1)
            return _e(n, {
                code: me.invalid_type,
                expected: ke.promise,
                received: n.parsedType
            }),
                Je;
        const r = n.parsedType === ke.promise ? n.data : Promise.resolve(n.data);
        return pr(r.then(i => this._def.type.parseAsync(i, {
            path: n.path,
            errorMap: n.common.contextualErrorMap
        })))
    }
}
uu.create = (t, e) => new uu({
    type: t,
    typeName: qe.ZodPromise,
    ...at(e)
});
class Pi extends dt {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === qe.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(e) {
        const { status: n, ctx: r } = this._processInputParams(e)
            , i = this._def.effect || null
            , s = {
                addIssue: o => {
                    _e(r, o),
                        o.fatal ? n.abort() : n.dirty()
                }
                ,
                get path() {
                    return r.path
                }
            };
        if (s.addIssue = s.addIssue.bind(s),
            i.type === "preprocess") {
            const o = i.transform(r.data, s);
            if (r.common.async)
                return Promise.resolve(o).then(async a => {
                    if (n.value === "aborted")
                        return Je;
                    const l = await this._def.schema._parseAsync({
                        data: a,
                        path: r.path,
                        parent: r
                    });
                    return l.status === "aborted" ? Je : l.status === "dirty" || n.value === "dirty" ? Rl(l.value) : l
                }
                );
            {
                if (n.value === "aborted")
                    return Je;
                const a = this._def.schema._parseSync({
                    data: o,
                    path: r.path,
                    parent: r
                });
                return a.status === "aborted" ? Je : a.status === "dirty" || n.value === "dirty" ? Rl(a.value) : a
            }
        }
        if (i.type === "refinement") {
            const o = a => {
                const l = i.refinement(a, s);
                if (r.common.async)
                    return Promise.resolve(l);
                if (l instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a
            }
                ;
            if (r.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return a.status === "aborted" ? Je : (a.status === "dirty" && n.dirty(),
                    o(a.value),
                {
                    status: n.value,
                    value: a.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                }).then(a => a.status === "aborted" ? Je : (a.status === "dirty" && n.dirty(),
                    o(a.value).then(() => ({
                        status: n.value,
                        value: a.value
                    }))))
        }
        if (i.type === "transform")
            if (r.common.async === !1) {
                const o = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                if (!Gc(o))
                    return o;
                const a = i.transform(o.value, s);
                if (a instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: n.value,
                    value: a
                }
            } else
                return this._def.schema._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                }).then(o => Gc(o) ? Promise.resolve(i.transform(o.value, s)).then(a => ({
                    status: n.value,
                    value: a
                })) : o);
        Ct.assertNever(i)
    }
}
Pi.create = (t, e, n) => new Pi({
    schema: t,
    typeName: qe.ZodEffects,
    effect: e,
    ...at(n)
});
Pi.createWithPreprocess = (t, e, n) => new Pi({
    schema: e,
    effect: {
        type: "preprocess",
        transform: t
    },
    typeName: qe.ZodEffects,
    ...at(n)
});
class Ji extends dt {
    _parse(e) {
        return this._getType(e) === ke.undefined ? pr(void 0) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
Ji.create = (t, e) => new Ji({
    innerType: t,
    typeName: qe.ZodOptional,
    ...at(e)
});
class Ho extends dt {
    _parse(e) {
        return this._getType(e) === ke.null ? pr(null) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
Ho.create = (t, e) => new Ho({
    innerType: t,
    typeName: qe.ZodNullable,
    ...at(e)
});
class sd extends dt {
    _parse(e) {
        const { ctx: n } = this._processInputParams(e);
        let r = n.data;
        return n.parsedType === ke.undefined && (r = this._def.defaultValue()),
            this._def.innerType._parse({
                data: r,
                path: n.path,
                parent: n
            })
    }
    removeDefault() {
        return this._def.innerType
    }
}
sd.create = (t, e) => new sd({
    innerType: t,
    typeName: qe.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...at(e)
});
class od extends dt {
    _parse(e) {
        const { ctx: n } = this._processInputParams(e)
            , r = {
                ...n,
                common: {
                    ...n.common,
                    issues: []
                }
            }
            , i = this._def.innerType._parse({
                data: r.data,
                path: r.path,
                parent: {
                    ...r
                }
            });
        return Jc(i) ? i.then(s => ({
            status: "valid",
            value: s.status === "valid" ? s.value : this._def.catchValue({
                get error() {
                    return new $r(r.common.issues)
                },
                input: r.data
            })
        })) : {
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error() {
                    return new $r(r.common.issues)
                },
                input: r.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
od.create = (t, e) => new od({
    innerType: t,
    typeName: qe.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...at(e)
});
class Wp extends dt {
    _parse(e) {
        if (this._getType(e) !== ke.nan) {
            const r = this._getOrReturnCtx(e);
            return _e(r, {
                code: me.invalid_type,
                expected: ke.nan,
                received: r.parsedType
            }),
                Je
        }
        return {
            status: "valid",
            value: e.data
        }
    }
}
Wp.create = t => new Wp({
    typeName: qe.ZodNaN,
    ...at(t)
});
const cY = Symbol("zod_brand");
class db extends dt {
    _parse(e) {
        const { ctx: n } = this._processInputParams(e)
            , r = n.data;
        return this._def.type._parse({
            data: r,
            path: n.path,
            parent: n
        })
    }
    unwrap() {
        return this._def.type
    }
}
class Od extends dt {
    _parse(e) {
        const { status: n, ctx: r } = this._processInputParams(e);
        if (r.common.async)
            return (async () => {
                const s = await this._def.in._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return s.status === "aborted" ? Je : s.status === "dirty" ? (n.dirty(),
                    Rl(s.value)) : this._def.out._parseAsync({
                        data: s.value,
                        path: r.path,
                        parent: r
                    })
            }
            )();
        {
            const i = this._def.in._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return i.status === "aborted" ? Je : i.status === "dirty" ? (n.dirty(),
            {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({
                data: i.value,
                path: r.path,
                parent: r
            })
        }
    }
    static create(e, n) {
        return new Od({
            in: e,
            out: n,
            typeName: qe.ZodPipeline
        })
    }
}
class ad extends dt {
    _parse(e) {
        const n = this._def.innerType._parse(e)
            , r = i => (Gc(i) && (i.value = Object.freeze(i.value)),
                i);
        return Jc(n) ? n.then(i => r(i)) : r(n)
    }
    unwrap() {
        return this._def.innerType
    }
}
ad.create = (t, e) => new ad({
    innerType: t,
    typeName: qe.ZodReadonly,
    ...at(e)
});
function lO(t, e = {}, n) {
    return t ? lu.create().superRefine((r, i) => {
        var s, o;
        if (!t(r)) {
            const a = typeof e == "function" ? e(r) : typeof e == "string" ? {
                message: e
            } : e
                , l = (o = (s = a.fatal) !== null && s !== void 0 ? s : n) !== null && o !== void 0 ? o : !0
                , c = typeof a == "string" ? {
                    message: a
                } : a;
            i.addIssue({
                code: "custom",
                ...c,
                fatal: l
            })
        }
    }
    ) : lu.create()
}
const dY = {
    object: en.lazycreate
};
var qe;
(function (t) {
    t.ZodString = "ZodString",
        t.ZodNumber = "ZodNumber",
        t.ZodNaN = "ZodNaN",
        t.ZodBigInt = "ZodBigInt",
        t.ZodBoolean = "ZodBoolean",
        t.ZodDate = "ZodDate",
        t.ZodSymbol = "ZodSymbol",
        t.ZodUndefined = "ZodUndefined",
        t.ZodNull = "ZodNull",
        t.ZodAny = "ZodAny",
        t.ZodUnknown = "ZodUnknown",
        t.ZodNever = "ZodNever",
        t.ZodVoid = "ZodVoid",
        t.ZodArray = "ZodArray",
        t.ZodObject = "ZodObject",
        t.ZodUnion = "ZodUnion",
        t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
        t.ZodIntersection = "ZodIntersection",
        t.ZodTuple = "ZodTuple",
        t.ZodRecord = "ZodRecord",
        t.ZodMap = "ZodMap",
        t.ZodSet = "ZodSet",
        t.ZodFunction = "ZodFunction",
        t.ZodLazy = "ZodLazy",
        t.ZodLiteral = "ZodLiteral",
        t.ZodEnum = "ZodEnum",
        t.ZodEffects = "ZodEffects",
        t.ZodNativeEnum = "ZodNativeEnum",
        t.ZodOptional = "ZodOptional",
        t.ZodNullable = "ZodNullable",
        t.ZodDefault = "ZodDefault",
        t.ZodCatch = "ZodCatch",
        t.ZodPromise = "ZodPromise",
        t.ZodBranded = "ZodBranded",
        t.ZodPipeline = "ZodPipeline",
        t.ZodReadonly = "ZodReadonly"
}
)(qe || (qe = {}));
const fY = (t, e = {
    message: `Input not instance of ${t.name}`
}) => lO(n => n instanceof t, e)
    , uO = Si.create
    , cO = $o.create
    , hY = Wp.create
    , pY = zo.create
    , dO = Zc.create
    , mY = Fa.create
    , gY = Fp.create
    , yY = Yc.create
    , vY = Xc.create
    , bY = lu.create
    , wY = Ta.create
    , xY = Bs.create
    , _Y = Hp.create
    , SY = Ei.create
    , kY = en.create
    , CY = en.strictCreate
    , EY = Qc.create
    , TY = zm.create
    , AY = ed.create
    , OY = is.create
    , MY = td.create
    , RY = Vp.create
    , PY = Ha.create
    , NY = Ul.create
    , IY = nd.create
    , LY = rd.create
    , DY = Fo.create
    , jY = id.create
    , BY = uu.create
    , SS = Pi.create
    , $Y = Ji.create
    , zY = Ho.create
    , FY = Pi.createWithPreprocess
    , HY = Od.create
    , VY = () => uO().optional()
    , WY = () => cO().optional()
    , UY = () => dO().optional()
    , KY = {
        string: t => Si.create({
            ...t,
            coerce: !0
        }),
        number: t => $o.create({
            ...t,
            coerce: !0
        }),
        boolean: t => Zc.create({
            ...t,
            coerce: !0
        }),
        bigint: t => zo.create({
            ...t,
            coerce: !0
        }),
        date: t => Fa.create({
            ...t,
            coerce: !0
        })
    }
    , qY = Je;
var GY = Object.freeze({
    __proto__: null,
    defaultErrorMap: au,
    setErrorMap: qZ,
    getErrorMap: Bp,
    makeIssue: $p,
    EMPTY_PATH: GZ,
    addIssueToContext: _e,
    ParseStatus: tr,
    INVALID: Je,
    DIRTY: Rl,
    OK: pr,
    isAborted: Ty,
    isDirty: Ay,
    isValid: Gc,
    isAsync: Jc,
    get util() {
        return Ct
    },
    get objectUtil() {
        return Ey
    },
    ZodParsedType: ke,
    getParsedType: go,
    ZodType: dt,
    datetimeRegex: oO,
    ZodString: Si,
    ZodNumber: $o,
    ZodBigInt: zo,
    ZodBoolean: Zc,
    ZodDate: Fa,
    ZodSymbol: Fp,
    ZodUndefined: Yc,
    ZodNull: Xc,
    ZodAny: lu,
    ZodUnknown: Ta,
    ZodNever: Bs,
    ZodVoid: Hp,
    ZodArray: Ei,
    ZodObject: en,
    ZodUnion: Qc,
    ZodDiscriminatedUnion: zm,
    ZodIntersection: ed,
    ZodTuple: is,
    ZodRecord: td,
    ZodMap: Vp,
    ZodSet: Ha,
    ZodFunction: Ul,
    ZodLazy: nd,
    ZodLiteral: rd,
    ZodEnum: Fo,
    ZodNativeEnum: id,
    ZodPromise: uu,
    ZodEffects: Pi,
    ZodTransformer: Pi,
    ZodOptional: Ji,
    ZodNullable: Ho,
    ZodDefault: sd,
    ZodCatch: od,
    ZodNaN: Wp,
    BRAND: cY,
    ZodBranded: db,
    ZodPipeline: Od,
    ZodReadonly: ad,
    custom: lO,
    Schema: dt,
    ZodSchema: dt,
    late: dY,
    get ZodFirstPartyTypeKind() {
        return qe
    },
    coerce: KY,
    any: bY,
    array: SY,
    bigint: pY,
    boolean: dO,
    date: mY,
    discriminatedUnion: TY,
    effect: SS,
    enum: DY,
    function: NY,
    instanceof: fY,
    intersection: AY,
    lazy: IY,
    literal: LY,
    map: RY,
    nan: hY,
    nativeEnum: jY,
    never: xY,
    null: vY,
    nullable: zY,
    number: cO,
    object: kY,
    oboolean: UY,
    onumber: WY,
    optional: $Y,
    ostring: VY,
    pipeline: HY,
    preprocess: FY,
    promise: BY,
    record: MY,
    set: PY,
    strictObject: CY,
    string: uO,
    symbol: gY,
    transformer: SS,
    tuple: OY,
    undefined: yY,
    union: EY,
    unknown: wY,
    void: _Y,
    NEVER: qY,
    ZodIssueCode: me,
    quotelessJson: KZ,
    ZodError: $r
});
function Up(t) {
    Hq({
        position: "bottom-right",
        ...t
    })
}
function Eee(t) {
    const e = JSON.parse(t);
    return (Array.isArray(e) ? e : []).slice(-1).pop()
}
function Tee(t) {
    return /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(t)
}
function Aee(t) {
    return GY.string().email().safeParse(t).success
}
function Oee(t, e) {
    return b9(t, e || "DD-MM-YYYY HH:mm:ss").value
}
function Mee(t) {
    return j9(t).value
}
const Ree = "ddd, MMM D, YYYY h:mm A";
function Pee(t) {
    const e = Math.floor(t / 86400)
        , n = Math.floor(t % (3600 * 24) / 3600)
        , r = Math.floor(t % 3600 / 60)
        , i = Math.floor(t % 60);
    let s = "";
    return e > 0 && (s += `${e}d `),
        (n > 0 || e > 0) && (s += `${n}h `),
        (r > 0 || n > 0 || e > 0) && (s += `${r}m `),
        s += `${i}s`,
        s.trim()
}
function kS(t, e) {
    return new Function(t + `
return setupForm`)()(e)?.actions || []
}
function Nee(t, e) {
    if (!t._form_script)
        return [];
    let n = [];
    Array.isArray(t._form_script) ? t._form_script.forEach(r => {
        n = n.concat(kS(r, e))
    }
    ) : n = kS(t._form_script, e),
        t._customActions = n
}
const JY = 9e3;
function ZY() {
    const t = YY()
        , e = kh(t, {
            withCredentials: !0,
            reconnectionAttempts: 5
        });
    return e.on("refetch_resource", n => {
        if (n.cache_key) {
            const r = $A(n.cache_key) || FA(n.cache_key);
            r && r.reload()
        }
    }
    ),
        e
}
function YY() {
    const t = window.location.hostname
        , e = window.location.port ? `:${JY}` : ""
        , n = e ? "http" : "https"
        , r = window.frappe_version;
    if (r && r.startsWith("14"))
        return `${n}://${t}${e}`;
    const i = window.site_name
        , s = i?.startsWith("{{") ? t : i;
    return `${n}://${t}${e}/${s}`
}
const fO = ZY()
    , XY = um("config", () => {
        const t = zn({
            url: "helpdesk.api.config.get_config",
            auto: !0
        })
            , e = G(() => t.data || {})
            , n = G(() => e.value.brand_logo)
            , r = G(() => !!parseInt(e.value.setup_complete))
            , i = G(() => !!parseInt(e.value.skip_email_workflow))
            , s = G(() => !!parseInt(e.value.prefer_knowledge_base));
        return fO.on("helpdesk:settings-updated", () => t.reload()),
        {
            brandLogo: n,
            config: e,
            preferKnowledgeBase: s,
            isSetupComplete: r,
            skipEmailWorkflow: i
        }
    }
    );
var Kp = {
    exports: {}
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Kp.exports;
(function (t, e) {
    (function () {
        var n, r = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", a = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", c = 500, d = "__lodash_placeholder__", h = 1, p = 2, g = 4, y = 1, x = 2, S = 1, k = 2, A = 4, C = 8, m = 16, b = 32, w = 64, T = 128, O = 256, M = 512, E = 30, N = "...", j = 800, z = 16, V = 1, W = 2, P = 3, F = 1 / 0, K = 9007199254740991, re = 17976931348623157e292, Te = 0 / 0, ee = 4294967295, Se = ee - 1, Ze = ee >>> 1, Ke = [["ary", T], ["bind", S], ["bindKey", k], ["curry", C], ["curryRight", m], ["flip", M], ["partial", b], ["partialRight", w], ["rearg", O]], Ye = "[object Arguments]", Qe = "[object Array]", Y = "[object AsyncFunction]", he = "[object Boolean]", ge = "[object Date]", Ee = "[object DOMException]", st = "[object Error]", xt = "[object Function]", D = "[object GeneratorFunction]", B = "[object Map]", J = "[object Number]", ae = "[object Null]", X = "[object Object]", de = "[object Promise]", be = "[object Proxy]", pe = "[object RegExp]", fe = "[object Set]", ue = "[object String]", Ne = "[object Symbol]", we = "[object Undefined]", Oe = "[object WeakMap]", ze = "[object WeakSet]", nt = "[object ArrayBuffer]", bt = "[object DataView]", Et = "[object Float32Array]", Mn = "[object Float64Array]", dn = "[object Int8Array]", rr = "[object Int16Array]", Rn = "[object Int32Array]", us = "[object Uint8Array]", Ja = "[object Uint8ClampedArray]", Pn = "[object Uint16Array]", mr = "[object Uint32Array]", Md = /\b__p \+= '';/g, gO = /\b(__p \+=) '' \+/g, yO = /(__e\(.*?\)|\b__t\)) \+\n'';/g, pb = /&(?:amp|lt|gt|quot|#39);/g, mb = /[&<>"']/g, vO = RegExp(pb.source), bO = RegExp(mb.source), wO = /<%-([\s\S]+?)%>/g, xO = /<%([\s\S]+?)%>/g, gb = /<%=([\s\S]+?)%>/g, _O = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, SO = /^\w*$/, kO = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Fm = /[\\^$.*+?()[\]{}|]/g, CO = RegExp(Fm.source), Hm = /^\s+/, EO = /\s/, TO = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, AO = /\{\n\/\* \[wrapped with (.+)\] \*/, OO = /,? & /, MO = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, RO = /[()=,{}\[\]\/\s]/, PO = /\\(\\)?/g, NO = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, yb = /\w*$/, IO = /^[-+]0x[0-9a-f]+$/i, LO = /^0b[01]+$/i, DO = /^\[object .+?Constructor\]$/, jO = /^0o[0-7]+$/i, BO = /^(?:0|[1-9]\d*)$/, $O = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Rd = /($^)/, zO = /['\n\r\u2028\u2029\\]/g, Pd = "\\ud800-\\udfff", FO = "\\u0300-\\u036f", HO = "\\ufe20-\\ufe2f", VO = "\\u20d0-\\u20ff", vb = FO + HO + VO, bb = "\\u2700-\\u27bf", wb = "a-z\\xdf-\\xf6\\xf8-\\xff", WO = "\\xac\\xb1\\xd7\\xf7", UO = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", KO = "\\u2000-\\u206f", qO = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", xb = "A-Z\\xc0-\\xd6\\xd8-\\xde", _b = "\\ufe0e\\ufe0f", Sb = WO + UO + KO + qO, Vm = "[']", GO = "[" + Pd + "]", kb = "[" + Sb + "]", Nd = "[" + vb + "]", Cb = "\\d+", JO = "[" + bb + "]", Eb = "[" + wb + "]", Tb = "[^" + Pd + Sb + Cb + bb + wb + xb + "]", Wm = "\\ud83c[\\udffb-\\udfff]", ZO = "(?:" + Nd + "|" + Wm + ")", Ab = "[^" + Pd + "]", Um = "(?:\\ud83c[\\udde6-\\uddff]){2}", Km = "[\\ud800-\\udbff][\\udc00-\\udfff]", Za = "[" + xb + "]", Ob = "\\u200d", Mb = "(?:" + Eb + "|" + Tb + ")", YO = "(?:" + Za + "|" + Tb + ")", Rb = "(?:" + Vm + "(?:d|ll|m|re|s|t|ve))?", Pb = "(?:" + Vm + "(?:D|LL|M|RE|S|T|VE))?", Nb = ZO + "?", Ib = "[" + _b + "]?", XO = "(?:" + Ob + "(?:" + [Ab, Um, Km].join("|") + ")" + Ib + Nb + ")*", QO = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", e8 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Lb = Ib + Nb + XO, t8 = "(?:" + [JO, Um, Km].join("|") + ")" + Lb, n8 = "(?:" + [Ab + Nd + "?", Nd, Um, Km, GO].join("|") + ")", r8 = RegExp(Vm, "g"), i8 = RegExp(Nd, "g"), qm = RegExp(Wm + "(?=" + Wm + ")|" + n8 + Lb, "g"), s8 = RegExp([Za + "?" + Eb + "+" + Rb + "(?=" + [kb, Za, "$"].join("|") + ")", YO + "+" + Pb + "(?=" + [kb, Za + Mb, "$"].join("|") + ")", Za + "?" + Mb + "+" + Rb, Za + "+" + Pb, e8, QO, Cb, t8].join("|"), "g"), o8 = RegExp("[" + Ob + Pd + vb + _b + "]"), a8 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, l8 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], u8 = -1, Gt = {};
        Gt[Et] = Gt[Mn] = Gt[dn] = Gt[rr] = Gt[Rn] = Gt[us] = Gt[Ja] = Gt[Pn] = Gt[mr] = !0,
            Gt[Ye] = Gt[Qe] = Gt[nt] = Gt[he] = Gt[bt] = Gt[ge] = Gt[st] = Gt[xt] = Gt[B] = Gt[J] = Gt[X] = Gt[pe] = Gt[fe] = Gt[ue] = Gt[Oe] = !1;
        var Ht = {};
        Ht[Ye] = Ht[Qe] = Ht[nt] = Ht[bt] = Ht[he] = Ht[ge] = Ht[Et] = Ht[Mn] = Ht[dn] = Ht[rr] = Ht[Rn] = Ht[B] = Ht[J] = Ht[X] = Ht[pe] = Ht[fe] = Ht[ue] = Ht[Ne] = Ht[us] = Ht[Ja] = Ht[Pn] = Ht[mr] = !0,
            Ht[st] = Ht[xt] = Ht[Oe] = !1;
        var c8 = {
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "C",
            : "c",
            : "D",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "N",
            : "n",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "Y",
            : "y",
            : "y",
            : "Ae",
            : "ae",
            : "Th",
            : "th",
            : "ss",
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "C",
            : "C",
            : "C",
            : "C",
            : "c",
            : "c",
            : "c",
            : "c",
            : "D",
            : "D",
            : "d",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "G",
            : "G",
            : "G",
            : "G",
            : "g",
            : "g",
            : "g",
            : "g",
            : "H",
            : "H",
            : "h",
            : "h",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "J",
            : "j",
            : "K",
            : "k",
            : "k",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "N",
            : "N",
            : "N",
            : "N",
            : "n",
            : "n",
            : "n",
            : "n",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "R",
            : "R",
            : "R",
            : "r",
            : "r",
            : "r",
            : "S",
            : "S",
            : "S",
            : "S",
            : "s",
            : "s",
            : "s",
            : "s",
            : "T",
            : "T",
            : "T",
            : "t",
            : "t",
            : "t",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "W",
            : "w",
            : "Y",
            : "y",
            : "Y",
            : "Z",
            : "Z",
            : "Z",
            : "z",
            : "z",
            : "z",
            : "IJ",
            : "ij",
            : "Oe",
            : "oe",
            : "'n",
            : "s"
        }
            , d8 = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            }
            , f8 = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
            }
            , h8 = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
            }
            , p8 = parseFloat
            , m8 = parseInt
            , Db = typeof ua == "object" && ua && ua.Object === Object && ua
            , g8 = typeof self == "object" && self && self.Object === Object && self
            , Nn = Db || g8 || Function("return this")()
            , Gm = e && !e.nodeType && e
            , Zo = Gm && !0 && t && !t.nodeType && t
            , jb = Zo && Zo.exports === Gm
            , Jm = jb && Db.process
            , Vr = function () {
                try {
                    var U = Zo && Zo.require && Zo.require("util").types;
                    return U || Jm && Jm.binding && Jm.binding("util")
                } catch { }
            }()
            , Bb = Vr && Vr.isArrayBuffer
            , $b = Vr && Vr.isDate
            , zb = Vr && Vr.isMap
            , Fb = Vr && Vr.isRegExp
            , Hb = Vr && Vr.isSet
            , Vb = Vr && Vr.isTypedArray;
        function Or(U, Q, Z) {
            switch (Z.length) {
                case 0:
                    return U.call(Q);
                case 1:
                    return U.call(Q, Z[0]);
                case 2:
                    return U.call(Q, Z[0], Z[1]);
                case 3:
                    return U.call(Q, Z[0], Z[1], Z[2])
            }
            return U.apply(Q, Z)
        }
        function y8(U, Q, Z, Ce) {
            for (var et = -1, At = U == null ? 0 : U.length; ++et < At;) {
                var gn = U[et];
                Q(Ce, gn, Z(gn), U)
            }
            return Ce
        }
        function Wr(U, Q) {
            for (var Z = -1, Ce = U == null ? 0 : U.length; ++Z < Ce && Q(U[Z], Z, U) !== !1;)
                ;
            return U
        }
        function v8(U, Q) {
            for (var Z = U == null ? 0 : U.length; Z-- && Q(U[Z], Z, U) !== !1;)
                ;
            return U
        }
        function Wb(U, Q) {
            for (var Z = -1, Ce = U == null ? 0 : U.length; ++Z < Ce;)
                if (!Q(U[Z], Z, U))
                    return !1;
            return !0
        }
        function Fs(U, Q) {
            for (var Z = -1, Ce = U == null ? 0 : U.length, et = 0, At = []; ++Z < Ce;) {
                var gn = U[Z];
                Q(gn, Z, U) && (At[et++] = gn)
            }
            return At
        }
        function Id(U, Q) {
            var Z = U == null ? 0 : U.length;
            return !!Z && Ya(U, Q, 0) > -1
        }
        function Zm(U, Q, Z) {
            for (var Ce = -1, et = U == null ? 0 : U.length; ++Ce < et;)
                if (Z(Q, U[Ce]))
                    return !0;
            return !1
        }
        function Jt(U, Q) {
            for (var Z = -1, Ce = U == null ? 0 : U.length, et = Array(Ce); ++Z < Ce;)
                et[Z] = Q(U[Z], Z, U);
            return et
        }
        function Hs(U, Q) {
            for (var Z = -1, Ce = Q.length, et = U.length; ++Z < Ce;)
                U[et + Z] = Q[Z];
            return U
        }
        function Ym(U, Q, Z, Ce) {
            var et = -1
                , At = U == null ? 0 : U.length;
            for (Ce && At && (Z = U[++et]); ++et < At;)
                Z = Q(Z, U[et], et, U);
            return Z
        }
        function b8(U, Q, Z, Ce) {
            var et = U == null ? 0 : U.length;
            for (Ce && et && (Z = U[--et]); et--;)
                Z = Q(Z, U[et], et, U);
            return Z
        }
        function Xm(U, Q) {
            for (var Z = -1, Ce = U == null ? 0 : U.length; ++Z < Ce;)
                if (Q(U[Z], Z, U))
                    return !0;
            return !1
        }
        var w8 = Qm("length");
        function x8(U) {
            return U.split("")
        }
        function _8(U) {
            return U.match(MO) || []
        }
        function Ub(U, Q, Z) {
            var Ce;
            return Z(U, function (et, At, gn) {
                if (Q(et, At, gn))
                    return Ce = At,
                        !1
            }),
                Ce
        }
        function Ld(U, Q, Z, Ce) {
            for (var et = U.length, At = Z + (Ce ? 1 : -1); Ce ? At-- : ++At < et;)
                if (Q(U[At], At, U))
                    return At;
            return -1
        }
        function Ya(U, Q, Z) {
            return Q === Q ? I8(U, Q, Z) : Ld(U, Kb, Z)
        }
        function S8(U, Q, Z, Ce) {
            for (var et = Z - 1, At = U.length; ++et < At;)
                if (Ce(U[et], Q))
                    return et;
            return -1
        }
        function Kb(U) {
            return U !== U
        }
        function qb(U, Q) {
            var Z = U == null ? 0 : U.length;
            return Z ? tg(U, Q) / Z : Te
        }
        function Qm(U) {
            return function (Q) {
                return Q == null ? n : Q[U]
            }
        }
        function eg(U) {
            return function (Q) {
                return U == null ? n : U[Q]
            }
        }
        function Gb(U, Q, Z, Ce, et) {
            return et(U, function (At, gn, Bt) {
                Z = Ce ? (Ce = !1,
                    At) : Q(Z, At, gn, Bt)
            }),
                Z
        }
        function k8(U, Q) {
            var Z = U.length;
            for (U.sort(Q); Z--;)
                U[Z] = U[Z].value;
            return U
        }
        function tg(U, Q) {
            for (var Z, Ce = -1, et = U.length; ++Ce < et;) {
                var At = Q(U[Ce]);
                At !== n && (Z = Z === n ? At : Z + At)
            }
            return Z
        }
        function ng(U, Q) {
            for (var Z = -1, Ce = Array(U); ++Z < U;)
                Ce[Z] = Q(Z);
            return Ce
        }
        function C8(U, Q) {
            return Jt(Q, function (Z) {
                return [Z, U[Z]]
            })
        }
        function Jb(U) {
            return U && U.slice(0, Qb(U) + 1).replace(Hm, "")
        }
        function Mr(U) {
            return function (Q) {
                return U(Q)
            }
        }
        function rg(U, Q) {
            return Jt(Q, function (Z) {
                return U[Z]
            })
        }
        function wu(U, Q) {
            return U.has(Q)
        }
        function Zb(U, Q) {
            for (var Z = -1, Ce = U.length; ++Z < Ce && Ya(Q, U[Z], 0) > -1;)
                ;
            return Z
        }
        function Yb(U, Q) {
            for (var Z = U.length; Z-- && Ya(Q, U[Z], 0) > -1;)
                ;
            return Z
        }
        function E8(U, Q) {
            for (var Z = U.length, Ce = 0; Z--;)
                U[Z] === Q && ++Ce;
            return Ce
        }
        var T8 = eg(c8)
            , A8 = eg(d8);
        function O8(U) {
            return "\\" + h8[U]
        }
        function M8(U, Q) {
            return U == null ? n : U[Q]
        }
        function Xa(U) {
            return o8.test(U)
        }
        function R8(U) {
            return a8.test(U)
        }
        function P8(U) {
            for (var Q, Z = []; !(Q = U.next()).done;)
                Z.push(Q.value);
            return Z
        }
        function ig(U) {
            var Q = -1
                , Z = Array(U.size);
            return U.forEach(function (Ce, et) {
                Z[++Q] = [et, Ce]
            }),
                Z
        }
        function Xb(U, Q) {
            return function (Z) {
                return U(Q(Z))
            }
        }
        function Vs(U, Q) {
            for (var Z = -1, Ce = U.length, et = 0, At = []; ++Z < Ce;) {
                var gn = U[Z];
                (gn === Q || gn === d) && (U[Z] = d,
                    At[et++] = Z)
            }
            return At
        }
        function Dd(U) {
            var Q = -1
                , Z = Array(U.size);
            return U.forEach(function (Ce) {
                Z[++Q] = Ce
            }),
                Z
        }
        function N8(U) {
            var Q = -1
                , Z = Array(U.size);
            return U.forEach(function (Ce) {
                Z[++Q] = [Ce, Ce]
            }),
                Z
        }
        function I8(U, Q, Z) {
            for (var Ce = Z - 1, et = U.length; ++Ce < et;)
                if (U[Ce] === Q)
                    return Ce;
            return -1
        }
        function L8(U, Q, Z) {
            for (var Ce = Z + 1; Ce--;)
                if (U[Ce] === Q)
                    return Ce;
            return Ce
        }
        function Qa(U) {
            return Xa(U) ? j8(U) : w8(U)
        }
        function fi(U) {
            return Xa(U) ? B8(U) : x8(U)
        }
        function Qb(U) {
            for (var Q = U.length; Q-- && EO.test(U.charAt(Q));)
                ;
            return Q
        }
        var D8 = eg(f8);
        function j8(U) {
            for (var Q = qm.lastIndex = 0; qm.test(U);)
                ++Q;
            return Q
        }
        function B8(U) {
            return U.match(qm) || []
        }
        function $8(U) {
            return U.match(s8) || []
        }
        var z8 = function U(Q) {
            Q = Q == null ? Nn : el.defaults(Nn.Object(), Q, el.pick(Nn, l8));
            var Z = Q.Array
                , Ce = Q.Date
                , et = Q.Error
                , At = Q.Function
                , gn = Q.Math
                , Bt = Q.Object
                , sg = Q.RegExp
                , F8 = Q.String
                , Ur = Q.TypeError
                , jd = Z.prototype
                , H8 = At.prototype
                , tl = Bt.prototype
                , Bd = Q["__core-js_shared__"]
                , $d = H8.toString
                , It = tl.hasOwnProperty
                , V8 = 0
                , e2 = function () {
                    var u = /[^.]+$/.exec(Bd && Bd.keys && Bd.keys.IE_PROTO || "");
                    return u ? "Symbol(src)_1." + u : ""
                }()
                , zd = tl.toString
                , W8 = $d.call(Bt)
                , U8 = Nn._
                , K8 = sg("^" + $d.call(It).replace(Fm, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
                , Fd = jb ? Q.Buffer : n
                , Ws = Q.Symbol
                , Hd = Q.Uint8Array
                , t2 = Fd ? Fd.allocUnsafe : n
                , Vd = Xb(Bt.getPrototypeOf, Bt)
                , n2 = Bt.create
                , r2 = tl.propertyIsEnumerable
                , Wd = jd.splice
                , i2 = Ws ? Ws.isConcatSpreadable : n
                , xu = Ws ? Ws.iterator : n
                , Yo = Ws ? Ws.toStringTag : n
                , Ud = function () {
                    try {
                        var u = na(Bt, "defineProperty");
                        return u({}, "", {}),
                            u
                    } catch { }
                }()
                , q8 = Q.clearTimeout !== Nn.clearTimeout && Q.clearTimeout
                , G8 = Ce && Ce.now !== Nn.Date.now && Ce.now
                , J8 = Q.setTimeout !== Nn.setTimeout && Q.setTimeout
                , Kd = gn.ceil
                , qd = gn.floor
                , og = Bt.getOwnPropertySymbols
                , Z8 = Fd ? Fd.isBuffer : n
                , s2 = Q.isFinite
                , Y8 = jd.join
                , X8 = Xb(Bt.keys, Bt)
                , yn = gn.max
                , Un = gn.min
                , Q8 = Ce.now
                , eM = Q.parseInt
                , o2 = gn.random
                , tM = jd.reverse
                , ag = na(Q, "DataView")
                , _u = na(Q, "Map")
                , lg = na(Q, "Promise")
                , nl = na(Q, "Set")
                , Su = na(Q, "WeakMap")
                , ku = na(Bt, "create")
                , Gd = Su && new Su
                , rl = {}
                , nM = ra(ag)
                , rM = ra(_u)
                , iM = ra(lg)
                , sM = ra(nl)
                , oM = ra(Su)
                , Jd = Ws ? Ws.prototype : n
                , Cu = Jd ? Jd.valueOf : n
                , a2 = Jd ? Jd.toString : n;
            function I(u) {
                if (tn(u) && !rt(u) && !(u instanceof wt)) {
                    if (u instanceof Kr)
                        return u;
                    if (It.call(u, "__wrapped__"))
                        return lw(u)
                }
                return new Kr(u)
            }
            var il = function () {
                function u() { }
                return function (f) {
                    if (!Xt(f))
                        return {};
                    if (n2)
                        return n2(f);
                    u.prototype = f;
                    var v = new u;
                    return u.prototype = n,
                        v
                }
            }();
            function Zd() { }
            function Kr(u, f) {
                this.__wrapped__ = u,
                    this.__actions__ = [],
                    this.__chain__ = !!f,
                    this.__index__ = 0,
                    this.__values__ = n
            }
            I.templateSettings = {
                escape: wO,
                evaluate: xO,
                interpolate: gb,
                variable: "",
                imports: {
                    _: I
                }
            },
                I.prototype = Zd.prototype,
                I.prototype.constructor = I,
                Kr.prototype = il(Zd.prototype),
                Kr.prototype.constructor = Kr;
            function wt(u) {
                this.__wrapped__ = u,
                    this.__actions__ = [],
                    this.__dir__ = 1,
                    this.__filtered__ = !1,
                    this.__iteratees__ = [],
                    this.__takeCount__ = ee,
                    this.__views__ = []
            }
            function aM() {
                var u = new wt(this.__wrapped__);
                return u.__actions__ = gr(this.__actions__),
                    u.__dir__ = this.__dir__,
                    u.__filtered__ = this.__filtered__,
                    u.__iteratees__ = gr(this.__iteratees__),
                    u.__takeCount__ = this.__takeCount__,
                    u.__views__ = gr(this.__views__),
                    u
            }
            function lM() {
                if (this.__filtered__) {
                    var u = new wt(this);
                    u.__dir__ = -1,
                        u.__filtered__ = !0
                } else
                    u = this.clone(),
                        u.__dir__ *= -1;
                return u
            }
            function uM() {
                var u = this.__wrapped__.value()
                    , f = this.__dir__
                    , v = rt(u)
                    , _ = f < 0
                    , R = v ? u.length : 0
                    , L = xR(0, R, this.__views__)
                    , $ = L.start
                    , H = L.end
                    , q = H - $
                    , te = _ ? H : $ - 1
                    , ne = this.__iteratees__
                    , le = ne.length
                    , xe = 0
                    , Pe = Un(q, this.__takeCount__);
                if (!v || !_ && R == q && Pe == q)
                    return R2(u, this.__actions__);
                var Fe = [];
                e: for (; q-- && xe < Pe;) {
                    te += f;
                    for (var ut = -1, He = u[te]; ++ut < le;) {
                        var yt = ne[ut]
                            , _t = yt.iteratee
                            , Nr = yt.type
                            , or = _t(He);
                        if (Nr == W)
                            He = or;
                        else if (!or) {
                            if (Nr == V)
                                continue e;
                            break e
                        }
                    }
                    Fe[xe++] = He
                }
                return Fe
            }
            wt.prototype = il(Zd.prototype),
                wt.prototype.constructor = wt;
            function Xo(u) {
                var f = -1
                    , v = u == null ? 0 : u.length;
                for (this.clear(); ++f < v;) {
                    var _ = u[f];
                    this.set(_[0], _[1])
                }
            }
            function cM() {
                this.__data__ = ku ? ku(null) : {},
                    this.size = 0
            }
            function dM(u) {
                var f = this.has(u) && delete this.__data__[u];
                return this.size -= f ? 1 : 0,
                    f
            }
            function fM(u) {
                var f = this.__data__;
                if (ku) {
                    var v = f[u];
                    return v === l ? n : v
                }
                return It.call(f, u) ? f[u] : n
            }
            function hM(u) {
                var f = this.__data__;
                return ku ? f[u] !== n : It.call(f, u)
            }
            function pM(u, f) {
                var v = this.__data__;
                return this.size += this.has(u) ? 0 : 1,
                    v[u] = ku && f === n ? l : f,
                    this
            }
            Xo.prototype.clear = cM,
                Xo.prototype.delete = dM,
                Xo.prototype.get = fM,
                Xo.prototype.has = hM,
                Xo.prototype.set = pM;
            function cs(u) {
                var f = -1
                    , v = u == null ? 0 : u.length;
                for (this.clear(); ++f < v;) {
                    var _ = u[f];
                    this.set(_[0], _[1])
                }
            }
            function mM() {
                this.__data__ = [],
                    this.size = 0
            }
            function gM(u) {
                var f = this.__data__
                    , v = Yd(f, u);
                if (v < 0)
                    return !1;
                var _ = f.length - 1;
                return v == _ ? f.pop() : Wd.call(f, v, 1),
                    --this.size,
                    !0
            }
            function yM(u) {
                var f = this.__data__
                    , v = Yd(f, u);
                return v < 0 ? n : f[v][1]
            }
            function vM(u) {
                return Yd(this.__data__, u) > -1
            }
            function bM(u, f) {
                var v = this.__data__
                    , _ = Yd(v, u);
                return _ < 0 ? (++this.size,
                    v.push([u, f])) : v[_][1] = f,
                    this
            }
            cs.prototype.clear = mM,
                cs.prototype.delete = gM,
                cs.prototype.get = yM,
                cs.prototype.has = vM,
                cs.prototype.set = bM;
            function ds(u) {
                var f = -1
                    , v = u == null ? 0 : u.length;
                for (this.clear(); ++f < v;) {
                    var _ = u[f];
                    this.set(_[0], _[1])
                }
            }
            function wM() {
                this.size = 0,
                    this.__data__ = {
                        hash: new Xo,
                        map: new (_u || cs),
                        string: new Xo
                    }
            }
            function xM(u) {
                var f = cf(this, u).delete(u);
                return this.size -= f ? 1 : 0,
                    f
            }
            function _M(u) {
                return cf(this, u).get(u)
            }
            function SM(u) {
                return cf(this, u).has(u)
            }
            function kM(u, f) {
                var v = cf(this, u)
                    , _ = v.size;
                return v.set(u, f),
                    this.size += v.size == _ ? 0 : 1,
                    this
            }
            ds.prototype.clear = wM,
                ds.prototype.delete = xM,
                ds.prototype.get = _M,
                ds.prototype.has = SM,
                ds.prototype.set = kM;
            function Qo(u) {
                var f = -1
                    , v = u == null ? 0 : u.length;
                for (this.__data__ = new ds; ++f < v;)
                    this.add(u[f])
            }
            function CM(u) {
                return this.__data__.set(u, l),
                    this
            }
            function EM(u) {
                return this.__data__.has(u)
            }
            Qo.prototype.add = Qo.prototype.push = CM,
                Qo.prototype.has = EM;
            function hi(u) {
                var f = this.__data__ = new cs(u);
                this.size = f.size
            }
            function TM() {
                this.__data__ = new cs,
                    this.size = 0
            }
            function AM(u) {
                var f = this.__data__
                    , v = f.delete(u);
                return this.size = f.size,
                    v
            }
            function OM(u) {
                return this.__data__.get(u)
            }
            function MM(u) {
                return this.__data__.has(u)
            }
            function RM(u, f) {
                var v = this.__data__;
                if (v instanceof cs) {
                    var _ = v.__data__;
                    if (!_u || _.length < i - 1)
                        return _.push([u, f]),
                            this.size = ++v.size,
                            this;
                    v = this.__data__ = new ds(_)
                }
                return v.set(u, f),
                    this.size = v.size,
                    this
            }
            hi.prototype.clear = TM,
                hi.prototype.delete = AM,
                hi.prototype.get = OM,
                hi.prototype.has = MM,
                hi.prototype.set = RM;
            function l2(u, f) {
                var v = rt(u)
                    , _ = !v && ia(u)
                    , R = !v && !_ && Js(u)
                    , L = !v && !_ && !R && ll(u)
                    , $ = v || _ || R || L
                    , H = $ ? ng(u.length, F8) : []
                    , q = H.length;
                for (var te in u)
                    (f || It.call(u, te)) && !($ && (te == "length" || R && (te == "offset" || te == "parent") || L && (te == "buffer" || te == "byteLength" || te == "byteOffset") || ms(te, q))) && H.push(te);
                return H
            }
            function u2(u) {
                var f = u.length;
                return f ? u[bg(0, f - 1)] : n
            }
            function PM(u, f) {
                return df(gr(u), ea(f, 0, u.length))
            }
            function NM(u) {
                return df(gr(u))
            }
            function ug(u, f, v) {
                (v !== n && !pi(u[f], v) || v === n && !(f in u)) && fs(u, f, v)
            }
            function Eu(u, f, v) {
                var _ = u[f];
                (!(It.call(u, f) && pi(_, v)) || v === n && !(f in u)) && fs(u, f, v)
            }
            function Yd(u, f) {
                for (var v = u.length; v--;)
                    if (pi(u[v][0], f))
                        return v;
                return -1
            }
            function IM(u, f, v, _) {
                return Us(u, function (R, L, $) {
                    f(_, R, v(R), $)
                }),
                    _
            }
            function c2(u, f) {
                return u && Li(f, Sn(f), u)
            }
            function LM(u, f) {
                return u && Li(f, vr(f), u)
            }
            function fs(u, f, v) {
                f == "__proto__" && Ud ? Ud(u, f, {
                    configurable: !0,
                    enumerable: !0,
                    value: v,
                    writable: !0
                }) : u[f] = v
            }
            function cg(u, f) {
                for (var v = -1, _ = f.length, R = Z(_), L = u == null; ++v < _;)
                    R[v] = L ? n : Wg(u, f[v]);
                return R
            }
            function ea(u, f, v) {
                return u === u && (v !== n && (u = u <= v ? u : v),
                    f !== n && (u = u >= f ? u : f)),
                    u
            }
            function qr(u, f, v, _, R, L) {
                var $, H = f & h, q = f & p, te = f & g;
                if (v && ($ = R ? v(u, _, R, L) : v(u)),
                    $ !== n)
                    return $;
                if (!Xt(u))
                    return u;
                var ne = rt(u);
                if (ne) {
                    if ($ = SR(u),
                        !H)
                        return gr(u, $)
                } else {
                    var le = Kn(u)
                        , xe = le == xt || le == D;
                    if (Js(u))
                        return I2(u, H);
                    if (le == X || le == Ye || xe && !R) {
                        if ($ = q || xe ? {} : Q2(u),
                            !H)
                            return q ? fR(u, LM($, u)) : dR(u, c2($, u))
                    } else {
                        if (!Ht[le])
                            return R ? u : {};
                        $ = kR(u, le, H)
                    }
                }
                L || (L = new hi);
                var Pe = L.get(u);
                if (Pe)
                    return Pe;
                L.set(u, $),
                    Aw(u) ? u.forEach(function (He) {
                        $.add(qr(He, f, v, He, u, L))
                    }) : Ew(u) && u.forEach(function (He, yt) {
                        $.set(yt, qr(He, f, v, yt, u, L))
                    });
                var Fe = te ? q ? Mg : Og : q ? vr : Sn
                    , ut = ne ? n : Fe(u);
                return Wr(ut || u, function (He, yt) {
                    ut && (yt = He,
                        He = u[yt]),
                        Eu($, yt, qr(He, f, v, yt, u, L))
                }),
                    $
            }
            function DM(u) {
                var f = Sn(u);
                return function (v) {
                    return d2(v, u, f)
                }
            }
            function d2(u, f, v) {
                var _ = v.length;
                if (u == null)
                    return !_;
                for (u = Bt(u); _--;) {
                    var R = v[_]
                        , L = f[R]
                        , $ = u[R];
                    if ($ === n && !(R in u) || !L($))
                        return !1
                }
                return !0
            }
            function f2(u, f, v) {
                if (typeof u != "function")
                    throw new Ur(o);
                return Nu(function () {
                    u.apply(n, v)
                }, f)
            }
            function Tu(u, f, v, _) {
                var R = -1
                    , L = Id
                    , $ = !0
                    , H = u.length
                    , q = []
                    , te = f.length;
                if (!H)
                    return q;
                v && (f = Jt(f, Mr(v))),
                    _ ? (L = Zm,
                        $ = !1) : f.length >= i && (L = wu,
                            $ = !1,
                            f = new Qo(f));
                e: for (; ++R < H;) {
                    var ne = u[R]
                        , le = v == null ? ne : v(ne);
                    if (ne = _ || ne !== 0 ? ne : 0,
                        $ && le === le) {
                        for (var xe = te; xe--;)
                            if (f[xe] === le)
                                continue e;
                        q.push(ne)
                    } else
                        L(f, le, _) || q.push(ne)
                }
                return q
            }
            var Us = $2(Ii)
                , h2 = $2(fg, !0);
            function jM(u, f) {
                var v = !0;
                return Us(u, function (_, R, L) {
                    return v = !!f(_, R, L),
                        v
                }),
                    v
            }
            function Xd(u, f, v) {
                for (var _ = -1, R = u.length; ++_ < R;) {
                    var L = u[_]
                        , $ = f(L);
                    if ($ != null && (H === n ? $ === $ && !Pr($) : v($, H)))
                        var H = $
                            , q = L
                }
                return q
            }
            function BM(u, f, v, _) {
                var R = u.length;
                for (v = lt(v),
                    v < 0 && (v = -v > R ? 0 : R + v),
                    _ = _ === n || _ > R ? R : lt(_),
                    _ < 0 && (_ += R),
                    _ = v > _ ? 0 : Mw(_); v < _;)
                    u[v++] = f;
                return u
            }
            function p2(u, f) {
                var v = [];
                return Us(u, function (_, R, L) {
                    f(_, R, L) && v.push(_)
                }),
                    v
            }
            function In(u, f, v, _, R) {
                var L = -1
                    , $ = u.length;
                for (v || (v = ER),
                    R || (R = []); ++L < $;) {
                    var H = u[L];
                    f > 0 && v(H) ? f > 1 ? In(H, f - 1, v, _, R) : Hs(R, H) : _ || (R[R.length] = H)
                }
                return R
            }
            var dg = z2()
                , m2 = z2(!0);
            function Ii(u, f) {
                return u && dg(u, f, Sn)
            }
            function fg(u, f) {
                return u && m2(u, f, Sn)
            }
            function Qd(u, f) {
                return Fs(f, function (v) {
                    return gs(u[v])
                })
            }
            function ta(u, f) {
                f = qs(f, u);
                for (var v = 0, _ = f.length; u != null && v < _;)
                    u = u[Di(f[v++])];
                return v && v == _ ? u : n
            }
            function g2(u, f, v) {
                var _ = f(u);
                return rt(u) ? _ : Hs(_, v(u))
            }
            function ir(u) {
                return u == null ? u === n ? we : ae : Yo && Yo in Bt(u) ? wR(u) : NR(u)
            }
            function hg(u, f) {
                return u > f
            }
            function $M(u, f) {
                return u != null && It.call(u, f)
            }
            function zM(u, f) {
                return u != null && f in Bt(u)
            }
            function FM(u, f, v) {
                return u >= Un(f, v) && u < yn(f, v)
            }
            function pg(u, f, v) {
                for (var _ = v ? Zm : Id, R = u[0].length, L = u.length, $ = L, H = Z(L), q = 1 / 0, te = []; $--;) {
                    var ne = u[$];
                    $ && f && (ne = Jt(ne, Mr(f))),
                        q = Un(ne.length, q),
                        H[$] = !v && (f || R >= 120 && ne.length >= 120) ? new Qo($ && ne) : n
                }
                ne = u[0];
                var le = -1
                    , xe = H[0];
                e: for (; ++le < R && te.length < q;) {
                    var Pe = ne[le]
                        , Fe = f ? f(Pe) : Pe;
                    if (Pe = v || Pe !== 0 ? Pe : 0,
                        !(xe ? wu(xe, Fe) : _(te, Fe, v))) {
                        for ($ = L; --$;) {
                            var ut = H[$];
                            if (!(ut ? wu(ut, Fe) : _(u[$], Fe, v)))
                                continue e
                        }
                        xe && xe.push(Fe),
                            te.push(Pe)
                    }
                }
                return te
            }
            function HM(u, f, v, _) {
                return Ii(u, function (R, L, $) {
                    f(_, v(R), L, $)
                }),
                    _
            }
            function Au(u, f, v) {
                f = qs(f, u),
                    u = rw(u, f);
                var _ = u == null ? u : u[Di(Jr(f))];
                return _ == null ? n : Or(_, u, v)
            }
            function y2(u) {
                return tn(u) && ir(u) == Ye
            }
            function VM(u) {
                return tn(u) && ir(u) == nt
            }
            function WM(u) {
                return tn(u) && ir(u) == ge
            }
            function Ou(u, f, v, _, R) {
                return u === f ? !0 : u == null || f == null || !tn(u) && !tn(f) ? u !== u && f !== f : UM(u, f, v, _, Ou, R)
            }
            function UM(u, f, v, _, R, L) {
                var $ = rt(u)
                    , H = rt(f)
                    , q = $ ? Qe : Kn(u)
                    , te = H ? Qe : Kn(f);
                q = q == Ye ? X : q,
                    te = te == Ye ? X : te;
                var ne = q == X
                    , le = te == X
                    , xe = q == te;
                if (xe && Js(u)) {
                    if (!Js(f))
                        return !1;
                    $ = !0,
                        ne = !1
                }
                if (xe && !ne)
                    return L || (L = new hi),
                        $ || ll(u) ? Z2(u, f, v, _, R, L) : vR(u, f, q, v, _, R, L);
                if (!(v & y)) {
                    var Pe = ne && It.call(u, "__wrapped__")
                        , Fe = le && It.call(f, "__wrapped__");
                    if (Pe || Fe) {
                        var ut = Pe ? u.value() : u
                            , He = Fe ? f.value() : f;
                        return L || (L = new hi),
                            R(ut, He, v, _, L)
                    }
                }
                return xe ? (L || (L = new hi),
                    bR(u, f, v, _, R, L)) : !1
            }
            function KM(u) {
                return tn(u) && Kn(u) == B
            }
            function mg(u, f, v, _) {
                var R = v.length
                    , L = R
                    , $ = !_;
                if (u == null)
                    return !L;
                for (u = Bt(u); R--;) {
                    var H = v[R];
                    if ($ && H[2] ? H[1] !== u[H[0]] : !(H[0] in u))
                        return !1
                }
                for (; ++R < L;) {
                    H = v[R];
                    var q = H[0]
                        , te = u[q]
                        , ne = H[1];
                    if ($ && H[2]) {
                        if (te === n && !(q in u))
                            return !1
                    } else {
                        var le = new hi;
                        if (_)
                            var xe = _(te, ne, q, u, f, le);
                        if (!(xe === n ? Ou(ne, te, y | x, _, le) : xe))
                            return !1
                    }
                }
                return !0
            }
            function v2(u) {
                if (!Xt(u) || AR(u))
                    return !1;
                var f = gs(u) ? K8 : DO;
                return f.test(ra(u))
            }
            function qM(u) {
                return tn(u) && ir(u) == pe
            }
            function GM(u) {
                return tn(u) && Kn(u) == fe
            }
            function JM(u) {
                return tn(u) && yf(u.length) && !!Gt[ir(u)]
            }
            function b2(u) {
                return typeof u == "function" ? u : u == null ? br : typeof u == "object" ? rt(u) ? _2(u[0], u[1]) : x2(u) : Fw(u)
            }
            function gg(u) {
                if (!Pu(u))
                    return X8(u);
                var f = [];
                for (var v in Bt(u))
                    It.call(u, v) && v != "constructor" && f.push(v);
                return f
            }
            function ZM(u) {
                if (!Xt(u))
                    return PR(u);
                var f = Pu(u)
                    , v = [];
                for (var _ in u)
                    _ == "constructor" && (f || !It.call(u, _)) || v.push(_);
                return v
            }
            function yg(u, f) {
                return u < f
            }
            function w2(u, f) {
                var v = -1
                    , _ = yr(u) ? Z(u.length) : [];
                return Us(u, function (R, L, $) {
                    _[++v] = f(R, L, $)
                }),
                    _
            }
            function x2(u) {
                var f = Pg(u);
                return f.length == 1 && f[0][2] ? tw(f[0][0], f[0][1]) : function (v) {
                    return v === u || mg(v, u, f)
                }
            }
            function _2(u, f) {
                return Ig(u) && ew(f) ? tw(Di(u), f) : function (v) {
                    var _ = Wg(v, u);
                    return _ === n && _ === f ? Ug(v, u) : Ou(f, _, y | x)
                }
            }
            function ef(u, f, v, _, R) {
                u !== f && dg(f, function (L, $) {
                    if (R || (R = new hi),
                        Xt(L))
                        YM(u, f, $, v, ef, _, R);
                    else {
                        var H = _ ? _(Dg(u, $), L, $ + "", u, f, R) : n;
                        H === n && (H = L),
                            ug(u, $, H)
                    }
                }, vr)
            }
            function YM(u, f, v, _, R, L, $) {
                var H = Dg(u, v)
                    , q = Dg(f, v)
                    , te = $.get(q);
                if (te) {
                    ug(u, v, te);
                    return
                }
                var ne = L ? L(H, q, v + "", u, f, $) : n
                    , le = ne === n;
                if (le) {
                    var xe = rt(q)
                        , Pe = !xe && Js(q)
                        , Fe = !xe && !Pe && ll(q);
                    ne = q,
                        xe || Pe || Fe ? rt(H) ? ne = H : an(H) ? ne = gr(H) : Pe ? (le = !1,
                            ne = I2(q, !0)) : Fe ? (le = !1,
                                ne = L2(q, !0)) : ne = [] : Iu(q) || ia(q) ? (ne = H,
                                    ia(H) ? ne = Rw(H) : (!Xt(H) || gs(H)) && (ne = Q2(q))) : le = !1
                }
                le && ($.set(q, ne),
                    R(ne, q, _, L, $),
                    $.delete(q)),
                    ug(u, v, ne)
            }
            function S2(u, f) {
                var v = u.length;
                if (v)
                    return f += f < 0 ? v : 0,
                        ms(f, v) ? u[f] : n
            }
            function k2(u, f, v) {
                f.length ? f = Jt(f, function (L) {
                    return rt(L) ? function ($) {
                        return ta($, L.length === 1 ? L[0] : L)
                    }
                        : L
                }) : f = [br];
                var _ = -1;
                f = Jt(f, Mr(Be()));
                var R = w2(u, function (L, $, H) {
                    var q = Jt(f, function (te) {
                        return te(L)
                    });
                    return {
                        criteria: q,
                        index: ++_,
                        value: L
                    }
                });
                return k8(R, function (L, $) {
                    return cR(L, $, v)
                })
            }
            function XM(u, f) {
                return C2(u, f, function (v, _) {
                    return Ug(u, _)
                })
            }
            function C2(u, f, v) {
                for (var _ = -1, R = f.length, L = {}; ++_ < R;) {
                    var $ = f[_]
                        , H = ta(u, $);
                    v(H, $) && Mu(L, qs($, u), H)
                }
                return L
            }
            function QM(u) {
                return function (f) {
                    return ta(f, u)
                }
            }
            function vg(u, f, v, _) {
                var R = _ ? S8 : Ya
                    , L = -1
                    , $ = f.length
                    , H = u;
                for (u === f && (f = gr(f)),
                    v && (H = Jt(u, Mr(v))); ++L < $;)
                    for (var q = 0, te = f[L], ne = v ? v(te) : te; (q = R(H, ne, q, _)) > -1;)
                        H !== u && Wd.call(H, q, 1),
                            Wd.call(u, q, 1);
                return u
            }
            function E2(u, f) {
                for (var v = u ? f.length : 0, _ = v - 1; v--;) {
                    var R = f[v];
                    if (v == _ || R !== L) {
                        var L = R;
                        ms(R) ? Wd.call(u, R, 1) : _g(u, R)
                    }
                }
                return u
            }
            function bg(u, f) {
                return u + qd(o2() * (f - u + 1))
            }
            function eR(u, f, v, _) {
                for (var R = -1, L = yn(Kd((f - u) / (v || 1)), 0), $ = Z(L); L--;)
                    $[_ ? L : ++R] = u,
                        u += v;
                return $
            }
            function wg(u, f) {
                var v = "";
                if (!u || f < 1 || f > K)
                    return v;
                do
                    f % 2 && (v += u),
                        f = qd(f / 2),
                        f && (u += u);
                while (f);
                return v
            }
            function ft(u, f) {
                return jg(nw(u, f, br), u + "")
            }
            function tR(u) {
                return u2(ul(u))
            }
            function nR(u, f) {
                var v = ul(u);
                return df(v, ea(f, 0, v.length))
            }
            function Mu(u, f, v, _) {
                if (!Xt(u))
                    return u;
                f = qs(f, u);
                for (var R = -1, L = f.length, $ = L - 1, H = u; H != null && ++R < L;) {
                    var q = Di(f[R])
                        , te = v;
                    if (q === "__proto__" || q === "constructor" || q === "prototype")
                        return u;
                    if (R != $) {
                        var ne = H[q];
                        te = _ ? _(ne, q, H) : n,
                            te === n && (te = Xt(ne) ? ne : ms(f[R + 1]) ? [] : {})
                    }
                    Eu(H, q, te),
                        H = H[q]
                }
                return u
            }
            var T2 = Gd ? function (u, f) {
                return Gd.set(u, f),
                    u
            }
                : br
                , rR = Ud ? function (u, f) {
                    return Ud(u, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: qg(f),
                        writable: !0
                    })
                }
                    : br;
            function iR(u) {
                return df(ul(u))
            }
            function Gr(u, f, v) {
                var _ = -1
                    , R = u.length;
                f < 0 && (f = -f > R ? 0 : R + f),
                    v = v > R ? R : v,
                    v < 0 && (v += R),
                    R = f > v ? 0 : v - f >>> 0,
                    f >>>= 0;
                for (var L = Z(R); ++_ < R;)
                    L[_] = u[_ + f];
                return L
            }
            function sR(u, f) {
                var v;
                return Us(u, function (_, R, L) {
                    return v = f(_, R, L),
                        !v
                }),
                    !!v
            }
            function tf(u, f, v) {
                var _ = 0
                    , R = u == null ? _ : u.length;
                if (typeof f == "number" && f === f && R <= Ze) {
                    for (; _ < R;) {
                        var L = _ + R >>> 1
                            , $ = u[L];
                        $ !== null && !Pr($) && (v ? $ <= f : $ < f) ? _ = L + 1 : R = L
                    }
                    return R
                }
                return xg(u, f, br, v)
            }
            function xg(u, f, v, _) {
                var R = 0
                    , L = u == null ? 0 : u.length;
                if (L === 0)
                    return 0;
                f = v(f);
                for (var $ = f !== f, H = f === null, q = Pr(f), te = f === n; R < L;) {
                    var ne = qd((R + L) / 2)
                        , le = v(u[ne])
                        , xe = le !== n
                        , Pe = le === null
                        , Fe = le === le
                        , ut = Pr(le);
                    if ($)
                        var He = _ || Fe;
                    else
                        te ? He = Fe && (_ || xe) : H ? He = Fe && xe && (_ || !Pe) : q ? He = Fe && xe && !Pe && (_ || !ut) : Pe || ut ? He = !1 : He = _ ? le <= f : le < f;
                    He ? R = ne + 1 : L = ne
                }
                return Un(L, Se)
            }
            function A2(u, f) {
                for (var v = -1, _ = u.length, R = 0, L = []; ++v < _;) {
                    var $ = u[v]
                        , H = f ? f($) : $;
                    if (!v || !pi(H, q)) {
                        var q = H;
                        L[R++] = $ === 0 ? 0 : $
                    }
                }
                return L
            }
            function O2(u) {
                return typeof u == "number" ? u : Pr(u) ? Te : +u
            }
            function Rr(u) {
                if (typeof u == "string")
                    return u;
                if (rt(u))
                    return Jt(u, Rr) + "";
                if (Pr(u))
                    return a2 ? a2.call(u) : "";
                var f = u + "";
                return f == "0" && 1 / u == -F ? "-0" : f
            }
            function Ks(u, f, v) {
                var _ = -1
                    , R = Id
                    , L = u.length
                    , $ = !0
                    , H = []
                    , q = H;
                if (v)
                    $ = !1,
                        R = Zm;
                else if (L >= i) {
                    var te = f ? null : gR(u);
                    if (te)
                        return Dd(te);
                    $ = !1,
                        R = wu,
                        q = new Qo
                } else
                    q = f ? [] : H;
                e: for (; ++_ < L;) {
                    var ne = u[_]
                        , le = f ? f(ne) : ne;
                    if (ne = v || ne !== 0 ? ne : 0,
                        $ && le === le) {
                        for (var xe = q.length; xe--;)
                            if (q[xe] === le)
                                continue e;
                        f && q.push(le),
                            H.push(ne)
                    } else
                        R(q, le, v) || (q !== H && q.push(le),
                            H.push(ne))
                }
                return H
            }
            function _g(u, f) {
                return f = qs(f, u),
                    u = rw(u, f),
                    u == null || delete u[Di(Jr(f))]
            }
            function M2(u, f, v, _) {
                return Mu(u, f, v(ta(u, f)), _)
            }
            function nf(u, f, v, _) {
                for (var R = u.length, L = _ ? R : -1; (_ ? L-- : ++L < R) && f(u[L], L, u);)
                    ;
                return v ? Gr(u, _ ? 0 : L, _ ? L + 1 : R) : Gr(u, _ ? L + 1 : 0, _ ? R : L)
            }
            function R2(u, f) {
                var v = u;
                return v instanceof wt && (v = v.value()),
                    Ym(f, function (_, R) {
                        return R.func.apply(R.thisArg, Hs([_], R.args))
                    }, v)
            }
            function Sg(u, f, v) {
                var _ = u.length;
                if (_ < 2)
                    return _ ? Ks(u[0]) : [];
                for (var R = -1, L = Z(_); ++R < _;)
                    for (var $ = u[R], H = -1; ++H < _;)
                        H != R && (L[R] = Tu(L[R] || $, u[H], f, v));
                return Ks(In(L, 1), f, v)
            }
            function P2(u, f, v) {
                for (var _ = -1, R = u.length, L = f.length, $ = {}; ++_ < R;) {
                    var H = _ < L ? f[_] : n;
                    v($, u[_], H)
                }
                return $
            }
            function kg(u) {
                return an(u) ? u : []
            }
            function Cg(u) {
                return typeof u == "function" ? u : br
            }
            function qs(u, f) {
                return rt(u) ? u : Ig(u, f) ? [u] : aw(Pt(u))
            }
            var oR = ft;
            function Gs(u, f, v) {
                var _ = u.length;
                return v = v === n ? _ : v,
                    !f && v >= _ ? u : Gr(u, f, v)
            }
            var N2 = q8 || function (u) {
                return Nn.clearTimeout(u)
            }
                ;
            function I2(u, f) {
                if (f)
                    return u.slice();
                var v = u.length
                    , _ = t2 ? t2(v) : new u.constructor(v);
                return u.copy(_),
                    _
            }
            function Eg(u) {
                var f = new u.constructor(u.byteLength);
                return new Hd(f).set(new Hd(u)),
                    f
            }
            function aR(u, f) {
                var v = f ? Eg(u.buffer) : u.buffer;
                return new u.constructor(v, u.byteOffset, u.byteLength)
            }
            function lR(u) {
                var f = new u.constructor(u.source, yb.exec(u));
                return f.lastIndex = u.lastIndex,
                    f
            }
            function uR(u) {
                return Cu ? Bt(Cu.call(u)) : {}
            }
            function L2(u, f) {
                var v = f ? Eg(u.buffer) : u.buffer;
                return new u.constructor(v, u.byteOffset, u.length)
            }
            function D2(u, f) {
                if (u !== f) {
                    var v = u !== n
                        , _ = u === null
                        , R = u === u
                        , L = Pr(u)
                        , $ = f !== n
                        , H = f === null
                        , q = f === f
                        , te = Pr(f);
                    if (!H && !te && !L && u > f || L && $ && q && !H && !te || _ && $ && q || !v && q || !R)
                        return 1;
                    if (!_ && !L && !te && u < f || te && v && R && !_ && !L || H && v && R || !$ && R || !q)
                        return -1
                }
                return 0
            }
            function cR(u, f, v) {
                for (var _ = -1, R = u.criteria, L = f.criteria, $ = R.length, H = v.length; ++_ < $;) {
                    var q = D2(R[_], L[_]);
                    if (q) {
                        if (_ >= H)
                            return q;
                        var te = v[_];
                        return q * (te == "desc" ? -1 : 1)
                    }
                }
                return u.index - f.index
            }
            function j2(u, f, v, _) {
                for (var R = -1, L = u.length, $ = v.length, H = -1, q = f.length, te = yn(L - $, 0), ne = Z(q + te), le = !_; ++H < q;)
                    ne[H] = f[H];
                for (; ++R < $;)
                    (le || R < L) && (ne[v[R]] = u[R]);
                for (; te--;)
                    ne[H++] = u[R++];
                return ne
            }
            function B2(u, f, v, _) {
                for (var R = -1, L = u.length, $ = -1, H = v.length, q = -1, te = f.length, ne = yn(L - H, 0), le = Z(ne + te), xe = !_; ++R < ne;)
                    le[R] = u[R];
                for (var Pe = R; ++q < te;)
                    le[Pe + q] = f[q];
                for (; ++$ < H;)
                    (xe || R < L) && (le[Pe + v[$]] = u[R++]);
                return le
            }
            function gr(u, f) {
                var v = -1
                    , _ = u.length;
                for (f || (f = Z(_)); ++v < _;)
                    f[v] = u[v];
                return f
            }
            function Li(u, f, v, _) {
                var R = !v;
                v || (v = {});
                for (var L = -1, $ = f.length; ++L < $;) {
                    var H = f[L]
                        , q = _ ? _(v[H], u[H], H, v, u) : n;
                    q === n && (q = u[H]),
                        R ? fs(v, H, q) : Eu(v, H, q)
                }
                return v
            }
            function dR(u, f) {
                return Li(u, Ng(u), f)
            }
            function fR(u, f) {
                return Li(u, Y2(u), f)
            }
            function rf(u, f) {
                return function (v, _) {
                    var R = rt(v) ? y8 : IM
                        , L = f ? f() : {};
                    return R(v, u, Be(_, 2), L)
                }
            }
            function sl(u) {
                return ft(function (f, v) {
                    var _ = -1
                        , R = v.length
                        , L = R > 1 ? v[R - 1] : n
                        , $ = R > 2 ? v[2] : n;
                    for (L = u.length > 3 && typeof L == "function" ? (R--,
                        L) : n,
                        $ && sr(v[0], v[1], $) && (L = R < 3 ? n : L,
                            R = 1),
                        f = Bt(f); ++_ < R;) {
                        var H = v[_];
                        H && u(f, H, _, L)
                    }
                    return f
                })
            }
            function $2(u, f) {
                return function (v, _) {
                    if (v == null)
                        return v;
                    if (!yr(v))
                        return u(v, _);
                    for (var R = v.length, L = f ? R : -1, $ = Bt(v); (f ? L-- : ++L < R) && _($[L], L, $) !== !1;)
                        ;
                    return v
                }
            }
            function z2(u) {
                return function (f, v, _) {
                    for (var R = -1, L = Bt(f), $ = _(f), H = $.length; H--;) {
                        var q = $[u ? H : ++R];
                        if (v(L[q], q, L) === !1)
                            break
                    }
                    return f
                }
            }
            function hR(u, f, v) {
                var _ = f & S
                    , R = Ru(u);
                function L() {
                    var $ = this && this !== Nn && this instanceof L ? R : u;
                    return $.apply(_ ? v : this, arguments)
                }
                return L
            }
            function F2(u) {
                return function (f) {
                    f = Pt(f);
                    var v = Xa(f) ? fi(f) : n
                        , _ = v ? v[0] : f.charAt(0)
                        , R = v ? Gs(v, 1).join("") : f.slice(1);
                    return _[u]() + R
                }
            }
            function ol(u) {
                return function (f) {
                    return Ym($w(Bw(f).replace(r8, "")), u, "")
                }
            }
            function Ru(u) {
                return function () {
                    var f = arguments;
                    switch (f.length) {
                        case 0:
                            return new u;
                        case 1:
                            return new u(f[0]);
                        case 2:
                            return new u(f[0], f[1]);
                        case 3:
                            return new u(f[0], f[1], f[2]);
                        case 4:
                            return new u(f[0], f[1], f[2], f[3]);
                        case 5:
                            return new u(f[0], f[1], f[2], f[3], f[4]);
                        case 6:
                            return new u(f[0], f[1], f[2], f[3], f[4], f[5]);
                        case 7:
                            return new u(f[0], f[1], f[2], f[3], f[4], f[5], f[6])
                    }
                    var v = il(u.prototype)
                        , _ = u.apply(v, f);
                    return Xt(_) ? _ : v
                }
            }
            function pR(u, f, v) {
                var _ = Ru(u);
                function R() {
                    for (var L = arguments.length, $ = Z(L), H = L, q = al(R); H--;)
                        $[H] = arguments[H];
                    var te = L < 3 && $[0] !== q && $[L - 1] !== q ? [] : Vs($, q);
                    if (L -= te.length,
                        L < v)
                        return K2(u, f, sf, R.placeholder, n, $, te, n, n, v - L);
                    var ne = this && this !== Nn && this instanceof R ? _ : u;
                    return Or(ne, this, $)
                }
                return R
            }
            function H2(u) {
                return function (f, v, _) {
                    var R = Bt(f);
                    if (!yr(f)) {
                        var L = Be(v, 3);
                        f = Sn(f),
                            v = function (H) {
                                return L(R[H], H, R)
                            }
                    }
                    var $ = u(f, v, _);
                    return $ > -1 ? R[L ? f[$] : $] : n
                }
            }
            function V2(u) {
                return ps(function (f) {
                    var v = f.length
                        , _ = v
                        , R = Kr.prototype.thru;
                    for (u && f.reverse(); _--;) {
                        var L = f[_];
                        if (typeof L != "function")
                            throw new Ur(o);
                        if (R && !$ && uf(L) == "wrapper")
                            var $ = new Kr([], !0)
                    }
                    for (_ = $ ? _ : v; ++_ < v;) {
                        L = f[_];
                        var H = uf(L)
                            , q = H == "wrapper" ? Rg(L) : n;
                        q && Lg(q[0]) && q[1] == (T | C | b | O) && !q[4].length && q[9] == 1 ? $ = $[uf(q[0])].apply($, q[3]) : $ = L.length == 1 && Lg(L) ? $[H]() : $.thru(L)
                    }
                    return function () {
                        var te = arguments
                            , ne = te[0];
                        if ($ && te.length == 1 && rt(ne))
                            return $.plant(ne).value();
                        for (var le = 0, xe = v ? f[le].apply(this, te) : ne; ++le < v;)
                            xe = f[le].call(this, xe);
                        return xe
                    }
                })
            }
            function sf(u, f, v, _, R, L, $, H, q, te) {
                var ne = f & T
                    , le = f & S
                    , xe = f & k
                    , Pe = f & (C | m)
                    , Fe = f & M
                    , ut = xe ? n : Ru(u);
                function He() {
                    for (var yt = arguments.length, _t = Z(yt), Nr = yt; Nr--;)
                        _t[Nr] = arguments[Nr];
                    if (Pe)
                        var or = al(He)
                            , Ir = E8(_t, or);
                    if (_ && (_t = j2(_t, _, R, Pe)),
                        L && (_t = B2(_t, L, $, Pe)),
                        yt -= Ir,
                        Pe && yt < te) {
                        var ln = Vs(_t, or);
                        return K2(u, f, sf, He.placeholder, v, _t, ln, H, q, te - yt)
                    }
                    var mi = le ? v : this
                        , vs = xe ? mi[u] : u;
                    return yt = _t.length,
                        H ? _t = IR(_t, H) : Fe && yt > 1 && _t.reverse(),
                        ne && q < yt && (_t.length = q),
                        this && this !== Nn && this instanceof He && (vs = ut || Ru(vs)),
                        vs.apply(mi, _t)
                }
                return He
            }
            function W2(u, f) {
                return function (v, _) {
                    return HM(v, u, f(_), {})
                }
            }
            function of(u, f) {
                return function (v, _) {
                    var R;
                    if (v === n && _ === n)
                        return f;
                    if (v !== n && (R = v),
                        _ !== n) {
                        if (R === n)
                            return _;
                        typeof v == "string" || typeof _ == "string" ? (v = Rr(v),
                            _ = Rr(_)) : (v = O2(v),
                                _ = O2(_)),
                            R = u(v, _)
                    }
                    return R
                }
            }
            function Tg(u) {
                return ps(function (f) {
                    return f = Jt(f, Mr(Be())),
                        ft(function (v) {
                            var _ = this;
                            return u(f, function (R) {
                                return Or(R, _, v)
                            })
                        })
                })
            }
            function af(u, f) {
                f = f === n ? " " : Rr(f);
                var v = f.length;
                if (v < 2)
                    return v ? wg(f, u) : f;
                var _ = wg(f, Kd(u / Qa(f)));
                return Xa(f) ? Gs(fi(_), 0, u).join("") : _.slice(0, u)
            }
            function mR(u, f, v, _) {
                var R = f & S
                    , L = Ru(u);
                function $() {
                    for (var H = -1, q = arguments.length, te = -1, ne = _.length, le = Z(ne + q), xe = this && this !== Nn && this instanceof $ ? L : u; ++te < ne;)
                        le[te] = _[te];
                    for (; q--;)
                        le[te++] = arguments[++H];
                    return Or(xe, R ? v : this, le)
                }
                return $
            }
            function U2(u) {
                return function (f, v, _) {
                    return _ && typeof _ != "number" && sr(f, v, _) && (v = _ = n),
                        f = ys(f),
                        v === n ? (v = f,
                            f = 0) : v = ys(v),
                        _ = _ === n ? f < v ? 1 : -1 : ys(_),
                        eR(f, v, _, u)
                }
            }
            function lf(u) {
                return function (f, v) {
                    return typeof f == "string" && typeof v == "string" || (f = Zr(f),
                        v = Zr(v)),
                        u(f, v)
                }
            }
            function K2(u, f, v, _, R, L, $, H, q, te) {
                var ne = f & C
                    , le = ne ? $ : n
                    , xe = ne ? n : $
                    , Pe = ne ? L : n
                    , Fe = ne ? n : L;
                f |= ne ? b : w,
                    f &= ~(ne ? w : b),
                    f & A || (f &= ~(S | k));
                var ut = [u, f, R, Pe, le, Fe, xe, H, q, te]
                    , He = v.apply(n, ut);
                return Lg(u) && iw(He, ut),
                    He.placeholder = _,
                    sw(He, u, f)
            }
            function Ag(u) {
                var f = gn[u];
                return function (v, _) {
                    if (v = Zr(v),
                        _ = _ == null ? 0 : Un(lt(_), 292),
                        _ && s2(v)) {
                        var R = (Pt(v) + "e").split("e")
                            , L = f(R[0] + "e" + (+R[1] + _));
                        return R = (Pt(L) + "e").split("e"),
                            +(R[0] + "e" + (+R[1] - _))
                    }
                    return f(v)
                }
            }
            var gR = nl && 1 / Dd(new nl([, -0]))[1] == F ? function (u) {
                return new nl(u)
            }
                : Zg;
            function q2(u) {
                return function (f) {
                    var v = Kn(f);
                    return v == B ? ig(f) : v == fe ? N8(f) : C8(f, u(f))
                }
            }
            function hs(u, f, v, _, R, L, $, H) {
                var q = f & k;
                if (!q && typeof u != "function")
                    throw new Ur(o);
                var te = _ ? _.length : 0;
                if (te || (f &= ~(b | w),
                    _ = R = n),
                    $ = $ === n ? $ : yn(lt($), 0),
                    H = H === n ? H : lt(H),
                    te -= R ? R.length : 0,
                    f & w) {
                    var ne = _
                        , le = R;
                    _ = R = n
                }
                var xe = q ? n : Rg(u)
                    , Pe = [u, f, v, _, R, ne, le, L, $, H];
                if (xe && RR(Pe, xe),
                    u = Pe[0],
                    f = Pe[1],
                    v = Pe[2],
                    _ = Pe[3],
                    R = Pe[4],
                    H = Pe[9] = Pe[9] === n ? q ? 0 : u.length : yn(Pe[9] - te, 0),
                    !H && f & (C | m) && (f &= ~(C | m)),
                    !f || f == S)
                    var Fe = hR(u, f, v);
                else
                    f == C || f == m ? Fe = pR(u, f, H) : (f == b || f == (S | b)) && !R.length ? Fe = mR(u, f, v, _) : Fe = sf.apply(n, Pe);
                var ut = xe ? T2 : iw;
                return sw(ut(Fe, Pe), u, f)
            }
            function G2(u, f, v, _) {
                return u === n || pi(u, tl[v]) && !It.call(_, v) ? f : u
            }
            function J2(u, f, v, _, R, L) {
                return Xt(u) && Xt(f) && (L.set(f, u),
                    ef(u, f, n, J2, L),
                    L.delete(f)),
                    u
            }
            function yR(u) {
                return Iu(u) ? n : u
            }
            function Z2(u, f, v, _, R, L) {
                var $ = v & y
                    , H = u.length
                    , q = f.length;
                if (H != q && !($ && q > H))
                    return !1;
                var te = L.get(u)
                    , ne = L.get(f);
                if (te && ne)
                    return te == f && ne == u;
                var le = -1
                    , xe = !0
                    , Pe = v & x ? new Qo : n;
                for (L.set(u, f),
                    L.set(f, u); ++le < H;) {
                    var Fe = u[le]
                        , ut = f[le];
                    if (_)
                        var He = $ ? _(ut, Fe, le, f, u, L) : _(Fe, ut, le, u, f, L);
                    if (He !== n) {
                        if (He)
                            continue;
                        xe = !1;
                        break
                    }
                    if (Pe) {
                        if (!Xm(f, function (yt, _t) {
                            if (!wu(Pe, _t) && (Fe === yt || R(Fe, yt, v, _, L)))
                                return Pe.push(_t)
                        })) {
                            xe = !1;
                            break
                        }
                    } else if (!(Fe === ut || R(Fe, ut, v, _, L))) {
                        xe = !1;
                        break
                    }
                }
                return L.delete(u),
                    L.delete(f),
                    xe
            }
            function vR(u, f, v, _, R, L, $) {
                switch (v) {
                    case bt:
                        if (u.byteLength != f.byteLength || u.byteOffset != f.byteOffset)
                            return !1;
                        u = u.buffer,
                            f = f.buffer;
                    case nt:
                        return !(u.byteLength != f.byteLength || !L(new Hd(u), new Hd(f)));
                    case he:
                    case ge:
                    case J:
                        return pi(+u, +f);
                    case st:
                        return u.name == f.name && u.message == f.message;
                    case pe:
                    case ue:
                        return u == f + "";
                    case B:
                        var H = ig;
                    case fe:
                        var q = _ & y;
                        if (H || (H = Dd),
                            u.size != f.size && !q)
                            return !1;
                        var te = $.get(u);
                        if (te)
                            return te == f;
                        _ |= x,
                            $.set(u, f);
                        var ne = Z2(H(u), H(f), _, R, L, $);
                        return $.delete(u),
                            ne;
                    case Ne:
                        if (Cu)
                            return Cu.call(u) == Cu.call(f)
                }
                return !1
            }
            function bR(u, f, v, _, R, L) {
                var $ = v & y
                    , H = Og(u)
                    , q = H.length
                    , te = Og(f)
                    , ne = te.length;
                if (q != ne && !$)
                    return !1;
                for (var le = q; le--;) {
                    var xe = H[le];
                    if (!($ ? xe in f : It.call(f, xe)))
                        return !1
                }
                var Pe = L.get(u)
                    , Fe = L.get(f);
                if (Pe && Fe)
                    return Pe == f && Fe == u;
                var ut = !0;
                L.set(u, f),
                    L.set(f, u);
                for (var He = $; ++le < q;) {
                    xe = H[le];
                    var yt = u[xe]
                        , _t = f[xe];
                    if (_)
                        var Nr = $ ? _(_t, yt, xe, f, u, L) : _(yt, _t, xe, u, f, L);
                    if (!(Nr === n ? yt === _t || R(yt, _t, v, _, L) : Nr)) {
                        ut = !1;
                        break
                    }
                    He || (He = xe == "constructor")
                }
                if (ut && !He) {
                    var or = u.constructor
                        , Ir = f.constructor;
                    or != Ir && "constructor" in u && "constructor" in f && !(typeof or == "function" && or instanceof or && typeof Ir == "function" && Ir instanceof Ir) && (ut = !1)
                }
                return L.delete(u),
                    L.delete(f),
                    ut
            }
            function ps(u) {
                return jg(nw(u, n, dw), u + "")
            }
            function Og(u) {
                return g2(u, Sn, Ng)
            }
            function Mg(u) {
                return g2(u, vr, Y2)
            }
            var Rg = Gd ? function (u) {
                return Gd.get(u)
            }
                : Zg;
            function uf(u) {
                for (var f = u.name + "", v = rl[f], _ = It.call(rl, f) ? v.length : 0; _--;) {
                    var R = v[_]
                        , L = R.func;
                    if (L == null || L == u)
                        return R.name
                }
                return f
            }
            function al(u) {
                var f = It.call(I, "placeholder") ? I : u;
                return f.placeholder
            }
            function Be() {
                var u = I.iteratee || Gg;
                return u = u === Gg ? b2 : u,
                    arguments.length ? u(arguments[0], arguments[1]) : u
            }
            function cf(u, f) {
                var v = u.__data__;
                return TR(f) ? v[typeof f == "string" ? "string" : "hash"] : v.map
            }
            function Pg(u) {
                for (var f = Sn(u), v = f.length; v--;) {
                    var _ = f[v]
                        , R = u[_];
                    f[v] = [_, R, ew(R)]
                }
                return f
            }
            function na(u, f) {
                var v = M8(u, f);
                return v2(v) ? v : n
            }
            function wR(u) {
                var f = It.call(u, Yo)
                    , v = u[Yo];
                try {
                    u[Yo] = n;
                    var _ = !0
                } catch { }
                var R = zd.call(u);
                return _ && (f ? u[Yo] = v : delete u[Yo]),
                    R
            }
            var Ng = og ? function (u) {
                return u == null ? [] : (u = Bt(u),
                    Fs(og(u), function (f) {
                        return r2.call(u, f)
                    }))
            }
                : Yg
                , Y2 = og ? function (u) {
                    for (var f = []; u;)
                        Hs(f, Ng(u)),
                            u = Vd(u);
                    return f
                }
                    : Yg
                , Kn = ir;
            (ag && Kn(new ag(new ArrayBuffer(1))) != bt || _u && Kn(new _u) != B || lg && Kn(lg.resolve()) != de || nl && Kn(new nl) != fe || Su && Kn(new Su) != Oe) && (Kn = function (u) {
                var f = ir(u)
                    , v = f == X ? u.constructor : n
                    , _ = v ? ra(v) : "";
                if (_)
                    switch (_) {
                        case nM:
                            return bt;
                        case rM:
                            return B;
                        case iM:
                            return de;
                        case sM:
                            return fe;
                        case oM:
                            return Oe
                    }
                return f
            }
            );
            function xR(u, f, v) {
                for (var _ = -1, R = v.length; ++_ < R;) {
                    var L = v[_]
                        , $ = L.size;
                    switch (L.type) {
                        case "drop":
                            u += $;
                            break;
                        case "dropRight":
                            f -= $;
                            break;
                        case "take":
                            f = Un(f, u + $);
                            break;
                        case "takeRight":
                            u = yn(u, f - $);
                            break
                    }
                }
                return {
                    start: u,
                    end: f
                }
            }
            function _R(u) {
                var f = u.match(AO);
                return f ? f[1].split(OO) : []
            }
            function X2(u, f, v) {
                f = qs(f, u);
                for (var _ = -1, R = f.length, L = !1; ++_ < R;) {
                    var $ = Di(f[_]);
                    if (!(L = u != null && v(u, $)))
                        break;
                    u = u[$]
                }
                return L || ++_ != R ? L : (R = u == null ? 0 : u.length,
                    !!R && yf(R) && ms($, R) && (rt(u) || ia(u)))
            }
            function SR(u) {
                var f = u.length
                    , v = new u.constructor(f);
                return f && typeof u[0] == "string" && It.call(u, "index") && (v.index = u.index,
                    v.input = u.input),
                    v
            }
            function Q2(u) {
                return typeof u.constructor == "function" && !Pu(u) ? il(Vd(u)) : {}
            }
            function kR(u, f, v) {
                var _ = u.constructor;
                switch (f) {
                    case nt:
                        return Eg(u);
                    case he:
                    case ge:
                        return new _(+u);
                    case bt:
                        return aR(u, v);
                    case Et:
                    case Mn:
                    case dn:
                    case rr:
                    case Rn:
                    case us:
                    case Ja:
                    case Pn:
                    case mr:
                        return L2(u, v);
                    case B:
                        return new _;
                    case J:
                    case ue:
                        return new _(u);
                    case pe:
                        return lR(u);
                    case fe:
                        return new _;
                    case Ne:
                        return uR(u)
                }
            }
            function CR(u, f) {
                var v = f.length;
                if (!v)
                    return u;
                var _ = v - 1;
                return f[_] = (v > 1 ? "& " : "") + f[_],
                    f = f.join(v > 2 ? ", " : " "),
                    u.replace(TO, `{
/* [wrapped with ` + f + `] */
`)
            }
            function ER(u) {
                return rt(u) || ia(u) || !!(i2 && u && u[i2])
            }
            function ms(u, f) {
                var v = typeof u;
                return f = f ?? K,
                    !!f && (v == "number" || v != "symbol" && BO.test(u)) && u > -1 && u % 1 == 0 && u < f
            }
            function sr(u, f, v) {
                if (!Xt(v))
                    return !1;
                var _ = typeof f;
                return (_ == "number" ? yr(v) && ms(f, v.length) : _ == "string" && f in v) ? pi(v[f], u) : !1
            }
            function Ig(u, f) {
                if (rt(u))
                    return !1;
                var v = typeof u;
                return v == "number" || v == "symbol" || v == "boolean" || u == null || Pr(u) ? !0 : SO.test(u) || !_O.test(u) || f != null && u in Bt(f)
            }
            function TR(u) {
                var f = typeof u;
                return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? u !== "__proto__" : u === null
            }
            function Lg(u) {
                var f = uf(u)
                    , v = I[f];
                if (typeof v != "function" || !(f in wt.prototype))
                    return !1;
                if (u === v)
                    return !0;
                var _ = Rg(v);
                return !!_ && u === _[0]
            }
            function AR(u) {
                return !!e2 && e2 in u
            }
            var OR = Bd ? gs : Xg;
            function Pu(u) {
                var f = u && u.constructor
                    , v = typeof f == "function" && f.prototype || tl;
                return u === v
            }
            function ew(u) {
                return u === u && !Xt(u)
            }
            function tw(u, f) {
                return function (v) {
                    return v == null ? !1 : v[u] === f && (f !== n || u in Bt(v))
                }
            }
            function MR(u) {
                var f = mf(u, function (_) {
                    return v.size === c && v.clear(),
                        _
                })
                    , v = f.cache;
                return f
            }
            function RR(u, f) {
                var v = u[1]
                    , _ = f[1]
                    , R = v | _
                    , L = R < (S | k | T)
                    , $ = _ == T && v == C || _ == T && v == O && u[7].length <= f[8] || _ == (T | O) && f[7].length <= f[8] && v == C;
                if (!(L || $))
                    return u;
                _ & S && (u[2] = f[2],
                    R |= v & S ? 0 : A);
                var H = f[3];
                if (H) {
                    var q = u[3];
                    u[3] = q ? j2(q, H, f[4]) : H,
                        u[4] = q ? Vs(u[3], d) : f[4]
                }
                return H = f[5],
                    H && (q = u[5],
                        u[5] = q ? B2(q, H, f[6]) : H,
                        u[6] = q ? Vs(u[5], d) : f[6]),
                    H = f[7],
                    H && (u[7] = H),
                    _ & T && (u[8] = u[8] == null ? f[8] : Un(u[8], f[8])),
                    u[9] == null && (u[9] = f[9]),
                    u[0] = f[0],
                    u[1] = R,
                    u
            }
            function PR(u) {
                var f = [];
                if (u != null)
                    for (var v in Bt(u))
                        f.push(v);
                return f
            }
            function NR(u) {
                return zd.call(u)
            }
            function nw(u, f, v) {
                return f = yn(f === n ? u.length - 1 : f, 0),
                    function () {
                        for (var _ = arguments, R = -1, L = yn(_.length - f, 0), $ = Z(L); ++R < L;)
                            $[R] = _[f + R];
                        R = -1;
                        for (var H = Z(f + 1); ++R < f;)
                            H[R] = _[R];
                        return H[f] = v($),
                            Or(u, this, H)
                    }
            }
            function rw(u, f) {
                return f.length < 2 ? u : ta(u, Gr(f, 0, -1))
            }
            function IR(u, f) {
                for (var v = u.length, _ = Un(f.length, v), R = gr(u); _--;) {
                    var L = f[_];
                    u[_] = ms(L, v) ? R[L] : n
                }
                return u
            }
            function Dg(u, f) {
                if (!(f === "constructor" && typeof u[f] == "function") && f != "__proto__")
                    return u[f]
            }
            var iw = ow(T2)
                , Nu = J8 || function (u, f) {
                    return Nn.setTimeout(u, f)
                }
                , jg = ow(rR);
            function sw(u, f, v) {
                var _ = f + "";
                return jg(u, CR(_, LR(_R(_), v)))
            }
            function ow(u) {
                var f = 0
                    , v = 0;
                return function () {
                    var _ = Q8()
                        , R = z - (_ - v);
                    if (v = _,
                        R > 0) {
                        if (++f >= j)
                            return arguments[0]
                    } else
                        f = 0;
                    return u.apply(n, arguments)
                }
            }
            function df(u, f) {
                var v = -1
                    , _ = u.length
                    , R = _ - 1;
                for (f = f === n ? _ : f; ++v < f;) {
                    var L = bg(v, R)
                        , $ = u[L];
                    u[L] = u[v],
                        u[v] = $
                }
                return u.length = f,
                    u
            }
            var aw = MR(function (u) {
                var f = [];
                return u.charCodeAt(0) === 46 && f.push(""),
                    u.replace(kO, function (v, _, R, L) {
                        f.push(R ? L.replace(PO, "$1") : _ || v)
                    }),
                    f
            });
            function Di(u) {
                if (typeof u == "string" || Pr(u))
                    return u;
                var f = u + "";
                return f == "0" && 1 / u == -F ? "-0" : f
            }
            function ra(u) {
                if (u != null) {
                    try {
                        return $d.call(u)
                    } catch { }
                    try {
                        return u + ""
                    } catch { }
                }
                return ""
            }
            function LR(u, f) {
                return Wr(Ke, function (v) {
                    var _ = "_." + v[0];
                    f & v[1] && !Id(u, _) && u.push(_)
                }),
                    u.sort()
            }
            function lw(u) {
                if (u instanceof wt)
                    return u.clone();
                var f = new Kr(u.__wrapped__, u.__chain__);
                return f.__actions__ = gr(u.__actions__),
                    f.__index__ = u.__index__,
                    f.__values__ = u.__values__,
                    f
            }
            function DR(u, f, v) {
                (v ? sr(u, f, v) : f === n) ? f = 1 : f = yn(lt(f), 0);
                var _ = u == null ? 0 : u.length;
                if (!_ || f < 1)
                    return [];
                for (var R = 0, L = 0, $ = Z(Kd(_ / f)); R < _;)
                    $[L++] = Gr(u, R, R += f);
                return $
            }
            function jR(u) {
                for (var f = -1, v = u == null ? 0 : u.length, _ = 0, R = []; ++f < v;) {
                    var L = u[f];
                    L && (R[_++] = L)
                }
                return R
            }
            function BR() {
                var u = arguments.length;
                if (!u)
                    return [];
                for (var f = Z(u - 1), v = arguments[0], _ = u; _--;)
                    f[_ - 1] = arguments[_];
                return Hs(rt(v) ? gr(v) : [v], In(f, 1))
            }
            var $R = ft(function (u, f) {
                return an(u) ? Tu(u, In(f, 1, an, !0)) : []
            })
                , zR = ft(function (u, f) {
                    var v = Jr(f);
                    return an(v) && (v = n),
                        an(u) ? Tu(u, In(f, 1, an, !0), Be(v, 2)) : []
                })
                , FR = ft(function (u, f) {
                    var v = Jr(f);
                    return an(v) && (v = n),
                        an(u) ? Tu(u, In(f, 1, an, !0), n, v) : []
                });
            function HR(u, f, v) {
                var _ = u == null ? 0 : u.length;
                return _ ? (f = v || f === n ? 1 : lt(f),
                    Gr(u, f < 0 ? 0 : f, _)) : []
            }
            function VR(u, f, v) {
                var _ = u == null ? 0 : u.length;
                return _ ? (f = v || f === n ? 1 : lt(f),
                    f = _ - f,
                    Gr(u, 0, f < 0 ? 0 : f)) : []
            }
            function WR(u, f) {
                return u && u.length ? nf(u, Be(f, 3), !0, !0) : []
            }
            function UR(u, f) {
                return u && u.length ? nf(u, Be(f, 3), !0) : []
            }
            function KR(u, f, v, _) {
                var R = u == null ? 0 : u.length;
                return R ? (v && typeof v != "number" && sr(u, f, v) && (v = 0,
                    _ = R),
                    BM(u, f, v, _)) : []
            }
            function uw(u, f, v) {
                var _ = u == null ? 0 : u.length;
                if (!_)
                    return -1;
                var R = v == null ? 0 : lt(v);
                return R < 0 && (R = yn(_ + R, 0)),
                    Ld(u, Be(f, 3), R)
            }
            function cw(u, f, v) {
                var _ = u == null ? 0 : u.length;
                if (!_)
                    return -1;
                var R = _ - 1;
                return v !== n && (R = lt(v),
                    R = v < 0 ? yn(_ + R, 0) : Un(R, _ - 1)),
                    Ld(u, Be(f, 3), R, !0)
            }
            function dw(u) {
                var f = u == null ? 0 : u.length;
                return f ? In(u, 1) : []
            }
            function qR(u) {
                var f = u == null ? 0 : u.length;
                return f ? In(u, F) : []
            }
            function GR(u, f) {
                var v = u == null ? 0 : u.length;
                return v ? (f = f === n ? 1 : lt(f),
                    In(u, f)) : []
            }
            function JR(u) {
                for (var f = -1, v = u == null ? 0 : u.length, _ = {}; ++f < v;) {
                    var R = u[f];
                    _[R[0]] = R[1]
                }
                return _
            }
            function fw(u) {
                return u && u.length ? u[0] : n
            }
            function ZR(u, f, v) {
                var _ = u == null ? 0 : u.length;
                if (!_)
                    return -1;
                var R = v == null ? 0 : lt(v);
                return R < 0 && (R = yn(_ + R, 0)),
                    Ya(u, f, R)
            }
            function YR(u) {
                var f = u == null ? 0 : u.length;
                return f ? Gr(u, 0, -1) : []
            }
            var XR = ft(function (u) {
                var f = Jt(u, kg);
                return f.length && f[0] === u[0] ? pg(f) : []
            })
                , QR = ft(function (u) {
                    var f = Jr(u)
                        , v = Jt(u, kg);
                    return f === Jr(v) ? f = n : v.pop(),
                        v.length && v[0] === u[0] ? pg(v, Be(f, 2)) : []
                })
                , eP = ft(function (u) {
                    var f = Jr(u)
                        , v = Jt(u, kg);
                    return f = typeof f == "function" ? f : n,
                        f && v.pop(),
                        v.length && v[0] === u[0] ? pg(v, n, f) : []
                });
            function tP(u, f) {
                return u == null ? "" : Y8.call(u, f)
            }
            function Jr(u) {
                var f = u == null ? 0 : u.length;
                return f ? u[f - 1] : n
            }
            function nP(u, f, v) {
                var _ = u == null ? 0 : u.length;
                if (!_)
                    return -1;
                var R = _;
                return v !== n && (R = lt(v),
                    R = R < 0 ? yn(_ + R, 0) : Un(R, _ - 1)),
                    f === f ? L8(u, f, R) : Ld(u, Kb, R, !0)
            }
            function rP(u, f) {
                return u && u.length ? S2(u, lt(f)) : n
            }
            var iP = ft(hw);
            function hw(u, f) {
                return u && u.length && f && f.length ? vg(u, f) : u
            }
            function sP(u, f, v) {
                return u && u.length && f && f.length ? vg(u, f, Be(v, 2)) : u
            }
            function oP(u, f, v) {
                return u && u.length && f && f.length ? vg(u, f, n, v) : u
            }
            var aP = ps(function (u, f) {
                var v = u == null ? 0 : u.length
                    , _ = cg(u, f);
                return E2(u, Jt(f, function (R) {
                    return ms(R, v) ? +R : R
                }).sort(D2)),
                    _
            });
            function lP(u, f) {
                var v = [];
                if (!(u && u.length))
                    return v;
                var _ = -1
                    , R = []
                    , L = u.length;
                for (f = Be(f, 3); ++_ < L;) {
                    var $ = u[_];
                    f($, _, u) && (v.push($),
                        R.push(_))
                }
                return E2(u, R),
                    v
            }
            function Bg(u) {
                return u == null ? u : tM.call(u)
            }
            function uP(u, f, v) {
                var _ = u == null ? 0 : u.length;
                return _ ? (v && typeof v != "number" && sr(u, f, v) ? (f = 0,
                    v = _) : (f = f == null ? 0 : lt(f),
                        v = v === n ? _ : lt(v)),
                    Gr(u, f, v)) : []
            }
            function cP(u, f) {
                return tf(u, f)
            }
            function dP(u, f, v) {
                return xg(u, f, Be(v, 2))
            }
            function fP(u, f) {
                var v = u == null ? 0 : u.length;
                if (v) {
                    var _ = tf(u, f);
                    if (_ < v && pi(u[_], f))
                        return _
                }
                return -1
            }
            function hP(u, f) {
                return tf(u, f, !0)
            }
            function pP(u, f, v) {
                return xg(u, f, Be(v, 2), !0)
            }
            function mP(u, f) {
                var v = u == null ? 0 : u.length;
                if (v) {
                    var _ = tf(u, f, !0) - 1;
                    if (pi(u[_], f))
                        return _
                }
                return -1
            }
            function gP(u) {
                return u && u.length ? A2(u) : []
            }
            function yP(u, f) {
                return u && u.length ? A2(u, Be(f, 2)) : []
            }
            function vP(u) {
                var f = u == null ? 0 : u.length;
                return f ? Gr(u, 1, f) : []
            }
            function bP(u, f, v) {
                return u && u.length ? (f = v || f === n ? 1 : lt(f),
                    Gr(u, 0, f < 0 ? 0 : f)) : []
            }
            function wP(u, f, v) {
                var _ = u == null ? 0 : u.length;
                return _ ? (f = v || f === n ? 1 : lt(f),
                    f = _ - f,
                    Gr(u, f < 0 ? 0 : f, _)) : []
            }
            function xP(u, f) {
                return u && u.length ? nf(u, Be(f, 3), !1, !0) : []
            }
            function _P(u, f) {
                return u && u.length ? nf(u, Be(f, 3)) : []
            }
            var SP = ft(function (u) {
                return Ks(In(u, 1, an, !0))
            })
                , kP = ft(function (u) {
                    var f = Jr(u);
                    return an(f) && (f = n),
                        Ks(In(u, 1, an, !0), Be(f, 2))
                })
                , CP = ft(function (u) {
                    var f = Jr(u);
                    return f = typeof f == "function" ? f : n,
                        Ks(In(u, 1, an, !0), n, f)
                });
            function EP(u) {
                return u && u.length ? Ks(u) : []
            }
            function TP(u, f) {
                return u && u.length ? Ks(u, Be(f, 2)) : []
            }
            function AP(u, f) {
                return f = typeof f == "function" ? f : n,
                    u && u.length ? Ks(u, n, f) : []
            }
            function $g(u) {
                if (!(u && u.length))
                    return [];
                var f = 0;
                return u = Fs(u, function (v) {
                    if (an(v))
                        return f = yn(v.length, f),
                            !0
                }),
                    ng(f, function (v) {
                        return Jt(u, Qm(v))
                    })
            }
            function pw(u, f) {
                if (!(u && u.length))
                    return [];
                var v = $g(u);
                return f == null ? v : Jt(v, function (_) {
                    return Or(f, n, _)
                })
            }
            var OP = ft(function (u, f) {
                return an(u) ? Tu(u, f) : []
            })
                , MP = ft(function (u) {
                    return Sg(Fs(u, an))
                })
                , RP = ft(function (u) {
                    var f = Jr(u);
                    return an(f) && (f = n),
                        Sg(Fs(u, an), Be(f, 2))
                })
                , PP = ft(function (u) {
                    var f = Jr(u);
                    return f = typeof f == "function" ? f : n,
                        Sg(Fs(u, an), n, f)
                })
                , NP = ft($g);
            function IP(u, f) {
                return P2(u || [], f || [], Eu)
            }
            function LP(u, f) {
                return P2(u || [], f || [], Mu)
            }
            var DP = ft(function (u) {
                var f = u.length
                    , v = f > 1 ? u[f - 1] : n;
                return v = typeof v == "function" ? (u.pop(),
                    v) : n,
                    pw(u, v)
            });
            function mw(u) {
                var f = I(u);
                return f.__chain__ = !0,
                    f
            }
            function jP(u, f) {
                return f(u),
                    u
            }
            function ff(u, f) {
                return f(u)
            }
            var BP = ps(function (u) {
                var f = u.length
                    , v = f ? u[0] : 0
                    , _ = this.__wrapped__
                    , R = function (L) {
                        return cg(L, u)
                    };
                return f > 1 || this.__actions__.length || !(_ instanceof wt) || !ms(v) ? this.thru(R) : (_ = _.slice(v, +v + (f ? 1 : 0)),
                    _.__actions__.push({
                        func: ff,
                        args: [R],
                        thisArg: n
                    }),
                    new Kr(_, this.__chain__).thru(function (L) {
                        return f && !L.length && L.push(n),
                            L
                    }))
            });
            function $P() {
                return mw(this)
            }
            function zP() {
                return new Kr(this.value(), this.__chain__)
            }
            function FP() {
                this.__values__ === n && (this.__values__ = Ow(this.value()));
                var u = this.__index__ >= this.__values__.length
                    , f = u ? n : this.__values__[this.__index__++];
                return {
                    done: u,
                    value: f
                }
            }
            function HP() {
                return this
            }
            function VP(u) {
                for (var f, v = this; v instanceof Zd;) {
                    var _ = lw(v);
                    _.__index__ = 0,
                        _.__values__ = n,
                        f ? R.__wrapped__ = _ : f = _;
                    var R = _;
                    v = v.__wrapped__
                }
                return R.__wrapped__ = u,
                    f
            }
            function WP() {
                var u = this.__wrapped__;
                if (u instanceof wt) {
                    var f = u;
                    return this.__actions__.length && (f = new wt(this)),
                        f = f.reverse(),
                        f.__actions__.push({
                            func: ff,
                            args: [Bg],
                            thisArg: n
                        }),
                        new Kr(f, this.__chain__)
                }
                return this.thru(Bg)
            }
            function UP() {
                return R2(this.__wrapped__, this.__actions__)
            }
            var KP = rf(function (u, f, v) {
                It.call(u, v) ? ++u[v] : fs(u, v, 1)
            });
            function qP(u, f, v) {
                var _ = rt(u) ? Wb : jM;
                return v && sr(u, f, v) && (f = n),
                    _(u, Be(f, 3))
            }
            function GP(u, f) {
                var v = rt(u) ? Fs : p2;
                return v(u, Be(f, 3))
            }
            var JP = H2(uw)
                , ZP = H2(cw);
            function YP(u, f) {
                return In(hf(u, f), 1)
            }
            function XP(u, f) {
                return In(hf(u, f), F)
            }
            function QP(u, f, v) {
                return v = v === n ? 1 : lt(v),
                    In(hf(u, f), v)
            }
            function gw(u, f) {
                var v = rt(u) ? Wr : Us;
                return v(u, Be(f, 3))
            }
            function yw(u, f) {
                var v = rt(u) ? v8 : h2;
                return v(u, Be(f, 3))
            }
            var eN = rf(function (u, f, v) {
                It.call(u, v) ? u[v].push(f) : fs(u, v, [f])
            });
            function tN(u, f, v, _) {
                u = yr(u) ? u : ul(u),
                    v = v && !_ ? lt(v) : 0;
                var R = u.length;
                return v < 0 && (v = yn(R + v, 0)),
                    vf(u) ? v <= R && u.indexOf(f, v) > -1 : !!R && Ya(u, f, v) > -1
            }
            var nN = ft(function (u, f, v) {
                var _ = -1
                    , R = typeof f == "function"
                    , L = yr(u) ? Z(u.length) : [];
                return Us(u, function ($) {
                    L[++_] = R ? Or(f, $, v) : Au($, f, v)
                }),
                    L
            })
                , rN = rf(function (u, f, v) {
                    fs(u, v, f)
                });
            function hf(u, f) {
                var v = rt(u) ? Jt : w2;
                return v(u, Be(f, 3))
            }
            function iN(u, f, v, _) {
                return u == null ? [] : (rt(f) || (f = f == null ? [] : [f]),
                    v = _ ? n : v,
                    rt(v) || (v = v == null ? [] : [v]),
                    k2(u, f, v))
            }
            var sN = rf(function (u, f, v) {
                u[v ? 0 : 1].push(f)
            }, function () {
                return [[], []]
            });
            function oN(u, f, v) {
                var _ = rt(u) ? Ym : Gb
                    , R = arguments.length < 3;
                return _(u, Be(f, 4), v, R, Us)
            }
            function aN(u, f, v) {
                var _ = rt(u) ? b8 : Gb
                    , R = arguments.length < 3;
                return _(u, Be(f, 4), v, R, h2)
            }
            function lN(u, f) {
                var v = rt(u) ? Fs : p2;
                return v(u, gf(Be(f, 3)))
            }
            function uN(u) {
                var f = rt(u) ? u2 : tR;
                return f(u)
            }
            function cN(u, f, v) {
                (v ? sr(u, f, v) : f === n) ? f = 1 : f = lt(f);
                var _ = rt(u) ? PM : nR;
                return _(u, f)
            }
            function dN(u) {
                var f = rt(u) ? NM : iR;
                return f(u)
            }
            function fN(u) {
                if (u == null)
                    return 0;
                if (yr(u))
                    return vf(u) ? Qa(u) : u.length;
                var f = Kn(u);
                return f == B || f == fe ? u.size : gg(u).length
            }
            function hN(u, f, v) {
                var _ = rt(u) ? Xm : sR;
                return v && sr(u, f, v) && (f = n),
                    _(u, Be(f, 3))
            }
            var pN = ft(function (u, f) {
                if (u == null)
                    return [];
                var v = f.length;
                return v > 1 && sr(u, f[0], f[1]) ? f = [] : v > 2 && sr(f[0], f[1], f[2]) && (f = [f[0]]),
                    k2(u, In(f, 1), [])
            })
                , pf = G8 || function () {
                    return Nn.Date.now()
                }
                ;
            function mN(u, f) {
                if (typeof f != "function")
                    throw new Ur(o);
                return u = lt(u),
                    function () {
                        if (--u < 1)
                            return f.apply(this, arguments)
                    }
            }
            function vw(u, f, v) {
                return f = v ? n : f,
                    f = u && f == null ? u.length : f,
                    hs(u, T, n, n, n, n, f)
            }
            function bw(u, f) {
                var v;
                if (typeof f != "function")
                    throw new Ur(o);
                return u = lt(u),
                    function () {
                        return --u > 0 && (v = f.apply(this, arguments)),
                            u <= 1 && (f = n),
                            v
                    }
            }
            var zg = ft(function (u, f, v) {
                var _ = S;
                if (v.length) {
                    var R = Vs(v, al(zg));
                    _ |= b
                }
                return hs(u, _, f, v, R)
            })
                , ww = ft(function (u, f, v) {
                    var _ = S | k;
                    if (v.length) {
                        var R = Vs(v, al(ww));
                        _ |= b
                    }
                    return hs(f, _, u, v, R)
                });
            function xw(u, f, v) {
                f = v ? n : f;
                var _ = hs(u, C, n, n, n, n, n, f);
                return _.placeholder = xw.placeholder,
                    _
            }
            function _w(u, f, v) {
                f = v ? n : f;
                var _ = hs(u, m, n, n, n, n, n, f);
                return _.placeholder = _w.placeholder,
                    _
            }
            function Sw(u, f, v) {
                var _, R, L, $, H, q, te = 0, ne = !1, le = !1, xe = !0;
                if (typeof u != "function")
                    throw new Ur(o);
                f = Zr(f) || 0,
                    Xt(v) && (ne = !!v.leading,
                        le = "maxWait" in v,
                        L = le ? yn(Zr(v.maxWait) || 0, f) : L,
                        xe = "trailing" in v ? !!v.trailing : xe);
                function Pe(ln) {
                    var mi = _
                        , vs = R;
                    return _ = R = n,
                        te = ln,
                        $ = u.apply(vs, mi),
                        $
                }
                function Fe(ln) {
                    return te = ln,
                        H = Nu(yt, f),
                        ne ? Pe(ln) : $
                }
                function ut(ln) {
                    var mi = ln - q
                        , vs = ln - te
                        , Hw = f - mi;
                    return le ? Un(Hw, L - vs) : Hw
                }
                function He(ln) {
                    var mi = ln - q
                        , vs = ln - te;
                    return q === n || mi >= f || mi < 0 || le && vs >= L
                }
                function yt() {
                    var ln = pf();
                    if (He(ln))
                        return _t(ln);
                    H = Nu(yt, ut(ln))
                }
                function _t(ln) {
                    return H = n,
                        xe && _ ? Pe(ln) : (_ = R = n,
                            $)
                }
                function Nr() {
                    H !== n && N2(H),
                        te = 0,
                        _ = q = R = H = n
                }
                function or() {
                    return H === n ? $ : _t(pf())
                }
                function Ir() {
                    var ln = pf()
                        , mi = He(ln);
                    if (_ = arguments,
                        R = this,
                        q = ln,
                        mi) {
                        if (H === n)
                            return Fe(q);
                        if (le)
                            return N2(H),
                                H = Nu(yt, f),
                                Pe(q)
                    }
                    return H === n && (H = Nu(yt, f)),
                        $
                }
                return Ir.cancel = Nr,
                    Ir.flush = or,
                    Ir
            }
            var gN = ft(function (u, f) {
                return f2(u, 1, f)
            })
                , yN = ft(function (u, f, v) {
                    return f2(u, Zr(f) || 0, v)
                });
            function vN(u) {
                return hs(u, M)
            }
            function mf(u, f) {
                if (typeof u != "function" || f != null && typeof f != "function")
                    throw new Ur(o);
                var v = function () {
                    var _ = arguments
                        , R = f ? f.apply(this, _) : _[0]
                        , L = v.cache;
                    if (L.has(R))
                        return L.get(R);
                    var $ = u.apply(this, _);
                    return v.cache = L.set(R, $) || L,
                        $
                };
                return v.cache = new (mf.Cache || ds),
                    v
            }
            mf.Cache = ds;
            function gf(u) {
                if (typeof u != "function")
                    throw new Ur(o);
                return function () {
                    var f = arguments;
                    switch (f.length) {
                        case 0:
                            return !u.call(this);
                        case 1:
                            return !u.call(this, f[0]);
                        case 2:
                            return !u.call(this, f[0], f[1]);
                        case 3:
                            return !u.call(this, f[0], f[1], f[2])
                    }
                    return !u.apply(this, f)
                }
            }
            function bN(u) {
                return bw(2, u)
            }
            var wN = oR(function (u, f) {
                f = f.length == 1 && rt(f[0]) ? Jt(f[0], Mr(Be())) : Jt(In(f, 1), Mr(Be()));
                var v = f.length;
                return ft(function (_) {
                    for (var R = -1, L = Un(_.length, v); ++R < L;)
                        _[R] = f[R].call(this, _[R]);
                    return Or(u, this, _)
                })
            })
                , Fg = ft(function (u, f) {
                    var v = Vs(f, al(Fg));
                    return hs(u, b, n, f, v)
                })
                , kw = ft(function (u, f) {
                    var v = Vs(f, al(kw));
                    return hs(u, w, n, f, v)
                })
                , xN = ps(function (u, f) {
                    return hs(u, O, n, n, n, f)
                });
            function _N(u, f) {
                if (typeof u != "function")
                    throw new Ur(o);
                return f = f === n ? f : lt(f),
                    ft(u, f)
            }
            function SN(u, f) {
                if (typeof u != "function")
                    throw new Ur(o);
                return f = f == null ? 0 : yn(lt(f), 0),
                    ft(function (v) {
                        var _ = v[f]
                            , R = Gs(v, 0, f);
                        return _ && Hs(R, _),
                            Or(u, this, R)
                    })
            }
            function kN(u, f, v) {
                var _ = !0
                    , R = !0;
                if (typeof u != "function")
                    throw new Ur(o);
                return Xt(v) && (_ = "leading" in v ? !!v.leading : _,
                    R = "trailing" in v ? !!v.trailing : R),
                    Sw(u, f, {
                        leading: _,
                        maxWait: f,
                        trailing: R
                    })
            }
            function CN(u) {
                return vw(u, 1)
            }
            function EN(u, f) {
                return Fg(Cg(f), u)
            }
            function TN() {
                if (!arguments.length)
                    return [];
                var u = arguments[0];
                return rt(u) ? u : [u]
            }
            function AN(u) {
                return qr(u, g)
            }
            function ON(u, f) {
                return f = typeof f == "function" ? f : n,
                    qr(u, g, f)
            }
            function MN(u) {
                return qr(u, h | g)
            }
            function RN(u, f) {
                return f = typeof f == "function" ? f : n,
                    qr(u, h | g, f)
            }
            function PN(u, f) {
                return f == null || d2(u, f, Sn(f))
            }
            function pi(u, f) {
                return u === f || u !== u && f !== f
            }
            var NN = lf(hg)
                , IN = lf(function (u, f) {
                    return u >= f
                })
                , ia = y2(function () {
                    return arguments
                }()) ? y2 : function (u) {
                    return tn(u) && It.call(u, "callee") && !r2.call(u, "callee")
                }
                , rt = Z.isArray
                , LN = Bb ? Mr(Bb) : VM;
            function yr(u) {
                return u != null && yf(u.length) && !gs(u)
            }
            function an(u) {
                return tn(u) && yr(u)
            }
            function DN(u) {
                return u === !0 || u === !1 || tn(u) && ir(u) == he
            }
            var Js = Z8 || Xg
                , jN = $b ? Mr($b) : WM;
            function BN(u) {
                return tn(u) && u.nodeType === 1 && !Iu(u)
            }
            function $N(u) {
                if (u == null)
                    return !0;
                if (yr(u) && (rt(u) || typeof u == "string" || typeof u.splice == "function" || Js(u) || ll(u) || ia(u)))
                    return !u.length;
                var f = Kn(u);
                if (f == B || f == fe)
                    return !u.size;
                if (Pu(u))
                    return !gg(u).length;
                for (var v in u)
                    if (It.call(u, v))
                        return !1;
                return !0
            }
            function zN(u, f) {
                return Ou(u, f)
            }
            function FN(u, f, v) {
                v = typeof v == "function" ? v : n;
                var _ = v ? v(u, f) : n;
                return _ === n ? Ou(u, f, n, v) : !!_
            }
            function Hg(u) {
                if (!tn(u))
                    return !1;
                var f = ir(u);
                return f == st || f == Ee || typeof u.message == "string" && typeof u.name == "string" && !Iu(u)
            }
            function HN(u) {
                return typeof u == "number" && s2(u)
            }
            function gs(u) {
                if (!Xt(u))
                    return !1;
                var f = ir(u);
                return f == xt || f == D || f == Y || f == be
            }
            function Cw(u) {
                return typeof u == "number" && u == lt(u)
            }
            function yf(u) {
                return typeof u == "number" && u > -1 && u % 1 == 0 && u <= K
            }
            function Xt(u) {
                var f = typeof u;
                return u != null && (f == "object" || f == "function")
            }
            function tn(u) {
                return u != null && typeof u == "object"
            }
            var Ew = zb ? Mr(zb) : KM;
            function VN(u, f) {
                return u === f || mg(u, f, Pg(f))
            }
            function WN(u, f, v) {
                return v = typeof v == "function" ? v : n,
                    mg(u, f, Pg(f), v)
            }
            function UN(u) {
                return Tw(u) && u != +u
            }
            function KN(u) {
                if (OR(u))
                    throw new et(s);
                return v2(u)
            }
            function qN(u) {
                return u === null
            }
            function GN(u) {
                return u == null
            }
            function Tw(u) {
                return typeof u == "number" || tn(u) && ir(u) == J
            }
            function Iu(u) {
                if (!tn(u) || ir(u) != X)
                    return !1;
                var f = Vd(u);
                if (f === null)
                    return !0;
                var v = It.call(f, "constructor") && f.constructor;
                return typeof v == "function" && v instanceof v && $d.call(v) == W8
            }
            var Vg = Fb ? Mr(Fb) : qM;
            function JN(u) {
                return Cw(u) && u >= -K && u <= K
            }
            var Aw = Hb ? Mr(Hb) : GM;
            function vf(u) {
                return typeof u == "string" || !rt(u) && tn(u) && ir(u) == ue
            }
            function Pr(u) {
                return typeof u == "symbol" || tn(u) && ir(u) == Ne
            }
            var ll = Vb ? Mr(Vb) : JM;
            function ZN(u) {
                return u === n
            }
            function YN(u) {
                return tn(u) && Kn(u) == Oe
            }
            function XN(u) {
                return tn(u) && ir(u) == ze
            }
            var QN = lf(yg)
                , e6 = lf(function (u, f) {
                    return u <= f
                });
            function Ow(u) {
                if (!u)
                    return [];
                if (yr(u))
                    return vf(u) ? fi(u) : gr(u);
                if (xu && u[xu])
                    return P8(u[xu]());
                var f = Kn(u)
                    , v = f == B ? ig : f == fe ? Dd : ul;
                return v(u)
            }
            function ys(u) {
                if (!u)
                    return u === 0 ? u : 0;
                if (u = Zr(u),
                    u === F || u === -F) {
                    var f = u < 0 ? -1 : 1;
                    return f * re
                }
                return u === u ? u : 0
            }
            function lt(u) {
                var f = ys(u)
                    , v = f % 1;
                return f === f ? v ? f - v : f : 0
            }
            function Mw(u) {
                return u ? ea(lt(u), 0, ee) : 0
            }
            function Zr(u) {
                if (typeof u == "number")
                    return u;
                if (Pr(u))
                    return Te;
                if (Xt(u)) {
                    var f = typeof u.valueOf == "function" ? u.valueOf() : u;
                    u = Xt(f) ? f + "" : f
                }
                if (typeof u != "string")
                    return u === 0 ? u : +u;
                u = Jb(u);
                var v = LO.test(u);
                return v || jO.test(u) ? m8(u.slice(2), v ? 2 : 8) : IO.test(u) ? Te : +u
            }
            function Rw(u) {
                return Li(u, vr(u))
            }
            function t6(u) {
                return u ? ea(lt(u), -K, K) : u === 0 ? u : 0
            }
            function Pt(u) {
                return u == null ? "" : Rr(u)
            }
            var n6 = sl(function (u, f) {
                if (Pu(f) || yr(f)) {
                    Li(f, Sn(f), u);
                    return
                }
                for (var v in f)
                    It.call(f, v) && Eu(u, v, f[v])
            })
                , Pw = sl(function (u, f) {
                    Li(f, vr(f), u)
                })
                , bf = sl(function (u, f, v, _) {
                    Li(f, vr(f), u, _)
                })
                , r6 = sl(function (u, f, v, _) {
                    Li(f, Sn(f), u, _)
                })
                , i6 = ps(cg);
            function s6(u, f) {
                var v = il(u);
                return f == null ? v : c2(v, f)
            }
            var o6 = ft(function (u, f) {
                u = Bt(u);
                var v = -1
                    , _ = f.length
                    , R = _ > 2 ? f[2] : n;
                for (R && sr(f[0], f[1], R) && (_ = 1); ++v < _;)
                    for (var L = f[v], $ = vr(L), H = -1, q = $.length; ++H < q;) {
                        var te = $[H]
                            , ne = u[te];
                        (ne === n || pi(ne, tl[te]) && !It.call(u, te)) && (u[te] = L[te])
                    }
                return u
            })
                , a6 = ft(function (u) {
                    return u.push(n, J2),
                        Or(Nw, n, u)
                });
            function l6(u, f) {
                return Ub(u, Be(f, 3), Ii)
            }
            function u6(u, f) {
                return Ub(u, Be(f, 3), fg)
            }
            function c6(u, f) {
                return u == null ? u : dg(u, Be(f, 3), vr)
            }
            function d6(u, f) {
                return u == null ? u : m2(u, Be(f, 3), vr)
            }
            function f6(u, f) {
                return u && Ii(u, Be(f, 3))
            }
            function h6(u, f) {
                return u && fg(u, Be(f, 3))
            }
            function p6(u) {
                return u == null ? [] : Qd(u, Sn(u))
            }
            function m6(u) {
                return u == null ? [] : Qd(u, vr(u))
            }
            function Wg(u, f, v) {
                var _ = u == null ? n : ta(u, f);
                return _ === n ? v : _
            }
            function g6(u, f) {
                return u != null && X2(u, f, $M)
            }
            function Ug(u, f) {
                return u != null && X2(u, f, zM)
            }
            var y6 = W2(function (u, f, v) {
                f != null && typeof f.toString != "function" && (f = zd.call(f)),
                    u[f] = v
            }, qg(br))
                , v6 = W2(function (u, f, v) {
                    f != null && typeof f.toString != "function" && (f = zd.call(f)),
                        It.call(u, f) ? u[f].push(v) : u[f] = [v]
                }, Be)
                , b6 = ft(Au);
            function Sn(u) {
                return yr(u) ? l2(u) : gg(u)
            }
            function vr(u) {
                return yr(u) ? l2(u, !0) : ZM(u)
            }
            function w6(u, f) {
                var v = {};
                return f = Be(f, 3),
                    Ii(u, function (_, R, L) {
                        fs(v, f(_, R, L), _)
                    }),
                    v
            }
            function x6(u, f) {
                var v = {};
                return f = Be(f, 3),
                    Ii(u, function (_, R, L) {
                        fs(v, R, f(_, R, L))
                    }),
                    v
            }
            var _6 = sl(function (u, f, v) {
                ef(u, f, v)
            })
                , Nw = sl(function (u, f, v, _) {
                    ef(u, f, v, _)
                })
                , S6 = ps(function (u, f) {
                    var v = {};
                    if (u == null)
                        return v;
                    var _ = !1;
                    f = Jt(f, function (L) {
                        return L = qs(L, u),
                            _ || (_ = L.length > 1),
                            L
                    }),
                        Li(u, Mg(u), v),
                        _ && (v = qr(v, h | p | g, yR));
                    for (var R = f.length; R--;)
                        _g(v, f[R]);
                    return v
                });
            function k6(u, f) {
                return Iw(u, gf(Be(f)))
            }
            var C6 = ps(function (u, f) {
                return u == null ? {} : XM(u, f)
            });
            function Iw(u, f) {
                if (u == null)
                    return {};
                var v = Jt(Mg(u), function (_) {
                    return [_]
                });
                return f = Be(f),
                    C2(u, v, function (_, R) {
                        return f(_, R[0])
                    })
            }
            function E6(u, f, v) {
                f = qs(f, u);
                var _ = -1
                    , R = f.length;
                for (R || (R = 1,
                    u = n); ++_ < R;) {
                    var L = u == null ? n : u[Di(f[_])];
                    L === n && (_ = R,
                        L = v),
                        u = gs(L) ? L.call(u) : L
                }
                return u
            }
            function T6(u, f, v) {
                return u == null ? u : Mu(u, f, v)
            }
            function A6(u, f, v, _) {
                return _ = typeof _ == "function" ? _ : n,
                    u == null ? u : Mu(u, f, v, _)
            }
            var Lw = q2(Sn)
                , Dw = q2(vr);
            function O6(u, f, v) {
                var _ = rt(u)
                    , R = _ || Js(u) || ll(u);
                if (f = Be(f, 4),
                    v == null) {
                    var L = u && u.constructor;
                    R ? v = _ ? new L : [] : Xt(u) ? v = gs(L) ? il(Vd(u)) : {} : v = {}
                }
                return (R ? Wr : Ii)(u, function ($, H, q) {
                    return f(v, $, H, q)
                }),
                    v
            }
            function M6(u, f) {
                return u == null ? !0 : _g(u, f)
            }
            function R6(u, f, v) {
                return u == null ? u : M2(u, f, Cg(v))
            }
            function P6(u, f, v, _) {
                return _ = typeof _ == "function" ? _ : n,
                    u == null ? u : M2(u, f, Cg(v), _)
            }
            function ul(u) {
                return u == null ? [] : rg(u, Sn(u))
            }
            function N6(u) {
                return u == null ? [] : rg(u, vr(u))
            }
            function I6(u, f, v) {
                return v === n && (v = f,
                    f = n),
                    v !== n && (v = Zr(v),
                        v = v === v ? v : 0),
                    f !== n && (f = Zr(f),
                        f = f === f ? f : 0),
                    ea(Zr(u), f, v)
            }
            function L6(u, f, v) {
                return f = ys(f),
                    v === n ? (v = f,
                        f = 0) : v = ys(v),
                    u = Zr(u),
                    FM(u, f, v)
            }
            function D6(u, f, v) {
                if (v && typeof v != "boolean" && sr(u, f, v) && (f = v = n),
                    v === n && (typeof f == "boolean" ? (v = f,
                        f = n) : typeof u == "boolean" && (v = u,
                            u = n)),
                    u === n && f === n ? (u = 0,
                        f = 1) : (u = ys(u),
                            f === n ? (f = u,
                                u = 0) : f = ys(f)),
                    u > f) {
                    var _ = u;
                    u = f,
                        f = _
                }
                if (v || u % 1 || f % 1) {
                    var R = o2();
                    return Un(u + R * (f - u + p8("1e-" + ((R + "").length - 1))), f)
                }
                return bg(u, f)
            }
            var j6 = ol(function (u, f, v) {
                return f = f.toLowerCase(),
                    u + (v ? jw(f) : f)
            });
            function jw(u) {
                return Kg(Pt(u).toLowerCase())
            }
            function Bw(u) {
                return u = Pt(u),
                    u && u.replace($O, T8).replace(i8, "")
            }
            function B6(u, f, v) {
                u = Pt(u),
                    f = Rr(f);
                var _ = u.length;
                v = v === n ? _ : ea(lt(v), 0, _);
                var R = v;
                return v -= f.length,
                    v >= 0 && u.slice(v, R) == f
            }
            function $6(u) {
                return u = Pt(u),
                    u && bO.test(u) ? u.replace(mb, A8) : u
            }
            function z6(u) {
                return u = Pt(u),
                    u && CO.test(u) ? u.replace(Fm, "\\$&") : u
            }
            var F6 = ol(function (u, f, v) {
                return u + (v ? "-" : "") + f.toLowerCase()
            })
                , H6 = ol(function (u, f, v) {
                    return u + (v ? " " : "") + f.toLowerCase()
                })
                , V6 = F2("toLowerCase");
            function W6(u, f, v) {
                u = Pt(u),
                    f = lt(f);
                var _ = f ? Qa(u) : 0;
                if (!f || _ >= f)
                    return u;
                var R = (f - _) / 2;
                return af(qd(R), v) + u + af(Kd(R), v)
            }
            function U6(u, f, v) {
                u = Pt(u),
                    f = lt(f);
                var _ = f ? Qa(u) : 0;
                return f && _ < f ? u + af(f - _, v) : u
            }
            function K6(u, f, v) {
                u = Pt(u),
                    f = lt(f);
                var _ = f ? Qa(u) : 0;
                return f && _ < f ? af(f - _, v) + u : u
            }
            function q6(u, f, v) {
                return v || f == null ? f = 0 : f && (f = +f),
                    eM(Pt(u).replace(Hm, ""), f || 0)
            }
            function G6(u, f, v) {
                return (v ? sr(u, f, v) : f === n) ? f = 1 : f = lt(f),
                    wg(Pt(u), f)
            }
            function J6() {
                var u = arguments
                    , f = Pt(u[0]);
                return u.length < 3 ? f : f.replace(u[1], u[2])
            }
            var Z6 = ol(function (u, f, v) {
                return u + (v ? "_" : "") + f.toLowerCase()
            });
            function Y6(u, f, v) {
                return v && typeof v != "number" && sr(u, f, v) && (f = v = n),
                    v = v === n ? ee : v >>> 0,
                    v ? (u = Pt(u),
                        u && (typeof f == "string" || f != null && !Vg(f)) && (f = Rr(f),
                            !f && Xa(u)) ? Gs(fi(u), 0, v) : u.split(f, v)) : []
            }
            var X6 = ol(function (u, f, v) {
                return u + (v ? " " : "") + Kg(f)
            });
            function Q6(u, f, v) {
                return u = Pt(u),
                    v = v == null ? 0 : ea(lt(v), 0, u.length),
                    f = Rr(f),
                    u.slice(v, v + f.length) == f
            }
            function eI(u, f, v) {
                var _ = I.templateSettings;
                v && sr(u, f, v) && (f = n),
                    u = Pt(u),
                    f = bf({}, f, _, G2);
                var R = bf({}, f.imports, _.imports, G2), L = Sn(R), $ = rg(R, L), H, q, te = 0, ne = f.interpolate || Rd, le = "__p += '", xe = sg((f.escape || Rd).source + "|" + ne.source + "|" + (ne === gb ? NO : Rd).source + "|" + (f.evaluate || Rd).source + "|$", "g"), Pe = "//# sourceURL=" + (It.call(f, "sourceURL") ? (f.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++u8 + "]") + `
`;
                u.replace(xe, function (He, yt, _t, Nr, or, Ir) {
                    return _t || (_t = Nr),
                        le += u.slice(te, Ir).replace(zO, O8),
                        yt && (H = !0,
                            le += `' +
__e(` + yt + `) +
'`),
                        or && (q = !0,
                            le += `';
` + or + `;
__p += '`),
                        _t && (le += `' +
((__t = (` + _t + `)) == null ? '' : __t) +
'`),
                        te = Ir + He.length,
                        He
                }),
                    le += `';
`;
                var Fe = It.call(f, "variable") && f.variable;
                if (!Fe)
                    le = `with (obj) {
` + le + `
}
`;
                else if (RO.test(Fe))
                    throw new et(a);
                le = (q ? le.replace(Md, "") : le).replace(gO, "$1").replace(yO, "$1;"),
                    le = "function(" + (Fe || "obj") + `) {
` + (Fe ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (H ? ", __e = _.escape" : "") + (q ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + le + `return __p
}`;
                var ut = zw(function () {
                    return At(L, Pe + "return " + le).apply(n, $)
                });
                if (ut.source = le,
                    Hg(ut))
                    throw ut;
                return ut
            }
            function tI(u) {
                return Pt(u).toLowerCase()
            }
            function nI(u) {
                return Pt(u).toUpperCase()
            }
            function rI(u, f, v) {
                if (u = Pt(u),
                    u && (v || f === n))
                    return Jb(u);
                if (!u || !(f = Rr(f)))
                    return u;
                var _ = fi(u)
                    , R = fi(f)
                    , L = Zb(_, R)
                    , $ = Yb(_, R) + 1;
                return Gs(_, L, $).join("")
            }
            function iI(u, f, v) {
                if (u = Pt(u),
                    u && (v || f === n))
                    return u.slice(0, Qb(u) + 1);
                if (!u || !(f = Rr(f)))
                    return u;
                var _ = fi(u)
                    , R = Yb(_, fi(f)) + 1;
                return Gs(_, 0, R).join("")
            }
            function sI(u, f, v) {
                if (u = Pt(u),
                    u && (v || f === n))
                    return u.replace(Hm, "");
                if (!u || !(f = Rr(f)))
                    return u;
                var _ = fi(u)
                    , R = Zb(_, fi(f));
                return Gs(_, R).join("")
            }
            function oI(u, f) {
                var v = E
                    , _ = N;
                if (Xt(f)) {
                    var R = "separator" in f ? f.separator : R;
                    v = "length" in f ? lt(f.length) : v,
                        _ = "omission" in f ? Rr(f.omission) : _
                }
                u = Pt(u);
                var L = u.length;
                if (Xa(u)) {
                    var $ = fi(u);
                    L = $.length
                }
                if (v >= L)
                    return u;
                var H = v - Qa(_);
                if (H < 1)
                    return _;
                var q = $ ? Gs($, 0, H).join("") : u.slice(0, H);
                if (R === n)
                    return q + _;
                if ($ && (H += q.length - H),
                    Vg(R)) {
                    if (u.slice(H).search(R)) {
                        var te, ne = q;
                        for (R.global || (R = sg(R.source, Pt(yb.exec(R)) + "g")),
                            R.lastIndex = 0; te = R.exec(ne);)
                            var le = te.index;
                        q = q.slice(0, le === n ? H : le)
                    }
                } else if (u.indexOf(Rr(R), H) != H) {
                    var xe = q.lastIndexOf(R);
                    xe > -1 && (q = q.slice(0, xe))
                }
                return q + _
            }
            function aI(u) {
                return u = Pt(u),
                    u && vO.test(u) ? u.replace(pb, D8) : u
            }
            var lI = ol(function (u, f, v) {
                return u + (v ? " " : "") + f.toUpperCase()
            })
                , Kg = F2("toUpperCase");
            function $w(u, f, v) {
                return u = Pt(u),
                    f = v ? n : f,
                    f === n ? R8(u) ? $8(u) : _8(u) : u.match(f) || []
            }
            var zw = ft(function (u, f) {
                try {
                    return Or(u, n, f)
                } catch (v) {
                    return Hg(v) ? v : new et(v)
                }
            })
                , uI = ps(function (u, f) {
                    return Wr(f, function (v) {
                        v = Di(v),
                            fs(u, v, zg(u[v], u))
                    }),
                        u
                });
            function cI(u) {
                var f = u == null ? 0 : u.length
                    , v = Be();
                return u = f ? Jt(u, function (_) {
                    if (typeof _[1] != "function")
                        throw new Ur(o);
                    return [v(_[0]), _[1]]
                }) : [],
                    ft(function (_) {
                        for (var R = -1; ++R < f;) {
                            var L = u[R];
                            if (Or(L[0], this, _))
                                return Or(L[1], this, _)
                        }
                    })
            }
            function dI(u) {
                return DM(qr(u, h))
            }
            function qg(u) {
                return function () {
                    return u
                }
            }
            function fI(u, f) {
                return u == null || u !== u ? f : u
            }
            var hI = V2()
                , pI = V2(!0);
            function br(u) {
                return u
            }
            function Gg(u) {
                return b2(typeof u == "function" ? u : qr(u, h))
            }
            function mI(u) {
                return x2(qr(u, h))
            }
            function gI(u, f) {
                return _2(u, qr(f, h))
            }
            var yI = ft(function (u, f) {
                return function (v) {
                    return Au(v, u, f)
                }
            })
                , vI = ft(function (u, f) {
                    return function (v) {
                        return Au(u, v, f)
                    }
                });
            function Jg(u, f, v) {
                var _ = Sn(f)
                    , R = Qd(f, _);
                v == null && !(Xt(f) && (R.length || !_.length)) && (v = f,
                    f = u,
                    u = this,
                    R = Qd(f, Sn(f)));
                var L = !(Xt(v) && "chain" in v) || !!v.chain
                    , $ = gs(u);
                return Wr(R, function (H) {
                    var q = f[H];
                    u[H] = q,
                        $ && (u.prototype[H] = function () {
                            var te = this.__chain__;
                            if (L || te) {
                                var ne = u(this.__wrapped__)
                                    , le = ne.__actions__ = gr(this.__actions__);
                                return le.push({
                                    func: q,
                                    args: arguments,
                                    thisArg: u
                                }),
                                    ne.__chain__ = te,
                                    ne
                            }
                            return q.apply(u, Hs([this.value()], arguments))
                        }
                        )
                }),
                    u
            }
            function bI() {
                return Nn._ === this && (Nn._ = U8),
                    this
            }
            function Zg() { }
            function wI(u) {
                return u = lt(u),
                    ft(function (f) {
                        return S2(f, u)
                    })
            }
            var xI = Tg(Jt)
                , _I = Tg(Wb)
                , SI = Tg(Xm);
            function Fw(u) {
                return Ig(u) ? Qm(Di(u)) : QM(u)
            }
            function kI(u) {
                return function (f) {
                    return u == null ? n : ta(u, f)
                }
            }
            var CI = U2()
                , EI = U2(!0);
            function Yg() {
                return []
            }
            function Xg() {
                return !1
            }
            function TI() {
                return {}
            }
            function AI() {
                return ""
            }
            function OI() {
                return !0
            }
            function MI(u, f) {
                if (u = lt(u),
                    u < 1 || u > K)
                    return [];
                var v = ee
                    , _ = Un(u, ee);
                f = Be(f),
                    u -= ee;
                for (var R = ng(_, f); ++v < u;)
                    f(v);
                return R
            }
            function RI(u) {
                return rt(u) ? Jt(u, Di) : Pr(u) ? [u] : gr(aw(Pt(u)))
            }
            function PI(u) {
                var f = ++V8;
                return Pt(u) + f
            }
            var NI = of(function (u, f) {
                return u + f
            }, 0)
                , II = Ag("ceil")
                , LI = of(function (u, f) {
                    return u / f
                }, 1)
                , DI = Ag("floor");
            function jI(u) {
                return u && u.length ? Xd(u, br, hg) : n
            }
            function BI(u, f) {
                return u && u.length ? Xd(u, Be(f, 2), hg) : n
            }
            function $I(u) {
                return qb(u, br)
            }
            function zI(u, f) {
                return qb(u, Be(f, 2))
            }
            function FI(u) {
                return u && u.length ? Xd(u, br, yg) : n
            }
            function HI(u, f) {
                return u && u.length ? Xd(u, Be(f, 2), yg) : n
            }
            var VI = of(function (u, f) {
                return u * f
            }, 1)
                , WI = Ag("round")
                , UI = of(function (u, f) {
                    return u - f
                }, 0);
            function KI(u) {
                return u && u.length ? tg(u, br) : 0
            }
            function qI(u, f) {
                return u && u.length ? tg(u, Be(f, 2)) : 0
            }
            return I.after = mN,
                I.ary = vw,
                I.assign = n6,
                I.assignIn = Pw,
                I.assignInWith = bf,
                I.assignWith = r6,
                I.at = i6,
                I.before = bw,
                I.bind = zg,
                I.bindAll = uI,
                I.bindKey = ww,
                I.castArray = TN,
                I.chain = mw,
                I.chunk = DR,
                I.compact = jR,
                I.concat = BR,
                I.cond = cI,
                I.conforms = dI,
                I.constant = qg,
                I.countBy = KP,
                I.create = s6,
                I.curry = xw,
                I.curryRight = _w,
                I.debounce = Sw,
                I.defaults = o6,
                I.defaultsDeep = a6,
                I.defer = gN,
                I.delay = yN,
                I.difference = $R,
                I.differenceBy = zR,
                I.differenceWith = FR,
                I.drop = HR,
                I.dropRight = VR,
                I.dropRightWhile = WR,
                I.dropWhile = UR,
                I.fill = KR,
                I.filter = GP,
                I.flatMap = YP,
                I.flatMapDeep = XP,
                I.flatMapDepth = QP,
                I.flatten = dw,
                I.flattenDeep = qR,
                I.flattenDepth = GR,
                I.flip = vN,
                I.flow = hI,
                I.flowRight = pI,
                I.fromPairs = JR,
                I.functions = p6,
                I.functionsIn = m6,
                I.groupBy = eN,
                I.initial = YR,
                I.intersection = XR,
                I.intersectionBy = QR,
                I.intersectionWith = eP,
                I.invert = y6,
                I.invertBy = v6,
                I.invokeMap = nN,
                I.iteratee = Gg,
                I.keyBy = rN,
                I.keys = Sn,
                I.keysIn = vr,
                I.map = hf,
                I.mapKeys = w6,
                I.mapValues = x6,
                I.matches = mI,
                I.matchesProperty = gI,
                I.memoize = mf,
                I.merge = _6,
                I.mergeWith = Nw,
                I.method = yI,
                I.methodOf = vI,
                I.mixin = Jg,
                I.negate = gf,
                I.nthArg = wI,
                I.omit = S6,
                I.omitBy = k6,
                I.once = bN,
                I.orderBy = iN,
                I.over = xI,
                I.overArgs = wN,
                I.overEvery = _I,
                I.overSome = SI,
                I.partial = Fg,
                I.partialRight = kw,
                I.partition = sN,
                I.pick = C6,
                I.pickBy = Iw,
                I.property = Fw,
                I.propertyOf = kI,
                I.pull = iP,
                I.pullAll = hw,
                I.pullAllBy = sP,
                I.pullAllWith = oP,
                I.pullAt = aP,
                I.range = CI,
                I.rangeRight = EI,
                I.rearg = xN,
                I.reject = lN,
                I.remove = lP,
                I.rest = _N,
                I.reverse = Bg,
                I.sampleSize = cN,
                I.set = T6,
                I.setWith = A6,
                I.shuffle = dN,
                I.slice = uP,
                I.sortBy = pN,
                I.sortedUniq = gP,
                I.sortedUniqBy = yP,
                I.split = Y6,
                I.spread = SN,
                I.tail = vP,
                I.take = bP,
                I.takeRight = wP,
                I.takeRightWhile = xP,
                I.takeWhile = _P,
                I.tap = jP,
                I.throttle = kN,
                I.thru = ff,
                I.toArray = Ow,
                I.toPairs = Lw,
                I.toPairsIn = Dw,
                I.toPath = RI,
                I.toPlainObject = Rw,
                I.transform = O6,
                I.unary = CN,
                I.union = SP,
                I.unionBy = kP,
                I.unionWith = CP,
                I.uniq = EP,
                I.uniqBy = TP,
                I.uniqWith = AP,
                I.unset = M6,
                I.unzip = $g,
                I.unzipWith = pw,
                I.update = R6,
                I.updateWith = P6,
                I.values = ul,
                I.valuesIn = N6,
                I.without = OP,
                I.words = $w,
                I.wrap = EN,
                I.xor = MP,
                I.xorBy = RP,
                I.xorWith = PP,
                I.zip = NP,
                I.zipObject = IP,
                I.zipObjectDeep = LP,
                I.zipWith = DP,
                I.entries = Lw,
                I.entriesIn = Dw,
                I.extend = Pw,
                I.extendWith = bf,
                Jg(I, I),
                I.add = NI,
                I.attempt = zw,
                I.camelCase = j6,
                I.capitalize = jw,
                I.ceil = II,
                I.clamp = I6,
                I.clone = AN,
                I.cloneDeep = MN,
                I.cloneDeepWith = RN,
                I.cloneWith = ON,
                I.conformsTo = PN,
                I.deburr = Bw,
                I.defaultTo = fI,
                I.divide = LI,
                I.endsWith = B6,
                I.eq = pi,
                I.escape = $6,
                I.escapeRegExp = z6,
                I.every = qP,
                I.find = JP,
                I.findIndex = uw,
                I.findKey = l6,
                I.findLast = ZP,
                I.findLastIndex = cw,
                I.findLastKey = u6,
                I.floor = DI,
                I.forEach = gw,
                I.forEachRight = yw,
                I.forIn = c6,
                I.forInRight = d6,
                I.forOwn = f6,
                I.forOwnRight = h6,
                I.get = Wg,
                I.gt = NN,
                I.gte = IN,
                I.has = g6,
                I.hasIn = Ug,
                I.head = fw,
                I.identity = br,
                I.includes = tN,
                I.indexOf = ZR,
                I.inRange = L6,
                I.invoke = b6,
                I.isArguments = ia,
                I.isArray = rt,
                I.isArrayBuffer = LN,
                I.isArrayLike = yr,
                I.isArrayLikeObject = an,
                I.isBoolean = DN,
                I.isBuffer = Js,
                I.isDate = jN,
                I.isElement = BN,
                I.isEmpty = $N,
                I.isEqual = zN,
                I.isEqualWith = FN,
                I.isError = Hg,
                I.isFinite = HN,
                I.isFunction = gs,
                I.isInteger = Cw,
                I.isLength = yf,
                I.isMap = Ew,
                I.isMatch = VN,
                I.isMatchWith = WN,
                I.isNaN = UN,
                I.isNative = KN,
                I.isNil = GN,
                I.isNull = qN,
                I.isNumber = Tw,
                I.isObject = Xt,
                I.isObjectLike = tn,
                I.isPlainObject = Iu,
                I.isRegExp = Vg,
                I.isSafeInteger = JN,
                I.isSet = Aw,
                I.isString = vf,
                I.isSymbol = Pr,
                I.isTypedArray = ll,
                I.isUndefined = ZN,
                I.isWeakMap = YN,
                I.isWeakSet = XN,
                I.join = tP,
                I.kebabCase = F6,
                I.last = Jr,
                I.lastIndexOf = nP,
                I.lowerCase = H6,
                I.lowerFirst = V6,
                I.lt = QN,
                I.lte = e6,
                I.max = jI,
                I.maxBy = BI,
                I.mean = $I,
                I.meanBy = zI,
                I.min = FI,
                I.minBy = HI,
                I.stubArray = Yg,
                I.stubFalse = Xg,
                I.stubObject = TI,
                I.stubString = AI,
                I.stubTrue = OI,
                I.multiply = VI,
                I.nth = rP,
                I.noConflict = bI,
                I.noop = Zg,
                I.now = pf,
                I.pad = W6,
                I.padEnd = U6,
                I.padStart = K6,
                I.parseInt = q6,
                I.random = D6,
                I.reduce = oN,
                I.reduceRight = aN,
                I.repeat = G6,
                I.replace = J6,
                I.result = E6,
                I.round = WI,
                I.runInContext = U,
                I.sample = uN,
                I.size = fN,
                I.snakeCase = Z6,
                I.some = hN,
                I.sortedIndex = cP,
                I.sortedIndexBy = dP,
                I.sortedIndexOf = fP,
                I.sortedLastIndex = hP,
                I.sortedLastIndexBy = pP,
                I.sortedLastIndexOf = mP,
                I.startCase = X6,
                I.startsWith = Q6,
                I.subtract = UI,
                I.sum = KI,
                I.sumBy = qI,
                I.template = eI,
                I.times = MI,
                I.toFinite = ys,
                I.toInteger = lt,
                I.toLength = Mw,
                I.toLower = tI,
                I.toNumber = Zr,
                I.toSafeInteger = t6,
                I.toString = Pt,
                I.toUpper = nI,
                I.trim = rI,
                I.trimEnd = iI,
                I.trimStart = sI,
                I.truncate = oI,
                I.unescape = aI,
                I.uniqueId = PI,
                I.upperCase = lI,
                I.upperFirst = Kg,
                I.each = gw,
                I.eachRight = yw,
                I.first = fw,
                Jg(I, function () {
                    var u = {};
                    return Ii(I, function (f, v) {
                        It.call(I.prototype, v) || (u[v] = f)
                    }),
                        u
                }(), {
                    chain: !1
                }),
                I.VERSION = r,
                Wr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (u) {
                    I[u].placeholder = I
                }),
                Wr(["drop", "take"], function (u, f) {
                    wt.prototype[u] = function (v) {
                        v = v === n ? 1 : yn(lt(v), 0);
                        var _ = this.__filtered__ && !f ? new wt(this) : this.clone();
                        return _.__filtered__ ? _.__takeCount__ = Un(v, _.__takeCount__) : _.__views__.push({
                            size: Un(v, ee),
                            type: u + (_.__dir__ < 0 ? "Right" : "")
                        }),
                            _
                    }
                        ,
                        wt.prototype[u + "Right"] = function (v) {
                            return this.reverse()[u](v).reverse()
                        }
                }),
                Wr(["filter", "map", "takeWhile"], function (u, f) {
                    var v = f + 1
                        , _ = v == V || v == P;
                    wt.prototype[u] = function (R) {
                        var L = this.clone();
                        return L.__iteratees__.push({
                            iteratee: Be(R, 3),
                            type: v
                        }),
                            L.__filtered__ = L.__filtered__ || _,
                            L
                    }
                }),
                Wr(["head", "last"], function (u, f) {
                    var v = "take" + (f ? "Right" : "");
                    wt.prototype[u] = function () {
                        return this[v](1).value()[0]
                    }
                }),
                Wr(["initial", "tail"], function (u, f) {
                    var v = "drop" + (f ? "" : "Right");
                    wt.prototype[u] = function () {
                        return this.__filtered__ ? new wt(this) : this[v](1)
                    }
                }),
                wt.prototype.compact = function () {
                    return this.filter(br)
                }
                ,
                wt.prototype.find = function (u) {
                    return this.filter(u).head()
                }
                ,
                wt.prototype.findLast = function (u) {
                    return this.reverse().find(u)
                }
                ,
                wt.prototype.invokeMap = ft(function (u, f) {
                    return typeof u == "function" ? new wt(this) : this.map(function (v) {
                        return Au(v, u, f)
                    })
                }),
                wt.prototype.reject = function (u) {
                    return this.filter(gf(Be(u)))
                }
                ,
                wt.prototype.slice = function (u, f) {
                    u = lt(u);
                    var v = this;
                    return v.__filtered__ && (u > 0 || f < 0) ? new wt(v) : (u < 0 ? v = v.takeRight(-u) : u && (v = v.drop(u)),
                        f !== n && (f = lt(f),
                            v = f < 0 ? v.dropRight(-f) : v.take(f - u)),
                        v)
                }
                ,
                wt.prototype.takeRightWhile = function (u) {
                    return this.reverse().takeWhile(u).reverse()
                }
                ,
                wt.prototype.toArray = function () {
                    return this.take(ee)
                }
                ,
                Ii(wt.prototype, function (u, f) {
                    var v = /^(?:filter|find|map|reject)|While$/.test(f)
                        , _ = /^(?:head|last)$/.test(f)
                        , R = I[_ ? "take" + (f == "last" ? "Right" : "") : f]
                        , L = _ || /^find/.test(f);
                    R && (I.prototype[f] = function () {
                        var $ = this.__wrapped__
                            , H = _ ? [1] : arguments
                            , q = $ instanceof wt
                            , te = H[0]
                            , ne = q || rt($)
                            , le = function (yt) {
                                var _t = R.apply(I, Hs([yt], H));
                                return _ && xe ? _t[0] : _t
                            };
                        ne && v && typeof te == "function" && te.length != 1 && (q = ne = !1);
                        var xe = this.__chain__
                            , Pe = !!this.__actions__.length
                            , Fe = L && !xe
                            , ut = q && !Pe;
                        if (!L && ne) {
                            $ = ut ? $ : new wt(this);
                            var He = u.apply($, H);
                            return He.__actions__.push({
                                func: ff,
                                args: [le],
                                thisArg: n
                            }),
                                new Kr(He, xe)
                        }
                        return Fe && ut ? u.apply(this, H) : (He = this.thru(le),
                            Fe ? _ ? He.value()[0] : He.value() : He)
                    }
                    )
                }),
                Wr(["pop", "push", "shift", "sort", "splice", "unshift"], function (u) {
                    var f = jd[u]
                        , v = /^(?:push|sort|unshift)$/.test(u) ? "tap" : "thru"
                        , _ = /^(?:pop|shift)$/.test(u);
                    I.prototype[u] = function () {
                        var R = arguments;
                        if (_ && !this.__chain__) {
                            var L = this.value();
                            return f.apply(rt(L) ? L : [], R)
                        }
                        return this[v](function ($) {
                            return f.apply(rt($) ? $ : [], R)
                        })
                    }
                }),
                Ii(wt.prototype, function (u, f) {
                    var v = I[f];
                    if (v) {
                        var _ = v.name + "";
                        It.call(rl, _) || (rl[_] = []),
                            rl[_].push({
                                name: f,
                                func: v
                            })
                    }
                }),
                rl[sf(n, k).name] = [{
                    name: "wrapper",
                    func: n
                }],
                wt.prototype.clone = aM,
                wt.prototype.reverse = lM,
                wt.prototype.value = uM,
                I.prototype.at = BP,
                I.prototype.chain = $P,
                I.prototype.commit = zP,
                I.prototype.next = FP,
                I.prototype.plant = VP,
                I.prototype.reverse = WP,
                I.prototype.toJSON = I.prototype.valueOf = I.prototype.value = UP,
                I.prototype.first = I.prototype.head,
                xu && (I.prototype[xu] = HP),
                I
        }
            , el = z8();
        Zo ? ((Zo.exports = el)._ = el,
            Gm._ = el) : Nn._ = el
    }
    ).call(ua)
}
)(Kp, Kp.exports);
var hO = Kp.exports;
const QY = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
};
function eX(t, e) {
    return oe(),
        Ae("svg", QY, e[0] || (e[0] = [Xe("path", {
            d: "m18 15-6-6-6 6"
        }, null, -1)]))
}
const tX = {
    name: "lucide-chevron-up",
    render: eX
}
    , nX = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "1.5",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    };
function rX(t, e) {
    return oe(),
        Ae("svg", nX, e[0] || (e[0] = [Xe("path", {
            d: "M15 6v12a3 3 0 1 0 3-3H6a3 3 0 1 0 3 3V6a3 3 0 1 0-3 3h12a3 3 0 1 0-3-3"
        }, null, -1)]))
}
const iX = {
    name: "lucide-command",
    render: rX
};
function sX() {
    const t = navigator.userAgent.indexOf("Mac OS X") != -1;
    return {
        altKey: t ? "" : "Alt",
        controlKey: t ? "" : "Ctrl",
        isMac: t,
        metaKey: t ? "" : "Meta",
        modifier: t ? "meta" : "control",
        modifierIcon: t ? iX : tX
    }
}
const { isMac: oX, controlKey: aX, altKey: lX, metaKey: uX } = sX();
class cX {
    constructor(e, n, r, i) {
        this.isActive = e,
            this.keyCombination = n,
            this.handler = r,
            this.help = i
    }
    get display() {
        return this.keyCombination.map(e => {
            switch (e) {
                case "Control":
                    return aX;
                case "Alt":
                    return lX;
                case "Meta":
                    return uX;
                default:
                    return e
            }
        }
        )
    }
}
const dX = um("keymap", () => {
    const t = P9({
        passive: !1,
        onEventFired(a) {
            const l = e.value.find(c => c.isActive);
            l && (a.preventDefault(),
                l.handler())
        }
    })
        , e = ce([])
        , n = ce(!1);
    function r(a, l, c) {
        const d = Array.isArray(a) ? a : [a];
        i(d);
        const h = o(d)
            , p = t[h.join("+")]
            , g = new cX(p, h, l, c);
        e.value.push(g)
    }
    function i(a) {
        const l = o(a);
        e.value = e.value.filter(c => !hO.isEqual(c.keyCombination, l))
    }
    function s(a) {
        n.value = a ?? !n.value
    }
    function o(a) {
        return oX ? a.map(l => l === "Control" ? "Meta" : l) : a
    }
    return {
        add: r,
        isOpen: n,
        items: e,
        remove: i,
        toggleVisibility: s
    }
}
)
    , fX = {
        key: 0,
        class: "space-y-2"
    }
    , hX = {
        class: "text-base"
    }
    , pX = {
        class: "flex gap-1"
    }
    , mX = {
        key: 1,
        class: "text-gray-700"
    }
    , gX = je({
        __name: "KeymapDialog",
        setup(t) {
            const e = dX()
                , n = {
                    title: "Shortcuts"
                };
            return (r, i) => {
                const s = Cn("Dialog");
                return oe(),
                    gt(s, {
                        modelValue: ie(e).isOpen,
                        "onUpdate:modelValue": i[0] || (i[0] = o => ie(e).isOpen = o),
                        options: n
                    }, {
                        "body-content": tt(() => [ie(hO.isEmpty)(ie(e).items) ? (oe(),
                            Ae("div", mX, "No shortcuts defined")) : (oe(),
                                Ae("div", fX, [(oe(!0),
                                    Ae(Rt, null, Oa(ie(e).items, o => (oe(),
                                        Ae("div", {
                                            key: o.keyCombination.join(),
                                            class: "flex items-center justify-between"
                                        }, [Xe("div", hX, Vt(o.help), 1), Xe("div", pX, [(oe(!0),
                                            Ae(Rt, null, Oa(o.display, a => (oe(),
                                                gt(ie(mE), {
                                                    key: a,
                                                    label: a,
                                                    theme: "gray",
                                                    variant: "outline",
                                                    size: "lg"
                                                }, null, 8, ["label"]))), 128))])]))), 128))]))]),
                        _: 1
                    }, 8, ["modelValue"])
            }
        }
    });
(function (t, e) {
    var n, r, i, s;
    e.__SV || (window.posthog = e,
        e._i = [],
        e.init = function (o, a, l) {
            function c(h, p) {
                var g = p.split(".");
                g.length == 2 && (h = h[g[0]],
                    p = g[1]),
                    h[p] = function () {
                        h.push([p].concat(Array.prototype.slice.call(arguments, 0)))
                    }
            }
            (i = t.createElement("script")).type = "text/javascript",
                i.async = !0,
                i.src = a.api_host + "/static/array.js",
                (s = t.getElementsByTagName("script")[0]).parentNode.insertBefore(i, s);
            var d = e;
            for (l !== void 0 ? d = e[l] = [] : l = "posthog",
                d.people = d.people || [],
                d.toString = function (h) {
                    var p = "posthog";
                    return l !== "posthog" && (p += "." + l),
                        h || (p += " (stub)"),
                        p
                }
                ,
                d.people.toString = function () {
                    return d.toString(1) + ".people (stub)"
                }
                ,
                n = "capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags".split(" "),
                r = 0; r < n.length; r++)
                c(d, n[r]);
            e._i.push([o, a, l])
        }
        ,
        e.__SV = 1)
}
)(document, window.posthog || []);
const yX = "helpdesk"
    , vX = window.location.hostname
    , jr = O9("telemetry", {
        enabled: !1,
        project_id: "",
        host: ""
    });
async function bX() {
    if (await wX(),
        !!jr.value.enabled)
        try {
            await xX(),
                window.posthog.init(jr.value.project_id, {
                    api_host: jr.value.host,
                    autocapture: !1,
                    person_profiles: "always",
                    capture_pageview: !0,
                    capture_pageleave: !0,
                    disable_session_recording: !1,
                    session_recording: {
                        maskAllInputs: !1,
                        maskInputOptions: {
                            password: !0
                        }
                    },
                    loaded: t => {
                        window.posthog = t,
                            window.posthog.identify(vX)
                    }
                })
        } catch (t) {
            console.trace("Failed to initialize telemetry", t),
                jr.value.enabled = !1
        }
}
async function wX() {
    jr.value.enabled || await tb("helpdesk.api.telemetry.is_enabled").then(t => {
        jr.value.enabled = t
    }
    )
}
async function xX() {
    jr.value.enabled && (jr.value.project_id && jr.value.host || await tb("helpdesk.api.telemetry.get_credentials").then(t => {
        jr.value.project_id = t.project_id,
            jr.value.host = t.telemetry_host
    }
    ))
}
function Iee(t, e = {
    data: {
        user: ""
    }
}) {
    jr.value.enabled && window.posthog.capture(`${yX}_${t}`, e)
}
function _X() {
    jr.value.enabled && window.posthog && window.posthog.__loaded && window.posthog.sessionRecordingStarted() && window.posthog.stopSessionRecording()
}
const SX = je({
    __name: "App",
    setup(t) {
        return XY(),
            Nt(async () => {
                window.addEventListener("online", () => {
                    Up({
                        title: "You are now online",
                        icon: "wifi",
                        iconClasses: "stroke-green-600"
                    })
                }
                ),
                    window.addEventListener("offline", () => {
                        Up({
                            title: "You are now offline",
                            icon: "wifi-off",
                            iconClasses: "stroke-red-600"
                        })
                    }
                    ),
                    await bX()
            }
            ),
            xn(() => {
                _X()
            }
            ),
            (e, n) => {
                const r = Cn("RouterView");
                return oe(),
                    Ae(Rt, null, [$e(r, {
                        class: "antialiased"
                    }), $e(ie(Fq)), $e(gX)], 64)
            }
    }
});
const kX = (t, e) => {
    const n = t[e];
    return n ? typeof n == "function" ? n() : Promise.resolve(n) : new Promise((r, i) => {
        (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(i.bind(null, new Error("Unknown variable dynamic import: " + e)))
    }
    )
}
    , CX = "login"
    , EX = "logout"
    , TX = "helpdesk.api.auth.get_user"
    , pO = um("auth", () => {
        const t = zn({
            url: TX
        })
            , e = t.fetch
            , n = t.reload
            , r = G(() => t.data || {})
            , i = G(() => r.value.has_desk_access)
            , s = G(() => r.value.is_admin)
            , o = G(() => r.value.is_agent)
            , a = G(() => r.value.user_id)
            , l = G(() => r.value.user_image)
            , c = G(() => r.value.user_first_name)
            , d = G(() => r.value.user_name)
            , h = G(() => r.value.username)
            , p = G(() => r.value.time_zone);
        function g() {
            let C = new URLSearchParams(document.cookie.split("; ").join("&")).get("user_id");
            return C === "Guest" && (C = null),
                C
        }
        const y = ce(g())
            , x = G(() => !!y.value)
            , S = zn({
                url: CX,
                onError() {
                    throw new Error("Invalid email or password")
                },
                onSuccess() {
                    y.value = g(),
                        S.reset(),
                        hb.replace({
                            path: "/"
                        })
                }
            });
        function k() {
            y.value = null,
                tb(EX).then(() => {
                    window.location.href = fb
                }
                )
        }
        return {
            hasDeskAccess: i,
            init: e,
            isAdmin: s,
            isAgent: o,
            isLoggedIn: x,
            login: S,
            reloadUser: n,
            userFirstName: c,
            userId: a,
            userImage: l,
            userName: d,
            username: h,
            timezone: p,
            user: y,
            logout: k
        }
    }
    )
    , AX = um("user", () => {
        const t = pO()
            , e = wn({})
            , n = zn({
                url: "helpdesk.api.session.get_users",
                cache: "Users",
                initialData: [],
                transform(s) {
                    for (const o of s)
                        e[o.name] = o;
                    return s
                },
                onError(s) {
                    s && s.exc_type === "AuthenticationError" && (window.location.href = fb)
                }
            })
            , r = n.fetch;
        function i(s) {
            return (!s || s === "sessionUser") && (s = t.username),
                e[s] || (e[s] = {
                    name: s,
                    email: s,
                    full_name: s.split("@")[0],
                    user_image: null,
                    role: null
                }),
                e[s]
        }
        return {
            users: n,
            getUser: i,
            init: r
        }
    }
    );
function OX() {
    const t = wn({
        width: window.innerWidth,
        height: window.innerHeight
    })
        , e = () => {
            t.width = window.innerWidth,
                t.height = window.innerHeight
        }
        ;
    Nt(() => {
        window.addEventListener("resize", e)
    }
    ),
        xn(() => {
            window.removeEventListener("resize", e)
        }
        );
    const n = 640
        , r = G(() => t.width < n);
    return {
        size: t,
        isMobileView: r
    }
}
const { isMobileView: MX } = OX()
    , RX = "Setup"
    , Lee = "TicketNew"
    , Dee = "TicketCustomer"
    , PX = "AgentList"
    , NX = "ContactList"
    , IX = "CustomerList"
    , LX = "EscalationRules"
    , DX = "Teams"
    , jX = "Team"
    , mO = "TicketsAgent"
    , BX = "DeskKBHome"
    , $X = "DeskKBCategory"
    , zX = "DeskKBSubcategory"
    , FX = "DeskKBArticle"
    , jee = "KBHome"
    , Bee = "KBArticlePublic"
    , $ee = "KBCategoryPublic"
    , zee = "TicketsCustomer"
    , Fee = mO
    , fb = "/login?redirect-to=/helpdesk"
    , HX = [{
        path: "",
        component: () => ot(() => import("./HRoot-6bda4f99.js"), [])
    }, {
        path: "/knowledge-base",
        component: () => ot(() => import("./KnowledgeBasePublic-1f4adfdf.js"), ["assets/KnowledgeBasePublic-1f4adfdf.js", "assets/iconify-c88ef0fb.js", "assets/BrandLogo.vue_vue_type_script_setup_true_lang-6aa7cf78.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js"]),
        children: [{
            path: "",
            name: "KBHome",
            component: () => ot(() => import("./KnowledgeBasePublicHome-3d8dbde5.js"), ["assets/KnowledgeBasePublicHome-3d8dbde5.js", "assets/util-75f74f01.js", "assets/iconify-c88ef0fb.js"])
        }, {
            path: ":categoryId",
            name: "KBCategoryPublic",
            component: () => ot(() => import("./KnowledgeBasePublicCategory-ef90ed9b.js"), ["assets/KnowledgeBasePublicCategory-ef90ed9b.js", "assets/iconify-c88ef0fb.js"]),
            props: !0
        }, {
            path: "articles/:articleId",
            name: "KBArticlePublic",
            component: () => ot(() => import("./KnowledgeBaseArticle-2265797a.js"), ["assets/KnowledgeBaseArticle-2265797a.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/TextEditor-02ecf25b.js", "assets/error-5568bea1.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js", "assets/edit-3-87731720.js", "assets/more-horizontal-1aa4d75a.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js"]),
            meta: {
                public: !0
            },
            props: !0
        }]
    }, {
        path: "/my-tickets",
        component: () => ot(() => import("./CLayout-0affc302.js"), ["assets/CLayout-0affc302.js", "assets/Dropdown-8f619cae.js", "assets/iconify-c88ef0fb.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/BrandLogo.vue_vue_type_script_setup_true_lang-6aa7cf78.js"]),
        meta: {
            auth: !0
        },
        children: [{
            path: "",
            name: "TicketsCustomer",
            component: () => ot(() => import("./TicketsCustomer-cdf805c9.js"), ["assets/TicketsCustomer-cdf805c9.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/ticketStatus-a3c044fe.js", "assets/listManager-63e5fbf4.js", "assets/LV.vue_vue_type_script_setup_true_lang-3bafdd12.js", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/error-5568bea1.js", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js"])
        }, {
            path: "new/:templateId?",
            name: "TicketNew",
            component: () => ot(() => import("./TicketNew-9cdf9e1d.js"), ["assets/TicketNew-9cdf9e1d.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-f3285ff6.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js", "assets/FileUploader-8ee84604.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-62ca66db.js", "assets/file-text-0dcc21fe.js", "assets/TextEditor-02ecf25b.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/error-5568bea1.js", "assets/Autocomplete-73ca6f95.js"]),
            props: !0,
            meta: {
                onSuccessRoute: "TicketCustomer",
                parent: "TicketsCustomer"
            }
        }, {
            path: ":ticketId",
            name: "TicketCustomer",
            component: () => ot(() => import("./TicketCustomer-3f96ebf8.js"), ["assets/TicketCustomer-3f96ebf8.js", "assets/iconify-c88ef0fb.js", "assets/error-5568bea1.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-f3285ff6.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/FileUploader-8ee84604.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-62ca66db.js", "assets/file-text-0dcc21fe.js", "assets/TextEditor-02ecf25b.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-5d56159e.js"]),
            props: !0
        }]
    }, {
        path: "/onboarding",
        name: RX,
        component: () => ot(() => import("./SimpleOnboarding-dd0493e8.js"), ["assets/SimpleOnboarding-dd0493e8.js", "assets/yandex-d4d20afa.js", "assets/error-5568bea1.js", "assets/FileUploader-8ee84604.js", "assets/SimpleOnboarding-0853491a.css"])
    }, {
        path: "/:invalidpath",
        name: "Invalid Page",
        component: () => ot(() => import("./InvalidPage-77d5574c.js"), ["assets/InvalidPage-77d5574c.js", "assets/TicketIcon-cc85c120.js"])
    }, {
        path: "",
        name: "AgentRoot",
        component: () => ot(() => import("./AgentRoot-f8117755.js"), []),
        meta: {
            auth: !0,
            agent: !0,
            admin: !1
        },
        children: [{
            path: "tickets",
            name: mO,
            component: () => ot(() => import("./TicketsAgent-5eb44b25.js"), ["assets/TicketsAgent-5eb44b25.js", "assets/plus-5350301e.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/iconify-c88ef0fb.js", "assets/Autocomplete-73ca6f95.js", "assets/LayoutHeader-721126a2.js", "assets/TicketAgentFields.vue_vue_type_style_index_0_scoped_96b4e0ce_lang-d7bdeb83.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/TicketAgentFields-483bbb88.css", "assets/ticketStatus-a3c044fe.js", "assets/TicketIcon-cc85c120.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-5d56159e.js"])
        }, {
            path: "notifications",
            name: "Notifications",
            component: () => ot(() => import("./MobileNotifications-dbb96647.js"), ["assets/MobileNotifications-dbb96647.js", "assets/check-check-ebea6126.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/LayoutHeader-721126a2.js", "assets/bell-090ecf03.js", "assets/error-5568bea1.js", "assets/listManager-63e5fbf4.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/iconify-c88ef0fb.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js"])
        }, {
            path: "tickets/new/:templateId?",
            name: "TicketAgentNew",
            component: () => ot(() => import("./TicketNew-9cdf9e1d.js"), ["assets/TicketNew-9cdf9e1d.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-f3285ff6.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js", "assets/FileUploader-8ee84604.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-62ca66db.js", "assets/file-text-0dcc21fe.js", "assets/TextEditor-02ecf25b.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/error-5568bea1.js", "assets/Autocomplete-73ca6f95.js"]),
            props: !0,
            meta: {
                onSuccessRoute: "TicketAgent",
                parent: "TicketsAgent"
            }
        }, {
            path: "tickets/:ticketId",
            name: "TicketAgent",
            component: () => kX(Object.assign({
                "../pages/CLayout.vue": () => ot(() => import("./CLayout-0affc302.js"), ["assets/CLayout-0affc302.js", "assets/Dropdown-8f619cae.js", "assets/iconify-c88ef0fb.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/BrandLogo.vue_vue_type_script_setup_true_lang-6aa7cf78.js"]),
                "../pages/CannedResponses.vue": () => ot(() => import("./CannedResponses-76ece340.js"), ["assets/CannedResponses-76ece340.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/plus-5350301e.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/TextEditor-02ecf25b.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/iconify-c88ef0fb.js", "assets/LayoutHeader-721126a2.js"]),
                "../pages/HRoot.vue": () => ot(() => import("./HRoot-6bda4f99.js"), []),
                "../pages/InvalidPage.vue": () => ot(() => import("./InvalidPage-77d5574c.js"), ["assets/InvalidPage-77d5574c.js", "assets/TicketIcon-cc85c120.js"]),
                "../pages/KeymapDialog.vue": () => ot(() => import("./KeymapDialog-c0534bbb.js"), []),
                "../pages/KnowledgeBaseArticle.vue": () => ot(() => import("./KnowledgeBaseArticle-2265797a.js"), ["assets/KnowledgeBaseArticle-2265797a.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/TextEditor-02ecf25b.js", "assets/error-5568bea1.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js", "assets/edit-3-87731720.js", "assets/more-horizontal-1aa4d75a.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js"]),
                "../pages/KnowledgeBasePublic.vue": () => ot(() => import("./KnowledgeBasePublic-1f4adfdf.js"), ["assets/KnowledgeBasePublic-1f4adfdf.js", "assets/iconify-c88ef0fb.js", "assets/BrandLogo.vue_vue_type_script_setup_true_lang-6aa7cf78.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js"]),
                "../pages/KnowledgeBasePublicCategory.vue": () => ot(() => import("./KnowledgeBasePublicCategory-ef90ed9b.js"), ["assets/KnowledgeBasePublicCategory-ef90ed9b.js", "assets/iconify-c88ef0fb.js"]),
                "../pages/KnowledgeBasePublicHome.vue": () => ot(() => import("./KnowledgeBasePublicHome-3d8dbde5.js"), ["assets/KnowledgeBasePublicHome-3d8dbde5.js", "assets/util-75f74f01.js", "assets/iconify-c88ef0fb.js"]),
                "../pages/MobileNotifications.vue": () => ot(() => import("./MobileNotifications-dbb96647.js"), ["assets/MobileNotifications-dbb96647.js", "assets/check-check-ebea6126.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/LayoutHeader-721126a2.js", "assets/bell-090ecf03.js", "assets/error-5568bea1.js", "assets/listManager-63e5fbf4.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/iconify-c88ef0fb.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js"]),
                "../pages/MobileTicketAgent.vue": () => ot(() => import("./MobileTicketAgent-2ed0238e.js"), ["assets/MobileTicketAgent-2ed0238e.js", "assets/CustomActions-e14dd051.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/iconify-c88ef0fb.js", "assets/FileUploader-8ee84604.js", "assets/TextEditor-02ecf25b.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-62ca66db.js", "assets/file-text-0dcc21fe.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/agent-8e859276.js", "assets/label-b1f3adac.js", "assets/Autocomplete-73ca6f95.js", "assets/Dropdown-8f619cae.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/TicketAgentFields.vue_vue_type_style_index_0_scoped_96b4e0ce_lang-d7bdeb83.js", "assets/TicketAgentFields-483bbb88.css", "assets/LayoutHeader-721126a2.js", "assets/ticketStatus-a3c044fe.js"]),
                "../pages/TicketAgent.vue": () => ot(() => import("./TicketAgent-a9c2a46a.js"), ["assets/TicketAgent-a9c2a46a.js", "assets/CustomActions-e14dd051.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/iconify-c88ef0fb.js", "assets/FileUploader-8ee84604.js", "assets/TextEditor-02ecf25b.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-62ca66db.js", "assets/file-text-0dcc21fe.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/agent-8e859276.js", "assets/label-b1f3adac.js", "assets/Autocomplete-73ca6f95.js", "assets/Dropdown-8f619cae.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/TicketAgentFields.vue_vue_type_style_index_0_scoped_96b4e0ce_lang-d7bdeb83.js", "assets/TicketAgentFields-483bbb88.css", "assets/LayoutHeader-721126a2.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-5d56159e.js", "assets/ticketStatus-a3c044fe.js"]),
                "../pages/TicketCustomer.vue": () => ot(() => import("./TicketCustomer-3f96ebf8.js"), ["assets/TicketCustomer-3f96ebf8.js", "assets/iconify-c88ef0fb.js", "assets/error-5568bea1.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-f3285ff6.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/FileUploader-8ee84604.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-62ca66db.js", "assets/file-text-0dcc21fe.js", "assets/TextEditor-02ecf25b.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-5d56159e.js"]),
                "../pages/TicketNew.vue": () => ot(() => import("./TicketNew-9cdf9e1d.js"), ["assets/TicketNew-9cdf9e1d.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-f3285ff6.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js", "assets/FileUploader-8ee84604.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-62ca66db.js", "assets/file-text-0dcc21fe.js", "assets/TextEditor-02ecf25b.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/error-5568bea1.js", "assets/Autocomplete-73ca6f95.js"]),
                "../pages/TicketsAgent.vue": () => ot(() => import("./TicketsAgent-5eb44b25.js"), ["assets/TicketsAgent-5eb44b25.js", "assets/plus-5350301e.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/iconify-c88ef0fb.js", "assets/Autocomplete-73ca6f95.js", "assets/LayoutHeader-721126a2.js", "assets/TicketAgentFields.vue_vue_type_style_index_0_scoped_96b4e0ce_lang-d7bdeb83.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/TicketAgentFields-483bbb88.css", "assets/ticketStatus-a3c044fe.js", "assets/TicketIcon-cc85c120.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-5d56159e.js"]),
                "../pages/TicketsCustomer.vue": () => ot(() => import("./TicketsCustomer-cdf805c9.js"), ["assets/TicketsCustomer-cdf805c9.js", "assets/Dropdown-8f619cae.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/ticketStatus-a3c044fe.js", "assets/listManager-63e5fbf4.js", "assets/LV.vue_vue_type_script_setup_true_lang-3bafdd12.js", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/error-5568bea1.js", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js"])
            }), `../pages/${VX("TicketAgent")}.vue`),
            props: !0
        }, {
            path: "kb",
            name: BX,
            component: () => ot(() => import("./KnowledgeBase-1d7f76d1.js"), ["assets/KnowledgeBase-1d7f76d1.js", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/iconify-c88ef0fb.js", "assets/SidebarLink.vue_vue_type_script_setup_true_lang-9e824e0a.js", "assets/KnowledgeBaseIconSelector.vue_vue_type_script_setup_true_lang-8edb2d3d.js", "assets/util-75f74f01.js", "assets/LayoutHeader-721126a2.js"]),
            children: [{
                path: ":categoryId",
                name: $X,
                props: !0,
                component: () => ot(() => import("./KnowledgeBaseCategory-20be58a3.js"), ["assets/KnowledgeBaseCategory-20be58a3.js", "assets/listManager-63e5fbf4.js", "assets/error-5568bea1.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/iconify-c88ef0fb.js", "assets/plus-5350301e.js", "assets/KnowledgeBaseCategoryHeader.vue_vue_type_script_setup_true_lang-6c52a054.js", "assets/KnowledgeBaseIconSelector.vue_vue_type_script_setup_true_lang-8edb2d3d.js", "assets/util-75f74f01.js", "assets/edit-3-87731720.js"])
            }, {
                path: ":categoryId/:subCategoryId",
                name: zX,
                props: !0,
                component: () => ot(() => import("./KnowledgeBaseSubcategory-28f052b9.js"), ["assets/KnowledgeBaseSubcategory-28f052b9.js", "assets/listManager-63e5fbf4.js", "assets/error-5568bea1.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/file-text-0dcc21fe.js", "assets/LV.vue_vue_type_script_setup_true_lang-3bafdd12.js", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/iconify-c88ef0fb.js", "assets/plus-5350301e.js", "assets/KnowledgeBaseCategoryHeader.vue_vue_type_script_setup_true_lang-6c52a054.js", "assets/edit-3-87731720.js"])
            }]
        }, {
            path: "kb/articles/:articleId",
            name: FX,
            props: !0,
            component: () => ot(() => import("./KnowledgeBaseArticle-2265797a.js"), ["assets/KnowledgeBaseArticle-2265797a.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/TextEditor-02ecf25b.js", "assets/error-5568bea1.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js", "assets/edit-3-87731720.js", "assets/more-horizontal-1aa4d75a.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js"])
        }, {
            path: "customers",
            name: IX,
            component: () => ot(() => import("./CustomerList-efe3d66f.js"), ["assets/CustomerList-efe3d66f.js", "assets/plus-5350301e.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/listManager-63e5fbf4.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/LV.vue_vue_type_script_setup_true_lang-3bafdd12.js", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/error-5568bea1.js", "assets/iconify-c88ef0fb.js", "assets/LayoutHeader-721126a2.js", "assets/FileUploader-8ee84604.js"])
        }, {
            path: "contacts",
            name: NX,
            component: () => ot(() => import("./ContactList-f240292e.js"), ["assets/ContactList-f240292e.js", "assets/plus-5350301e.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/listManager-63e5fbf4.js", "assets/LayoutHeader-721126a2.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/LV.vue_vue_type_script_setup_true_lang-3bafdd12.js", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/error-5568bea1.js", "assets/iconify-c88ef0fb.js", "assets/FileUploader-8ee84604.js", "assets/Pill-8a518fc0.js", "assets/x-a1d98e60.js"])
        }, {
            path: "agents",
            name: PX,
            component: () => ot(() => import("./AgentList-1b65a71d.js"), ["assets/AgentList-1b65a71d.js", "assets/plus-5350301e.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/listManager-63e5fbf4.js", "assets/LV.vue_vue_type_script_setup_true_lang-3bafdd12.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/error-5568bea1.js", "assets/iconify-c88ef0fb.js", "assets/LayoutHeader-721126a2.js"])
        }, {
            path: "teams",
            name: DX,
            component: () => ot(() => import("./TeamList-57111456.js"), ["assets/TeamList-57111456.js", "assets/listManager-63e5fbf4.js", "assets/error-5568bea1.js", "assets/LayoutHeader-721126a2.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/LV.vue_vue_type_script_setup_true_lang-3bafdd12.js", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/iconify-c88ef0fb.js", "assets/plus-5350301e.js"])
        }, {
            path: "teams/:teamId",
            name: jX,
            component: () => ot(() => import("./TeamSingle-3bdc4f13.js"), ["assets/TeamSingle-3bdc4f13.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/agent-8e859276.js", "assets/label-b1f3adac.js", "assets/error-5568bea1.js", "assets/more-horizontal-1aa4d75a.js", "assets/plus-5350301e.js", "assets/Pill-8a518fc0.js", "assets/x-a1d98e60.js", "assets/LayoutHeader-721126a2.js"]),
            props: !0
        }, {
            path: "canned-responses",
            name: "CannedResponses",
            component: () => ot(() => import("./CannedResponses-76ece340.js"), ["assets/CannedResponses-76ece340.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-28b9b1a6.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-904a60fd.js", "assets/plus-5350301e.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-3e970a5d.js", "assets/Dropdown-8f619cae.js", "assets/TextEditor-02ecf25b.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/iconify-c88ef0fb.js", "assets/LayoutHeader-721126a2.js"])
        }, {
            path: "escalation-rules",
            name: LX,
            component: () => ot(() => import("./EscalationRuleList-34abd4e9.js"), ["assets/EscalationRuleList-34abd4e9.js", "assets/plus-5350301e.js", "assets/listManager-63e5fbf4.js", "assets/EmailBox.vue_vue_type_style_index_0_lang-fbe765d3.js", "assets/book-open-653606eb.js", "assets/EmailBox-b7d95169.css", "assets/LV.vue_vue_type_script_setup_true_lang-3bafdd12.js", "assets/EmptyMessage.vue_vue_type_script_setup_true_lang-2739fc52.js", "assets/TabButtons-aa465984.js", "assets/label-b1f3adac.js", "assets/error-5568bea1.js", "assets/PageTitle.vue_vue_type_script_setup_true_lang-52bae42e.js", "assets/iconify-c88ef0fb.js", "assets/Autocomplete-73ca6f95.js"])
        }]
    }]
    , VX = t => MX.value ? `Mobile${t}` : t
    , hb = D$({
        history: f$("/helpdesk/"),
        routes: HX
    });
hb.beforeEach(async (t, e, n) => {
    const r = pO()
        , i = AX();
    r.isLoggedIn && (await r.init(),
        await i.users.fetch()),
        r.isLoggedIn ? n() : window.location.href = fb
}
);
const CS = {
    Badge: mE,
    Button: gv,
    Dialog: h7,
    ErrorMessage: y7,
    FeatherIcon: ko,
    FormControl: A7,
    Input: X9,
    Tooltip: FJ,
    TextInput: SE
};
BA("resourceFetcher", nZ);
BA("fallbackErrorHandler", t => {
    Up({
        title: t.exc_type || "Error",
        text: (t.messages || []).join(", "),
        icon: "alert-triangle",
        iconClasses: "text-red-500"
    })
}
);
const WX = WL()
    , Ga = g1(SX);
Ga.use(tZ);
Ga.use(WX);
Ga.use(hb);
for (const t in CS)
    Ga.component(t, CS[t]);
Ga.config.globalProperties.$socket = fO;
Ga.config.globalProperties.$toast = Up;
Ga.mount("#app");
export { gm as $, Fee as A, Pa as B, zee as C, h7 as D, zn as E, Rt as F, d5 as G, $ee as H, XJ as I, xi as J, jee as K, _i as L, kQ as M, G as N, A7 as O, Hy as P, $X as Q, zX as R, FX as S, Iee as T, Vn as U, pt as V, Wt as W, XQ as X, Up as Y, Lee as Z, gv as _, XY as a, Yt as a$, Dee as a0, FJ as a1, Mt as a2, vt as a3, hO as a4, wn as a5, Cee as a6, Rh as a7, Oc as a8, mE as a9, Ft as aA, IC as aB, SC as aC, vC as aD, yC as aE, Wn as aF, ss as aG, _D as aH, zD as aI, Fh as aJ, Mc as aK, ac as aL, fo as aM, cm as aN, Po as aO, xr as aP, qu as aQ, mC as aR, QQ as aS, V9 as aT, Vo as aU, oL as aV, om as aW, Gy as aX, CB as aY, ko as aZ, o0 as a_, Ue as aa, un as ab, Dt as ac, nee as ad, Hn as ae, ua as af, YQ as ag, tE as ah, m1 as ai, um as aj, WQ as ak, X9 as al, pk as am, Ua as an, OX as ao, RX as ap, lQ as aq, ot as ar, zs as as, Ge as at, gC as au, Zn as av, TC as aw, jn as ax, aj as ay, XD as az, B$ as b, Eee as b$, AX as b0, O9 as b1, tee as b2, vQ as b3, xQ as b4, SE as b5, tb as b6, Oee as b7, Ree as b8, gX as b9, vee as bA, uee as bB, bee as bC, xee as bD, wee as bE, mee as bF, gee as bG, yee as bH, lee as bI, hc as bJ, hd as bK, GY as bL, s9 as bM, y7 as bN, mO as bO, jX as bP, DX as bQ, rj as bR, uD as bS, CD as bT, vd as bU, JQ as bV, GQ as bW, ree as bX, im as bY, fO as bZ, R$ as b_, Nee as ba, Pee as bb, Tee as bc, eee as bd, FQ as be, MB as bf, Mee as bg, Ij as bh, sn as bi, _n as bj, qT as bk, XV as bl, iee as bm, see as bn, zy as bo, pn as bp, YS as bq, FL as br, _ee as bs, See as bt, j4 as bu, aee as bv, dee as bw, pee as bx, hee as by, fee as bz, JJ as c, p5 as c$, it as c0, bC as c1, kD as c2, OC as c3, W3 as c4, J4 as c5, uk as c6, cn as c7, DQ as c8, PS as c9, gQ as cA, pQ as cB, dQ as cC, BQ as cD, mQ as cE, RQ as cF, UX as cG, Iy as cH, ud as cI, YX as cJ, Uy as cK, fu as cL, _5 as cM, HQ as cN, iQ as cO, aQ as cP, oQ as cQ, sQ as cR, TQ as cS, VQ as cT, Q5 as cU, $y as cV, Ui as cW, Aa as cX, EQ as cY, si as cZ, Ra as c_, QX as ca, MQ as cb, uQ as cc, Th as cd, Bl as ce, _Q as cf, va as cg, JX as ch, OL as ci, ZX as cj, rv as ck, XX as cl, Ti as cm, dd as cn, Fn as co, Zp as cp, ui as cq, LQ as cr, g1 as cs, M5 as ct, bQ as cu, O5 as cv, HL as cw, kL as cx, fQ as cy, hQ as cz, je as d, cj as d$, n5 as d0, s5 as d1, r5 as d2, u5 as d3, l5 as d4, a5 as d5, cd as d6, o5 as d7, qy as d8, B4 as d9, EL as dA, e1 as dB, N5 as dC, $Q as dD, rQ as dE, lk as dF, tC as dG, DL as dH, nC as dI, LL as dJ, p1 as dK, eL as dL, OQ as dM, Rk as dN, I5 as dO, wQ as dP, yQ as dQ, AQ as dR, nQ as dS, SD as dT, zx as dU, Dn as dV, qQ as dW, KQ as dX, PX as dY, IX as dZ, NX as d_, tQ as da, ZS as db, eQ as dc, X0 as dd, du as de, CQ as df, cQ as dg, IQ as dh, Ec as di, dx as dj, PQ as dk, Oo as dl, GS as dm, dl as dn, Wa as dp, P5 as dq, NQ as dr, KX as ds, ec as dt, f5 as du, GX as dv, SQ as dw, Yw as dx, zQ as dy, jQ as dz, gt as e, WC as e0, ZQ as e1, UC as e2, Aee as e3, sX as e4, Xe as f, $e as g, ie as h, Ae as i, Bee as j, jD as k, LD as l, BD as m, mt as n, oe as o, $D as p, Vt as q, Oa as r, dX as s, XS as t, pO as u, ce as v, tt as w, Nt as x, xn as y, Cn as z };
//# sourceMappingURL=index-a95a3bd9.js.map
